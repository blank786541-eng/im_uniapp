/*! NeRTC 5.8.28|BUILD v5.8.28-0-gf5f839f2 production 20250827 */
!function(n,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.AIAudioEffects=e():n.AIAudioEffects=e()}(window,(function(){return function(n){var e={};function t(r){if(e[r])return e[r].exports;var a=e[r]={i:r,l:!1,exports:{}};return n[r].call(a.exports,a,a.exports,t),a.l=!0,a.exports}return t.m=n,t.c=e,t.d=function(n,e,r){t.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:r})},t.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.t=function(n,e){if(1&e&&(n=t(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var a in n)t.d(r,a,function(e){return n[e]}.bind(null,a));return r},t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,"a",e),e},t.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},t.p="",t(t.s=352)}({3:function(n,e,t){"use strict";var r=Object.prototype.hasOwnProperty,a="~";function o(){}function i(n,e,t){this.fn=n,this.context=e,this.once=t||!1}function s(){this._events=new o,this._eventsCount=0}Object.create&&(o.prototype=Object.create(null),(new o).__proto__||(a=!1)),s.prototype.eventNames=function(){var n,e,t=[];if(0===this._eventsCount)return t;for(e in n=this._events)r.call(n,e)&&t.push(a?e.slice(1):e);return Object.getOwnPropertySymbols?t.concat(Object.getOwnPropertySymbols(n)):t},s.prototype.listeners=function(n,e){var t=a?a+n:n,r=this._events[t];if(e)return!!r;if(!r)return[];if(r.fn)return[r.fn];for(var o=0,i=r.length,s=new Array(i);o<i;o++)s[o]=r[o].fn;return s},s.prototype.emit=function(n,e,t,r,o,i){var s=a?a+n:n;if(!this._events[s])return!1;var u,l,d=this._events[s],f=arguments.length;if(d.fn){switch(d.once&&this.removeListener(n,d.fn,void 0,!0),f){case 1:return d.fn.call(d.context),!0;case 2:return d.fn.call(d.context,e),!0;case 3:return d.fn.call(d.context,e,t),!0;case 4:return d.fn.call(d.context,e,t,r),!0;case 5:return d.fn.call(d.context,e,t,r,o),!0;case 6:return d.fn.call(d.context,e,t,r,o,i),!0}for(l=1,u=new Array(f-1);l<f;l++)u[l-1]=arguments[l];d.fn.apply(d.context,u)}else{var c,p=d.length;for(l=0;l<p;l++)switch(d[l].once&&this.removeListener(n,d[l].fn,void 0,!0),f){case 1:d[l].fn.call(d[l].context);break;case 2:d[l].fn.call(d[l].context,e);break;case 3:d[l].fn.call(d[l].context,e,t);break;case 4:d[l].fn.call(d[l].context,e,t,r);break;default:if(!u)for(c=1,u=new Array(f-1);c<f;c++)u[c-1]=arguments[c];d[l].fn.apply(d[l].context,u)}}return!0},s.prototype.on=function(n,e,t){var r=new i(e,t||this),o=a?a+n:n;return this._events[o]?this._events[o].fn?this._events[o]=[this._events[o],r]:this._events[o].push(r):(this._events[o]=r,this._eventsCount++),this},s.prototype.once=function(n,e,t){var r=new i(e,t||this,!0),o=a?a+n:n;return this._events[o]?this._events[o].fn?this._events[o]=[this._events[o],r]:this._events[o].push(r):(this._events[o]=r,this._eventsCount++),this},s.prototype.removeListener=function(n,e,t,r){var i=a?a+n:n;if(!this._events[i])return this;if(!e)return 0==--this._eventsCount?this._events=new o:delete this._events[i],this;var s=this._events[i];if(s.fn)s.fn!==e||r&&!s.once||t&&s.context!==t||(0==--this._eventsCount?this._events=new o:delete this._events[i]);else{for(var u=0,l=[],d=s.length;u<d;u++)(s[u].fn!==e||r&&!s[u].once||t&&s[u].context!==t)&&l.push(s[u]);l.length?this._events[i]=1===l.length?l[0]:l:0==--this._eventsCount?this._events=new o:delete this._events[i]}return this},s.prototype.removeAllListeners=function(n){var e;return n?(e=a?a+n:n,this._events[e]&&(0==--this._eventsCount?this._events=new o:delete this._events[e])):(this._events=new o,this._eventsCount=0),this},s.prototype.off=s.prototype.removeListener,s.prototype.addListener=s.prototype.on,s.prototype.setMaxListeners=function(){return this},s.prefixed=a,s.EventEmitter=s,n.exports=s},352:function(n,e,t){"use strict";var r=this&&this.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(e,"__esModule",{value:!0});const a=r(t(353));n.exports=a.default},353:function(n,e,t){"use strict";var r=this&&this.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(e,"__esModule",{value:!0});const a=t(3),o=r(t(354)),i={audioEffectsWorkletAgentProcessor:{blobParts:[o.default],options:{type:"text/javascript; charset=utf-8"},url:""}};class s extends a.EventEmitter{constructor(n){super(),this.wasmBinary=null,this.logger=n.adapterRef.logger.getChild(()=>"AIAudioEffects"),this.version="5.8.28",this.logger.info("Plugin AIAudioEffects 5.8.28 v5.8.28-0-gf5f839f2: 创建成功。"),this.url=function(n){if(!i[n].url){const e=new Blob(i[n].blobParts,i[n].options);i[n].url=window.URL.createObjectURL(e)}return i[n].url}("audioEffectsWorkletAgentProcessor"),this.preload(n)}async preload(n){fetch(n.wasmUrl).then(n=>{if(200==n.status)return n.arrayBuffer();this.emit("plugin-load-error")}).then(n=>{n&&(this.wasmBinary=new Uint8Array(n),this.emit("plugin-load"))})}init(){this.logger.log("AIAudioEffects create")}}e.default=s},354:function(n,e,t){"use strict";n.exports="/* eslint-disable */\n\nconst createModule = function (Module) {\n  var Module = typeof Module != 'undefined' ? Module : {}\n  var moduleOverrides = Object.assign({}, Module)\n  var arguments_ = []\n  var thisProgram = './this.program'\n  var quit_ = (status, toThrow) => {\n    throw toThrow\n  }\n  var ENVIRONMENT_IS_WEB = typeof window == 'object'\n  var ENVIRONMENT_IS_WORKER = typeof importScripts == 'function'\n  var ENVIRONMENT_IS_NODE =\n    typeof process == 'object' &&\n    typeof process.versions == 'object' &&\n    typeof process.versions.node == 'string'\n  var scriptDirectory = ''\n  function locateFile(path) {\n    if (Module['locateFile']) {\n      return Module['locateFile'](path, scriptDirectory)\n    }\n    return scriptDirectory + path\n  }\n  var read_, readAsync, readBinary, setWindowTitle\n  function logExceptionOnExit(e) {\n    if (e instanceof ExitStatus) return\n    let toLog = e\n    err('exiting due to exception: ' + toLog)\n  }\n  if (ENVIRONMENT_IS_NODE) {\n    if (ENVIRONMENT_IS_WORKER) {\n      scriptDirectory = require('path').dirname(scriptDirectory) + '/'\n    } else {\n      scriptDirectory = __dirname + '/'\n    }\n    var fs\n    var nodePath\n    var requireNodeFS = () => {\n      if (!nodePath) {\n        fs = require('fs')\n        nodePath = require('path')\n      }\n    }\n    read_ = (filename, binary) => {\n      requireNodeFS()\n      filename = nodePath['normalize'](filename)\n      return fs.readFileSync(filename, binary ? undefined : 'utf8')\n    }\n    readBinary = (filename) => {\n      var ret = read_(filename, true)\n      if (!ret.buffer) {\n        ret = new Uint8Array(ret)\n      }\n      return ret\n    }\n    readAsync = (filename, onload, onerror) => {\n      requireNodeFS()\n      filename = nodePath['normalize'](filename)\n      fs.readFile(filename, function (err, data) {\n        if (err) onerror(err)\n        else onload(data.buffer)\n      })\n    }\n    if (process['argv'].length > 1) {\n      thisProgram = process['argv'][1].replace(/\\\\/g, '/')\n    }\n    arguments_ = process['argv'].slice(2)\n    if (typeof module != 'undefined') {\n      module['exports'] = Module\n    }\n    process['on']('uncaughtException', function (ex) {\n      if (!(ex instanceof ExitStatus)) {\n        throw ex\n      }\n    })\n    process['on']('unhandledRejection', function (reason) {\n      throw reason\n    })\n    quit_ = (status, toThrow) => {\n      if (keepRuntimeAlive()) {\n        process['exitCode'] = status\n        throw toThrow\n      }\n      logExceptionOnExit(toThrow)\n      process['exit'](status)\n    }\n    Module['inspect'] = function () {\n      return '[Emscripten Module object]'\n    }\n  } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n    if (ENVIRONMENT_IS_WORKER) {\n      scriptDirectory = self.location.href\n    } else if (typeof document != 'undefined' && document.currentScript) {\n      scriptDirectory = document.currentScript.src\n    }\n    if (scriptDirectory.indexOf('blob:') !== 0) {\n      scriptDirectory = scriptDirectory.substr(\n        0,\n        scriptDirectory.replace(/[?#].*/, '').lastIndexOf('/') + 1\n      )\n    } else {\n      scriptDirectory = ''\n    }\n    {\n      read_ = (url) => {\n        var xhr = new XMLHttpRequest()\n        xhr.open('GET', url, false)\n        xhr.send(null)\n        return xhr.responseText\n      }\n      if (ENVIRONMENT_IS_WORKER) {\n        readBinary = (url) => {\n          var xhr = new XMLHttpRequest()\n          xhr.open('GET', url, false)\n          xhr.responseType = 'arraybuffer'\n          xhr.send(null)\n          return new Uint8Array(xhr.response)\n        }\n      }\n      readAsync = (url, onload, onerror) => {\n        var xhr = new XMLHttpRequest()\n        xhr.open('GET', url, true)\n        xhr.responseType = 'arraybuffer'\n        xhr.onload = () => {\n          if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) {\n            onload(xhr.response)\n            return\n          }\n          onerror()\n        }\n        xhr.onerror = onerror\n        xhr.send(null)\n      }\n    }\n    setWindowTitle = (title) => (document.title = title)\n  } else {\n  }\n  var out = Module['print'] || console.log.bind(console)\n  var err = Module['printErr'] || console.warn.bind(console)\n  Object.assign(Module, moduleOverrides)\n  moduleOverrides = null\n  if (Module['arguments']) arguments_ = Module['arguments']\n  if (Module['thisProgram']) thisProgram = Module['thisProgram']\n  if (Module['quit']) quit_ = Module['quit']\n  var wasmBinary\n  if (Module['wasmBinary']) wasmBinary = Module['wasmBinary']\n  var noExitRuntime = Module['noExitRuntime'] || true\n  if (typeof WebAssembly != 'object') {\n    abort('no native wasm support detected')\n  }\n  var wasmMemory\n  var ABORT = false\n  var EXITSTATUS\n  function assert(condition, text) {\n    if (!condition) {\n      abort(text)\n    }\n  }\n  var UTF8Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf8') : undefined\n  function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {\n    var endIdx = idx + maxBytesToRead\n    var endPtr = idx\n    while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr\n    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\n      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr))\n    }\n    var str = ''\n    while (idx < endPtr) {\n      var u0 = heapOrArray[idx++]\n      if (!(u0 & 128)) {\n        str += String.fromCharCode(u0)\n        continue\n      }\n      var u1 = heapOrArray[idx++] & 63\n      if ((u0 & 224) == 192) {\n        str += String.fromCharCode(((u0 & 31) << 6) | u1)\n        continue\n      }\n      var u2 = heapOrArray[idx++] & 63\n      if ((u0 & 240) == 224) {\n        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2\n      } else {\n        u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63)\n      }\n      if (u0 < 65536) {\n        str += String.fromCharCode(u0)\n      } else {\n        var ch = u0 - 65536\n        str += String.fromCharCode(55296 | (ch >> 10), 56320 | (ch & 1023))\n      }\n    }\n    return str\n  }\n  function UTF8ToString(ptr, maxBytesToRead) {\n    return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : ''\n  }\n  function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {\n    if (!(maxBytesToWrite > 0)) return 0\n    var startIdx = outIdx\n    var endIdx = outIdx + maxBytesToWrite - 1\n    for (var i = 0; i < str.length; ++i) {\n      var u = str.charCodeAt(i)\n      if (u >= 55296 && u <= 57343) {\n        var u1 = str.charCodeAt(++i)\n        u = (65536 + ((u & 1023) << 10)) | (u1 & 1023)\n      }\n      if (u <= 127) {\n        if (outIdx >= endIdx) break\n        heap[outIdx++] = u\n      } else if (u <= 2047) {\n        if (outIdx + 1 >= endIdx) break\n        heap[outIdx++] = 192 | (u >> 6)\n        heap[outIdx++] = 128 | (u & 63)\n      } else if (u <= 65535) {\n        if (outIdx + 2 >= endIdx) break\n        heap[outIdx++] = 224 | (u >> 12)\n        heap[outIdx++] = 128 | ((u >> 6) & 63)\n        heap[outIdx++] = 128 | (u & 63)\n      } else {\n        if (outIdx + 3 >= endIdx) break\n        heap[outIdx++] = 240 | (u >> 18)\n        heap[outIdx++] = 128 | ((u >> 12) & 63)\n        heap[outIdx++] = 128 | ((u >> 6) & 63)\n        heap[outIdx++] = 128 | (u & 63)\n      }\n    }\n    heap[outIdx] = 0\n    return outIdx - startIdx\n  }\n  function stringToUTF8(str, outPtr, maxBytesToWrite) {\n    return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite)\n  }\n  function lengthBytesUTF8(str) {\n    var len = 0\n    for (var i = 0; i < str.length; ++i) {\n      var c = str.charCodeAt(i)\n      if (c <= 127) {\n        len++\n      } else if (c <= 2047) {\n        len += 2\n      } else if (c >= 55296 && c <= 57343) {\n        len += 4\n        ++i\n      } else {\n        len += 3\n      }\n    }\n    return len\n  }\n  var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64\n  function updateGlobalBufferAndViews(buf) {\n    buffer = buf\n    Module['HEAP8'] = HEAP8 = new Int8Array(buf)\n    Module['HEAP16'] = HEAP16 = new Int16Array(buf)\n    Module['HEAP32'] = HEAP32 = new Int32Array(buf)\n    Module['HEAPU8'] = HEAPU8 = new Uint8Array(buf)\n    Module['HEAPU16'] = HEAPU16 = new Uint16Array(buf)\n    Module['HEAPU32'] = HEAPU32 = new Uint32Array(buf)\n    Module['HEAPF32'] = HEAPF32 = new Float32Array(buf)\n    Module['HEAPF64'] = HEAPF64 = new Float64Array(buf)\n  }\n  var INITIAL_MEMORY = Module['INITIAL_MEMORY'] || 16777216\n  var wasmTable\n  var __ATPRERUN__ = []\n  var __ATINIT__ = []\n  var __ATMAIN__ = []\n  var __ATPOSTRUN__ = []\n  var runtimeInitialized = false\n  function keepRuntimeAlive() {\n    return noExitRuntime\n  }\n  function preRun() {\n    if (Module['preRun']) {\n      if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']]\n      while (Module['preRun'].length) {\n        addOnPreRun(Module['preRun'].shift())\n      }\n    }\n    callRuntimeCallbacks(__ATPRERUN__)\n  }\n  function initRuntime() {\n    runtimeInitialized = true\n    if (!Module['noFSInit'] && !FS.init.initialized) FS.init()\n    FS.ignorePermissions = false\n    TTY.init()\n    callRuntimeCallbacks(__ATINIT__)\n  }\n  function preMain() {\n    callRuntimeCallbacks(__ATMAIN__)\n  }\n  function postRun() {\n    if (Module['postRun']) {\n      if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']]\n      while (Module['postRun'].length) {\n        addOnPostRun(Module['postRun'].shift())\n      }\n    }\n    callRuntimeCallbacks(__ATPOSTRUN__)\n  }\n  function addOnPreRun(cb) {\n    __ATPRERUN__.unshift(cb)\n  }\n  function addOnInit(cb) {\n    __ATINIT__.unshift(cb)\n  }\n  function addOnPostRun(cb) {\n    __ATPOSTRUN__.unshift(cb)\n  }\n  var runDependencies = 0\n  var runDependencyWatcher = null\n  var dependenciesFulfilled = null\n  function getUniqueRunDependency(id) {\n    return id\n  }\n  function addRunDependency(id) {\n    runDependencies++\n    if (Module['monitorRunDependencies']) {\n      Module['monitorRunDependencies'](runDependencies)\n    }\n  }\n  function removeRunDependency(id) {\n    runDependencies--\n    if (Module['monitorRunDependencies']) {\n      Module['monitorRunDependencies'](runDependencies)\n    }\n    if (runDependencies == 0) {\n      if (runDependencyWatcher !== null) {\n        clearInterval(runDependencyWatcher)\n        runDependencyWatcher = null\n      }\n      if (dependenciesFulfilled) {\n        var callback = dependenciesFulfilled\n        dependenciesFulfilled = null\n        callback()\n      }\n    }\n  }\n  function abort(what) {\n    {\n      if (Module['onAbort']) {\n        Module['onAbort'](what)\n      }\n    }\n    what = 'Aborted(' + what + ')'\n    err(what)\n    ABORT = true\n    EXITSTATUS = 1\n    what += '. Build with -sASSERTIONS for more info.'\n    var e = new WebAssembly.RuntimeError(what)\n    throw e\n  }\n  var dataURIPrefix = 'data:application/octet-stream;base64,'\n  function isDataURI(filename) {\n    return filename.startsWith(dataURIPrefix)\n  }\n  function isFileURI(filename) {\n    return filename.startsWith('file://')\n  }\n  var wasmBinaryFile\n  wasmBinaryFile = 'audio_effects_and_denoise.wasm'\n  if (!isDataURI(wasmBinaryFile)) {\n    wasmBinaryFile = locateFile(wasmBinaryFile)\n  }\n  function getBinary(file) {\n    try {\n      if (file == wasmBinaryFile && wasmBinary) {\n        return new Uint8Array(wasmBinary)\n      }\n      if (readBinary) {\n        return readBinary(file)\n      }\n      throw 'both async and sync fetching of the wasm failed'\n    } catch (err) {\n      abort(err)\n    }\n  }\n  function getBinaryPromise() {\n    if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {\n      if (typeof fetch == 'function' && !isFileURI(wasmBinaryFile)) {\n        return fetch(wasmBinaryFile, { credentials: 'same-origin' })\n          .then(function (response) {\n            if (!response['ok']) {\n              throw \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\"\n            }\n            return response['arrayBuffer']()\n          })\n          .catch(function () {\n            return getBinary(wasmBinaryFile)\n          })\n      } else {\n        if (readAsync) {\n          return new Promise(function (resolve, reject) {\n            readAsync(\n              wasmBinaryFile,\n              function (response) {\n                resolve(new Uint8Array(response))\n              },\n              reject\n            )\n          })\n        }\n      }\n    }\n    return Promise.resolve().then(function () {\n      return getBinary(wasmBinaryFile)\n    })\n  }\n  function createWasm() {\n    var info = { a: asmLibraryArg }\n    function receiveInstance(instance, module) {\n      var exports = instance.exports\n      Module['asm'] = exports\n      wasmMemory = Module['asm']['B']\n      updateGlobalBufferAndViews(wasmMemory.buffer)\n      wasmTable = Module['asm']['J']\n      addOnInit(Module['asm']['C'])\n      removeRunDependency('wasm-instantiate')\n    }\n    addRunDependency('wasm-instantiate')\n    function receiveInstantiationResult(result) {\n      receiveInstance(result['instance'])\n    }\n    function instantiateArrayBuffer(receiver) {\n      return getBinaryPromise()\n        .then(function (binary) {\n          return WebAssembly.instantiate(binary, info)\n        })\n        .then(function (instance) {\n          return instance\n        })\n        .then(receiver, function (reason) {\n          err('failed to asynchronously prepare wasm: ' + reason)\n          abort(reason)\n        })\n    }\n    function instantiateAsync() {\n      if (\n        !wasmBinary &&\n        typeof WebAssembly.instantiateStreaming == 'function' &&\n        !isDataURI(wasmBinaryFile) &&\n        !isFileURI(wasmBinaryFile) &&\n        !ENVIRONMENT_IS_NODE &&\n        typeof fetch == 'function'\n      ) {\n        return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function (response) {\n          var result = WebAssembly.instantiateStreaming(response, info)\n          return result.then(receiveInstantiationResult, function (reason) {\n            err('wasm streaming compile failed: ' + reason)\n            err('falling back to ArrayBuffer instantiation')\n            return instantiateArrayBuffer(receiveInstantiationResult)\n          })\n        })\n      } else {\n        return instantiateArrayBuffer(receiveInstantiationResult)\n      }\n    }\n    if (Module['instantiateWasm']) {\n      try {\n        var exports = Module['instantiateWasm'](info, receiveInstance)\n        return exports\n      } catch (e) {\n        err('Module.instantiateWasm callback failed with error: ' + e)\n        return false\n      }\n    }\n    instantiateAsync()\n    return {}\n  }\n  var tempDouble\n  var tempI64\n  function ExitStatus(status) {\n    this.name = 'ExitStatus'\n    this.message = 'Program terminated with exit(' + status + ')'\n    this.status = status\n  }\n  function callRuntimeCallbacks(callbacks) {\n    while (callbacks.length > 0) {\n      callbacks.shift()(Module)\n    }\n  }\n  function handleException(e) {\n    if (e instanceof ExitStatus || e == 'unwind') {\n      return EXITSTATUS\n    }\n    quit_(1, e)\n  }\n  function writeArrayToMemory(array, buffer) {\n    HEAP8.set(array, buffer)\n  }\n  function ___assert_fail(condition, filename, line, func) {\n    abort(\n      'Assertion failed: ' +\n        UTF8ToString(condition) +\n        ', at: ' +\n        [\n          filename ? UTF8ToString(filename) : 'unknown filename',\n          line,\n          func ? UTF8ToString(func) : 'unknown function'\n        ]\n    )\n  }\n  function ___cxa_allocate_exception(size) {\n    return _malloc(size + 24) + 24\n  }\n  function ExceptionInfo(excPtr) {\n    this.excPtr = excPtr\n    this.ptr = excPtr - 24\n    this.set_type = function (type) {\n      HEAPU32[(this.ptr + 4) >> 2] = type\n    }\n    this.get_type = function () {\n      return HEAPU32[(this.ptr + 4) >> 2]\n    }\n    this.set_destructor = function (destructor) {\n      HEAPU32[(this.ptr + 8) >> 2] = destructor\n    }\n    this.get_destructor = function () {\n      return HEAPU32[(this.ptr + 8) >> 2]\n    }\n    this.set_refcount = function (refcount) {\n      HEAP32[this.ptr >> 2] = refcount\n    }\n    this.set_caught = function (caught) {\n      caught = caught ? 1 : 0\n      HEAP8[(this.ptr + 12) >> 0] = caught\n    }\n    this.get_caught = function () {\n      return HEAP8[(this.ptr + 12) >> 0] != 0\n    }\n    this.set_rethrown = function (rethrown) {\n      rethrown = rethrown ? 1 : 0\n      HEAP8[(this.ptr + 13) >> 0] = rethrown\n    }\n    this.get_rethrown = function () {\n      return HEAP8[(this.ptr + 13) >> 0] != 0\n    }\n    this.init = function (type, destructor) {\n      this.set_adjusted_ptr(0)\n      this.set_type(type)\n      this.set_destructor(destructor)\n      this.set_refcount(0)\n      this.set_caught(false)\n      this.set_rethrown(false)\n    }\n    this.add_ref = function () {\n      var value = HEAP32[this.ptr >> 2]\n      HEAP32[this.ptr >> 2] = value + 1\n    }\n    this.release_ref = function () {\n      var prev = HEAP32[this.ptr >> 2]\n      HEAP32[this.ptr >> 2] = prev - 1\n      return prev === 1\n    }\n    this.set_adjusted_ptr = function (adjustedPtr) {\n      HEAPU32[(this.ptr + 16) >> 2] = adjustedPtr\n    }\n    this.get_adjusted_ptr = function () {\n      return HEAPU32[(this.ptr + 16) >> 2]\n    }\n    this.get_exception_ptr = function () {\n      var isPointer = ___cxa_is_pointer_type(this.get_type())\n      if (isPointer) {\n        return HEAPU32[this.excPtr >> 2]\n      }\n      var adjusted = this.get_adjusted_ptr()\n      if (adjusted !== 0) return adjusted\n      return this.excPtr\n    }\n  }\n  var exceptionLast = 0\n  var uncaughtExceptionCount = 0\n  function ___cxa_throw(ptr, type, destructor) {\n    var info = new ExceptionInfo(ptr)\n    info.init(type, destructor)\n    exceptionLast = ptr\n    uncaughtExceptionCount++\n    throw ptr\n  }\n  function setErrNo(value) {\n    HEAP32[___errno_location() >> 2] = value\n    return value\n  }\n  var PATH = {\n    isAbs: (path) => path.charAt(0) === '/',\n    splitPath: (filename) => {\n      var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/\n      return splitPathRe.exec(filename).slice(1)\n    },\n    normalizeArray: (parts, allowAboveRoot) => {\n      var up = 0\n      for (var i = parts.length - 1; i >= 0; i--) {\n        var last = parts[i]\n        if (last === '.') {\n          parts.splice(i, 1)\n        } else if (last === '..') {\n          parts.splice(i, 1)\n          up++\n        } else if (up) {\n          parts.splice(i, 1)\n          up--\n        }\n      }\n      if (allowAboveRoot) {\n        for (; up; up--) {\n          parts.unshift('..')\n        }\n      }\n      return parts\n    },\n    normalize: (path) => {\n      var isAbsolute = PATH.isAbs(path),\n        trailingSlash = path.substr(-1) === '/'\n      path = PATH.normalizeArray(\n        path.split('/').filter((p) => !!p),\n        !isAbsolute\n      ).join('/')\n      if (!path && !isAbsolute) {\n        path = '.'\n      }\n      if (path && trailingSlash) {\n        path += '/'\n      }\n      return (isAbsolute ? '/' : '') + path\n    },\n    dirname: (path) => {\n      var result = PATH.splitPath(path),\n        root = result[0],\n        dir = result[1]\n      if (!root && !dir) {\n        return '.'\n      }\n      if (dir) {\n        dir = dir.substr(0, dir.length - 1)\n      }\n      return root + dir\n    },\n    basename: (path) => {\n      if (path === '/') return '/'\n      path = PATH.normalize(path)\n      path = path.replace(/\\/$/, '')\n      var lastSlash = path.lastIndexOf('/')\n      if (lastSlash === -1) return path\n      return path.substr(lastSlash + 1)\n    },\n    join: function () {\n      var paths = Array.prototype.slice.call(arguments)\n      return PATH.normalize(paths.join('/'))\n    },\n    join2: (l, r) => {\n      return PATH.normalize(l + '/' + r)\n    }\n  }\n  function getRandomDevice() {\n    if (typeof crypto == 'object' && typeof crypto['getRandomValues'] == 'function') {\n      var randomBuffer = new Uint8Array(1)\n      return () => {\n        crypto.getRandomValues(randomBuffer)\n        return randomBuffer[0]\n      }\n    } else if (ENVIRONMENT_IS_NODE) {\n      try {\n        var crypto_module = require('crypto')\n        return () => crypto_module['randomBytes'](1)[0]\n      } catch (e) {}\n    }\n    return () => abort('randomDevice')\n  }\n  var PATH_FS = {\n    resolve: function () {\n      var resolvedPath = '',\n        resolvedAbsolute = false\n      for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n        var path = i >= 0 ? arguments[i] : FS.cwd()\n        if (typeof path != 'string') {\n          throw new TypeError('Arguments to path.resolve must be strings')\n        } else if (!path) {\n          return ''\n        }\n        resolvedPath = path + '/' + resolvedPath\n        resolvedAbsolute = PATH.isAbs(path)\n      }\n      resolvedPath = PATH.normalizeArray(\n        resolvedPath.split('/').filter((p) => !!p),\n        !resolvedAbsolute\n      ).join('/')\n      return (resolvedAbsolute ? '/' : '') + resolvedPath || '.'\n    },\n    relative: (from, to) => {\n      from = PATH_FS.resolve(from).substr(1)\n      to = PATH_FS.resolve(to).substr(1)\n      function trim(arr) {\n        var start = 0\n        for (; start < arr.length; start++) {\n          if (arr[start] !== '') break\n        }\n        var end = arr.length - 1\n        for (; end >= 0; end--) {\n          if (arr[end] !== '') break\n        }\n        if (start > end) return []\n        return arr.slice(start, end - start + 1)\n      }\n      var fromParts = trim(from.split('/'))\n      var toParts = trim(to.split('/'))\n      var length = Math.min(fromParts.length, toParts.length)\n      var samePartsLength = length\n      for (var i = 0; i < length; i++) {\n        if (fromParts[i] !== toParts[i]) {\n          samePartsLength = i\n          break\n        }\n      }\n      var outputParts = []\n      for (var i = samePartsLength; i < fromParts.length; i++) {\n        outputParts.push('..')\n      }\n      outputParts = outputParts.concat(toParts.slice(samePartsLength))\n      return outputParts.join('/')\n    }\n  }\n  function intArrayFromString(stringy, dontAddNull, length) {\n    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1\n    var u8array = new Array(len)\n    var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length)\n    if (dontAddNull) u8array.length = numBytesWritten\n    return u8array\n  }\n  var TTY = {\n    ttys: [],\n    init: function () {},\n    shutdown: function () {},\n    register: function (dev, ops) {\n      TTY.ttys[dev] = { input: [], output: [], ops: ops }\n      FS.registerDevice(dev, TTY.stream_ops)\n    },\n    stream_ops: {\n      open: function (stream) {\n        var tty = TTY.ttys[stream.node.rdev]\n        if (!tty) {\n          throw new FS.ErrnoError(43)\n        }\n        stream.tty = tty\n        stream.seekable = false\n      },\n      close: function (stream) {\n        stream.tty.ops.fsync(stream.tty)\n      },\n      fsync: function (stream) {\n        stream.tty.ops.fsync(stream.tty)\n      },\n      read: function (stream, buffer, offset, length, pos) {\n        if (!stream.tty || !stream.tty.ops.get_char) {\n          throw new FS.ErrnoError(60)\n        }\n        var bytesRead = 0\n        for (var i = 0; i < length; i++) {\n          var result\n          try {\n            result = stream.tty.ops.get_char(stream.tty)\n          } catch (e) {\n            throw new FS.ErrnoError(29)\n          }\n          if (result === undefined && bytesRead === 0) {\n            throw new FS.ErrnoError(6)\n          }\n          if (result === null || result === undefined) break\n          bytesRead++\n          buffer[offset + i] = result\n        }\n        if (bytesRead) {\n          stream.node.timestamp = Date.now()\n        }\n        return bytesRead\n      },\n      write: function (stream, buffer, offset, length, pos) {\n        if (!stream.tty || !stream.tty.ops.put_char) {\n          throw new FS.ErrnoError(60)\n        }\n        try {\n          for (var i = 0; i < length; i++) {\n            stream.tty.ops.put_char(stream.tty, buffer[offset + i])\n          }\n        } catch (e) {\n          throw new FS.ErrnoError(29)\n        }\n        if (length) {\n          stream.node.timestamp = Date.now()\n        }\n        return i\n      }\n    },\n    default_tty_ops: {\n      get_char: function (tty) {\n        if (!tty.input.length) {\n          var result = null\n          if (ENVIRONMENT_IS_NODE) {\n            var BUFSIZE = 256\n            var buf = Buffer.alloc(BUFSIZE)\n            var bytesRead = 0\n            try {\n              bytesRead = fs.readSync(process.stdin.fd, buf, 0, BUFSIZE, -1)\n            } catch (e) {\n              if (e.toString().includes('EOF')) bytesRead = 0\n              else throw e\n            }\n            if (bytesRead > 0) {\n              result = buf.slice(0, bytesRead).toString('utf-8')\n            } else {\n              result = null\n            }\n          } else if (typeof window != 'undefined' && typeof window.prompt == 'function') {\n            result = window.prompt('Input: ')\n            if (result !== null) {\n              result += '\\n'\n            }\n          } else if (typeof readline == 'function') {\n            result = readline()\n            if (result !== null) {\n              result += '\\n'\n            }\n          }\n          if (!result) {\n            return null\n          }\n          tty.input = intArrayFromString(result, true)\n        }\n        return tty.input.shift()\n      },\n      put_char: function (tty, val) {\n        if (val === null || val === 10) {\n          out(UTF8ArrayToString(tty.output, 0))\n          tty.output = []\n        } else {\n          if (val != 0) tty.output.push(val)\n        }\n      },\n      fsync: function (tty) {\n        if (tty.output && tty.output.length > 0) {\n          out(UTF8ArrayToString(tty.output, 0))\n          tty.output = []\n        }\n      }\n    },\n    default_tty1_ops: {\n      put_char: function (tty, val) {\n        if (val === null || val === 10) {\n          err(UTF8ArrayToString(tty.output, 0))\n          tty.output = []\n        } else {\n          if (val != 0) tty.output.push(val)\n        }\n      },\n      fsync: function (tty) {\n        if (tty.output && tty.output.length > 0) {\n          err(UTF8ArrayToString(tty.output, 0))\n          tty.output = []\n        }\n      }\n    }\n  }\n  function mmapAlloc(size) {\n    abort()\n  }\n  var MEMFS = {\n    ops_table: null,\n    mount: function (mount) {\n      return MEMFS.createNode(null, '/', 16384 | 511, 0)\n    },\n    createNode: function (parent, name, mode, dev) {\n      if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\n        throw new FS.ErrnoError(63)\n      }\n      if (!MEMFS.ops_table) {\n        MEMFS.ops_table = {\n          dir: {\n            node: {\n              getattr: MEMFS.node_ops.getattr,\n              setattr: MEMFS.node_ops.setattr,\n              lookup: MEMFS.node_ops.lookup,\n              mknod: MEMFS.node_ops.mknod,\n              rename: MEMFS.node_ops.rename,\n              unlink: MEMFS.node_ops.unlink,\n              rmdir: MEMFS.node_ops.rmdir,\n              readdir: MEMFS.node_ops.readdir,\n              symlink: MEMFS.node_ops.symlink\n            },\n            stream: { llseek: MEMFS.stream_ops.llseek }\n          },\n          file: {\n            node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr },\n            stream: {\n              llseek: MEMFS.stream_ops.llseek,\n              read: MEMFS.stream_ops.read,\n              write: MEMFS.stream_ops.write,\n              allocate: MEMFS.stream_ops.allocate,\n              mmap: MEMFS.stream_ops.mmap,\n              msync: MEMFS.stream_ops.msync\n            }\n          },\n          link: {\n            node: {\n              getattr: MEMFS.node_ops.getattr,\n              setattr: MEMFS.node_ops.setattr,\n              readlink: MEMFS.node_ops.readlink\n            },\n            stream: {}\n          },\n          chrdev: {\n            node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr },\n            stream: FS.chrdev_stream_ops\n          }\n        }\n      }\n      var node = FS.createNode(parent, name, mode, dev)\n      if (FS.isDir(node.mode)) {\n        node.node_ops = MEMFS.ops_table.dir.node\n        node.stream_ops = MEMFS.ops_table.dir.stream\n        node.contents = {}\n      } else if (FS.isFile(node.mode)) {\n        node.node_ops = MEMFS.ops_table.file.node\n        node.stream_ops = MEMFS.ops_table.file.stream\n        node.usedBytes = 0\n        node.contents = null\n      } else if (FS.isLink(node.mode)) {\n        node.node_ops = MEMFS.ops_table.link.node\n        node.stream_ops = MEMFS.ops_table.link.stream\n      } else if (FS.isChrdev(node.mode)) {\n        node.node_ops = MEMFS.ops_table.chrdev.node\n        node.stream_ops = MEMFS.ops_table.chrdev.stream\n      }\n      node.timestamp = Date.now()\n      if (parent) {\n        parent.contents[name] = node\n        parent.timestamp = node.timestamp\n      }\n      return node\n    },\n    getFileDataAsTypedArray: function (node) {\n      if (!node.contents) return new Uint8Array(0)\n      if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes)\n      return new Uint8Array(node.contents)\n    },\n    expandFileStorage: function (node, newCapacity) {\n      var prevCapacity = node.contents ? node.contents.length : 0\n      if (prevCapacity >= newCapacity) return\n      var CAPACITY_DOUBLING_MAX = 1024 * 1024\n      newCapacity = Math.max(\n        newCapacity,\n        (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125)) >>> 0\n      )\n      if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256)\n      var oldContents = node.contents\n      node.contents = new Uint8Array(newCapacity)\n      if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0)\n    },\n    resizeFileStorage: function (node, newSize) {\n      if (node.usedBytes == newSize) return\n      if (newSize == 0) {\n        node.contents = null\n        node.usedBytes = 0\n      } else {\n        var oldContents = node.contents\n        node.contents = new Uint8Array(newSize)\n        if (oldContents) {\n          node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)))\n        }\n        node.usedBytes = newSize\n      }\n    },\n    node_ops: {\n      getattr: function (node) {\n        var attr = {}\n        attr.dev = FS.isChrdev(node.mode) ? node.id : 1\n        attr.ino = node.id\n        attr.mode = node.mode\n        attr.nlink = 1\n        attr.uid = 0\n        attr.gid = 0\n        attr.rdev = node.rdev\n        if (FS.isDir(node.mode)) {\n          attr.size = 4096\n        } else if (FS.isFile(node.mode)) {\n          attr.size = node.usedBytes\n        } else if (FS.isLink(node.mode)) {\n          attr.size = node.link.length\n        } else {\n          attr.size = 0\n        }\n        attr.atime = new Date(node.timestamp)\n        attr.mtime = new Date(node.timestamp)\n        attr.ctime = new Date(node.timestamp)\n        attr.blksize = 4096\n        attr.blocks = Math.ceil(attr.size / attr.blksize)\n        return attr\n      },\n      setattr: function (node, attr) {\n        if (attr.mode !== undefined) {\n          node.mode = attr.mode\n        }\n        if (attr.timestamp !== undefined) {\n          node.timestamp = attr.timestamp\n        }\n        if (attr.size !== undefined) {\n          MEMFS.resizeFileStorage(node, attr.size)\n        }\n      },\n      lookup: function (parent, name) {\n        throw FS.genericErrors[44]\n      },\n      mknod: function (parent, name, mode, dev) {\n        return MEMFS.createNode(parent, name, mode, dev)\n      },\n      rename: function (old_node, new_dir, new_name) {\n        if (FS.isDir(old_node.mode)) {\n          var new_node\n          try {\n            new_node = FS.lookupNode(new_dir, new_name)\n          } catch (e) {}\n          if (new_node) {\n            for (var i in new_node.contents) {\n              throw new FS.ErrnoError(55)\n            }\n          }\n        }\n        delete old_node.parent.contents[old_node.name]\n        old_node.parent.timestamp = Date.now()\n        old_node.name = new_name\n        new_dir.contents[new_name] = old_node\n        new_dir.timestamp = old_node.parent.timestamp\n        old_node.parent = new_dir\n      },\n      unlink: function (parent, name) {\n        delete parent.contents[name]\n        parent.timestamp = Date.now()\n      },\n      rmdir: function (parent, name) {\n        var node = FS.lookupNode(parent, name)\n        for (var i in node.contents) {\n          throw new FS.ErrnoError(55)\n        }\n        delete parent.contents[name]\n        parent.timestamp = Date.now()\n      },\n      readdir: function (node) {\n        var entries = ['.', '..']\n        for (var key in node.contents) {\n          if (!node.contents.hasOwnProperty(key)) {\n            continue\n          }\n          entries.push(key)\n        }\n        return entries\n      },\n      symlink: function (parent, newname, oldpath) {\n        var node = MEMFS.createNode(parent, newname, 511 | 40960, 0)\n        node.link = oldpath\n        return node\n      },\n      readlink: function (node) {\n        if (!FS.isLink(node.mode)) {\n          throw new FS.ErrnoError(28)\n        }\n        return node.link\n      }\n    },\n    stream_ops: {\n      read: function (stream, buffer, offset, length, position) {\n        var contents = stream.node.contents\n        if (position >= stream.node.usedBytes) return 0\n        var size = Math.min(stream.node.usedBytes - position, length)\n        if (size > 8 && contents.subarray) {\n          buffer.set(contents.subarray(position, position + size), offset)\n        } else {\n          for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i]\n        }\n        return size\n      },\n      write: function (stream, buffer, offset, length, position, canOwn) {\n        if (!length) return 0\n        var node = stream.node\n        node.timestamp = Date.now()\n        if (buffer.subarray && (!node.contents || node.contents.subarray)) {\n          if (canOwn) {\n            node.contents = buffer.subarray(offset, offset + length)\n            node.usedBytes = length\n            return length\n          } else if (node.usedBytes === 0 && position === 0) {\n            node.contents = buffer.slice(offset, offset + length)\n            node.usedBytes = length\n            return length\n          } else if (position + length <= node.usedBytes) {\n            node.contents.set(buffer.subarray(offset, offset + length), position)\n            return length\n          }\n        }\n        MEMFS.expandFileStorage(node, position + length)\n        if (node.contents.subarray && buffer.subarray) {\n          node.contents.set(buffer.subarray(offset, offset + length), position)\n        } else {\n          for (var i = 0; i < length; i++) {\n            node.contents[position + i] = buffer[offset + i]\n          }\n        }\n        node.usedBytes = Math.max(node.usedBytes, position + length)\n        return length\n      },\n      llseek: function (stream, offset, whence) {\n        var position = offset\n        if (whence === 1) {\n          position += stream.position\n        } else if (whence === 2) {\n          if (FS.isFile(stream.node.mode)) {\n            position += stream.node.usedBytes\n          }\n        }\n        if (position < 0) {\n          throw new FS.ErrnoError(28)\n        }\n        return position\n      },\n      allocate: function (stream, offset, length) {\n        MEMFS.expandFileStorage(stream.node, offset + length)\n        stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length)\n      },\n      mmap: function (stream, length, position, prot, flags) {\n        if (!FS.isFile(stream.node.mode)) {\n          throw new FS.ErrnoError(43)\n        }\n        var ptr\n        var allocated\n        var contents = stream.node.contents\n        if (!(flags & 2) && contents.buffer === buffer) {\n          allocated = false\n          ptr = contents.byteOffset\n        } else {\n          if (position > 0 || position + length < contents.length) {\n            if (contents.subarray) {\n              contents = contents.subarray(position, position + length)\n            } else {\n              contents = Array.prototype.slice.call(contents, position, position + length)\n            }\n          }\n          allocated = true\n          ptr = mmapAlloc(length)\n          if (!ptr) {\n            throw new FS.ErrnoError(48)\n          }\n          HEAP8.set(contents, ptr)\n        }\n        return { ptr: ptr, allocated: allocated }\n      },\n      msync: function (stream, buffer, offset, length, mmapFlags) {\n        MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false)\n        return 0\n      }\n    }\n  }\n  function asyncLoad(url, onload, onerror, noRunDep) {\n    var dep = !noRunDep ? getUniqueRunDependency('al ' + url) : ''\n    readAsync(\n      url,\n      (arrayBuffer) => {\n        assert(arrayBuffer, 'Loading data file \"' + url + '\" failed (no arrayBuffer).')\n        onload(new Uint8Array(arrayBuffer))\n        if (dep) removeRunDependency(dep)\n      },\n      (event) => {\n        if (onerror) {\n          onerror()\n        } else {\n          throw 'Loading data file \"' + url + '\" failed.'\n        }\n      }\n    )\n    if (dep) addRunDependency(dep)\n  }\n  var FS = {\n    root: null,\n    mounts: [],\n    devices: {},\n    streams: [],\n    nextInode: 1,\n    nameTable: null,\n    currentPath: '/',\n    initialized: false,\n    ignorePermissions: true,\n    ErrnoError: null,\n    genericErrors: {},\n    filesystems: null,\n    syncFSRequests: 0,\n    lookupPath: (path, opts = {}) => {\n      path = PATH_FS.resolve(FS.cwd(), path)\n      if (!path) return { path: '', node: null }\n      var defaults = { follow_mount: true, recurse_count: 0 }\n      opts = Object.assign(defaults, opts)\n      if (opts.recurse_count > 8) {\n        throw new FS.ErrnoError(32)\n      }\n      var parts = PATH.normalizeArray(\n        path.split('/').filter((p) => !!p),\n        false\n      )\n      var current = FS.root\n      var current_path = '/'\n      for (var i = 0; i < parts.length; i++) {\n        var islast = i === parts.length - 1\n        if (islast && opts.parent) {\n          break\n        }\n        current = FS.lookupNode(current, parts[i])\n        current_path = PATH.join2(current_path, parts[i])\n        if (FS.isMountpoint(current)) {\n          if (!islast || (islast && opts.follow_mount)) {\n            current = current.mounted.root\n          }\n        }\n        if (!islast || opts.follow) {\n          var count = 0\n          while (FS.isLink(current.mode)) {\n            var link = FS.readlink(current_path)\n            current_path = PATH_FS.resolve(PATH.dirname(current_path), link)\n            var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count + 1 })\n            current = lookup.node\n            if (count++ > 40) {\n              throw new FS.ErrnoError(32)\n            }\n          }\n        }\n      }\n      return { path: current_path, node: current }\n    },\n    getPath: (node) => {\n      var path\n      while (true) {\n        if (FS.isRoot(node)) {\n          var mount = node.mount.mountpoint\n          if (!path) return mount\n          return mount[mount.length - 1] !== '/' ? mount + '/' + path : mount + path\n        }\n        path = path ? node.name + '/' + path : node.name\n        node = node.parent\n      }\n    },\n    hashName: (parentid, name) => {\n      var hash = 0\n      for (var i = 0; i < name.length; i++) {\n        hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0\n      }\n      return ((parentid + hash) >>> 0) % FS.nameTable.length\n    },\n    hashAddNode: (node) => {\n      var hash = FS.hashName(node.parent.id, node.name)\n      node.name_next = FS.nameTable[hash]\n      FS.nameTable[hash] = node\n    },\n    hashRemoveNode: (node) => {\n      var hash = FS.hashName(node.parent.id, node.name)\n      if (FS.nameTable[hash] === node) {\n        FS.nameTable[hash] = node.name_next\n      } else {\n        var current = FS.nameTable[hash]\n        while (current) {\n          if (current.name_next === node) {\n            current.name_next = node.name_next\n            break\n          }\n          current = current.name_next\n        }\n      }\n    },\n    lookupNode: (parent, name) => {\n      var errCode = FS.mayLookup(parent)\n      if (errCode) {\n        throw new FS.ErrnoError(errCode, parent)\n      }\n      var hash = FS.hashName(parent.id, name)\n      for (var node = FS.nameTable[hash]; node; node = node.name_next) {\n        var nodeName = node.name\n        if (node.parent.id === parent.id && nodeName === name) {\n          return node\n        }\n      }\n      return FS.lookup(parent, name)\n    },\n    createNode: (parent, name, mode, rdev) => {\n      var node = new FS.FSNode(parent, name, mode, rdev)\n      FS.hashAddNode(node)\n      return node\n    },\n    destroyNode: (node) => {\n      FS.hashRemoveNode(node)\n    },\n    isRoot: (node) => {\n      return node === node.parent\n    },\n    isMountpoint: (node) => {\n      return !!node.mounted\n    },\n    isFile: (mode) => {\n      return (mode & 61440) === 32768\n    },\n    isDir: (mode) => {\n      return (mode & 61440) === 16384\n    },\n    isLink: (mode) => {\n      return (mode & 61440) === 40960\n    },\n    isChrdev: (mode) => {\n      return (mode & 61440) === 8192\n    },\n    isBlkdev: (mode) => {\n      return (mode & 61440) === 24576\n    },\n    isFIFO: (mode) => {\n      return (mode & 61440) === 4096\n    },\n    isSocket: (mode) => {\n      return (mode & 49152) === 49152\n    },\n    flagModes: { r: 0, 'r+': 2, w: 577, 'w+': 578, a: 1089, 'a+': 1090 },\n    modeStringToFlags: (str) => {\n      var flags = FS.flagModes[str]\n      if (typeof flags == 'undefined') {\n        throw new Error('Unknown file open mode: ' + str)\n      }\n      return flags\n    },\n    flagsToPermissionString: (flag) => {\n      var perms = ['r', 'w', 'rw'][flag & 3]\n      if (flag & 512) {\n        perms += 'w'\n      }\n      return perms\n    },\n    nodePermissions: (node, perms) => {\n      if (FS.ignorePermissions) {\n        return 0\n      }\n      if (perms.includes('r') && !(node.mode & 292)) {\n        return 2\n      } else if (perms.includes('w') && !(node.mode & 146)) {\n        return 2\n      } else if (perms.includes('x') && !(node.mode & 73)) {\n        return 2\n      }\n      return 0\n    },\n    mayLookup: (dir) => {\n      var errCode = FS.nodePermissions(dir, 'x')\n      if (errCode) return errCode\n      if (!dir.node_ops.lookup) return 2\n      return 0\n    },\n    mayCreate: (dir, name) => {\n      try {\n        var node = FS.lookupNode(dir, name)\n        return 20\n      } catch (e) {}\n      return FS.nodePermissions(dir, 'wx')\n    },\n    mayDelete: (dir, name, isdir) => {\n      var node\n      try {\n        node = FS.lookupNode(dir, name)\n      } catch (e) {\n        return e.errno\n      }\n      var errCode = FS.nodePermissions(dir, 'wx')\n      if (errCode) {\n        return errCode\n      }\n      if (isdir) {\n        if (!FS.isDir(node.mode)) {\n          return 54\n        }\n        if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\n          return 10\n        }\n      } else {\n        if (FS.isDir(node.mode)) {\n          return 31\n        }\n      }\n      return 0\n    },\n    mayOpen: (node, flags) => {\n      if (!node) {\n        return 44\n      }\n      if (FS.isLink(node.mode)) {\n        return 32\n      } else if (FS.isDir(node.mode)) {\n        if (FS.flagsToPermissionString(flags) !== 'r' || flags & 512) {\n          return 31\n        }\n      }\n      return FS.nodePermissions(node, FS.flagsToPermissionString(flags))\n    },\n    MAX_OPEN_FDS: 4096,\n    nextfd: (fd_start = 0, fd_end = FS.MAX_OPEN_FDS) => {\n      for (var fd = fd_start; fd <= fd_end; fd++) {\n        if (!FS.streams[fd]) {\n          return fd\n        }\n      }\n      throw new FS.ErrnoError(33)\n    },\n    getStream: (fd) => FS.streams[fd],\n    createStream: (stream, fd_start, fd_end) => {\n      if (!FS.FSStream) {\n        FS.FSStream = function () {\n          this.shared = {}\n        }\n        FS.FSStream.prototype = {}\n        Object.defineProperties(FS.FSStream.prototype, {\n          object: {\n            get: function () {\n              return this.node\n            },\n            set: function (val) {\n              this.node = val\n            }\n          },\n          isRead: {\n            get: function () {\n              return (this.flags & 2097155) !== 1\n            }\n          },\n          isWrite: {\n            get: function () {\n              return (this.flags & 2097155) !== 0\n            }\n          },\n          isAppend: {\n            get: function () {\n              return this.flags & 1024\n            }\n          },\n          flags: {\n            get: function () {\n              return this.shared.flags\n            },\n            set: function (val) {\n              this.shared.flags = val\n            }\n          },\n          position: {\n            get: function () {\n              return this.shared.position\n            },\n            set: function (val) {\n              this.shared.position = val\n            }\n          }\n        })\n      }\n      stream = Object.assign(new FS.FSStream(), stream)\n      var fd = FS.nextfd(fd_start, fd_end)\n      stream.fd = fd\n      FS.streams[fd] = stream\n      return stream\n    },\n    closeStream: (fd) => {\n      FS.streams[fd] = null\n    },\n    chrdev_stream_ops: {\n      open: (stream) => {\n        var device = FS.getDevice(stream.node.rdev)\n        stream.stream_ops = device.stream_ops\n        if (stream.stream_ops.open) {\n          stream.stream_ops.open(stream)\n        }\n      },\n      llseek: () => {\n        throw new FS.ErrnoError(70)\n      }\n    },\n    major: (dev) => dev >> 8,\n    minor: (dev) => dev & 255,\n    makedev: (ma, mi) => (ma << 8) | mi,\n    registerDevice: (dev, ops) => {\n      FS.devices[dev] = { stream_ops: ops }\n    },\n    getDevice: (dev) => FS.devices[dev],\n    getMounts: (mount) => {\n      var mounts = []\n      var check = [mount]\n      while (check.length) {\n        var m = check.pop()\n        mounts.push(m)\n        check.push.apply(check, m.mounts)\n      }\n      return mounts\n    },\n    syncfs: (populate, callback) => {\n      if (typeof populate == 'function') {\n        callback = populate\n        populate = false\n      }\n      FS.syncFSRequests++\n      if (FS.syncFSRequests > 1) {\n        err(\n          'warning: ' +\n            FS.syncFSRequests +\n            ' FS.syncfs operations in flight at once, probably just doing extra work'\n        )\n      }\n      var mounts = FS.getMounts(FS.root.mount)\n      var completed = 0\n      function doCallback(errCode) {\n        FS.syncFSRequests--\n        return callback(errCode)\n      }\n      function done(errCode) {\n        if (errCode) {\n          if (!done.errored) {\n            done.errored = true\n            return doCallback(errCode)\n          }\n          return\n        }\n        if (++completed >= mounts.length) {\n          doCallback(null)\n        }\n      }\n      mounts.forEach((mount) => {\n        if (!mount.type.syncfs) {\n          return done(null)\n        }\n        mount.type.syncfs(mount, populate, done)\n      })\n    },\n    mount: (type, opts, mountpoint) => {\n      var root = mountpoint === '/'\n      var pseudo = !mountpoint\n      var node\n      if (root && FS.root) {\n        throw new FS.ErrnoError(10)\n      } else if (!root && !pseudo) {\n        var lookup = FS.lookupPath(mountpoint, { follow_mount: false })\n        mountpoint = lookup.path\n        node = lookup.node\n        if (FS.isMountpoint(node)) {\n          throw new FS.ErrnoError(10)\n        }\n        if (!FS.isDir(node.mode)) {\n          throw new FS.ErrnoError(54)\n        }\n      }\n      var mount = { type: type, opts: opts, mountpoint: mountpoint, mounts: [] }\n      var mountRoot = type.mount(mount)\n      mountRoot.mount = mount\n      mount.root = mountRoot\n      if (root) {\n        FS.root = mountRoot\n      } else if (node) {\n        node.mounted = mount\n        if (node.mount) {\n          node.mount.mounts.push(mount)\n        }\n      }\n      return mountRoot\n    },\n    unmount: (mountpoint) => {\n      var lookup = FS.lookupPath(mountpoint, { follow_mount: false })\n      if (!FS.isMountpoint(lookup.node)) {\n        throw new FS.ErrnoError(28)\n      }\n      var node = lookup.node\n      var mount = node.mounted\n      var mounts = FS.getMounts(mount)\n      Object.keys(FS.nameTable).forEach((hash) => {\n        var current = FS.nameTable[hash]\n        while (current) {\n          var next = current.name_next\n          if (mounts.includes(current.mount)) {\n            FS.destroyNode(current)\n          }\n          current = next\n        }\n      })\n      node.mounted = null\n      var idx = node.mount.mounts.indexOf(mount)\n      node.mount.mounts.splice(idx, 1)\n    },\n    lookup: (parent, name) => {\n      return parent.node_ops.lookup(parent, name)\n    },\n    mknod: (path, mode, dev) => {\n      var lookup = FS.lookupPath(path, { parent: true })\n      var parent = lookup.node\n      var name = PATH.basename(path)\n      if (!name || name === '.' || name === '..') {\n        throw new FS.ErrnoError(28)\n      }\n      var errCode = FS.mayCreate(parent, name)\n      if (errCode) {\n        throw new FS.ErrnoError(errCode)\n      }\n      if (!parent.node_ops.mknod) {\n        throw new FS.ErrnoError(63)\n      }\n      return parent.node_ops.mknod(parent, name, mode, dev)\n    },\n    create: (path, mode) => {\n      mode = mode !== undefined ? mode : 438\n      mode &= 4095\n      mode |= 32768\n      return FS.mknod(path, mode, 0)\n    },\n    mkdir: (path, mode) => {\n      mode = mode !== undefined ? mode : 511\n      mode &= 511 | 512\n      mode |= 16384\n      return FS.mknod(path, mode, 0)\n    },\n    mkdirTree: (path, mode) => {\n      var dirs = path.split('/')\n      var d = ''\n      for (var i = 0; i < dirs.length; ++i) {\n        if (!dirs[i]) continue\n        d += '/' + dirs[i]\n        try {\n          FS.mkdir(d, mode)\n        } catch (e) {\n          if (e.errno != 20) throw e\n        }\n      }\n    },\n    mkdev: (path, mode, dev) => {\n      if (typeof dev == 'undefined') {\n        dev = mode\n        mode = 438\n      }\n      mode |= 8192\n      return FS.mknod(path, mode, dev)\n    },\n    symlink: (oldpath, newpath) => {\n      if (!PATH_FS.resolve(oldpath)) {\n        throw new FS.ErrnoError(44)\n      }\n      var lookup = FS.lookupPath(newpath, { parent: true })\n      var parent = lookup.node\n      if (!parent) {\n        throw new FS.ErrnoError(44)\n      }\n      var newname = PATH.basename(newpath)\n      var errCode = FS.mayCreate(parent, newname)\n      if (errCode) {\n        throw new FS.ErrnoError(errCode)\n      }\n      if (!parent.node_ops.symlink) {\n        throw new FS.ErrnoError(63)\n      }\n      return parent.node_ops.symlink(parent, newname, oldpath)\n    },\n    rename: (old_path, new_path) => {\n      var old_dirname = PATH.dirname(old_path)\n      var new_dirname = PATH.dirname(new_path)\n      var old_name = PATH.basename(old_path)\n      var new_name = PATH.basename(new_path)\n      var lookup, old_dir, new_dir\n      lookup = FS.lookupPath(old_path, { parent: true })\n      old_dir = lookup.node\n      lookup = FS.lookupPath(new_path, { parent: true })\n      new_dir = lookup.node\n      if (!old_dir || !new_dir) throw new FS.ErrnoError(44)\n      if (old_dir.mount !== new_dir.mount) {\n        throw new FS.ErrnoError(75)\n      }\n      var old_node = FS.lookupNode(old_dir, old_name)\n      var relative = PATH_FS.relative(old_path, new_dirname)\n      if (relative.charAt(0) !== '.') {\n        throw new FS.ErrnoError(28)\n      }\n      relative = PATH_FS.relative(new_path, old_dirname)\n      if (relative.charAt(0) !== '.') {\n        throw new FS.ErrnoError(55)\n      }\n      var new_node\n      try {\n        new_node = FS.lookupNode(new_dir, new_name)\n      } catch (e) {}\n      if (old_node === new_node) {\n        return\n      }\n      var isdir = FS.isDir(old_node.mode)\n      var errCode = FS.mayDelete(old_dir, old_name, isdir)\n      if (errCode) {\n        throw new FS.ErrnoError(errCode)\n      }\n      errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name)\n      if (errCode) {\n        throw new FS.ErrnoError(errCode)\n      }\n      if (!old_dir.node_ops.rename) {\n        throw new FS.ErrnoError(63)\n      }\n      if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {\n        throw new FS.ErrnoError(10)\n      }\n      if (new_dir !== old_dir) {\n        errCode = FS.nodePermissions(old_dir, 'w')\n        if (errCode) {\n          throw new FS.ErrnoError(errCode)\n        }\n      }\n      FS.hashRemoveNode(old_node)\n      try {\n        old_dir.node_ops.rename(old_node, new_dir, new_name)\n      } catch (e) {\n        throw e\n      } finally {\n        FS.hashAddNode(old_node)\n      }\n    },\n    rmdir: (path) => {\n      var lookup = FS.lookupPath(path, { parent: true })\n      var parent = lookup.node\n      var name = PATH.basename(path)\n      var node = FS.lookupNode(parent, name)\n      var errCode = FS.mayDelete(parent, name, true)\n      if (errCode) {\n        throw new FS.ErrnoError(errCode)\n      }\n      if (!parent.node_ops.rmdir) {\n        throw new FS.ErrnoError(63)\n      }\n      if (FS.isMountpoint(node)) {\n        throw new FS.ErrnoError(10)\n      }\n      parent.node_ops.rmdir(parent, name)\n      FS.destroyNode(node)\n    },\n    readdir: (path) => {\n      var lookup = FS.lookupPath(path, { follow: true })\n      var node = lookup.node\n      if (!node.node_ops.readdir) {\n        throw new FS.ErrnoError(54)\n      }\n      return node.node_ops.readdir(node)\n    },\n    unlink: (path) => {\n      var lookup = FS.lookupPath(path, { parent: true })\n      var parent = lookup.node\n      if (!parent) {\n        throw new FS.ErrnoError(44)\n      }\n      var name = PATH.basename(path)\n      var node = FS.lookupNode(parent, name)\n      var errCode = FS.mayDelete(parent, name, false)\n      if (errCode) {\n        throw new FS.ErrnoError(errCode)\n      }\n      if (!parent.node_ops.unlink) {\n        throw new FS.ErrnoError(63)\n      }\n      if (FS.isMountpoint(node)) {\n        throw new FS.ErrnoError(10)\n      }\n      parent.node_ops.unlink(parent, name)\n      FS.destroyNode(node)\n    },\n    readlink: (path) => {\n      var lookup = FS.lookupPath(path)\n      var link = lookup.node\n      if (!link) {\n        throw new FS.ErrnoError(44)\n      }\n      if (!link.node_ops.readlink) {\n        throw new FS.ErrnoError(28)\n      }\n      return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link))\n    },\n    stat: (path, dontFollow) => {\n      var lookup = FS.lookupPath(path, { follow: !dontFollow })\n      var node = lookup.node\n      if (!node) {\n        throw new FS.ErrnoError(44)\n      }\n      if (!node.node_ops.getattr) {\n        throw new FS.ErrnoError(63)\n      }\n      return node.node_ops.getattr(node)\n    },\n    lstat: (path) => {\n      return FS.stat(path, true)\n    },\n    chmod: (path, mode, dontFollow) => {\n      var node\n      if (typeof path == 'string') {\n        var lookup = FS.lookupPath(path, { follow: !dontFollow })\n        node = lookup.node\n      } else {\n        node = path\n      }\n      if (!node.node_ops.setattr) {\n        throw new FS.ErrnoError(63)\n      }\n      node.node_ops.setattr(node, {\n        mode: (mode & 4095) | (node.mode & ~4095),\n        timestamp: Date.now()\n      })\n    },\n    lchmod: (path, mode) => {\n      FS.chmod(path, mode, true)\n    },\n    fchmod: (fd, mode) => {\n      var stream = FS.getStream(fd)\n      if (!stream) {\n        throw new FS.ErrnoError(8)\n      }\n      FS.chmod(stream.node, mode)\n    },\n    chown: (path, uid, gid, dontFollow) => {\n      var node\n      if (typeof path == 'string') {\n        var lookup = FS.lookupPath(path, { follow: !dontFollow })\n        node = lookup.node\n      } else {\n        node = path\n      }\n      if (!node.node_ops.setattr) {\n        throw new FS.ErrnoError(63)\n      }\n      node.node_ops.setattr(node, { timestamp: Date.now() })\n    },\n    lchown: (path, uid, gid) => {\n      FS.chown(path, uid, gid, true)\n    },\n    fchown: (fd, uid, gid) => {\n      var stream = FS.getStream(fd)\n      if (!stream) {\n        throw new FS.ErrnoError(8)\n      }\n      FS.chown(stream.node, uid, gid)\n    },\n    truncate: (path, len) => {\n      if (len < 0) {\n        throw new FS.ErrnoError(28)\n      }\n      var node\n      if (typeof path == 'string') {\n        var lookup = FS.lookupPath(path, { follow: true })\n        node = lookup.node\n      } else {\n        node = path\n      }\n      if (!node.node_ops.setattr) {\n        throw new FS.ErrnoError(63)\n      }\n      if (FS.isDir(node.mode)) {\n        throw new FS.ErrnoError(31)\n      }\n      if (!FS.isFile(node.mode)) {\n        throw new FS.ErrnoError(28)\n      }\n      var errCode = FS.nodePermissions(node, 'w')\n      if (errCode) {\n        throw new FS.ErrnoError(errCode)\n      }\n      node.node_ops.setattr(node, { size: len, timestamp: Date.now() })\n    },\n    ftruncate: (fd, len) => {\n      var stream = FS.getStream(fd)\n      if (!stream) {\n        throw new FS.ErrnoError(8)\n      }\n      if ((stream.flags & 2097155) === 0) {\n        throw new FS.ErrnoError(28)\n      }\n      FS.truncate(stream.node, len)\n    },\n    utime: (path, atime, mtime) => {\n      var lookup = FS.lookupPath(path, { follow: true })\n      var node = lookup.node\n      node.node_ops.setattr(node, { timestamp: Math.max(atime, mtime) })\n    },\n    open: (path, flags, mode) => {\n      if (path === '') {\n        throw new FS.ErrnoError(44)\n      }\n      flags = typeof flags == 'string' ? FS.modeStringToFlags(flags) : flags\n      mode = typeof mode == 'undefined' ? 438 : mode\n      if (flags & 64) {\n        mode = (mode & 4095) | 32768\n      } else {\n        mode = 0\n      }\n      var node\n      if (typeof path == 'object') {\n        node = path\n      } else {\n        path = PATH.normalize(path)\n        try {\n          var lookup = FS.lookupPath(path, { follow: !(flags & 131072) })\n          node = lookup.node\n        } catch (e) {}\n      }\n      var created = false\n      if (flags & 64) {\n        if (node) {\n          if (flags & 128) {\n            throw new FS.ErrnoError(20)\n          }\n        } else {\n          node = FS.mknod(path, mode, 0)\n          created = true\n        }\n      }\n      if (!node) {\n        throw new FS.ErrnoError(44)\n      }\n      if (FS.isChrdev(node.mode)) {\n        flags &= ~512\n      }\n      if (flags & 65536 && !FS.isDir(node.mode)) {\n        throw new FS.ErrnoError(54)\n      }\n      if (!created) {\n        var errCode = FS.mayOpen(node, flags)\n        if (errCode) {\n          throw new FS.ErrnoError(errCode)\n        }\n      }\n      if (flags & 512 && !created) {\n        FS.truncate(node, 0)\n      }\n      flags &= ~(128 | 512 | 131072)\n      var stream = FS.createStream({\n        node: node,\n        path: FS.getPath(node),\n        flags: flags,\n        seekable: true,\n        position: 0,\n        stream_ops: node.stream_ops,\n        ungotten: [],\n        error: false\n      })\n      if (stream.stream_ops.open) {\n        stream.stream_ops.open(stream)\n      }\n      if (Module['logReadFiles'] && !(flags & 1)) {\n        if (!FS.readFiles) FS.readFiles = {}\n        if (!(path in FS.readFiles)) {\n          FS.readFiles[path] = 1\n        }\n      }\n      return stream\n    },\n    close: (stream) => {\n      if (FS.isClosed(stream)) {\n        throw new FS.ErrnoError(8)\n      }\n      if (stream.getdents) stream.getdents = null\n      try {\n        if (stream.stream_ops.close) {\n          stream.stream_ops.close(stream)\n        }\n      } catch (e) {\n        throw e\n      } finally {\n        FS.closeStream(stream.fd)\n      }\n      stream.fd = null\n    },\n    isClosed: (stream) => {\n      return stream.fd === null\n    },\n    llseek: (stream, offset, whence) => {\n      if (FS.isClosed(stream)) {\n        throw new FS.ErrnoError(8)\n      }\n      if (!stream.seekable || !stream.stream_ops.llseek) {\n        throw new FS.ErrnoError(70)\n      }\n      if (whence != 0 && whence != 1 && whence != 2) {\n        throw new FS.ErrnoError(28)\n      }\n      stream.position = stream.stream_ops.llseek(stream, offset, whence)\n      stream.ungotten = []\n      return stream.position\n    },\n    read: (stream, buffer, offset, length, position) => {\n      if (length < 0 || position < 0) {\n        throw new FS.ErrnoError(28)\n      }\n      if (FS.isClosed(stream)) {\n        throw new FS.ErrnoError(8)\n      }\n      if ((stream.flags & 2097155) === 1) {\n        throw new FS.ErrnoError(8)\n      }\n      if (FS.isDir(stream.node.mode)) {\n        throw new FS.ErrnoError(31)\n      }\n      if (!stream.stream_ops.read) {\n        throw new FS.ErrnoError(28)\n      }\n      var seeking = typeof position != 'undefined'\n      if (!seeking) {\n        position = stream.position\n      } else if (!stream.seekable) {\n        throw new FS.ErrnoError(70)\n      }\n      var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position)\n      if (!seeking) stream.position += bytesRead\n      return bytesRead\n    },\n    write: (stream, buffer, offset, length, position, canOwn) => {\n      if (length < 0 || position < 0) {\n        throw new FS.ErrnoError(28)\n      }\n      if (FS.isClosed(stream)) {\n        throw new FS.ErrnoError(8)\n      }\n      if ((stream.flags & 2097155) === 0) {\n        throw new FS.ErrnoError(8)\n      }\n      if (FS.isDir(stream.node.mode)) {\n        throw new FS.ErrnoError(31)\n      }\n      if (!stream.stream_ops.write) {\n        throw new FS.ErrnoError(28)\n      }\n      if (stream.seekable && stream.flags & 1024) {\n        FS.llseek(stream, 0, 2)\n      }\n      var seeking = typeof position != 'undefined'\n      if (!seeking) {\n        position = stream.position\n      } else if (!stream.seekable) {\n        throw new FS.ErrnoError(70)\n      }\n      var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn)\n      if (!seeking) stream.position += bytesWritten\n      return bytesWritten\n    },\n    allocate: (stream, offset, length) => {\n      if (FS.isClosed(stream)) {\n        throw new FS.ErrnoError(8)\n      }\n      if (offset < 0 || length <= 0) {\n        throw new FS.ErrnoError(28)\n      }\n      if ((stream.flags & 2097155) === 0) {\n        throw new FS.ErrnoError(8)\n      }\n      if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {\n        throw new FS.ErrnoError(43)\n      }\n      if (!stream.stream_ops.allocate) {\n        throw new FS.ErrnoError(138)\n      }\n      stream.stream_ops.allocate(stream, offset, length)\n    },\n    mmap: (stream, length, position, prot, flags) => {\n      if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {\n        throw new FS.ErrnoError(2)\n      }\n      if ((stream.flags & 2097155) === 1) {\n        throw new FS.ErrnoError(2)\n      }\n      if (!stream.stream_ops.mmap) {\n        throw new FS.ErrnoError(43)\n      }\n      return stream.stream_ops.mmap(stream, length, position, prot, flags)\n    },\n    msync: (stream, buffer, offset, length, mmapFlags) => {\n      if (!stream.stream_ops.msync) {\n        return 0\n      }\n      return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags)\n    },\n    munmap: (stream) => 0,\n    ioctl: (stream, cmd, arg) => {\n      if (!stream.stream_ops.ioctl) {\n        throw new FS.ErrnoError(59)\n      }\n      return stream.stream_ops.ioctl(stream, cmd, arg)\n    },\n    readFile: (path, opts = {}) => {\n      opts.flags = opts.flags || 0\n      opts.encoding = opts.encoding || 'binary'\n      if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {\n        throw new Error('Invalid encoding type \"' + opts.encoding + '\"')\n      }\n      var ret\n      var stream = FS.open(path, opts.flags)\n      var stat = FS.stat(path)\n      var length = stat.size\n      var buf = new Uint8Array(length)\n      FS.read(stream, buf, 0, length, 0)\n      if (opts.encoding === 'utf8') {\n        ret = UTF8ArrayToString(buf, 0)\n      } else if (opts.encoding === 'binary') {\n        ret = buf\n      }\n      FS.close(stream)\n      return ret\n    },\n    writeFile: (path, data, opts = {}) => {\n      opts.flags = opts.flags || 577\n      var stream = FS.open(path, opts.flags, opts.mode)\n      if (typeof data == 'string') {\n        var buf = new Uint8Array(lengthBytesUTF8(data) + 1)\n        var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length)\n        FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn)\n      } else if (ArrayBuffer.isView(data)) {\n        FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn)\n      } else {\n        throw new Error('Unsupported data type')\n      }\n      FS.close(stream)\n    },\n    cwd: () => FS.currentPath,\n    chdir: (path) => {\n      var lookup = FS.lookupPath(path, { follow: true })\n      if (lookup.node === null) {\n        throw new FS.ErrnoError(44)\n      }\n      if (!FS.isDir(lookup.node.mode)) {\n        throw new FS.ErrnoError(54)\n      }\n      var errCode = FS.nodePermissions(lookup.node, 'x')\n      if (errCode) {\n        throw new FS.ErrnoError(errCode)\n      }\n      FS.currentPath = lookup.path\n    },\n    createDefaultDirectories: () => {\n      FS.mkdir('/tmp')\n      FS.mkdir('/home')\n      FS.mkdir('/home/web_user')\n    },\n    createDefaultDevices: () => {\n      FS.mkdir('/dev')\n      FS.registerDevice(FS.makedev(1, 3), {\n        read: () => 0,\n        write: (stream, buffer, offset, length, pos) => length\n      })\n      FS.mkdev('/dev/null', FS.makedev(1, 3))\n      TTY.register(FS.makedev(5, 0), TTY.default_tty_ops)\n      TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops)\n      FS.mkdev('/dev/tty', FS.makedev(5, 0))\n      FS.mkdev('/dev/tty1', FS.makedev(6, 0))\n      var random_device = getRandomDevice()\n      FS.createDevice('/dev', 'random', random_device)\n      FS.createDevice('/dev', 'urandom', random_device)\n      FS.mkdir('/dev/shm')\n      FS.mkdir('/dev/shm/tmp')\n    },\n    createSpecialDirectories: () => {\n      FS.mkdir('/proc')\n      var proc_self = FS.mkdir('/proc/self')\n      FS.mkdir('/proc/self/fd')\n      FS.mount(\n        {\n          mount: () => {\n            var node = FS.createNode(proc_self, 'fd', 16384 | 511, 73)\n            node.node_ops = {\n              lookup: (parent, name) => {\n                var fd = +name\n                var stream = FS.getStream(fd)\n                if (!stream) throw new FS.ErrnoError(8)\n                var ret = {\n                  parent: null,\n                  mount: { mountpoint: 'fake' },\n                  node_ops: { readlink: () => stream.path }\n                }\n                ret.parent = ret\n                return ret\n              }\n            }\n            return node\n          }\n        },\n        {},\n        '/proc/self/fd'\n      )\n    },\n    createStandardStreams: () => {\n      if (Module['stdin']) {\n        FS.createDevice('/dev', 'stdin', Module['stdin'])\n      } else {\n        FS.symlink('/dev/tty', '/dev/stdin')\n      }\n      if (Module['stdout']) {\n        FS.createDevice('/dev', 'stdout', null, Module['stdout'])\n      } else {\n        FS.symlink('/dev/tty', '/dev/stdout')\n      }\n      if (Module['stderr']) {\n        FS.createDevice('/dev', 'stderr', null, Module['stderr'])\n      } else {\n        FS.symlink('/dev/tty1', '/dev/stderr')\n      }\n      var stdin = FS.open('/dev/stdin', 0)\n      var stdout = FS.open('/dev/stdout', 1)\n      var stderr = FS.open('/dev/stderr', 1)\n    },\n    ensureErrnoError: () => {\n      if (FS.ErrnoError) return\n      FS.ErrnoError = function ErrnoError(errno, node) {\n        this.node = node\n        this.setErrno = function (errno) {\n          this.errno = errno\n        }\n        this.setErrno(errno)\n        this.message = 'FS error'\n      }\n      FS.ErrnoError.prototype = new Error()\n      FS.ErrnoError.prototype.constructor = FS.ErrnoError\n      ;[44].forEach((code) => {\n        FS.genericErrors[code] = new FS.ErrnoError(code)\n        FS.genericErrors[code].stack = '<generic error, no stack>'\n      })\n    },\n    staticInit: () => {\n      FS.ensureErrnoError()\n      FS.nameTable = new Array(4096)\n      FS.mount(MEMFS, {}, '/')\n      FS.createDefaultDirectories()\n      FS.createDefaultDevices()\n      FS.createSpecialDirectories()\n      FS.filesystems = { MEMFS: MEMFS }\n    },\n    init: (input, output, error) => {\n      FS.init.initialized = true\n      FS.ensureErrnoError()\n      Module['stdin'] = input || Module['stdin']\n      Module['stdout'] = output || Module['stdout']\n      Module['stderr'] = error || Module['stderr']\n      FS.createStandardStreams()\n    },\n    quit: () => {\n      FS.init.initialized = false\n      for (var i = 0; i < FS.streams.length; i++) {\n        var stream = FS.streams[i]\n        if (!stream) {\n          continue\n        }\n        FS.close(stream)\n      }\n    },\n    getMode: (canRead, canWrite) => {\n      var mode = 0\n      if (canRead) mode |= 292 | 73\n      if (canWrite) mode |= 146\n      return mode\n    },\n    findObject: (path, dontResolveLastLink) => {\n      var ret = FS.analyzePath(path, dontResolveLastLink)\n      if (!ret.exists) {\n        return null\n      }\n      return ret.object\n    },\n    analyzePath: (path, dontResolveLastLink) => {\n      try {\n        var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink })\n        path = lookup.path\n      } catch (e) {}\n      var ret = {\n        isRoot: false,\n        exists: false,\n        error: 0,\n        name: null,\n        path: null,\n        object: null,\n        parentExists: false,\n        parentPath: null,\n        parentObject: null\n      }\n      try {\n        var lookup = FS.lookupPath(path, { parent: true })\n        ret.parentExists = true\n        ret.parentPath = lookup.path\n        ret.parentObject = lookup.node\n        ret.name = PATH.basename(path)\n        lookup = FS.lookupPath(path, { follow: !dontResolveLastLink })\n        ret.exists = true\n        ret.path = lookup.path\n        ret.object = lookup.node\n        ret.name = lookup.node.name\n        ret.isRoot = lookup.path === '/'\n      } catch (e) {\n        ret.error = e.errno\n      }\n      return ret\n    },\n    createPath: (parent, path, canRead, canWrite) => {\n      parent = typeof parent == 'string' ? parent : FS.getPath(parent)\n      var parts = path.split('/').reverse()\n      while (parts.length) {\n        var part = parts.pop()\n        if (!part) continue\n        var current = PATH.join2(parent, part)\n        try {\n          FS.mkdir(current)\n        } catch (e) {}\n        parent = current\n      }\n      return current\n    },\n    createFile: (parent, name, properties, canRead, canWrite) => {\n      var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name)\n      var mode = FS.getMode(canRead, canWrite)\n      return FS.create(path, mode)\n    },\n    createDataFile: (parent, name, data, canRead, canWrite, canOwn) => {\n      var path = name\n      if (parent) {\n        parent = typeof parent == 'string' ? parent : FS.getPath(parent)\n        path = name ? PATH.join2(parent, name) : parent\n      }\n      var mode = FS.getMode(canRead, canWrite)\n      var node = FS.create(path, mode)\n      if (data) {\n        if (typeof data == 'string') {\n          var arr = new Array(data.length)\n          for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i)\n          data = arr\n        }\n        FS.chmod(node, mode | 146)\n        var stream = FS.open(node, 577)\n        FS.write(stream, data, 0, data.length, 0, canOwn)\n        FS.close(stream)\n        FS.chmod(node, mode)\n      }\n      return node\n    },\n    createDevice: (parent, name, input, output) => {\n      var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name)\n      var mode = FS.getMode(!!input, !!output)\n      if (!FS.createDevice.major) FS.createDevice.major = 64\n      var dev = FS.makedev(FS.createDevice.major++, 0)\n      FS.registerDevice(dev, {\n        open: (stream) => {\n          stream.seekable = false\n        },\n        close: (stream) => {\n          if (output && output.buffer && output.buffer.length) {\n            output(10)\n          }\n        },\n        read: (stream, buffer, offset, length, pos) => {\n          var bytesRead = 0\n          for (var i = 0; i < length; i++) {\n            var result\n            try {\n              result = input()\n            } catch (e) {\n              throw new FS.ErrnoError(29)\n            }\n            if (result === undefined && bytesRead === 0) {\n              throw new FS.ErrnoError(6)\n            }\n            if (result === null || result === undefined) break\n            bytesRead++\n            buffer[offset + i] = result\n          }\n          if (bytesRead) {\n            stream.node.timestamp = Date.now()\n          }\n          return bytesRead\n        },\n        write: (stream, buffer, offset, length, pos) => {\n          for (var i = 0; i < length; i++) {\n            try {\n              output(buffer[offset + i])\n            } catch (e) {\n              throw new FS.ErrnoError(29)\n            }\n          }\n          if (length) {\n            stream.node.timestamp = Date.now()\n          }\n          return i\n        }\n      })\n      return FS.mkdev(path, mode, dev)\n    },\n    forceLoadFile: (obj) => {\n      if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true\n      if (typeof XMLHttpRequest != 'undefined') {\n        throw new Error(\n          'Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.'\n        )\n      } else if (read_) {\n        try {\n          obj.contents = intArrayFromString(read_(obj.url), true)\n          obj.usedBytes = obj.contents.length\n        } catch (e) {\n          throw new FS.ErrnoError(29)\n        }\n      } else {\n        throw new Error('Cannot load without read() or XMLHttpRequest.')\n      }\n    },\n    createLazyFile: (parent, name, url, canRead, canWrite) => {\n      function LazyUint8Array() {\n        this.lengthKnown = false\n        this.chunks = []\n      }\n      LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {\n        if (idx > this.length - 1 || idx < 0) {\n          return undefined\n        }\n        var chunkOffset = idx % this.chunkSize\n        var chunkNum = (idx / this.chunkSize) | 0\n        return this.getter(chunkNum)[chunkOffset]\n      }\n      LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {\n        this.getter = getter\n      }\n      LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {\n        var xhr = new XMLHttpRequest()\n        xhr.open('HEAD', url, false)\n        xhr.send(null)\n        if (!((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304))\n          throw new Error(\"Couldn't load \" + url + '. Status: ' + xhr.status)\n        var datalength = Number(xhr.getResponseHeader('Content-length'))\n        var header\n        var hasByteServing = (header = xhr.getResponseHeader('Accept-Ranges')) && header === 'bytes'\n        var usesGzip = (header = xhr.getResponseHeader('Content-Encoding')) && header === 'gzip'\n        var chunkSize = 1024 * 1024\n        if (!hasByteServing) chunkSize = datalength\n        var doXHR = (from, to) => {\n          if (from > to)\n            throw new Error('invalid range (' + from + ', ' + to + ') or no bytes requested!')\n          if (to > datalength - 1)\n            throw new Error('only ' + datalength + ' bytes available! programmer error!')\n          var xhr = new XMLHttpRequest()\n          xhr.open('GET', url, false)\n          if (datalength !== chunkSize) xhr.setRequestHeader('Range', 'bytes=' + from + '-' + to)\n          xhr.responseType = 'arraybuffer'\n          if (xhr.overrideMimeType) {\n            xhr.overrideMimeType('text/plain; charset=x-user-defined')\n          }\n          xhr.send(null)\n          if (!((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304))\n            throw new Error(\"Couldn't load \" + url + '. Status: ' + xhr.status)\n          if (xhr.response !== undefined) {\n            return new Uint8Array(xhr.response || [])\n          }\n          return intArrayFromString(xhr.responseText || '', true)\n        }\n        var lazyArray = this\n        lazyArray.setDataGetter((chunkNum) => {\n          var start = chunkNum * chunkSize\n          var end = (chunkNum + 1) * chunkSize - 1\n          end = Math.min(end, datalength - 1)\n          if (typeof lazyArray.chunks[chunkNum] == 'undefined') {\n            lazyArray.chunks[chunkNum] = doXHR(start, end)\n          }\n          if (typeof lazyArray.chunks[chunkNum] == 'undefined') throw new Error('doXHR failed!')\n          return lazyArray.chunks[chunkNum]\n        })\n        if (usesGzip || !datalength) {\n          chunkSize = datalength = 1\n          datalength = this.getter(0).length\n          chunkSize = datalength\n          out('LazyFiles on gzip forces download of the whole file when length is accessed')\n        }\n        this._length = datalength\n        this._chunkSize = chunkSize\n        this.lengthKnown = true\n      }\n      if (typeof XMLHttpRequest != 'undefined') {\n        if (!ENVIRONMENT_IS_WORKER)\n          throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc'\n        var lazyArray = new LazyUint8Array()\n        Object.defineProperties(lazyArray, {\n          length: {\n            get: function () {\n              if (!this.lengthKnown) {\n                this.cacheLength()\n              }\n              return this._length\n            }\n          },\n          chunkSize: {\n            get: function () {\n              if (!this.lengthKnown) {\n                this.cacheLength()\n              }\n              return this._chunkSize\n            }\n          }\n        })\n        var properties = { isDevice: false, contents: lazyArray }\n      } else {\n        var properties = { isDevice: false, url: url }\n      }\n      var node = FS.createFile(parent, name, properties, canRead, canWrite)\n      if (properties.contents) {\n        node.contents = properties.contents\n      } else if (properties.url) {\n        node.contents = null\n        node.url = properties.url\n      }\n      Object.defineProperties(node, {\n        usedBytes: {\n          get: function () {\n            return this.contents.length\n          }\n        }\n      })\n      var stream_ops = {}\n      var keys = Object.keys(node.stream_ops)\n      keys.forEach((key) => {\n        var fn = node.stream_ops[key]\n        stream_ops[key] = function forceLoadLazyFile() {\n          FS.forceLoadFile(node)\n          return fn.apply(null, arguments)\n        }\n      })\n      function writeChunks(stream, buffer, offset, length, position) {\n        var contents = stream.node.contents\n        if (position >= contents.length) return 0\n        var size = Math.min(contents.length - position, length)\n        if (contents.slice) {\n          for (var i = 0; i < size; i++) {\n            buffer[offset + i] = contents[position + i]\n          }\n        } else {\n          for (var i = 0; i < size; i++) {\n            buffer[offset + i] = contents.get(position + i)\n          }\n        }\n        return size\n      }\n      stream_ops.read = (stream, buffer, offset, length, position) => {\n        FS.forceLoadFile(node)\n        return writeChunks(stream, buffer, offset, length, position)\n      }\n      stream_ops.mmap = (stream, length, position, prot, flags) => {\n        FS.forceLoadFile(node)\n        var ptr = mmapAlloc(length)\n        if (!ptr) {\n          throw new FS.ErrnoError(48)\n        }\n        writeChunks(stream, HEAP8, ptr, length, position)\n        return { ptr: ptr, allocated: true }\n      }\n      node.stream_ops = stream_ops\n      return node\n    },\n    createPreloadedFile: (\n      parent,\n      name,\n      url,\n      canRead,\n      canWrite,\n      onload,\n      onerror,\n      dontCreateFile,\n      canOwn,\n      preFinish\n    ) => {\n      var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent\n      var dep = getUniqueRunDependency('cp ' + fullname)\n      function processData(byteArray) {\n        function finish(byteArray) {\n          if (preFinish) preFinish()\n          if (!dontCreateFile) {\n            FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn)\n          }\n          if (onload) onload()\n          removeRunDependency(dep)\n        }\n        if (\n          Browser.handledByPreloadPlugin(byteArray, fullname, finish, () => {\n            if (onerror) onerror()\n            removeRunDependency(dep)\n          })\n        ) {\n          return\n        }\n        finish(byteArray)\n      }\n      addRunDependency(dep)\n      if (typeof url == 'string') {\n        asyncLoad(url, (byteArray) => processData(byteArray), onerror)\n      } else {\n        processData(url)\n      }\n    },\n    indexedDB: () => {\n      return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB\n    },\n    DB_NAME: () => {\n      return 'EM_FS_' + window.location.pathname\n    },\n    DB_VERSION: 20,\n    DB_STORE_NAME: 'FILE_DATA',\n    saveFilesToDB: (paths, onload, onerror) => {\n      onload = onload || (() => {})\n      onerror = onerror || (() => {})\n      var indexedDB = FS.indexedDB()\n      try {\n        var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION)\n      } catch (e) {\n        return onerror(e)\n      }\n      openRequest.onupgradeneeded = () => {\n        out('creating db')\n        var db = openRequest.result\n        db.createObjectStore(FS.DB_STORE_NAME)\n      }\n      openRequest.onsuccess = () => {\n        var db = openRequest.result\n        var transaction = db.transaction([FS.DB_STORE_NAME], 'readwrite')\n        var files = transaction.objectStore(FS.DB_STORE_NAME)\n        var ok = 0,\n          fail = 0,\n          total = paths.length\n        function finish() {\n          if (fail == 0) onload()\n          else onerror()\n        }\n        paths.forEach((path) => {\n          var putRequest = files.put(FS.analyzePath(path).object.contents, path)\n          putRequest.onsuccess = () => {\n            ok++\n            if (ok + fail == total) finish()\n          }\n          putRequest.onerror = () => {\n            fail++\n            if (ok + fail == total) finish()\n          }\n        })\n        transaction.onerror = onerror\n      }\n      openRequest.onerror = onerror\n    },\n    loadFilesFromDB: (paths, onload, onerror) => {\n      onload = onload || (() => {})\n      onerror = onerror || (() => {})\n      var indexedDB = FS.indexedDB()\n      try {\n        var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION)\n      } catch (e) {\n        return onerror(e)\n      }\n      openRequest.onupgradeneeded = onerror\n      openRequest.onsuccess = () => {\n        var db = openRequest.result\n        try {\n          var transaction = db.transaction([FS.DB_STORE_NAME], 'readonly')\n        } catch (e) {\n          onerror(e)\n          return\n        }\n        var files = transaction.objectStore(FS.DB_STORE_NAME)\n        var ok = 0,\n          fail = 0,\n          total = paths.length\n        function finish() {\n          if (fail == 0) onload()\n          else onerror()\n        }\n        paths.forEach((path) => {\n          var getRequest = files.get(path)\n          getRequest.onsuccess = () => {\n            if (FS.analyzePath(path).exists) {\n              FS.unlink(path)\n            }\n            FS.createDataFile(\n              PATH.dirname(path),\n              PATH.basename(path),\n              getRequest.result,\n              true,\n              true,\n              true\n            )\n            ok++\n            if (ok + fail == total) finish()\n          }\n          getRequest.onerror = () => {\n            fail++\n            if (ok + fail == total) finish()\n          }\n        })\n        transaction.onerror = onerror\n      }\n      openRequest.onerror = onerror\n    }\n  }\n  var SYSCALLS = {\n    DEFAULT_POLLMASK: 5,\n    calculateAt: function (dirfd, path, allowEmpty) {\n      if (PATH.isAbs(path)) {\n        return path\n      }\n      var dir\n      if (dirfd === -100) {\n        dir = FS.cwd()\n      } else {\n        var dirstream = SYSCALLS.getStreamFromFD(dirfd)\n        dir = dirstream.path\n      }\n      if (path.length == 0) {\n        if (!allowEmpty) {\n          throw new FS.ErrnoError(44)\n        }\n        return dir\n      }\n      return PATH.join2(dir, path)\n    },\n    doStat: function (func, path, buf) {\n      try {\n        var stat = func(path)\n      } catch (e) {\n        if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {\n          return -54\n        }\n        throw e\n      }\n      HEAP32[buf >> 2] = stat.dev\n      HEAP32[(buf + 8) >> 2] = stat.ino\n      HEAP32[(buf + 12) >> 2] = stat.mode\n      HEAPU32[(buf + 16) >> 2] = stat.nlink\n      HEAP32[(buf + 20) >> 2] = stat.uid\n      HEAP32[(buf + 24) >> 2] = stat.gid\n      HEAP32[(buf + 28) >> 2] = stat.rdev\n      ;(tempI64 = [\n        stat.size >>> 0,\n        ((tempDouble = stat.size),\n        +Math.abs(tempDouble) >= 1\n          ? tempDouble > 0\n            ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0\n            : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0\n          : 0)\n      ]),\n        (HEAP32[(buf + 40) >> 2] = tempI64[0]),\n        (HEAP32[(buf + 44) >> 2] = tempI64[1])\n      HEAP32[(buf + 48) >> 2] = 4096\n      HEAP32[(buf + 52) >> 2] = stat.blocks\n      ;(tempI64 = [\n        Math.floor(stat.atime.getTime() / 1e3) >>> 0,\n        ((tempDouble = Math.floor(stat.atime.getTime() / 1e3)),\n        +Math.abs(tempDouble) >= 1\n          ? tempDouble > 0\n            ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0\n            : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0\n          : 0)\n      ]),\n        (HEAP32[(buf + 56) >> 2] = tempI64[0]),\n        (HEAP32[(buf + 60) >> 2] = tempI64[1])\n      HEAPU32[(buf + 64) >> 2] = 0\n      ;(tempI64 = [\n        Math.floor(stat.mtime.getTime() / 1e3) >>> 0,\n        ((tempDouble = Math.floor(stat.mtime.getTime() / 1e3)),\n        +Math.abs(tempDouble) >= 1\n          ? tempDouble > 0\n            ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0\n            : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0\n          : 0)\n      ]),\n        (HEAP32[(buf + 72) >> 2] = tempI64[0]),\n        (HEAP32[(buf + 76) >> 2] = tempI64[1])\n      HEAPU32[(buf + 80) >> 2] = 0\n      ;(tempI64 = [\n        Math.floor(stat.ctime.getTime() / 1e3) >>> 0,\n        ((tempDouble = Math.floor(stat.ctime.getTime() / 1e3)),\n        +Math.abs(tempDouble) >= 1\n          ? tempDouble > 0\n            ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0\n            : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0\n          : 0)\n      ]),\n        (HEAP32[(buf + 88) >> 2] = tempI64[0]),\n        (HEAP32[(buf + 92) >> 2] = tempI64[1])\n      HEAPU32[(buf + 96) >> 2] = 0\n      ;(tempI64 = [\n        stat.ino >>> 0,\n        ((tempDouble = stat.ino),\n        +Math.abs(tempDouble) >= 1\n          ? tempDouble > 0\n            ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0\n            : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0\n          : 0)\n      ]),\n        (HEAP32[(buf + 104) >> 2] = tempI64[0]),\n        (HEAP32[(buf + 108) >> 2] = tempI64[1])\n      return 0\n    },\n    doMsync: function (addr, stream, len, flags, offset) {\n      if (!FS.isFile(stream.node.mode)) {\n        throw new FS.ErrnoError(43)\n      }\n      if (flags & 2) {\n        return 0\n      }\n      var buffer = HEAPU8.slice(addr, addr + len)\n      FS.msync(stream, buffer, offset, len, flags)\n    },\n    varargs: undefined,\n    get: function () {\n      SYSCALLS.varargs += 4\n      var ret = HEAP32[(SYSCALLS.varargs - 4) >> 2]\n      return ret\n    },\n    getStr: function (ptr) {\n      var ret = UTF8ToString(ptr)\n      return ret\n    },\n    getStreamFromFD: function (fd) {\n      var stream = FS.getStream(fd)\n      if (!stream) throw new FS.ErrnoError(8)\n      return stream\n    }\n  }\n  function ___syscall_fcntl64(fd, cmd, varargs) {\n    SYSCALLS.varargs = varargs\n    try {\n      var stream = SYSCALLS.getStreamFromFD(fd)\n      switch (cmd) {\n        case 0: {\n          var arg = SYSCALLS.get()\n          if (arg < 0) {\n            return -28\n          }\n          var newStream\n          newStream = FS.createStream(stream, arg)\n          return newStream.fd\n        }\n        case 1:\n        case 2:\n          return 0\n        case 3:\n          return stream.flags\n        case 4: {\n          var arg = SYSCALLS.get()\n          stream.flags |= arg\n          return 0\n        }\n        case 5: {\n          var arg = SYSCALLS.get()\n          var offset = 0\n          HEAP16[(arg + offset) >> 1] = 2\n          return 0\n        }\n        case 6:\n        case 7:\n          return 0\n        case 16:\n        case 8:\n          return -28\n        case 9:\n          setErrNo(28)\n          return -1\n        default: {\n          return -28\n        }\n      }\n    } catch (e) {\n      if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e\n      return -e.errno\n    }\n  }\n  function ___syscall_ioctl(fd, op, varargs) {\n    SYSCALLS.varargs = varargs\n    try {\n      var stream = SYSCALLS.getStreamFromFD(fd)\n      switch (op) {\n        case 21509:\n        case 21505: {\n          if (!stream.tty) return -59\n          return 0\n        }\n        case 21510:\n        case 21511:\n        case 21512:\n        case 21506:\n        case 21507:\n        case 21508: {\n          if (!stream.tty) return -59\n          return 0\n        }\n        case 21519: {\n          if (!stream.tty) return -59\n          var argp = SYSCALLS.get()\n          HEAP32[argp >> 2] = 0\n          return 0\n        }\n        case 21520: {\n          if (!stream.tty) return -59\n          return -28\n        }\n        case 21531: {\n          var argp = SYSCALLS.get()\n          return FS.ioctl(stream, op, argp)\n        }\n        case 21523: {\n          if (!stream.tty) return -59\n          return 0\n        }\n        case 21524: {\n          if (!stream.tty) return -59\n          return 0\n        }\n        default:\n          return -28\n      }\n    } catch (e) {\n      if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e\n      return -e.errno\n    }\n  }\n  function ___syscall_openat(dirfd, path, flags, varargs) {\n    SYSCALLS.varargs = varargs\n    try {\n      path = SYSCALLS.getStr(path)\n      path = SYSCALLS.calculateAt(dirfd, path)\n      var mode = varargs ? SYSCALLS.get() : 0\n      return FS.open(path, flags, mode).fd\n    } catch (e) {\n      if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e\n      return -e.errno\n    }\n  }\n  function __embind_register_bigint(primitiveType, name, size, minRange, maxRange) {}\n  function getShiftFromSize(size) {\n    switch (size) {\n      case 1:\n        return 0\n      case 2:\n        return 1\n      case 4:\n        return 2\n      case 8:\n        return 3\n      default:\n        throw new TypeError('Unknown type size: ' + size)\n    }\n  }\n  function embind_init_charCodes() {\n    var codes = new Array(256)\n    for (var i = 0; i < 256; ++i) {\n      codes[i] = String.fromCharCode(i)\n    }\n    embind_charCodes = codes\n  }\n  var embind_charCodes = undefined\n  function readLatin1String(ptr) {\n    var ret = ''\n    var c = ptr\n    while (HEAPU8[c]) {\n      ret += embind_charCodes[HEAPU8[c++]]\n    }\n    return ret\n  }\n  var awaitingDependencies = {}\n  var registeredTypes = {}\n  var typeDependencies = {}\n  var char_0 = 48\n  var char_9 = 57\n  function makeLegalFunctionName(name) {\n    if (undefined === name) {\n      return '_unknown'\n    }\n    name = name.replace(/[^a-zA-Z0-9_]/g, '$')\n    var f = name.charCodeAt(0)\n    if (f >= char_0 && f <= char_9) {\n      return '_' + name\n    }\n    return name\n  }\n  function createNamedFunction(name, body) {\n    name = makeLegalFunctionName(name)\n    return new Function(\n      'body',\n      'return function ' +\n        name +\n        '() {\\n' +\n        '    \"use strict\";' +\n        '    return body.apply(this, arguments);\\n' +\n        '};\\n'\n    )(body)\n  }\n  function extendError(baseErrorType, errorName) {\n    var errorClass = createNamedFunction(errorName, function (message) {\n      this.name = errorName\n      this.message = message\n      var stack = new Error(message).stack\n      if (stack !== undefined) {\n        this.stack = this.toString() + '\\n' + stack.replace(/^Error(:[^\\n]*)?\\n/, '')\n      }\n    })\n    errorClass.prototype = Object.create(baseErrorType.prototype)\n    errorClass.prototype.constructor = errorClass\n    errorClass.prototype.toString = function () {\n      if (this.message === undefined) {\n        return this.name\n      } else {\n        return this.name + ': ' + this.message\n      }\n    }\n    return errorClass\n  }\n  var BindingError = undefined\n  function throwBindingError(message) {\n    throw new BindingError(message)\n  }\n  var InternalError = undefined\n  function registerType(rawType, registeredInstance, options = {}) {\n    if (!('argPackAdvance' in registeredInstance)) {\n      throw new TypeError('registerType registeredInstance requires argPackAdvance')\n    }\n    var name = registeredInstance.name\n    if (!rawType) {\n      throwBindingError('type \"' + name + '\" must have a positive integer typeid pointer')\n    }\n    if (registeredTypes.hasOwnProperty(rawType)) {\n      if (options.ignoreDuplicateRegistrations) {\n        return\n      } else {\n        throwBindingError(\"Cannot register type '\" + name + \"' twice\")\n      }\n    }\n    registeredTypes[rawType] = registeredInstance\n    delete typeDependencies[rawType]\n    if (awaitingDependencies.hasOwnProperty(rawType)) {\n      var callbacks = awaitingDependencies[rawType]\n      delete awaitingDependencies[rawType]\n      callbacks.forEach((cb) => cb())\n    }\n  }\n  function __embind_register_bool(rawType, name, size, trueValue, falseValue) {\n    var shift = getShiftFromSize(size)\n    name = readLatin1String(name)\n    registerType(rawType, {\n      name: name,\n      fromWireType: function (wt) {\n        return !!wt\n      },\n      toWireType: function (destructors, o) {\n        return o ? trueValue : falseValue\n      },\n      argPackAdvance: 8,\n      readValueFromPointer: function (pointer) {\n        var heap\n        if (size === 1) {\n          heap = HEAP8\n        } else if (size === 2) {\n          heap = HEAP16\n        } else if (size === 4) {\n          heap = HEAP32\n        } else {\n          throw new TypeError('Unknown boolean type size: ' + name)\n        }\n        return this['fromWireType'](heap[pointer >> shift])\n      },\n      destructorFunction: null\n    })\n  }\n  var emval_free_list = []\n  var emval_handle_array = [\n    {},\n    { value: undefined },\n    { value: null },\n    { value: true },\n    { value: false }\n  ]\n  function __emval_decref(handle) {\n    if (handle > 4 && 0 === --emval_handle_array[handle].refcount) {\n      emval_handle_array[handle] = undefined\n      emval_free_list.push(handle)\n    }\n  }\n  function count_emval_handles() {\n    var count = 0\n    for (var i = 5; i < emval_handle_array.length; ++i) {\n      if (emval_handle_array[i] !== undefined) {\n        ++count\n      }\n    }\n    return count\n  }\n  function get_first_emval() {\n    for (var i = 5; i < emval_handle_array.length; ++i) {\n      if (emval_handle_array[i] !== undefined) {\n        return emval_handle_array[i]\n      }\n    }\n    return null\n  }\n  function init_emval() {\n    Module['count_emval_handles'] = count_emval_handles\n    Module['get_first_emval'] = get_first_emval\n  }\n  var Emval = {\n    toValue: (handle) => {\n      if (!handle) {\n        throwBindingError('Cannot use deleted val. handle = ' + handle)\n      }\n      return emval_handle_array[handle].value\n    },\n    toHandle: (value) => {\n      switch (value) {\n        case undefined:\n          return 1\n        case null:\n          return 2\n        case true:\n          return 3\n        case false:\n          return 4\n        default: {\n          var handle = emval_free_list.length ? emval_free_list.pop() : emval_handle_array.length\n          emval_handle_array[handle] = { refcount: 1, value: value }\n          return handle\n        }\n      }\n    }\n  }\n  function simpleReadValueFromPointer(pointer) {\n    return this['fromWireType'](HEAP32[pointer >> 2])\n  }\n  function __embind_register_emval(rawType, name) {\n    name = readLatin1String(name)\n    registerType(rawType, {\n      name: name,\n      fromWireType: function (handle) {\n        var rv = Emval.toValue(handle)\n        __emval_decref(handle)\n        return rv\n      },\n      toWireType: function (destructors, value) {\n        return Emval.toHandle(value)\n      },\n      argPackAdvance: 8,\n      readValueFromPointer: simpleReadValueFromPointer,\n      destructorFunction: null\n    })\n  }\n  function floatReadValueFromPointer(name, shift) {\n    switch (shift) {\n      case 2:\n        return function (pointer) {\n          return this['fromWireType'](HEAPF32[pointer >> 2])\n        }\n      case 3:\n        return function (pointer) {\n          return this['fromWireType'](HEAPF64[pointer >> 3])\n        }\n      default:\n        throw new TypeError('Unknown float type: ' + name)\n    }\n  }\n  function __embind_register_float(rawType, name, size) {\n    var shift = getShiftFromSize(size)\n    name = readLatin1String(name)\n    registerType(rawType, {\n      name: name,\n      fromWireType: function (value) {\n        return value\n      },\n      toWireType: function (destructors, value) {\n        return value\n      },\n      argPackAdvance: 8,\n      readValueFromPointer: floatReadValueFromPointer(name, shift),\n      destructorFunction: null\n    })\n  }\n  function integerReadValueFromPointer(name, shift, signed) {\n    switch (shift) {\n      case 0:\n        return signed\n          ? function readS8FromPointer(pointer) {\n              return HEAP8[pointer]\n            }\n          : function readU8FromPointer(pointer) {\n              return HEAPU8[pointer]\n            }\n      case 1:\n        return signed\n          ? function readS16FromPointer(pointer) {\n              return HEAP16[pointer >> 1]\n            }\n          : function readU16FromPointer(pointer) {\n              return HEAPU16[pointer >> 1]\n            }\n      case 2:\n        return signed\n          ? function readS32FromPointer(pointer) {\n              return HEAP32[pointer >> 2]\n            }\n          : function readU32FromPointer(pointer) {\n              return HEAPU32[pointer >> 2]\n            }\n      default:\n        throw new TypeError('Unknown integer type: ' + name)\n    }\n  }\n  function __embind_register_integer(primitiveType, name, size, minRange, maxRange) {\n    name = readLatin1String(name)\n    if (maxRange === -1) {\n      maxRange = 4294967295\n    }\n    var shift = getShiftFromSize(size)\n    var fromWireType = (value) => value\n    if (minRange === 0) {\n      var bitshift = 32 - 8 * size\n      fromWireType = (value) => (value << bitshift) >>> bitshift\n    }\n    var isUnsignedType = name.includes('unsigned')\n    var checkAssertions = (value, toTypeName) => {}\n    var toWireType\n    if (isUnsignedType) {\n      toWireType = function (destructors, value) {\n        checkAssertions(value, this.name)\n        return value >>> 0\n      }\n    } else {\n      toWireType = function (destructors, value) {\n        checkAssertions(value, this.name)\n        return value\n      }\n    }\n    registerType(primitiveType, {\n      name: name,\n      fromWireType: fromWireType,\n      toWireType: toWireType,\n      argPackAdvance: 8,\n      readValueFromPointer: integerReadValueFromPointer(name, shift, minRange !== 0),\n      destructorFunction: null\n    })\n  }\n  function __embind_register_memory_view(rawType, dataTypeIndex, name) {\n    var typeMapping = [\n      Int8Array,\n      Uint8Array,\n      Int16Array,\n      Uint16Array,\n      Int32Array,\n      Uint32Array,\n      Float32Array,\n      Float64Array\n    ]\n    var TA = typeMapping[dataTypeIndex]\n    function decodeMemoryView(handle) {\n      handle = handle >> 2\n      var heap = HEAPU32\n      var size = heap[handle]\n      var data = heap[handle + 1]\n      return new TA(buffer, data, size)\n    }\n    name = readLatin1String(name)\n    registerType(\n      rawType,\n      {\n        name: name,\n        fromWireType: decodeMemoryView,\n        argPackAdvance: 8,\n        readValueFromPointer: decodeMemoryView\n      },\n      { ignoreDuplicateRegistrations: true }\n    )\n  }\n  function __embind_register_std_string(rawType, name) {\n    name = readLatin1String(name)\n    var stdStringIsUTF8 = name === 'std::string'\n    registerType(rawType, {\n      name: name,\n      fromWireType: function (value) {\n        var length = HEAPU32[value >> 2]\n        var payload = value + 4\n        var str\n        if (stdStringIsUTF8) {\n          var decodeStartPtr = payload\n          for (var i = 0; i <= length; ++i) {\n            var currentBytePtr = payload + i\n            if (i == length || HEAPU8[currentBytePtr] == 0) {\n              var maxRead = currentBytePtr - decodeStartPtr\n              var stringSegment = UTF8ToString(decodeStartPtr, maxRead)\n              if (str === undefined) {\n                str = stringSegment\n              } else {\n                str += String.fromCharCode(0)\n                str += stringSegment\n              }\n              decodeStartPtr = currentBytePtr + 1\n            }\n          }\n        } else {\n          var a = new Array(length)\n          for (var i = 0; i < length; ++i) {\n            a[i] = String.fromCharCode(HEAPU8[payload + i])\n          }\n          str = a.join('')\n        }\n        _free(value)\n        return str\n      },\n      toWireType: function (destructors, value) {\n        if (value instanceof ArrayBuffer) {\n          value = new Uint8Array(value)\n        }\n        var length\n        var valueIsOfTypeString = typeof value == 'string'\n        if (\n          !(\n            valueIsOfTypeString ||\n            value instanceof Uint8Array ||\n            value instanceof Uint8ClampedArray ||\n            value instanceof Int8Array\n          )\n        ) {\n          throwBindingError('Cannot pass non-string to std::string')\n        }\n        if (stdStringIsUTF8 && valueIsOfTypeString) {\n          length = lengthBytesUTF8(value)\n        } else {\n          length = value.length\n        }\n        var base = _malloc(4 + length + 1)\n        var ptr = base + 4\n        HEAPU32[base >> 2] = length\n        if (stdStringIsUTF8 && valueIsOfTypeString) {\n          stringToUTF8(value, ptr, length + 1)\n        } else {\n          if (valueIsOfTypeString) {\n            for (var i = 0; i < length; ++i) {\n              var charCode = value.charCodeAt(i)\n              if (charCode > 255) {\n                _free(ptr)\n                throwBindingError('String has UTF-16 code units that do not fit in 8 bits')\n              }\n              HEAPU8[ptr + i] = charCode\n            }\n          } else {\n            for (var i = 0; i < length; ++i) {\n              HEAPU8[ptr + i] = value[i]\n            }\n          }\n        }\n        if (destructors !== null) {\n          destructors.push(_free, base)\n        }\n        return base\n      },\n      argPackAdvance: 8,\n      readValueFromPointer: simpleReadValueFromPointer,\n      destructorFunction: function (ptr) {\n        _free(ptr)\n      }\n    })\n  }\n  var UTF16Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf-16le') : undefined\n  function UTF16ToString(ptr, maxBytesToRead) {\n    var endPtr = ptr\n    var idx = endPtr >> 1\n    var maxIdx = idx + maxBytesToRead / 2\n    while (!(idx >= maxIdx) && HEAPU16[idx]) ++idx\n    endPtr = idx << 1\n    if (endPtr - ptr > 32 && UTF16Decoder) return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr))\n    var str = ''\n    for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {\n      var codeUnit = HEAP16[(ptr + i * 2) >> 1]\n      if (codeUnit == 0) break\n      str += String.fromCharCode(codeUnit)\n    }\n    return str\n  }\n  function stringToUTF16(str, outPtr, maxBytesToWrite) {\n    if (maxBytesToWrite === undefined) {\n      maxBytesToWrite = 2147483647\n    }\n    if (maxBytesToWrite < 2) return 0\n    maxBytesToWrite -= 2\n    var startPtr = outPtr\n    var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length\n    for (var i = 0; i < numCharsToWrite; ++i) {\n      var codeUnit = str.charCodeAt(i)\n      HEAP16[outPtr >> 1] = codeUnit\n      outPtr += 2\n    }\n    HEAP16[outPtr >> 1] = 0\n    return outPtr - startPtr\n  }\n  function lengthBytesUTF16(str) {\n    return str.length * 2\n  }\n  function UTF32ToString(ptr, maxBytesToRead) {\n    var i = 0\n    var str = ''\n    while (!(i >= maxBytesToRead / 4)) {\n      var utf32 = HEAP32[(ptr + i * 4) >> 2]\n      if (utf32 == 0) break\n      ++i\n      if (utf32 >= 65536) {\n        var ch = utf32 - 65536\n        str += String.fromCharCode(55296 | (ch >> 10), 56320 | (ch & 1023))\n      } else {\n        str += String.fromCharCode(utf32)\n      }\n    }\n    return str\n  }\n  function stringToUTF32(str, outPtr, maxBytesToWrite) {\n    if (maxBytesToWrite === undefined) {\n      maxBytesToWrite = 2147483647\n    }\n    if (maxBytesToWrite < 4) return 0\n    var startPtr = outPtr\n    var endPtr = startPtr + maxBytesToWrite - 4\n    for (var i = 0; i < str.length; ++i) {\n      var codeUnit = str.charCodeAt(i)\n      if (codeUnit >= 55296 && codeUnit <= 57343) {\n        var trailSurrogate = str.charCodeAt(++i)\n        codeUnit = (65536 + ((codeUnit & 1023) << 10)) | (trailSurrogate & 1023)\n      }\n      HEAP32[outPtr >> 2] = codeUnit\n      outPtr += 4\n      if (outPtr + 4 > endPtr) break\n    }\n    HEAP32[outPtr >> 2] = 0\n    return outPtr - startPtr\n  }\n  function lengthBytesUTF32(str) {\n    var len = 0\n    for (var i = 0; i < str.length; ++i) {\n      var codeUnit = str.charCodeAt(i)\n      if (codeUnit >= 55296 && codeUnit <= 57343) ++i\n      len += 4\n    }\n    return len\n  }\n  function __embind_register_std_wstring(rawType, charSize, name) {\n    name = readLatin1String(name)\n    var decodeString, encodeString, getHeap, lengthBytesUTF, shift\n    if (charSize === 2) {\n      decodeString = UTF16ToString\n      encodeString = stringToUTF16\n      lengthBytesUTF = lengthBytesUTF16\n      getHeap = () => HEAPU16\n      shift = 1\n    } else if (charSize === 4) {\n      decodeString = UTF32ToString\n      encodeString = stringToUTF32\n      lengthBytesUTF = lengthBytesUTF32\n      getHeap = () => HEAPU32\n      shift = 2\n    }\n    registerType(rawType, {\n      name: name,\n      fromWireType: function (value) {\n        var length = HEAPU32[value >> 2]\n        var HEAP = getHeap()\n        var str\n        var decodeStartPtr = value + 4\n        for (var i = 0; i <= length; ++i) {\n          var currentBytePtr = value + 4 + i * charSize\n          if (i == length || HEAP[currentBytePtr >> shift] == 0) {\n            var maxReadBytes = currentBytePtr - decodeStartPtr\n            var stringSegment = decodeString(decodeStartPtr, maxReadBytes)\n            if (str === undefined) {\n              str = stringSegment\n            } else {\n              str += String.fromCharCode(0)\n              str += stringSegment\n            }\n            decodeStartPtr = currentBytePtr + charSize\n          }\n        }\n        _free(value)\n        return str\n      },\n      toWireType: function (destructors, value) {\n        if (!(typeof value == 'string')) {\n          throwBindingError('Cannot pass non-string to C++ string type ' + name)\n        }\n        var length = lengthBytesUTF(value)\n        var ptr = _malloc(4 + length + charSize)\n        HEAPU32[ptr >> 2] = length >> shift\n        encodeString(value, ptr + 4, length + charSize)\n        if (destructors !== null) {\n          destructors.push(_free, ptr)\n        }\n        return ptr\n      },\n      argPackAdvance: 8,\n      readValueFromPointer: simpleReadValueFromPointer,\n      destructorFunction: function (ptr) {\n        _free(ptr)\n      }\n    })\n  }\n  function __embind_register_void(rawType, name) {\n    name = readLatin1String(name)\n    registerType(rawType, {\n      isVoid: true,\n      name: name,\n      argPackAdvance: 0,\n      fromWireType: function () {\n        return undefined\n      },\n      toWireType: function (destructors, o) {\n        return undefined\n      }\n    })\n  }\n  function _abort() {\n    abort('')\n  }\n  function _emscripten_date_now() {\n    return Date.now()\n  }\n  function _emscripten_memcpy_big(dest, src, num) {\n    HEAPU8.copyWithin(dest, src, src + num)\n  }\n  function abortOnCannotGrowMemory(requestedSize) {\n    abort('OOM')\n  }\n  function _emscripten_resize_heap(requestedSize) {\n    var oldSize = HEAPU8.length\n    requestedSize = requestedSize >>> 0\n    abortOnCannotGrowMemory(requestedSize)\n  }\n  var ENV = {}\n  function getExecutableName() {\n    return thisProgram || './this.program'\n  }\n  function getEnvStrings() {\n    if (!getEnvStrings.strings) {\n      var lang =\n        (\n          (typeof navigator == 'object' && navigator.languages && navigator.languages[0]) ||\n          'C'\n        ).replace('-', '_') + '.UTF-8'\n      var env = {\n        USER: 'web_user',\n        LOGNAME: 'web_user',\n        PATH: '/',\n        PWD: '/',\n        HOME: '/home/web_user',\n        LANG: lang,\n        _: getExecutableName()\n      }\n      for (var x in ENV) {\n        if (ENV[x] === undefined) delete env[x]\n        else env[x] = ENV[x]\n      }\n      var strings = []\n      for (var x in env) {\n        strings.push(x + '=' + env[x])\n      }\n      getEnvStrings.strings = strings\n    }\n    return getEnvStrings.strings\n  }\n  function writeAsciiToMemory(str, buffer, dontAddNull) {\n    for (var i = 0; i < str.length; ++i) {\n      HEAP8[buffer++ >> 0] = str.charCodeAt(i)\n    }\n    if (!dontAddNull) HEAP8[buffer >> 0] = 0\n  }\n  function _environ_get(__environ, environ_buf) {\n    var bufSize = 0\n    getEnvStrings().forEach(function (string, i) {\n      var ptr = environ_buf + bufSize\n      HEAPU32[(__environ + i * 4) >> 2] = ptr\n      writeAsciiToMemory(string, ptr)\n      bufSize += string.length + 1\n    })\n    return 0\n  }\n  function _environ_sizes_get(penviron_count, penviron_buf_size) {\n    var strings = getEnvStrings()\n    HEAPU32[penviron_count >> 2] = strings.length\n    var bufSize = 0\n    strings.forEach(function (string) {\n      bufSize += string.length + 1\n    })\n    HEAPU32[penviron_buf_size >> 2] = bufSize\n    return 0\n  }\n  function _proc_exit(code) {\n    EXITSTATUS = code\n    if (!keepRuntimeAlive()) {\n      if (Module['onExit']) Module['onExit'](code)\n      ABORT = true\n    }\n    quit_(code, new ExitStatus(code))\n  }\n  function exitJS(status, implicit) {\n    EXITSTATUS = status\n    _proc_exit(status)\n  }\n  var _exit = exitJS\n  function _fd_close(fd) {\n    try {\n      var stream = SYSCALLS.getStreamFromFD(fd)\n      FS.close(stream)\n      return 0\n    } catch (e) {\n      if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e\n      return e.errno\n    }\n  }\n  function doReadv(stream, iov, iovcnt, offset) {\n    var ret = 0\n    for (var i = 0; i < iovcnt; i++) {\n      var ptr = HEAPU32[iov >> 2]\n      var len = HEAPU32[(iov + 4) >> 2]\n      iov += 8\n      var curr = FS.read(stream, HEAP8, ptr, len, offset)\n      if (curr < 0) return -1\n      ret += curr\n      if (curr < len) break\n    }\n    return ret\n  }\n  function _fd_read(fd, iov, iovcnt, pnum) {\n    try {\n      var stream = SYSCALLS.getStreamFromFD(fd)\n      var num = doReadv(stream, iov, iovcnt)\n      HEAPU32[pnum >> 2] = num\n      return 0\n    } catch (e) {\n      if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e\n      return e.errno\n    }\n  }\n  function convertI32PairToI53Checked(lo, hi) {\n    return (hi + 2097152) >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN\n  }\n  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {\n    try {\n      var offset = convertI32PairToI53Checked(offset_low, offset_high)\n      if (isNaN(offset)) return 61\n      var stream = SYSCALLS.getStreamFromFD(fd)\n      FS.llseek(stream, offset, whence)\n      ;(tempI64 = [\n        stream.position >>> 0,\n        ((tempDouble = stream.position),\n        +Math.abs(tempDouble) >= 1\n          ? tempDouble > 0\n            ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0\n            : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0\n          : 0)\n      ]),\n        (HEAP32[newOffset >> 2] = tempI64[0]),\n        (HEAP32[(newOffset + 4) >> 2] = tempI64[1])\n      if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null\n      return 0\n    } catch (e) {\n      if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e\n      return e.errno\n    }\n  }\n  function doWritev(stream, iov, iovcnt, offset) {\n    var ret = 0\n    for (var i = 0; i < iovcnt; i++) {\n      var ptr = HEAPU32[iov >> 2]\n      var len = HEAPU32[(iov + 4) >> 2]\n      iov += 8\n      var curr = FS.write(stream, HEAP8, ptr, len, offset)\n      if (curr < 0) return -1\n      ret += curr\n    }\n    return ret\n  }\n  function _fd_write(fd, iov, iovcnt, pnum) {\n    try {\n      var stream = SYSCALLS.getStreamFromFD(fd)\n      var num = doWritev(stream, iov, iovcnt)\n      HEAPU32[pnum >> 2] = num\n      return 0\n    } catch (e) {\n      if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e\n      return e.errno\n    }\n  }\n  function __isLeapYear(year) {\n    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0)\n  }\n  function __arraySum(array, index) {\n    var sum = 0\n    for (var i = 0; i <= index; sum += array[i++]) {}\n    return sum\n  }\n  var __MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n  var __MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n  function __addDays(date, days) {\n    var newDate = new Date(date.getTime())\n    while (days > 0) {\n      var leap = __isLeapYear(newDate.getFullYear())\n      var currentMonth = newDate.getMonth()\n      var daysInCurrentMonth = (leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[currentMonth]\n      if (days > daysInCurrentMonth - newDate.getDate()) {\n        days -= daysInCurrentMonth - newDate.getDate() + 1\n        newDate.setDate(1)\n        if (currentMonth < 11) {\n          newDate.setMonth(currentMonth + 1)\n        } else {\n          newDate.setMonth(0)\n          newDate.setFullYear(newDate.getFullYear() + 1)\n        }\n      } else {\n        newDate.setDate(newDate.getDate() + days)\n        return newDate\n      }\n    }\n    return newDate\n  }\n  function _strftime(s, maxsize, format, tm) {\n    var tm_zone = HEAP32[(tm + 40) >> 2]\n    var date = {\n      tm_sec: HEAP32[tm >> 2],\n      tm_min: HEAP32[(tm + 4) >> 2],\n      tm_hour: HEAP32[(tm + 8) >> 2],\n      tm_mday: HEAP32[(tm + 12) >> 2],\n      tm_mon: HEAP32[(tm + 16) >> 2],\n      tm_year: HEAP32[(tm + 20) >> 2],\n      tm_wday: HEAP32[(tm + 24) >> 2],\n      tm_yday: HEAP32[(tm + 28) >> 2],\n      tm_isdst: HEAP32[(tm + 32) >> 2],\n      tm_gmtoff: HEAP32[(tm + 36) >> 2],\n      tm_zone: tm_zone ? UTF8ToString(tm_zone) : ''\n    }\n    var pattern = UTF8ToString(format)\n    var EXPANSION_RULES_1 = {\n      '%c': '%a %b %d %H:%M:%S %Y',\n      '%D': '%m/%d/%y',\n      '%F': '%Y-%m-%d',\n      '%h': '%b',\n      '%r': '%I:%M:%S %p',\n      '%R': '%H:%M',\n      '%T': '%H:%M:%S',\n      '%x': '%m/%d/%y',\n      '%X': '%H:%M:%S',\n      '%Ec': '%c',\n      '%EC': '%C',\n      '%Ex': '%m/%d/%y',\n      '%EX': '%H:%M:%S',\n      '%Ey': '%y',\n      '%EY': '%Y',\n      '%Od': '%d',\n      '%Oe': '%e',\n      '%OH': '%H',\n      '%OI': '%I',\n      '%Om': '%m',\n      '%OM': '%M',\n      '%OS': '%S',\n      '%Ou': '%u',\n      '%OU': '%U',\n      '%OV': '%V',\n      '%Ow': '%w',\n      '%OW': '%W',\n      '%Oy': '%y'\n    }\n    for (var rule in EXPANSION_RULES_1) {\n      pattern = pattern.replace(new RegExp(rule, 'g'), EXPANSION_RULES_1[rule])\n    }\n    var WEEKDAYS = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']\n    var MONTHS = [\n      'January',\n      'February',\n      'March',\n      'April',\n      'May',\n      'June',\n      'July',\n      'August',\n      'September',\n      'October',\n      'November',\n      'December'\n    ]\n    function leadingSomething(value, digits, character) {\n      var str = typeof value == 'number' ? value.toString() : value || ''\n      while (str.length < digits) {\n        str = character[0] + str\n      }\n      return str\n    }\n    function leadingNulls(value, digits) {\n      return leadingSomething(value, digits, '0')\n    }\n    function compareByDay(date1, date2) {\n      function sgn(value) {\n        return value < 0 ? -1 : value > 0 ? 1 : 0\n      }\n      var compare\n      if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {\n        if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {\n          compare = sgn(date1.getDate() - date2.getDate())\n        }\n      }\n      return compare\n    }\n    function getFirstWeekStartDate(janFourth) {\n      switch (janFourth.getDay()) {\n        case 0:\n          return new Date(janFourth.getFullYear() - 1, 11, 29)\n        case 1:\n          return janFourth\n        case 2:\n          return new Date(janFourth.getFullYear(), 0, 3)\n        case 3:\n          return new Date(janFourth.getFullYear(), 0, 2)\n        case 4:\n          return new Date(janFourth.getFullYear(), 0, 1)\n        case 5:\n          return new Date(janFourth.getFullYear() - 1, 11, 31)\n        case 6:\n          return new Date(janFourth.getFullYear() - 1, 11, 30)\n      }\n    }\n    function getWeekBasedYear(date) {\n      var thisDate = __addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday)\n      var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4)\n      var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4)\n      var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear)\n      var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear)\n      if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {\n        if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {\n          return thisDate.getFullYear() + 1\n        }\n        return thisDate.getFullYear()\n      }\n      return thisDate.getFullYear() - 1\n    }\n    var EXPANSION_RULES_2 = {\n      '%a': function (date) {\n        return WEEKDAYS[date.tm_wday].substring(0, 3)\n      },\n      '%A': function (date) {\n        return WEEKDAYS[date.tm_wday]\n      },\n      '%b': function (date) {\n        return MONTHS[date.tm_mon].substring(0, 3)\n      },\n      '%B': function (date) {\n        return MONTHS[date.tm_mon]\n      },\n      '%C': function (date) {\n        var year = date.tm_year + 1900\n        return leadingNulls((year / 100) | 0, 2)\n      },\n      '%d': function (date) {\n        return leadingNulls(date.tm_mday, 2)\n      },\n      '%e': function (date) {\n        return leadingSomething(date.tm_mday, 2, ' ')\n      },\n      '%g': function (date) {\n        return getWeekBasedYear(date).toString().substring(2)\n      },\n      '%G': function (date) {\n        return getWeekBasedYear(date)\n      },\n      '%H': function (date) {\n        return leadingNulls(date.tm_hour, 2)\n      },\n      '%I': function (date) {\n        var twelveHour = date.tm_hour\n        if (twelveHour == 0) twelveHour = 12\n        else if (twelveHour > 12) twelveHour -= 12\n        return leadingNulls(twelveHour, 2)\n      },\n      '%j': function (date) {\n        return leadingNulls(\n          date.tm_mday +\n            __arraySum(\n              __isLeapYear(date.tm_year + 1900) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR,\n              date.tm_mon - 1\n            ),\n          3\n        )\n      },\n      '%m': function (date) {\n        return leadingNulls(date.tm_mon + 1, 2)\n      },\n      '%M': function (date) {\n        return leadingNulls(date.tm_min, 2)\n      },\n      '%n': function () {\n        return '\\n'\n      },\n      '%p': function (date) {\n        if (date.tm_hour >= 0 && date.tm_hour < 12) {\n          return 'AM'\n        }\n        return 'PM'\n      },\n      '%S': function (date) {\n        return leadingNulls(date.tm_sec, 2)\n      },\n      '%t': function () {\n        return '\\t'\n      },\n      '%u': function (date) {\n        return date.tm_wday || 7\n      },\n      '%U': function (date) {\n        var days = date.tm_yday + 7 - date.tm_wday\n        return leadingNulls(Math.floor(days / 7), 2)\n      },\n      '%V': function (date) {\n        var val = Math.floor((date.tm_yday + 7 - ((date.tm_wday + 6) % 7)) / 7)\n        if ((date.tm_wday + 371 - date.tm_yday - 2) % 7 <= 2) {\n          val++\n        }\n        if (!val) {\n          val = 52\n          var dec31 = (date.tm_wday + 7 - date.tm_yday - 1) % 7\n          if (dec31 == 4 || (dec31 == 5 && __isLeapYear((date.tm_year % 400) - 1))) {\n            val++\n          }\n        } else if (val == 53) {\n          var jan1 = (date.tm_wday + 371 - date.tm_yday) % 7\n          if (jan1 != 4 && (jan1 != 3 || !__isLeapYear(date.tm_year))) val = 1\n        }\n        return leadingNulls(val, 2)\n      },\n      '%w': function (date) {\n        return date.tm_wday\n      },\n      '%W': function (date) {\n        var days = date.tm_yday + 7 - ((date.tm_wday + 6) % 7)\n        return leadingNulls(Math.floor(days / 7), 2)\n      },\n      '%y': function (date) {\n        return (date.tm_year + 1900).toString().substring(2)\n      },\n      '%Y': function (date) {\n        return date.tm_year + 1900\n      },\n      '%z': function (date) {\n        var off = date.tm_gmtoff\n        var ahead = off >= 0\n        off = Math.abs(off) / 60\n        off = (off / 60) * 100 + (off % 60)\n        return (ahead ? '+' : '-') + String('0000' + off).slice(-4)\n      },\n      '%Z': function (date) {\n        return date.tm_zone\n      },\n      '%%': function () {\n        return '%'\n      }\n    }\n    pattern = pattern.replace(/%%/g, '\\0\\0')\n    for (var rule in EXPANSION_RULES_2) {\n      if (pattern.includes(rule)) {\n        pattern = pattern.replace(new RegExp(rule, 'g'), EXPANSION_RULES_2[rule](date))\n      }\n    }\n    pattern = pattern.replace(/\\0\\0/g, '%')\n    var bytes = intArrayFromString(pattern, false)\n    if (bytes.length > maxsize) {\n      return 0\n    }\n    writeArrayToMemory(bytes, s)\n    return bytes.length - 1\n  }\n  function _strftime_l(s, maxsize, format, tm) {\n    return _strftime(s, maxsize, format, tm)\n  }\n  function allocateUTF8OnStack(str) {\n    var size = lengthBytesUTF8(str) + 1\n    var ret = stackAlloc(size)\n    stringToUTF8Array(str, HEAP8, ret, size)\n    return ret\n  }\n  function uleb128Encode(n, target) {\n    if (n < 128) {\n      target.push(n)\n    } else {\n      target.push(n % 128 | 128, n >> 7)\n    }\n  }\n  function sigToWasmTypes(sig) {\n    var typeNames = { i: 'i32', j: 'i64', f: 'f32', d: 'f64', p: 'i32' }\n    var type = { parameters: [], results: sig[0] == 'v' ? [] : [typeNames[sig[0]]] }\n    for (var i = 1; i < sig.length; ++i) {\n      type.parameters.push(typeNames[sig[i]])\n    }\n    return type\n  }\n  function generateFuncType(sig, target) {\n    var sigRet = sig.slice(0, 1)\n    var sigParam = sig.slice(1)\n    var typeCodes = { i: 127, p: 127, j: 126, f: 125, d: 124 }\n    target.push(96)\n    uleb128Encode(sigParam.length, target)\n    for (var i = 0; i < sigParam.length; ++i) {\n      target.push(typeCodes[sigParam[i]])\n    }\n    if (sigRet == 'v') {\n      target.push(0)\n    } else {\n      target.push(1, typeCodes[sigRet])\n    }\n  }\n  function convertJsFunctionToWasm(func, sig) {\n    if (typeof WebAssembly.Function == 'function') {\n      return new WebAssembly.Function(sigToWasmTypes(sig), func)\n    }\n    var typeSectionBody = [1]\n    generateFuncType(sig, typeSectionBody)\n    var bytes = [0, 97, 115, 109, 1, 0, 0, 0, 1]\n    uleb128Encode(typeSectionBody.length, bytes)\n    bytes.push.apply(bytes, typeSectionBody)\n    bytes.push(2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0)\n    var module = new WebAssembly.Module(new Uint8Array(bytes))\n    var instance = new WebAssembly.Instance(module, { e: { f: func } })\n    var wrappedFunc = instance.exports['f']\n    return wrappedFunc\n  }\n  var wasmTableMirror = []\n  function getWasmTableEntry(funcPtr) {\n    var func = wasmTableMirror[funcPtr]\n    if (!func) {\n      if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1\n      wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr)\n    }\n    return func\n  }\n  function updateTableMap(offset, count) {\n    if (functionsInTableMap) {\n      for (var i = offset; i < offset + count; i++) {\n        var item = getWasmTableEntry(i)\n        if (item) {\n          functionsInTableMap.set(item, i)\n        }\n      }\n    }\n  }\n  var functionsInTableMap = undefined\n  var freeTableIndexes = []\n  function getEmptyTableSlot() {\n    if (freeTableIndexes.length) {\n      return freeTableIndexes.pop()\n    }\n    try {\n      wasmTable.grow(1)\n    } catch (err) {\n      if (!(err instanceof RangeError)) {\n        throw err\n      }\n      throw 'Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.'\n    }\n    return wasmTable.length - 1\n  }\n  function setWasmTableEntry(idx, func) {\n    wasmTable.set(idx, func)\n    wasmTableMirror[idx] = wasmTable.get(idx)\n  }\n  function addFunction(func, sig) {\n    if (!functionsInTableMap) {\n      functionsInTableMap = new WeakMap()\n      updateTableMap(0, wasmTable.length)\n    }\n    if (functionsInTableMap.has(func)) {\n      return functionsInTableMap.get(func)\n    }\n    var ret = getEmptyTableSlot()\n    try {\n      setWasmTableEntry(ret, func)\n    } catch (err) {\n      if (!(err instanceof TypeError)) {\n        throw err\n      }\n      var wrapped = convertJsFunctionToWasm(func, sig)\n      setWasmTableEntry(ret, wrapped)\n    }\n    functionsInTableMap.set(func, ret)\n    return ret\n  }\n  function removeFunction(index) {\n    functionsInTableMap.delete(getWasmTableEntry(index))\n    freeTableIndexes.push(index)\n  }\n  var FSNode = function (parent, name, mode, rdev) {\n    if (!parent) {\n      parent = this\n    }\n    this.parent = parent\n    this.mount = parent.mount\n    this.mounted = null\n    this.id = FS.nextInode++\n    this.name = name\n    this.mode = mode\n    this.node_ops = {}\n    this.stream_ops = {}\n    this.rdev = rdev\n  }\n  var readMode = 292 | 73\n  var writeMode = 146\n  Object.defineProperties(FSNode.prototype, {\n    read: {\n      get: function () {\n        return (this.mode & readMode) === readMode\n      },\n      set: function (val) {\n        val ? (this.mode |= readMode) : (this.mode &= ~readMode)\n      }\n    },\n    write: {\n      get: function () {\n        return (this.mode & writeMode) === writeMode\n      },\n      set: function (val) {\n        val ? (this.mode |= writeMode) : (this.mode &= ~writeMode)\n      }\n    },\n    isFolder: {\n      get: function () {\n        return FS.isDir(this.mode)\n      }\n    },\n    isDevice: {\n      get: function () {\n        return FS.isChrdev(this.mode)\n      }\n    }\n  })\n  FS.FSNode = FSNode\n  FS.staticInit()\n  embind_init_charCodes()\n  BindingError = Module['BindingError'] = extendError(Error, 'BindingError')\n  InternalError = Module['InternalError'] = extendError(Error, 'InternalError')\n  init_emval()\n  var asmLibraryArg = {\n    b: ___assert_fail,\n    k: ___cxa_allocate_exception,\n    i: ___cxa_throw,\n    m: ___syscall_fcntl64,\n    w: ___syscall_ioctl,\n    x: ___syscall_openat,\n    q: __embind_register_bigint,\n    n: __embind_register_bool,\n    A: __embind_register_emval,\n    h: __embind_register_float,\n    d: __embind_register_integer,\n    c: __embind_register_memory_view,\n    g: __embind_register_std_string,\n    e: __embind_register_std_wstring,\n    o: __embind_register_void,\n    a: _abort,\n    y: _emscripten_date_now,\n    z: _emscripten_memcpy_big,\n    s: _emscripten_resize_heap,\n    t: _environ_get,\n    u: _environ_sizes_get,\n    f: _exit,\n    j: _fd_close,\n    v: _fd_read,\n    p: _fd_seek,\n    l: _fd_write,\n    r: _strftime_l\n  }\n  var asm = createWasm()\n  var ___wasm_call_ctors = (Module['___wasm_call_ctors'] = function () {\n    return (___wasm_call_ctors = Module['___wasm_call_ctors'] = Module['asm']['C']).apply(\n      null,\n      arguments\n    )\n  })\n  var _CreateNEAudioEffect = (Module['_CreateNEAudioEffect'] = function () {\n    return (_CreateNEAudioEffect = Module['_CreateNEAudioEffect'] = Module['asm']['D']).apply(\n      null,\n      arguments\n    )\n  })\n  var _apm_create = (Module['_apm_create'] = function () {\n    return (_apm_create = Module['_apm_create'] = Module['asm']['E']).apply(null, arguments)\n  })\n  var _apm_ains_enable = (Module['_apm_ains_enable'] = function () {\n    return (_apm_ains_enable = Module['_apm_ains_enable'] = Module['asm']['F']).apply(\n      null,\n      arguments\n    )\n  })\n  var _apm_aivad_enable = (Module['_apm_aivad_enable'] = function () {\n    return (_apm_aivad_enable = Module['_apm_aivad_enable'] = Module['asm']['G']).apply(\n      null,\n      arguments\n    )\n  })\n  var _apm_process_stream = (Module['_apm_process_stream'] = function () {\n    return (_apm_process_stream = Module['_apm_process_stream'] = Module['asm']['H']).apply(\n      null,\n      arguments\n    )\n  })\n  var _main = (Module['_main'] = function () {\n    return (_main = Module['_main'] = Module['asm']['I']).apply(null, arguments)\n  })\n  var _DeleteNEAudioEffect = (Module['_DeleteNEAudioEffect'] = function () {\n    return (_DeleteNEAudioEffect = Module['_DeleteNEAudioEffect'] = Module['asm']['K']).apply(\n      null,\n      arguments\n    )\n  })\n  var _Process = (Module['_Process'] = function () {\n    return (_Process = Module['_Process'] = Module['asm']['L']).apply(null, arguments)\n  })\n  var _SetPara = (Module['_SetPara'] = function () {\n    return (_SetPara = Module['_SetPara'] = Module['asm']['M']).apply(null, arguments)\n  })\n  var _SetEQGain = (Module['_SetEQGain'] = function () {\n    return (_SetEQGain = Module['_SetEQGain'] = Module['asm']['N']).apply(null, arguments)\n  })\n  var _UpdateEffect = (Module['_UpdateEffect'] = function () {\n    return (_UpdateEffect = Module['_UpdateEffect'] = Module['asm']['O']).apply(null, arguments)\n  })\n  var _setLocalPitch = (Module['_setLocalPitch'] = function () {\n    return (_setLocalPitch = Module['_setLocalPitch'] = Module['asm']['P']).apply(null, arguments)\n  })\n  var _SetLocalVoiceReverbParam = (Module['_SetLocalVoiceReverbParam'] = function () {\n    return (_SetLocalVoiceReverbParam = Module['_SetLocalVoiceReverbParam'] =\n      Module['asm']['Q']).apply(null, arguments)\n  })\n  var _audio_effects_malloc = (Module['_audio_effects_malloc'] = function () {\n    return (_audio_effects_malloc = Module['_audio_effects_malloc'] = Module['asm']['R']).apply(\n      null,\n      arguments\n    )\n  })\n  var _malloc = (Module['_malloc'] = function () {\n    return (_malloc = Module['_malloc'] = Module['asm']['S']).apply(null, arguments)\n  })\n  var _audio_effects_free = (Module['_audio_effects_free'] = function () {\n    return (_audio_effects_free = Module['_audio_effects_free'] = Module['asm']['T']).apply(\n      null,\n      arguments\n    )\n  })\n  var _free = (Module['_free'] = function () {\n    return (_free = Module['_free'] = Module['asm']['U']).apply(null, arguments)\n  })\n  var _apm_destroy = (Module['_apm_destroy'] = function () {\n    return (_apm_destroy = Module['_apm_destroy'] = Module['asm']['V']).apply(null, arguments)\n  })\n  var _register_aiHowling_callback = (Module['_register_aiHowling_callback'] = function () {\n    return (_register_aiHowling_callback = Module['_register_aiHowling_callback'] =\n      Module['asm']['W']).apply(null, arguments)\n  })\n  var _deregister_aiHowling_callback = (Module['_deregister_aiHowling_callback'] = function () {\n    return (_deregister_aiHowling_callback = Module['_deregister_aiHowling_callback'] =\n      Module['asm']['X']).apply(null, arguments)\n  })\n  var ___getTypeName = (Module['___getTypeName'] = function () {\n    return (___getTypeName = Module['___getTypeName'] = Module['asm']['Y']).apply(null, arguments)\n  })\n  var __embind_initialize_bindings = (Module['__embind_initialize_bindings'] = function () {\n    return (__embind_initialize_bindings = Module['__embind_initialize_bindings'] =\n      Module['asm']['Z']).apply(null, arguments)\n  })\n  var ___errno_location = (Module['___errno_location'] = function () {\n    return (___errno_location = Module['___errno_location'] = Module['asm']['_']).apply(\n      null,\n      arguments\n    )\n  })\n  var stackAlloc = (Module['stackAlloc'] = function () {\n    return (stackAlloc = Module['stackAlloc'] = Module['asm']['$']).apply(null, arguments)\n  })\n  var ___cxa_is_pointer_type = (Module['___cxa_is_pointer_type'] = function () {\n    return (___cxa_is_pointer_type = Module['___cxa_is_pointer_type'] = Module['asm']['aa']).apply(\n      null,\n      arguments\n    )\n  })\n  Module['addFunction'] = addFunction\n  Module['removeFunction'] = removeFunction\n  var calledRun\n  dependenciesFulfilled = function runCaller() {\n    if (!calledRun) run()\n    if (!calledRun) dependenciesFulfilled = runCaller\n  }\n  function callMain(args) {\n    var entryFunction = Module['_main']\n    args = args || []\n    args.unshift(thisProgram)\n    var argc = args.length\n    var argv = stackAlloc((argc + 1) * 4)\n    var argv_ptr = argv >> 2\n    args.forEach((arg) => {\n      HEAP32[argv_ptr++] = allocateUTF8OnStack(arg)\n    })\n    HEAP32[argv_ptr] = 0\n    try {\n      var ret = entryFunction(argc, argv)\n      exitJS(ret, true)\n      return ret\n    } catch (e) {\n      return handleException(e)\n    }\n  }\n  function run(args) {\n    args = args || arguments_\n    if (runDependencies > 0) {\n      return\n    }\n    preRun()\n    if (runDependencies > 0) {\n      return\n    }\n    function doRun() {\n      if (calledRun) return\n      calledRun = true\n      Module['calledRun'] = true\n      if (ABORT) return\n      initRuntime()\n      preMain()\n      if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']()\n      if (shouldRunNow) callMain(args)\n      postRun()\n    }\n    if (Module['setStatus']) {\n      Module['setStatus']('Running...')\n      setTimeout(function () {\n        setTimeout(function () {\n          Module['setStatus']('')\n        }, 1)\n        doRun()\n      }, 1)\n    } else {\n      doRun()\n    }\n  }\n  if (Module['preInit']) {\n    if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']]\n    while (Module['preInit'].length > 0) {\n      Module['preInit'].pop()()\n    }\n  }\n  var shouldRunNow = true\n  if (Module['noInitialRun']) shouldRunNow = false\n  run()\n}\n\nregisterProcessor(\n  'audioEffectsWorkletAgentProcessor',\n  class extends AudioWorkletProcessor {\n    // Float32Array[][][]\n    constructor() {\n      super()\n      this.audioProcess = new AudioProcess()\n      this.port.onmessage = (event) => {\n        const { type, option, effect } = event.data\n        if (!this.audioProcess) {\n          return\n        }\n        switch (type) {\n          case 'init':\n            this.audioProcess.init(event.data.wasmBinary, this.port)\n            break\n          case 'effect':\n            this.audioProcess.AudioEffect.setEffect(effect.type, effect.value)\n            break\n          case 'setState':\n            if (option.type === 'AIDenoise' && this.audioProcess.AIDenoise) {\n              console.log('AIDenoise', option)\n              this.audioProcess.AIDenoise.enable = option.enable\n              this.audioProcess.AIDenoise.howlingSuppressionEnable = option.howlingSuppressionEnable\n            }\n            if (option.type === 'AudioEffect' && this.audioProcess.AudioEffect) {\n              this.audioProcess.AudioEffect.enable = option.enable\n            }\n            break\n          case 'AIVadEnable':\n            const { vad_enable, vad_noise_enable, noise_gate_enable } = option\n            this.audioProcess.AIDenoise.setAIVadEnable(\n              vad_enable,\n              vad_noise_enable,\n              noise_gate_enable\n            )\n            break\n          case 'VoiceGate':\n            const { level } = option\n            this.audioProcess.AIDenoise.setVoiceGate(level)\n            break\n        }\n      }\n    }\n\n    process(inputs, outputs) {\n      const result = this.audioProcess.process(inputs[0])\n      if (result) {\n        outputs[0][0].set(result[0])\n        if (outputs[0][1]) {\n          outputs[0][1].set(result[0])\n        }\n      }\n\n      return true\n    }\n  }\n)\n\nclass AIDenoise {\n  rnnoise = null\n  inArrayPtr = null\n  outArrayPtr = null\n  enabled = false\n  howlingSuppressionEnabled = false\n  Module = null\n  level = 0\n\n  constructor(Module) {\n    //创建实例\n    this.Module = Module\n    this.rnnoise = Module._apm_create()\n  }\n\n  init(inArrayPtr, outArrayPtr) {\n    this.inArrayPtr = inArrayPtr\n    this.outArrayPtr = outArrayPtr\n    //默认开启ai vad\n    this.setAIVadEnable(true, true, true)\n    this.enable = 0\n    this.howlingSuppressionEnable = 0\n  }\n\n  process() {\n    const Module = this.Module\n    const hasResult = Module._apm_process_stream(this.rnnoise, this.outArrayPtr, this.inArrayPtr, 1)\n    return hasResult\n  }\n\n  set enable(value) {\n    const Module = this.Module\n    this.enabled = value\n    console.log('enable', this.enabled)\n    Module._apm_ains_enable(this.rnnoise, this.enabled ? 2 : 0, this.level)\n  }\n\n  set howlingSuppressionEnable(value) {\n    const Module = this.Module\n    this.howlingSuppressionEnabled = value\n    if (value) {\n      //只处理开启howlingSuppression的情况\n      //如果用户连续调用 enableAIDenoise({howlingSuppressionEnable: true}), enableAIDenoise({howlingSuppressionEnable: false})\n      //也可以兼容，因为先执行 set enable()方法\n      console.log('howlingSuppressionEnable', value)\n      Module._apm_ains_enable(this.rnnoise, 3, this.level)\n    }\n  }\n\n  setVoiceGate(level) {\n    const Module = this.Module\n    this.level = level\n    let enable = this.enabled ? 2 : 0\n    if (this.howlingSuppressionEnabled && this.enabled) {\n      enable = 3\n    }\n    console.log('setVoiceGate enable: ', enable)\n    Module._apm_ains_enable(this.rnnoise, enable, this.level)\n  }\n\n  setAIVadEnable(vad_enable, vad_noise_enable, noise_gate_enable) {\n    const Module = this.Module\n    Module._apm_aivad_enable(this.rnnoise, vad_enable, vad_noise_enable, noise_gate_enable)\n  }\n\n  get enable() {\n    return this.enabled\n  }\n\n  destroy() {\n    if (this.rnnoise) {\n      const Module = this.Module\n      Module._apm_destroy(this.rnnoise)\n      this.rnnoise = null\n    }\n  }\n}\n\nclass AudioEffect {\n  aeInterface = null\n  initMem = false\n  inArrayPtr = null\n  outArrayPtr = null\n  EQArrayPtr = null\n  ReverbPtr = null\n  enabled = false\n  Module = null\n\n  constructor(Module) {\n    this.Module = Module\n  }\n\n  init(inArrayPtr, outArrayPtr) {\n    const Module = this.Module\n    //创建实例\n    this.aeInterface = Module._CreateNEAudioEffect()\n    Module._SetPara(this.aeInterface, 48000, 1, 128)\n    Module._UpdateEffect(this.aeInterface, 0, 0)\n\n    this.inArrayPtr = inArrayPtr\n    this.outArrayPtr = outArrayPtr\n    this.EQArrayPtr = Module._audio_effects_malloc(128 * 4)\n    this.ReverbPtr = Module._audio_effects_malloc(6 * 4)\n  }\n\n  process() {\n    const Module = this.Module\n    const hasResult = Module._Process(this.aeInterface, this.inArrayPtr, 1, 128, this.outArrayPtr)\n    return hasResult\n  }\n\n  setEffect(type, value) {\n    const Module = this.Module\n    if (this.aeInterface) {\n      switch (type) {\n        case 0:\n        case 1:\n          Module._UpdateEffect(this.aeInterface, type, value)\n          break\n        case 'Pitch':\n          Module._setLocalPitch(this.aeInterface, value)\n          break\n        case 'EQ':\n          Module.HEAP32.set(new Int32Array(value), this.EQArrayPtr >> 2)\n          Module._SetEQGain(this.aeInterface, this.EQArrayPtr)\n          break\n        case 'Reverb':\n          const reverbArray = new Array()\n          reverbArray.push(value.wetGain)\n          reverbArray.push(value.dryGain)\n          reverbArray.push(value.damping)\n          reverbArray.push(value.roomSize)\n          reverbArray.push(value.decayTime)\n          reverbArray.push(value.preDelay)\n          Module.HEAPF32.set(reverbArray, this.ReverbPtr >> 2)\n          Module._SetLocalVoiceReverbParam(this.aeInterface, this.ReverbPtr)\n          break\n      }\n    }\n  }\n\n  set enable(value) {\n    const Module = this.Module\n    this.enabled = value\n    if (!value) {\n      Module._UpdateEffect(this.aeInterface, 0, 0)\n      Module._UpdateEffect(this.aeInterface, 1, 0)\n    }\n  }\n\n  get enable() {\n    return this.enabled\n  }\n\n  destroy() {\n    if (this.aeInterface) {\n      const Module = this.Module\n      Module._DeleteNEAudioEffect(this.aeInterface)\n      this.aeInterface = null\n    }\n  }\n}\n\nclass AudioProcess {\n  initMem = false\n  buffer_size = 128\n  inLeftPtr = null\n  outLeftPtr = null\n  inRightPtr = null\n  outRightPtr = null\n  tempLeftPtr = null\n  tempRightPtr = null\n  inArrayPtr = null\n  outArrayPtr = null\n  tempArrayPtr = null\n\n  aeInterface = null\n  EQArrayPtr = null\n\n  AIDenoise = null\n  AudioEffect = null\n  Module = null\n  port = null\n\n  processCount = 0\n  processStartTime = 0\n\n  init(binary, port) {\n    this.port = port\n    this.Module = {\n      wasmBinary: binary,\n      onRuntimeInitialized: () => {\n        this.malloc()\n        this.AIDenoise = new AIDenoise(this.Module, this.port)\n        this.AudioEffect = new AudioEffect(this.Module, this.port)\n        this.AIDenoise.init(this.inArrayPtr, this.tempArrayPtr)\n        this.AudioEffect.init(this.tempArrayPtr, this.outArrayPtr)\n\n        const callbackPtr = this.Module.addFunction(this.handleHasHowling, 'vi')\n        this.Module._register_aiHowling_callback(this.AIDenoise.rnnoise, callbackPtr)\n        this.initMem = true\n\n        this.handleInitFinished()\n      },\n      onAbort: (msg) => {\n        this.port.postMessage({ type: 'error', message: '' + msg })\n      }\n    }\n    createModule(this.Module)\n  }\n\n  malloc() {\n    const Module = this.Module\n    this.inLeftPtr = Module._audio_effects_malloc(this.buffer_size * 2)\n    this.inRightPtr = Module._audio_effects_malloc(this.buffer_size * 2)\n    this.inArrayPtr = Module._audio_effects_malloc(2)\n    Module.HEAP32.set([this.inLeftPtr, this.inRightPtr], this.inArrayPtr >> 2) //单位长度需要和第一个参数元素数据长度对应，第二个参数需要转化为内存地址\n\n    this.outLeftPtr = Module._audio_effects_malloc(this.buffer_size * 2)\n    this.outRightPtr = Module._audio_effects_malloc(this.buffer_size * 2)\n    this.outArrayPtr = Module._audio_effects_malloc(2)\n    Module.HEAP32.set([this.outLeftPtr, this.outRightPtr], this.outArrayPtr >> 2)\n\n    this.tempLeftPtr = Module._audio_effects_malloc(this.buffer_size * 2)\n    this.tempRightPtr = Module._audio_effects_malloc(this.buffer_size * 2)\n    this.tempArrayPtr = Module._audio_effects_malloc(2)\n    Module.HEAP32.set([this.tempLeftPtr, this.tempRightPtr], this.tempArrayPtr >> 2)\n  }\n\n  process(frame) {\n    if (!this.initMem) {\n      if (frame.length) {\n        return frame\n      } else {\n        return\n      }\n    }\n    const Module = this.Module\n\n    let leftData = null,\n      rightData = null\n    let result = []\n    if (frame.length == 2 || frame.length == 1) {\n      //混流后，音频振幅会叠加，样本点的值超过1，要做截断处理\n      rightData = leftData = Int16Array.from(frame[0], (x) => Math.max(-1, Math.min(x, 1)) * 32767)\n    } else {\n      //console.warn('音频源数据异常，长度-', frame.length)\n      return\n    }\n    Module.HEAP16.set(leftData, this.inLeftPtr >> 1)\n    Module.HEAP16.set(rightData, this.inRightPtr >> 1)\n    this.AIDenoise.process()\n    this.AudioEffect.process()\n    //只处理左声道\n    leftData = Float32Array.from(\n      Module.HEAP16.subarray(this.outLeftPtr >> 1, (this.outLeftPtr >> 1) + this.buffer_size),\n      (x) => x / 32768\n    )\n    result.push(leftData)\n    result.push(leftData)\n\n    if (this.processStartTime == 0) {\n      this.processStartTime = currentTime\n    }\n    this.processCount++\n    if (this.processCount - (sampleRate / 128) * 10 > 1) {\n      const now = currentTime\n      const duration = now - this.processStartTime\n      //存在大于10%的波动时，认为处理时间不稳定，抛出警告\n      if (duration > 11 || duration < 9) {\n        this.port.postMessage({\n          type: 'plugin-process-unstable',\n          startTime: this.processStartTime,\n          duration: parseInt(duration * 1000)\n        })\n      }\n      this.processCount = 0\n      this.processStartTime = currentTime\n    }\n\n    return result\n  }\n\n  destroy() {\n    console.warn('ai audio effetcts worker destroy')\n    if (this.initMem) {\n      const Module = this.Module\n      Module._audio_effects_free(this.inLeftPtr)\n      this.inLeftPtr = null\n      Module._audio_effects_free(this.inRightPtr)\n      this.inRightPtr = null\n      Module._audio_effects_free(this.outLeftPtr)\n      this.outLeftPtr = null\n      Module._audio_effects_free(this.outRightPtr)\n      this.outRightPtr = null\n      Module._audio_effects_free(this.inArrayPtr)\n      this.inArrayPtr = null\n      Module._audio_effects_free(this.outArrayPtr)\n      this.outArrayPtr = null\n      Module._audio_effects_free(this.tempLeftPtr)\n      this.tempLeftPtr = null\n      Module._audio_effects_free(this.tempRightPtr)\n      this.tempRightPtr = null\n      Module._audio_effects_free(this.tempArrayPtr)\n      this.tempArrayPtr = null\n      if (this.AudioEffect) {\n        this.AudioEffect.destroy()\n        this.AudioEffect = null\n      }\n      if (this.AIDenoise) {\n        this.AIDenoise.destroy()\n        this.AIDenoise = null\n      }\n      this.processCount = 0\n      this.processStartTime = 0\n      this.initMem = false\n    }\n  }\n\n  handleInitFinished() {\n    this.port.postMessage({\n      type: 'created',\n      value: 'AIAudioEffects'\n    })\n  }\n\n  handleAudioData = (data) => {\n    this.port.postMessage({\n      type: 'audioData',\n      audioData: data\n    })\n  }\n  handleHasHowling = (result) => {\n    console.log('has howling', result)\n    this.port.postMessage({\n      type: 'howlingSuppressionResult',\n      result\n    })\n  }\n}\n"}})}));