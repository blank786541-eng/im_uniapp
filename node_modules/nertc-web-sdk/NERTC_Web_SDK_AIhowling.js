/*! NeRTC 5.8.28|BUILD v5.8.28-0-gf5f839f2 production 20250827 */
!function(n,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.AIhowling=e():n.AIhowling=e()}(window,(function(){return function(n){var e={};function t(r){if(e[r])return e[r].exports;var a=e[r]={i:r,l:!1,exports:{}};return n[r].call(a.exports,a,a.exports,t),a.l=!0,a.exports}return t.m=n,t.c=e,t.d=function(n,e,r){t.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:r})},t.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.t=function(n,e){if(1&e&&(n=t(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var a in n)t.d(r,a,function(e){return n[e]}.bind(null,a));return r},t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,"a",e),e},t.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},t.p="",t(t.s=355)}({3:function(n,e,t){"use strict";var r=Object.prototype.hasOwnProperty,a="~";function o(){}function i(n,e,t){this.fn=n,this.context=e,this.once=t||!1}function s(){this._events=new o,this._eventsCount=0}Object.create&&(o.prototype=Object.create(null),(new o).__proto__||(a=!1)),s.prototype.eventNames=function(){var n,e,t=[];if(0===this._eventsCount)return t;for(e in n=this._events)r.call(n,e)&&t.push(a?e.slice(1):e);return Object.getOwnPropertySymbols?t.concat(Object.getOwnPropertySymbols(n)):t},s.prototype.listeners=function(n,e){var t=a?a+n:n,r=this._events[t];if(e)return!!r;if(!r)return[];if(r.fn)return[r.fn];for(var o=0,i=r.length,s=new Array(i);o<i;o++)s[o]=r[o].fn;return s},s.prototype.emit=function(n,e,t,r,o,i){var s=a?a+n:n;if(!this._events[s])return!1;var d,l,u=this._events[s],f=arguments.length;if(u.fn){switch(u.once&&this.removeListener(n,u.fn,void 0,!0),f){case 1:return u.fn.call(u.context),!0;case 2:return u.fn.call(u.context,e),!0;case 3:return u.fn.call(u.context,e,t),!0;case 4:return u.fn.call(u.context,e,t,r),!0;case 5:return u.fn.call(u.context,e,t,r,o),!0;case 6:return u.fn.call(u.context,e,t,r,o,i),!0}for(l=1,d=new Array(f-1);l<f;l++)d[l-1]=arguments[l];u.fn.apply(u.context,d)}else{var p,m=u.length;for(l=0;l<m;l++)switch(u[l].once&&this.removeListener(n,u[l].fn,void 0,!0),f){case 1:u[l].fn.call(u[l].context);break;case 2:u[l].fn.call(u[l].context,e);break;case 3:u[l].fn.call(u[l].context,e,t);break;case 4:u[l].fn.call(u[l].context,e,t,r);break;default:if(!d)for(p=1,d=new Array(f-1);p<f;p++)d[p-1]=arguments[p];u[l].fn.apply(u[l].context,d)}}return!0},s.prototype.on=function(n,e,t){var r=new i(e,t||this),o=a?a+n:n;return this._events[o]?this._events[o].fn?this._events[o]=[this._events[o],r]:this._events[o].push(r):(this._events[o]=r,this._eventsCount++),this},s.prototype.once=function(n,e,t){var r=new i(e,t||this,!0),o=a?a+n:n;return this._events[o]?this._events[o].fn?this._events[o]=[this._events[o],r]:this._events[o].push(r):(this._events[o]=r,this._eventsCount++),this},s.prototype.removeListener=function(n,e,t,r){var i=a?a+n:n;if(!this._events[i])return this;if(!e)return 0==--this._eventsCount?this._events=new o:delete this._events[i],this;var s=this._events[i];if(s.fn)s.fn!==e||r&&!s.once||t&&s.context!==t||(0==--this._eventsCount?this._events=new o:delete this._events[i]);else{for(var d=0,l=[],u=s.length;d<u;d++)(s[d].fn!==e||r&&!s[d].once||t&&s[d].context!==t)&&l.push(s[d]);l.length?this._events[i]=1===l.length?l[0]:l:0==--this._eventsCount?this._events=new o:delete this._events[i]}return this},s.prototype.removeAllListeners=function(n){var e;return n?(e=a?a+n:n,this._events[e]&&(0==--this._eventsCount?this._events=new o:delete this._events[e])):(this._events=new o,this._eventsCount=0),this},s.prototype.off=s.prototype.removeListener,s.prototype.addListener=s.prototype.on,s.prototype.setMaxListeners=function(){return this},s.prefixed=a,s.EventEmitter=s,n.exports=s},355:function(n,e,t){"use strict";var r=this&&this.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(e,"__esModule",{value:!0});const a=r(t(356));n.exports=a.default},356:function(n,e,t){"use strict";var r=this&&this.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(e,"__esModule",{value:!0});const a=t(3),o=r(t(357)),i={aiHowlingWorkletAgentProcessor:{blobParts:[o.default],options:{type:"text/javascript; charset=utf-8"},url:""}};class s extends a.EventEmitter{constructor(n){super(),this.wasmBinary=null,this.logger=n.adapterRef.logger.getChild(()=>"aiHowling"),this.version="5.8.28",this.logger.info("Plugin AIholwing 5.8.28 v5.8.28-0-gf5f839f2: 创建成功。"),this.url=function(n){if(!i[n].url){const e=new Blob(i[n].blobParts,i[n].options);i[n].url=window.URL.createObjectURL(e)}return i[n].url}("aiHowlingWorkletAgentProcessor"),this.preload(n)}async preload(n){fetch(n.wasmUrl).then(n=>{if(200==n.status)return n.arrayBuffer();this.emit("plugin-load-error")}).then(n=>{n&&(this.wasmBinary=new Uint8Array(n),this.emit("plugin-load"))})}init(){this.logger.log("AIholwing create")}}e.default=s},357:function(n,e,t){"use strict";n.exports="/* eslint-disable */\nvar Module = typeof Module != 'undefined' ? Module : {}\n\nfunction createModule() {\n  var moduleOverrides = Object.assign({}, Module)\n  var arguments_ = []\n  var thisProgram = './this.program'\n  var quit_ = (status, toThrow) => {\n    throw toThrow\n  }\n  var ENVIRONMENT_IS_WEB = typeof window == 'object'\n  var ENVIRONMENT_IS_WORKER = typeof importScripts == 'function'\n  var ENVIRONMENT_IS_NODE =\n    typeof process == 'object' &&\n    typeof process.versions == 'object' &&\n    typeof process.versions.node == 'string'\n  var scriptDirectory = ''\n  function locateFile(path) {\n    if (Module['locateFile']) {\n      return Module['locateFile'](path, scriptDirectory)\n    }\n    return scriptDirectory + path\n  }\n  var read_, readAsync, readBinary, setWindowTitle\n  if (ENVIRONMENT_IS_NODE) {\n    var fs = require('fs')\n    var nodePath = require('path')\n    if (ENVIRONMENT_IS_WORKER) {\n      scriptDirectory = nodePath.dirname(scriptDirectory) + '/'\n    } else {\n      scriptDirectory = __dirname + '/'\n    }\n    read_ = (filename, binary) => {\n      filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename)\n      return fs.readFileSync(filename, binary ? undefined : 'utf8')\n    }\n    readBinary = (filename) => {\n      var ret = read_(filename, true)\n      if (!ret.buffer) {\n        ret = new Uint8Array(ret)\n      }\n      return ret\n    }\n    readAsync = (filename, onload, onerror, binary = true) => {\n      filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename)\n      fs.readFile(filename, binary ? undefined : 'utf8', (err, data) => {\n        if (err) onerror(err)\n        else onload(binary ? data.buffer : data)\n      })\n    }\n    if (!Module['thisProgram'] && process.argv.length > 1) {\n      thisProgram = process.argv[1].replace(/\\\\/g, '/')\n    }\n    arguments_ = process.argv.slice(2)\n    if (typeof module != 'undefined') {\n      module['exports'] = Module\n    }\n    process.on('uncaughtException', (ex) => {\n      if (ex !== 'unwind' && !(ex instanceof ExitStatus) && !(ex.context instanceof ExitStatus)) {\n        throw ex\n      }\n    })\n    quit_ = (status, toThrow) => {\n      process.exitCode = status\n      throw toThrow\n    }\n    Module['inspect'] = () => '[Emscripten Module object]'\n  } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n    if (ENVIRONMENT_IS_WORKER) {\n      scriptDirectory = self.location.href\n    } else if (typeof document != 'undefined' && document.currentScript) {\n      scriptDirectory = document.currentScript.src\n    }\n    if (scriptDirectory.indexOf('blob:') !== 0) {\n      scriptDirectory = scriptDirectory.substr(\n        0,\n        scriptDirectory.replace(/[?#].*/, '').lastIndexOf('/') + 1\n      )\n    } else {\n      scriptDirectory = ''\n    }\n    {\n      read_ = (url) => {\n        var xhr = new XMLHttpRequest()\n        xhr.open('GET', url, false)\n        xhr.send(null)\n        return xhr.responseText\n      }\n      if (ENVIRONMENT_IS_WORKER) {\n        readBinary = (url) => {\n          var xhr = new XMLHttpRequest()\n          xhr.open('GET', url, false)\n          xhr.responseType = 'arraybuffer'\n          xhr.send(null)\n          return new Uint8Array(xhr.response)\n        }\n      }\n      readAsync = (url, onload, onerror) => {\n        var xhr = new XMLHttpRequest()\n        xhr.open('GET', url, true)\n        xhr.responseType = 'arraybuffer'\n        xhr.onload = () => {\n          if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) {\n            onload(xhr.response)\n            return\n          }\n          onerror()\n        }\n        xhr.onerror = onerror\n        xhr.send(null)\n      }\n    }\n    setWindowTitle = (title) => (document.title = title)\n  } else {\n  }\n  var out = Module['print'] || console.log.bind(console)\n  var err = Module['printErr'] || console.error.bind(console)\n  Object.assign(Module, moduleOverrides)\n  moduleOverrides = null\n  if (Module['arguments']) arguments_ = Module['arguments']\n  if (Module['thisProgram']) thisProgram = Module['thisProgram']\n  if (Module['quit']) quit_ = Module['quit']\n  var wasmBinary\n  if (Module['wasmBinary']) wasmBinary = Module['wasmBinary']\n  var noExitRuntime = Module['noExitRuntime'] || true\n  if (typeof WebAssembly != 'object') {\n    abort('no native wasm support detected')\n  }\n  var wasmMemory\n  var ABORT = false\n  var EXITSTATUS\n  function assert(condition, text) {\n    if (!condition) {\n      abort(text)\n    }\n  }\n  var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64\n  function updateMemoryViews() {\n    var b = wasmMemory.buffer\n    Module['HEAP8'] = HEAP8 = new Int8Array(b)\n    Module['HEAP16'] = HEAP16 = new Int16Array(b)\n    Module['HEAPU8'] = HEAPU8 = new Uint8Array(b)\n    Module['HEAPU16'] = HEAPU16 = new Uint16Array(b)\n    Module['HEAP32'] = HEAP32 = new Int32Array(b)\n    Module['HEAPU32'] = HEAPU32 = new Uint32Array(b)\n    Module['HEAPF32'] = HEAPF32 = new Float32Array(b)\n    Module['HEAPF64'] = HEAPF64 = new Float64Array(b)\n  }\n  var wasmTable\n  var __ATPRERUN__ = []\n  var __ATINIT__ = []\n  var __ATMAIN__ = []\n  var __ATPOSTRUN__ = []\n  var runtimeInitialized = false\n  var runtimeKeepaliveCounter = 0\n  function keepRuntimeAlive() {\n    return noExitRuntime || runtimeKeepaliveCounter > 0\n  }\n  function preRun() {\n    if (Module['preRun']) {\n      if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']]\n      while (Module['preRun'].length) {\n        addOnPreRun(Module['preRun'].shift())\n      }\n    }\n    callRuntimeCallbacks(__ATPRERUN__)\n  }\n  function initRuntime() {\n    runtimeInitialized = true\n    if (!Module['noFSInit'] && !FS.init.initialized) FS.init()\n    FS.ignorePermissions = false\n    TTY.init()\n    callRuntimeCallbacks(__ATINIT__)\n  }\n  function preMain() {\n    callRuntimeCallbacks(__ATMAIN__)\n  }\n  function postRun() {\n    if (Module['postRun']) {\n      if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']]\n      while (Module['postRun'].length) {\n        addOnPostRun(Module['postRun'].shift())\n      }\n    }\n    callRuntimeCallbacks(__ATPOSTRUN__)\n  }\n  function addOnPreRun(cb) {\n    __ATPRERUN__.unshift(cb)\n  }\n  function addOnInit(cb) {\n    __ATINIT__.unshift(cb)\n  }\n  function addOnPostRun(cb) {\n    __ATPOSTRUN__.unshift(cb)\n  }\n  var runDependencies = 0\n  var runDependencyWatcher = null\n  var dependenciesFulfilled = null\n  function getUniqueRunDependency(id) {\n    return id\n  }\n  function addRunDependency(id) {\n    runDependencies++\n    if (Module['monitorRunDependencies']) {\n      Module['monitorRunDependencies'](runDependencies)\n    }\n  }\n  function removeRunDependency(id) {\n    runDependencies--\n    if (Module['monitorRunDependencies']) {\n      Module['monitorRunDependencies'](runDependencies)\n    }\n    if (runDependencies == 0) {\n      if (runDependencyWatcher !== null) {\n        clearInterval(runDependencyWatcher)\n        runDependencyWatcher = null\n      }\n      if (dependenciesFulfilled) {\n        var callback = dependenciesFulfilled\n        dependenciesFulfilled = null\n        callback()\n      }\n    }\n  }\n  function abort(what) {\n    if (Module['onAbort']) {\n      Module['onAbort'](what)\n    }\n    what = 'Aborted(' + what + ')'\n    err(what)\n    ABORT = true\n    EXITSTATUS = 1\n    what += '. Build with -sASSERTIONS for more info.'\n    var e = new WebAssembly.RuntimeError(what)\n    throw e\n  }\n  var dataURIPrefix = 'data:application/octet-stream;base64,'\n  function isDataURI(filename) {\n    return filename.startsWith(dataURIPrefix)\n  }\n  function isFileURI(filename) {\n    return filename.startsWith('file://')\n  }\n  var wasmBinaryFile\n  wasmBinaryFile = 'audio_aihowling.wasm'\n  if (!isDataURI(wasmBinaryFile)) {\n    wasmBinaryFile = locateFile(wasmBinaryFile)\n  }\n  function getBinarySync(file) {\n    if (file == wasmBinaryFile && wasmBinary) {\n      return new Uint8Array(wasmBinary)\n    }\n    if (readBinary) {\n      return readBinary(file)\n    }\n    throw 'both async and sync fetching of the wasm failed'\n  }\n  function getBinaryPromise(binaryFile) {\n    if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {\n      if (typeof fetch == 'function' && !isFileURI(binaryFile)) {\n        return fetch(binaryFile, {\n          credentials: 'same-origin'\n        })\n          .then((response) => {\n            if (!response['ok']) {\n              throw \"failed to load wasm binary file at '\" + binaryFile + \"'\"\n            }\n            return response['arrayBuffer']()\n          })\n          .catch(() => getBinarySync(binaryFile))\n      } else if (readAsync) {\n        return new Promise((resolve, reject) => {\n          readAsync(binaryFile, (response) => resolve(new Uint8Array(response)), reject)\n        })\n      }\n    }\n    return Promise.resolve().then(() => getBinarySync(binaryFile))\n  }\n  function instantiateArrayBuffer(binaryFile, imports, receiver) {\n    return getBinaryPromise(binaryFile)\n      .then((binary) => WebAssembly.instantiate(binary, imports))\n      .then((instance) => instance)\n      .then(receiver, (reason) => {\n        err(`failed to asynchronously prepare wasm: $ {\n\t\t\treason\n\t\t}`)\n        abort(reason)\n      })\n  }\n  function instantiateAsync(binary, binaryFile, imports, callback) {\n    if (\n      !binary &&\n      typeof WebAssembly.instantiateStreaming == 'function' &&\n      !isDataURI(binaryFile) &&\n      !isFileURI(binaryFile) &&\n      !ENVIRONMENT_IS_NODE &&\n      typeof fetch == 'function'\n    ) {\n      return fetch(binaryFile, {\n        credentials: 'same-origin'\n      }).then((response) => {\n        var result = WebAssembly.instantiateStreaming(response, imports)\n        return result.then(callback, function (reason) {\n          err(`wasm streaming compile failed: $ {\n\t\t\t\t\treason\n\t\t\t\t}`)\n          err('falling back to ArrayBuffer instantiation')\n          return instantiateArrayBuffer(binaryFile, imports, callback)\n        })\n      })\n    }\n    return instantiateArrayBuffer(binaryFile, imports, callback)\n  }\n  function createWasm() {\n    var info = {\n      a: wasmImports\n    }\n    function receiveInstance(instance, module) {\n      var exports = instance.exports\n      wasmExports = exports\n      wasmMemory = wasmExports['y']\n      updateMemoryViews()\n      wasmTable = wasmExports['J']\n      addOnInit(wasmExports['z'])\n      removeRunDependency('wasm-instantiate')\n      return exports\n    }\n    addRunDependency('wasm-instantiate')\n    function receiveInstantiationResult(result) {\n      receiveInstance(result['instance'])\n    }\n    if (Module['instantiateWasm']) {\n      try {\n        return Module['instantiateWasm'](info, receiveInstance)\n      } catch (e) {\n        err(`Module.instantiateWasm callback failed with error: $ {\n\t\t\t\te\n\t\t\t}`)\n        return false\n      }\n    }\n    instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult)\n    return {}\n  }\n  var tempDouble\n  var tempI64\n  function ExitStatus(status) {\n    this.name = 'ExitStatus'\n    this.message = `Program terminated with exit($ {\n\t\tstatus\n\t})`\n    this.status = status\n  }\n  var callRuntimeCallbacks = (callbacks) => {\n    while (callbacks.length > 0) {\n      callbacks.shift()(Module)\n    }\n  }\n  function ExceptionInfo(excPtr) {\n    this.excPtr = excPtr\n    this.ptr = excPtr - 24\n    this.set_type = function (type) {\n      HEAPU32[(this.ptr + 4) >> 2] = type\n    }\n    this.get_type = function () {\n      return HEAPU32[(this.ptr + 4) >> 2]\n    }\n    this.set_destructor = function (destructor) {\n      HEAPU32[(this.ptr + 8) >> 2] = destructor\n    }\n    this.get_destructor = function () {\n      return HEAPU32[(this.ptr + 8) >> 2]\n    }\n    this.set_caught = function (caught) {\n      caught = caught ? 1 : 0\n      HEAP8[(this.ptr + 12) >> 0] = caught\n    }\n    this.get_caught = function () {\n      return HEAP8[(this.ptr + 12) >> 0] != 0\n    }\n    this.set_rethrown = function (rethrown) {\n      rethrown = rethrown ? 1 : 0\n      HEAP8[(this.ptr + 13) >> 0] = rethrown\n    }\n    this.get_rethrown = function () {\n      return HEAP8[(this.ptr + 13) >> 0] != 0\n    }\n    this.init = function (type, destructor) {\n      this.set_adjusted_ptr(0)\n      this.set_type(type)\n      this.set_destructor(destructor)\n    }\n    this.set_adjusted_ptr = function (adjustedPtr) {\n      HEAPU32[(this.ptr + 16) >> 2] = adjustedPtr\n    }\n    this.get_adjusted_ptr = function () {\n      return HEAPU32[(this.ptr + 16) >> 2]\n    }\n    this.get_exception_ptr = function () {\n      var isPointer = ___cxa_is_pointer_type(this.get_type())\n      if (isPointer) {\n        return HEAPU32[this.excPtr >> 2]\n      }\n      var adjusted = this.get_adjusted_ptr()\n      if (adjusted !== 0) return adjusted\n      return this.excPtr\n    }\n  }\n  var exceptionLast = 0\n  var uncaughtExceptionCount = 0\n  var ___cxa_throw = (ptr, type, destructor) => {\n    var info = new ExceptionInfo(ptr)\n    info.init(type, destructor)\n    exceptionLast = ptr\n    uncaughtExceptionCount++\n    throw exceptionLast\n  }\n  var setErrNo = (value) => {\n    HEAP32[___errno_location() >> 2] = value\n    return value\n  }\n  var PATH = {\n    isAbs: (path) => path.charAt(0) === '/',\n    splitPath: (filename) => {\n      var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/\n      return splitPathRe.exec(filename).slice(1)\n    },\n    normalizeArray: (parts, allowAboveRoot) => {\n      var up = 0\n      for (var i = parts.length - 1; i >= 0; i--) {\n        var last = parts[i]\n        if (last === '.') {\n          parts.splice(i, 1)\n        } else if (last === '..') {\n          parts.splice(i, 1)\n          up++\n        } else if (up) {\n          parts.splice(i, 1)\n          up--\n        }\n      }\n      if (allowAboveRoot) {\n        for (; up; up--) {\n          parts.unshift('..')\n        }\n      }\n      return parts\n    },\n    normalize: (path) => {\n      var isAbsolute = PATH.isAbs(path),\n        trailingSlash = path.substr(-1) === '/'\n      path = PATH.normalizeArray(\n        path.split('/').filter((p) => !!p),\n        !isAbsolute\n      ).join('/')\n      if (!path && !isAbsolute) {\n        path = '.'\n      }\n      if (path && trailingSlash) {\n        path += '/'\n      }\n      return (isAbsolute ? '/' : '') + path\n    },\n    dirname: (path) => {\n      var result = PATH.splitPath(path),\n        root = result[0],\n        dir = result[1]\n      if (!root && !dir) {\n        return '.'\n      }\n      if (dir) {\n        dir = dir.substr(0, dir.length - 1)\n      }\n      return root + dir\n    },\n    basename: (path) => {\n      if (path === '/') return '/'\n      path = PATH.normalize(path)\n      path = path.replace(/\\/$/, '')\n      var lastSlash = path.lastIndexOf('/')\n      if (lastSlash === -1) return path\n      return path.substr(lastSlash + 1)\n    },\n    join: function () {\n      var paths = Array.prototype.slice.call(arguments)\n      return PATH.normalize(paths.join('/'))\n    },\n    join2: (l, r) => PATH.normalize(l + '/' + r)\n  }\n  var initRandomFill = () => {\n    if (typeof crypto == 'object' && typeof crypto['getRandomValues'] == 'function') {\n      return (view) => crypto.getRandomValues(view)\n    } else if (ENVIRONMENT_IS_NODE) {\n      // try {\n      // \tvar crypto_module = require(\"crypto\");\n      // \tvar randomFillSync = crypto_module[\"randomFillSync\"];\n      // \tif (randomFillSync) {\n      // \t\treturn view =>crypto_module[\"randomFillSync\"](view)\n      // \t}\n      // \tvar randomBytes = crypto_module[\"randomBytes\"];\n      // \treturn view =>(view.set(randomBytes(view.byteLength)), view)\n      // } catch(e) {}\n    }\n    abort('initRandomDevice')\n  }\n  var randomFill = (view) => (randomFill = initRandomFill())(view)\n  var PATH_FS = {\n    resolve: function () {\n      var resolvedPath = '',\n        resolvedAbsolute = false\n      for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n        var path = i >= 0 ? arguments[i] : FS.cwd()\n        if (typeof path != 'string') {\n          throw new TypeError('Arguments to path.resolve must be strings')\n        } else if (!path) {\n          return ''\n        }\n        resolvedPath = path + '/' + resolvedPath\n        resolvedAbsolute = PATH.isAbs(path)\n      }\n      resolvedPath = PATH.normalizeArray(\n        resolvedPath.split('/').filter((p) => !!p),\n        !resolvedAbsolute\n      ).join('/')\n      return (resolvedAbsolute ? '/' : '') + resolvedPath || '.'\n    },\n    relative: (from, to) => {\n      from = PATH_FS.resolve(from).substr(1)\n      to = PATH_FS.resolve(to).substr(1)\n      function trim(arr) {\n        var start = 0\n        for (; start < arr.length; start++) {\n          if (arr[start] !== '') break\n        }\n        var end = arr.length - 1\n        for (; end >= 0; end--) {\n          if (arr[end] !== '') break\n        }\n        if (start > end) return []\n        return arr.slice(start, end - start + 1)\n      }\n      var fromParts = trim(from.split('/'))\n      var toParts = trim(to.split('/'))\n      var length = Math.min(fromParts.length, toParts.length)\n      var samePartsLength = length\n      for (var i = 0; i < length; i++) {\n        if (fromParts[i] !== toParts[i]) {\n          samePartsLength = i\n          break\n        }\n      }\n      var outputParts = []\n      for (var i = samePartsLength; i < fromParts.length; i++) {\n        outputParts.push('..')\n      }\n      outputParts = outputParts.concat(toParts.slice(samePartsLength))\n      return outputParts.join('/')\n    }\n  }\n  var UTF8Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf8') : undefined\n  var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => {\n    var endIdx = idx + maxBytesToRead\n    var endPtr = idx\n    while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr\n    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\n      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr))\n    }\n    var str = ''\n    while (idx < endPtr) {\n      var u0 = heapOrArray[idx++]\n      if (!(u0 & 128)) {\n        str += String.fromCharCode(u0)\n        continue\n      }\n      var u1 = heapOrArray[idx++] & 63\n      if ((u0 & 224) == 192) {\n        str += String.fromCharCode(((u0 & 31) << 6) | u1)\n        continue\n      }\n      var u2 = heapOrArray[idx++] & 63\n      if ((u0 & 240) == 224) {\n        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2\n      } else {\n        u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63)\n      }\n      if (u0 < 65536) {\n        str += String.fromCharCode(u0)\n      } else {\n        var ch = u0 - 65536\n        str += String.fromCharCode(55296 | (ch >> 10), 56320 | (ch & 1023))\n      }\n    }\n    return str\n  }\n  var FS_stdin_getChar_buffer = []\n  var lengthBytesUTF8 = (str) => {\n    var len = 0\n    for (var i = 0; i < str.length; ++i) {\n      var c = str.charCodeAt(i)\n      if (c <= 127) {\n        len++\n      } else if (c <= 2047) {\n        len += 2\n      } else if (c >= 55296 && c <= 57343) {\n        len += 4\n        ++i\n      } else {\n        len += 3\n      }\n    }\n    return len\n  }\n  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {\n    if (!(maxBytesToWrite > 0)) return 0\n    var startIdx = outIdx\n    var endIdx = outIdx + maxBytesToWrite - 1\n    for (var i = 0; i < str.length; ++i) {\n      var u = str.charCodeAt(i)\n      if (u >= 55296 && u <= 57343) {\n        var u1 = str.charCodeAt(++i)\n        u = (65536 + ((u & 1023) << 10)) | (u1 & 1023)\n      }\n      if (u <= 127) {\n        if (outIdx >= endIdx) break\n        heap[outIdx++] = u\n      } else if (u <= 2047) {\n        if (outIdx + 1 >= endIdx) break\n        heap[outIdx++] = 192 | (u >> 6)\n        heap[outIdx++] = 128 | (u & 63)\n      } else if (u <= 65535) {\n        if (outIdx + 2 >= endIdx) break\n        heap[outIdx++] = 224 | (u >> 12)\n        heap[outIdx++] = 128 | ((u >> 6) & 63)\n        heap[outIdx++] = 128 | (u & 63)\n      } else {\n        if (outIdx + 3 >= endIdx) break\n        heap[outIdx++] = 240 | (u >> 18)\n        heap[outIdx++] = 128 | ((u >> 12) & 63)\n        heap[outIdx++] = 128 | ((u >> 6) & 63)\n        heap[outIdx++] = 128 | (u & 63)\n      }\n    }\n    heap[outIdx] = 0\n    return outIdx - startIdx\n  }\n  function intArrayFromString(stringy, dontAddNull, length) {\n    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1\n    var u8array = new Array(len)\n    var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length)\n    if (dontAddNull) u8array.length = numBytesWritten\n    return u8array\n  }\n  var FS_stdin_getChar = () => {\n    if (!FS_stdin_getChar_buffer.length) {\n      var result = null\n      if (ENVIRONMENT_IS_NODE) {\n        var BUFSIZE = 256\n        var buf = Buffer.alloc(BUFSIZE)\n        var bytesRead = 0\n        var fd = process.stdin.fd\n        try {\n          bytesRead = fs.readSync(fd, buf)\n        } catch (e) {\n          if (e.toString().includes('EOF')) bytesRead = 0\n          else throw e\n        }\n        if (bytesRead > 0) {\n          result = buf.slice(0, bytesRead).toString('utf-8')\n        } else {\n          result = null\n        }\n      } else if (typeof window != 'undefined' && typeof window.prompt == 'function') {\n        result = window.prompt('Input: ')\n        if (result !== null) {\n          result += '\\n'\n        }\n      } else if (typeof readline == 'function') {\n        result = readline()\n        if (result !== null) {\n          result += '\\n'\n        }\n      }\n      if (!result) {\n        return null\n      }\n      FS_stdin_getChar_buffer = intArrayFromString(result, true)\n    }\n    return FS_stdin_getChar_buffer.shift()\n  }\n  var TTY = {\n    ttys: [],\n    init() {},\n    shutdown() {},\n    register(dev, ops) {\n      TTY.ttys[dev] = {\n        input: [],\n        output: [],\n        ops: ops\n      }\n      FS.registerDevice(dev, TTY.stream_ops)\n    },\n    stream_ops: {\n      open(stream) {\n        var tty = TTY.ttys[stream.node.rdev]\n        if (!tty) {\n          throw new FS.ErrnoError(43)\n        }\n        stream.tty = tty\n        stream.seekable = false\n      },\n      close(stream) {\n        stream.tty.ops.fsync(stream.tty)\n      },\n      fsync(stream) {\n        stream.tty.ops.fsync(stream.tty)\n      },\n      read(stream, buffer, offset, length, pos) {\n        if (!stream.tty || !stream.tty.ops.get_char) {\n          throw new FS.ErrnoError(60)\n        }\n        var bytesRead = 0\n        for (var i = 0; i < length; i++) {\n          var result\n          try {\n            result = stream.tty.ops.get_char(stream.tty)\n          } catch (e) {\n            throw new FS.ErrnoError(29)\n          }\n          if (result === undefined && bytesRead === 0) {\n            throw new FS.ErrnoError(6)\n          }\n          if (result === null || result === undefined) break\n          bytesRead++\n          buffer[offset + i] = result\n        }\n        if (bytesRead) {\n          stream.node.timestamp = Date.now()\n        }\n        return bytesRead\n      },\n      write(stream, buffer, offset, length, pos) {\n        if (!stream.tty || !stream.tty.ops.put_char) {\n          throw new FS.ErrnoError(60)\n        }\n        try {\n          for (var i = 0; i < length; i++) {\n            stream.tty.ops.put_char(stream.tty, buffer[offset + i])\n          }\n        } catch (e) {\n          throw new FS.ErrnoError(29)\n        }\n        if (length) {\n          stream.node.timestamp = Date.now()\n        }\n        return i\n      }\n    },\n    default_tty_ops: {\n      get_char(tty) {\n        return FS_stdin_getChar()\n      },\n      put_char(tty, val) {\n        if (val === null || val === 10) {\n          out(UTF8ArrayToString(tty.output, 0))\n          tty.output = []\n        } else {\n          if (val != 0) tty.output.push(val)\n        }\n      },\n      fsync(tty) {\n        if (tty.output && tty.output.length > 0) {\n          out(UTF8ArrayToString(tty.output, 0))\n          tty.output = []\n        }\n      },\n      ioctl_tcgets(tty) {\n        return {\n          c_iflag: 25856,\n          c_oflag: 5,\n          c_cflag: 191,\n          c_lflag: 35387,\n          c_cc: [\n            3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0\n          ]\n        }\n      },\n      ioctl_tcsets(tty, optional_actions, data) {\n        return 0\n      },\n      ioctl_tiocgwinsz(tty) {\n        return [24, 80]\n      }\n    },\n    default_tty1_ops: {\n      put_char(tty, val) {\n        if (val === null || val === 10) {\n          err(UTF8ArrayToString(tty.output, 0))\n          tty.output = []\n        } else {\n          if (val != 0) tty.output.push(val)\n        }\n      },\n      fsync(tty) {\n        if (tty.output && tty.output.length > 0) {\n          err(UTF8ArrayToString(tty.output, 0))\n          tty.output = []\n        }\n      }\n    }\n  }\n  var mmapAlloc = (size) => {\n    abort()\n  }\n  var MEMFS = {\n    ops_table: null,\n    mount(mount) {\n      return MEMFS.createNode(null, '/', 16384 | 511, 0)\n    },\n    createNode(parent, name, mode, dev) {\n      if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\n        throw new FS.ErrnoError(63)\n      }\n      if (!MEMFS.ops_table) {\n        MEMFS.ops_table = {\n          dir: {\n            node: {\n              getattr: MEMFS.node_ops.getattr,\n              setattr: MEMFS.node_ops.setattr,\n              lookup: MEMFS.node_ops.lookup,\n              mknod: MEMFS.node_ops.mknod,\n              rename: MEMFS.node_ops.rename,\n              unlink: MEMFS.node_ops.unlink,\n              rmdir: MEMFS.node_ops.rmdir,\n              readdir: MEMFS.node_ops.readdir,\n              symlink: MEMFS.node_ops.symlink\n            },\n            stream: {\n              llseek: MEMFS.stream_ops.llseek\n            }\n          },\n          file: {\n            node: {\n              getattr: MEMFS.node_ops.getattr,\n              setattr: MEMFS.node_ops.setattr\n            },\n            stream: {\n              llseek: MEMFS.stream_ops.llseek,\n              read: MEMFS.stream_ops.read,\n              write: MEMFS.stream_ops.write,\n              allocate: MEMFS.stream_ops.allocate,\n              mmap: MEMFS.stream_ops.mmap,\n              msync: MEMFS.stream_ops.msync\n            }\n          },\n          link: {\n            node: {\n              getattr: MEMFS.node_ops.getattr,\n              setattr: MEMFS.node_ops.setattr,\n              readlink: MEMFS.node_ops.readlink\n            },\n            stream: {}\n          },\n          chrdev: {\n            node: {\n              getattr: MEMFS.node_ops.getattr,\n              setattr: MEMFS.node_ops.setattr\n            },\n            stream: FS.chrdev_stream_ops\n          }\n        }\n      }\n      var node = FS.createNode(parent, name, mode, dev)\n      if (FS.isDir(node.mode)) {\n        node.node_ops = MEMFS.ops_table.dir.node\n        node.stream_ops = MEMFS.ops_table.dir.stream\n        node.contents = {}\n      } else if (FS.isFile(node.mode)) {\n        node.node_ops = MEMFS.ops_table.file.node\n        node.stream_ops = MEMFS.ops_table.file.stream\n        node.usedBytes = 0\n        node.contents = null\n      } else if (FS.isLink(node.mode)) {\n        node.node_ops = MEMFS.ops_table.link.node\n        node.stream_ops = MEMFS.ops_table.link.stream\n      } else if (FS.isChrdev(node.mode)) {\n        node.node_ops = MEMFS.ops_table.chrdev.node\n        node.stream_ops = MEMFS.ops_table.chrdev.stream\n      }\n      node.timestamp = Date.now()\n      if (parent) {\n        parent.contents[name] = node\n        parent.timestamp = node.timestamp\n      }\n      return node\n    },\n    getFileDataAsTypedArray(node) {\n      if (!node.contents) return new Uint8Array(0)\n      if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes)\n      return new Uint8Array(node.contents)\n    },\n    expandFileStorage(node, newCapacity) {\n      var prevCapacity = node.contents ? node.contents.length : 0\n      if (prevCapacity >= newCapacity) return\n      var CAPACITY_DOUBLING_MAX = 1024 * 1024\n      newCapacity = Math.max(\n        newCapacity,\n        (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125)) >>> 0\n      )\n      if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256)\n      var oldContents = node.contents\n      node.contents = new Uint8Array(newCapacity)\n      if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0)\n    },\n    resizeFileStorage(node, newSize) {\n      if (node.usedBytes == newSize) return\n      if (newSize == 0) {\n        node.contents = null\n        node.usedBytes = 0\n      } else {\n        var oldContents = node.contents\n        node.contents = new Uint8Array(newSize)\n        if (oldContents) {\n          node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)))\n        }\n        node.usedBytes = newSize\n      }\n    },\n    node_ops: {\n      getattr(node) {\n        var attr = {}\n        attr.dev = FS.isChrdev(node.mode) ? node.id : 1\n        attr.ino = node.id\n        attr.mode = node.mode\n        attr.nlink = 1\n        attr.uid = 0\n        attr.gid = 0\n        attr.rdev = node.rdev\n        if (FS.isDir(node.mode)) {\n          attr.size = 4096\n        } else if (FS.isFile(node.mode)) {\n          attr.size = node.usedBytes\n        } else if (FS.isLink(node.mode)) {\n          attr.size = node.link.length\n        } else {\n          attr.size = 0\n        }\n        attr.atime = new Date(node.timestamp)\n        attr.mtime = new Date(node.timestamp)\n        attr.ctime = new Date(node.timestamp)\n        attr.blksize = 4096\n        attr.blocks = Math.ceil(attr.size / attr.blksize)\n        return attr\n      },\n      setattr(node, attr) {\n        if (attr.mode !== undefined) {\n          node.mode = attr.mode\n        }\n        if (attr.timestamp !== undefined) {\n          node.timestamp = attr.timestamp\n        }\n        if (attr.size !== undefined) {\n          MEMFS.resizeFileStorage(node, attr.size)\n        }\n      },\n      lookup(parent, name) {\n        throw FS.genericErrors[44]\n      },\n      mknod(parent, name, mode, dev) {\n        return MEMFS.createNode(parent, name, mode, dev)\n      },\n      rename(old_node, new_dir, new_name) {\n        if (FS.isDir(old_node.mode)) {\n          var new_node\n          try {\n            new_node = FS.lookupNode(new_dir, new_name)\n          } catch (e) {}\n          if (new_node) {\n            for (var i in new_node.contents) {\n              throw new FS.ErrnoError(55)\n            }\n          }\n        }\n        delete old_node.parent.contents[old_node.name]\n        old_node.parent.timestamp = Date.now()\n        old_node.name = new_name\n        new_dir.contents[new_name] = old_node\n        new_dir.timestamp = old_node.parent.timestamp\n        old_node.parent = new_dir\n      },\n      unlink(parent, name) {\n        delete parent.contents[name]\n        parent.timestamp = Date.now()\n      },\n      rmdir(parent, name) {\n        var node = FS.lookupNode(parent, name)\n        for (var i in node.contents) {\n          throw new FS.ErrnoError(55)\n        }\n        delete parent.contents[name]\n        parent.timestamp = Date.now()\n      },\n      readdir(node) {\n        var entries = ['.', '..']\n        for (var key in node.contents) {\n          if (!node.contents.hasOwnProperty(key)) {\n            continue\n          }\n          entries.push(key)\n        }\n        return entries\n      },\n      symlink(parent, newname, oldpath) {\n        var node = MEMFS.createNode(parent, newname, 511 | 40960, 0)\n        node.link = oldpath\n        return node\n      },\n      readlink(node) {\n        if (!FS.isLink(node.mode)) {\n          throw new FS.ErrnoError(28)\n        }\n        return node.link\n      }\n    },\n    stream_ops: {\n      read(stream, buffer, offset, length, position) {\n        var contents = stream.node.contents\n        if (position >= stream.node.usedBytes) return 0\n        var size = Math.min(stream.node.usedBytes - position, length)\n        if (size > 8 && contents.subarray) {\n          buffer.set(contents.subarray(position, position + size), offset)\n        } else {\n          for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i]\n        }\n        return size\n      },\n      write(stream, buffer, offset, length, position, canOwn) {\n        if (!length) return 0\n        var node = stream.node\n        node.timestamp = Date.now()\n        if (buffer.subarray && (!node.contents || node.contents.subarray)) {\n          if (canOwn) {\n            node.contents = buffer.subarray(offset, offset + length)\n            node.usedBytes = length\n            return length\n          } else if (node.usedBytes === 0 && position === 0) {\n            node.contents = buffer.slice(offset, offset + length)\n            node.usedBytes = length\n            return length\n          } else if (position + length <= node.usedBytes) {\n            node.contents.set(buffer.subarray(offset, offset + length), position)\n            return length\n          }\n        }\n        MEMFS.expandFileStorage(node, position + length)\n        if (node.contents.subarray && buffer.subarray) {\n          node.contents.set(buffer.subarray(offset, offset + length), position)\n        } else {\n          for (var i = 0; i < length; i++) {\n            node.contents[position + i] = buffer[offset + i]\n          }\n        }\n        node.usedBytes = Math.max(node.usedBytes, position + length)\n        return length\n      },\n      llseek(stream, offset, whence) {\n        var position = offset\n        if (whence === 1) {\n          position += stream.position\n        } else if (whence === 2) {\n          if (FS.isFile(stream.node.mode)) {\n            position += stream.node.usedBytes\n          }\n        }\n        if (position < 0) {\n          throw new FS.ErrnoError(28)\n        }\n        return position\n      },\n      allocate(stream, offset, length) {\n        MEMFS.expandFileStorage(stream.node, offset + length)\n        stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length)\n      },\n      mmap(stream, length, position, prot, flags) {\n        if (!FS.isFile(stream.node.mode)) {\n          throw new FS.ErrnoError(43)\n        }\n        var ptr\n        var allocated\n        var contents = stream.node.contents\n        if (!(flags & 2) && contents.buffer === HEAP8.buffer) {\n          allocated = false\n          ptr = contents.byteOffset\n        } else {\n          if (position > 0 || position + length < contents.length) {\n            if (contents.subarray) {\n              contents = contents.subarray(position, position + length)\n            } else {\n              contents = Array.prototype.slice.call(contents, position, position + length)\n            }\n          }\n          allocated = true\n          ptr = mmapAlloc(length)\n          if (!ptr) {\n            throw new FS.ErrnoError(48)\n          }\n          HEAP8.set(contents, ptr)\n        }\n        return {\n          ptr: ptr,\n          allocated: allocated\n        }\n      },\n      msync(stream, buffer, offset, length, mmapFlags) {\n        MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false)\n        return 0\n      }\n    }\n  }\n  var asyncLoad = (url, onload, onerror, noRunDep) => {\n    var dep = !noRunDep\n      ? getUniqueRunDependency(`al $ {\n\t\turl\n\t}`)\n      : ''\n    readAsync(\n      url,\n      (arrayBuffer) => {\n        assert(arrayBuffer, `Loading data file \"${url}\"failed(no arrayBuffer).`)\n        onload(new Uint8Array(arrayBuffer))\n        if (dep) removeRunDependency(dep)\n      },\n      (event) => {\n        if (onerror) {\n          onerror()\n        } else {\n          throw `Loading data file \"${url}\"failed.`\n        }\n      }\n    )\n    if (dep) addRunDependency(dep)\n  }\n  var preloadPlugins = Module['preloadPlugins'] || []\n  var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {\n    if (typeof Browser != 'undefined') Browser.init()\n    var handled = false\n    preloadPlugins.forEach((plugin) => {\n      if (handled) return\n      if (plugin['canHandle'](fullname)) {\n        plugin['handle'](byteArray, fullname, finish, onerror)\n        handled = true\n      }\n    })\n    return handled\n  }\n  var FS_createPreloadedFile = (\n    parent,\n    name,\n    url,\n    canRead,\n    canWrite,\n    onload,\n    onerror,\n    dontCreateFile,\n    canOwn,\n    preFinish\n  ) => {\n    var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent\n    var dep = getUniqueRunDependency(`cp $ {\n\t\tfullname\n\t}`)\n    function processData(byteArray) {\n      function finish(byteArray) {\n        if (preFinish) preFinish()\n        if (!dontCreateFile) {\n          FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn)\n        }\n        if (onload) onload()\n        removeRunDependency(dep)\n      }\n      if (\n        FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {\n          if (onerror) onerror()\n          removeRunDependency(dep)\n        })\n      ) {\n        return\n      }\n      finish(byteArray)\n    }\n    addRunDependency(dep)\n    if (typeof url == 'string') {\n      asyncLoad(url, (byteArray) => processData(byteArray), onerror)\n    } else {\n      processData(url)\n    }\n  }\n  var FS_modeStringToFlags = (str) => {\n    var flagModes = {\n      r: 0,\n      'r+': 2,\n      w: 512 | 64 | 1,\n      'w+': 512 | 64 | 2,\n      a: 1024 | 64 | 1,\n      'a+': 1024 | 64 | 2\n    }\n    var flags = flagModes[str]\n    if (typeof flags == 'undefined') {\n      throw new Error(`Unknown file open mode: $ {\n\t\t\tstr\n\t\t}`)\n    }\n    return flags\n  }\n  var FS_getMode = (canRead, canWrite) => {\n    var mode = 0\n    if (canRead) mode |= 292 | 73\n    if (canWrite) mode |= 146\n    return mode\n  }\n  var FS = {\n    root: null,\n    mounts: [],\n    devices: {},\n    streams: [],\n    nextInode: 1,\n    nameTable: null,\n    currentPath: '/',\n    initialized: false,\n    ignorePermissions: true,\n    ErrnoError: null,\n    genericErrors: {},\n    filesystems: null,\n    syncFSRequests: 0,\n    lookupPath(path, opts = {}) {\n      path = PATH_FS.resolve(path)\n      if (!path)\n        return {\n          path: '',\n          node: null\n        }\n      var defaults = {\n        follow_mount: true,\n        recurse_count: 0\n      }\n      opts = Object.assign(defaults, opts)\n      if (opts.recurse_count > 8) {\n        throw new FS.ErrnoError(32)\n      }\n      var parts = path.split('/').filter((p) => !!p)\n      var current = FS.root\n      var current_path = '/'\n      for (var i = 0; i < parts.length; i++) {\n        var islast = i === parts.length - 1\n        if (islast && opts.parent) {\n          break\n        }\n        current = FS.lookupNode(current, parts[i])\n        current_path = PATH.join2(current_path, parts[i])\n        if (FS.isMountpoint(current)) {\n          if (!islast || (islast && opts.follow_mount)) {\n            current = current.mounted.root\n          }\n        }\n        if (!islast || opts.follow) {\n          var count = 0\n          while (FS.isLink(current.mode)) {\n            var link = FS.readlink(current_path)\n            current_path = PATH_FS.resolve(PATH.dirname(current_path), link)\n            var lookup = FS.lookupPath(current_path, {\n              recurse_count: opts.recurse_count + 1\n            })\n            current = lookup.node\n            if (count++ > 40) {\n              throw new FS.ErrnoError(32)\n            }\n          }\n        }\n      }\n      return {\n        path: current_path,\n        node: current\n      }\n    },\n    getPath(node) {\n      var path\n      while (true) {\n        if (FS.isRoot(node)) {\n          var mount = node.mount.mountpoint\n          if (!path) return mount\n          return mount[mount.length - 1] !== '/'\n            ? `$ {\n\t\t\t\t\tmount\n\t\t\t\t}\n\t\t\t\t/${path}`\n            : mount + path\n        }\n        path = path\n          ? `${node.name}/$ {\n\t\t\t\t\tpath\n\t\t\t\t}`\n          : node.name\n        node = node.parent\n      }\n    },\n    hashName(parentid, name) {\n      var hash = 0\n      for (var i = 0; i < name.length; i++) {\n        hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0\n      }\n      return ((parentid + hash) >>> 0) % FS.nameTable.length\n    },\n    hashAddNode(node) {\n      var hash = FS.hashName(node.parent.id, node.name)\n      node.name_next = FS.nameTable[hash]\n      FS.nameTable[hash] = node\n    },\n    hashRemoveNode(node) {\n      var hash = FS.hashName(node.parent.id, node.name)\n      if (FS.nameTable[hash] === node) {\n        FS.nameTable[hash] = node.name_next\n      } else {\n        var current = FS.nameTable[hash]\n        while (current) {\n          if (current.name_next === node) {\n            current.name_next = node.name_next\n            break\n          }\n          current = current.name_next\n        }\n      }\n    },\n    lookupNode(parent, name) {\n      var errCode = FS.mayLookup(parent)\n      if (errCode) {\n        throw new FS.ErrnoError(errCode, parent)\n      }\n      var hash = FS.hashName(parent.id, name)\n      for (var node = FS.nameTable[hash]; node; node = node.name_next) {\n        var nodeName = node.name\n        if (node.parent.id === parent.id && nodeName === name) {\n          return node\n        }\n      }\n      return FS.lookup(parent, name)\n    },\n    createNode(parent, name, mode, rdev) {\n      var node = new FS.FSNode(parent, name, mode, rdev)\n      FS.hashAddNode(node)\n      return node\n    },\n    destroyNode(node) {\n      FS.hashRemoveNode(node)\n    },\n    isRoot(node) {\n      return node === node.parent\n    },\n    isMountpoint(node) {\n      return !!node.mounted\n    },\n    isFile(mode) {\n      return (mode & 61440) === 32768\n    },\n    isDir(mode) {\n      return (mode & 61440) === 16384\n    },\n    isLink(mode) {\n      return (mode & 61440) === 40960\n    },\n    isChrdev(mode) {\n      return (mode & 61440) === 8192\n    },\n    isBlkdev(mode) {\n      return (mode & 61440) === 24576\n    },\n    isFIFO(mode) {\n      return (mode & 61440) === 4096\n    },\n    isSocket(mode) {\n      return (mode & 49152) === 49152\n    },\n    flagsToPermissionString(flag) {\n      var perms = ['r', 'w', 'rw'][flag & 3]\n      if (flag & 512) {\n        perms += 'w'\n      }\n      return perms\n    },\n    nodePermissions(node, perms) {\n      if (FS.ignorePermissions) {\n        return 0\n      }\n      if (perms.includes('r') && !(node.mode & 292)) {\n        return 2\n      } else if (perms.includes('w') && !(node.mode & 146)) {\n        return 2\n      } else if (perms.includes('x') && !(node.mode & 73)) {\n        return 2\n      }\n      return 0\n    },\n    mayLookup(dir) {\n      var errCode = FS.nodePermissions(dir, 'x')\n      if (errCode) return errCode\n      if (!dir.node_ops.lookup) return 2\n      return 0\n    },\n    mayCreate(dir, name) {\n      try {\n        var node = FS.lookupNode(dir, name)\n        return 20\n      } catch (e) {}\n      return FS.nodePermissions(dir, 'wx')\n    },\n    mayDelete(dir, name, isdir) {\n      var node\n      try {\n        node = FS.lookupNode(dir, name)\n      } catch (e) {\n        return e.errno\n      }\n      var errCode = FS.nodePermissions(dir, 'wx')\n      if (errCode) {\n        return errCode\n      }\n      if (isdir) {\n        if (!FS.isDir(node.mode)) {\n          return 54\n        }\n        if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\n          return 10\n        }\n      } else {\n        if (FS.isDir(node.mode)) {\n          return 31\n        }\n      }\n      return 0\n    },\n    mayOpen(node, flags) {\n      if (!node) {\n        return 44\n      }\n      if (FS.isLink(node.mode)) {\n        return 32\n      } else if (FS.isDir(node.mode)) {\n        if (FS.flagsToPermissionString(flags) !== 'r' || flags & 512) {\n          return 31\n        }\n      }\n      return FS.nodePermissions(node, FS.flagsToPermissionString(flags))\n    },\n    MAX_OPEN_FDS: 4096,\n    nextfd() {\n      for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {\n        if (!FS.streams[fd]) {\n          return fd\n        }\n      }\n      throw new FS.ErrnoError(33)\n    },\n    getStreamChecked(fd) {\n      var stream = FS.getStream(fd)\n      if (!stream) {\n        throw new FS.ErrnoError(8)\n      }\n      return stream\n    },\n    getStream: (fd) => FS.streams[fd],\n    createStream(stream, fd = -1) {\n      if (!FS.FSStream) {\n        FS.FSStream = function () {\n          this.shared = {}\n        }\n        FS.FSStream.prototype = {}\n        Object.defineProperties(FS.FSStream.prototype, {\n          object: {\n            get() {\n              return this.node\n            },\n            set(val) {\n              this.node = val\n            }\n          },\n          isRead: {\n            get() {\n              return (this.flags & 2097155) !== 1\n            }\n          },\n          isWrite: {\n            get() {\n              return (this.flags & 2097155) !== 0\n            }\n          },\n          isAppend: {\n            get() {\n              return this.flags & 1024\n            }\n          },\n          flags: {\n            get() {\n              return this.shared.flags\n            },\n            set(val) {\n              this.shared.flags = val\n            }\n          },\n          position: {\n            get() {\n              return this.shared.position\n            },\n            set(val) {\n              this.shared.position = val\n            }\n          }\n        })\n      }\n      stream = Object.assign(new FS.FSStream(), stream)\n      if (fd == -1) {\n        fd = FS.nextfd()\n      }\n      stream.fd = fd\n      FS.streams[fd] = stream\n      return stream\n    },\n    closeStream(fd) {\n      FS.streams[fd] = null\n    },\n    chrdev_stream_ops: {\n      open(stream) {\n        var device = FS.getDevice(stream.node.rdev)\n        stream.stream_ops = device.stream_ops\n        if (stream.stream_ops.open) {\n          stream.stream_ops.open(stream)\n        }\n      },\n      llseek() {\n        throw new FS.ErrnoError(70)\n      }\n    },\n    major: (dev) => dev >> 8,\n    minor: (dev) => dev & 255,\n    makedev: (ma, mi) => (ma << 8) | mi,\n    registerDevice(dev, ops) {\n      FS.devices[dev] = {\n        stream_ops: ops\n      }\n    },\n    getDevice: (dev) => FS.devices[dev],\n    getMounts(mount) {\n      var mounts = []\n      var check = [mount]\n      while (check.length) {\n        var m = check.pop()\n        mounts.push(m)\n        check.push.apply(check, m.mounts)\n      }\n      return mounts\n    },\n    syncfs(populate, callback) {\n      if (typeof populate == 'function') {\n        callback = populate\n        populate = false\n      }\n      FS.syncFSRequests++\n      if (FS.syncFSRequests > 1) {\n        err(`warning: $ {\n\t\t\t\t\tFS.syncFSRequests\n\t\t\t\t}\n\t\t\t\tFS.syncfs operations in flight at once, probably just doing extra work`)\n      }\n      var mounts = FS.getMounts(FS.root.mount)\n      var completed = 0\n      function doCallback(errCode) {\n        FS.syncFSRequests--\n        return callback(errCode)\n      }\n      function done(errCode) {\n        if (errCode) {\n          if (!done.errored) {\n            done.errored = true\n            return doCallback(errCode)\n          }\n          return\n        }\n        if (++completed >= mounts.length) {\n          doCallback(null)\n        }\n      }\n      mounts.forEach((mount) => {\n        if (!mount.type.syncfs) {\n          return done(null)\n        }\n        mount.type.syncfs(mount, populate, done)\n      })\n    },\n    mount(type, opts, mountpoint) {\n      var root = mountpoint === '/'\n      var pseudo = !mountpoint\n      var node\n      if (root && FS.root) {\n        throw new FS.ErrnoError(10)\n      } else if (!root && !pseudo) {\n        var lookup = FS.lookupPath(mountpoint, {\n          follow_mount: false\n        })\n        mountpoint = lookup.path\n        node = lookup.node\n        if (FS.isMountpoint(node)) {\n          throw new FS.ErrnoError(10)\n        }\n        if (!FS.isDir(node.mode)) {\n          throw new FS.ErrnoError(54)\n        }\n      }\n      var mount = {\n        type: type,\n        opts: opts,\n        mountpoint: mountpoint,\n        mounts: []\n      }\n      var mountRoot = type.mount(mount)\n      mountRoot.mount = mount\n      mount.root = mountRoot\n      if (root) {\n        FS.root = mountRoot\n      } else if (node) {\n        node.mounted = mount\n        if (node.mount) {\n          node.mount.mounts.push(mount)\n        }\n      }\n      return mountRoot\n    },\n    unmount(mountpoint) {\n      var lookup = FS.lookupPath(mountpoint, {\n        follow_mount: false\n      })\n      if (!FS.isMountpoint(lookup.node)) {\n        throw new FS.ErrnoError(28)\n      }\n      var node = lookup.node\n      var mount = node.mounted\n      var mounts = FS.getMounts(mount)\n      Object.keys(FS.nameTable).forEach((hash) => {\n        var current = FS.nameTable[hash]\n        while (current) {\n          var next = current.name_next\n          if (mounts.includes(current.mount)) {\n            FS.destroyNode(current)\n          }\n          current = next\n        }\n      })\n      node.mounted = null\n      var idx = node.mount.mounts.indexOf(mount)\n      node.mount.mounts.splice(idx, 1)\n    },\n    lookup(parent, name) {\n      return parent.node_ops.lookup(parent, name)\n    },\n    mknod(path, mode, dev) {\n      var lookup = FS.lookupPath(path, {\n        parent: true\n      })\n      var parent = lookup.node\n      var name = PATH.basename(path)\n      if (!name || name === '.' || name === '..') {\n        throw new FS.ErrnoError(28)\n      }\n      var errCode = FS.mayCreate(parent, name)\n      if (errCode) {\n        throw new FS.ErrnoError(errCode)\n      }\n      if (!parent.node_ops.mknod) {\n        throw new FS.ErrnoError(63)\n      }\n      return parent.node_ops.mknod(parent, name, mode, dev)\n    },\n    create(path, mode) {\n      mode = mode !== undefined ? mode : 438\n      mode &= 4095\n      mode |= 32768\n      return FS.mknod(path, mode, 0)\n    },\n    mkdir(path, mode) {\n      mode = mode !== undefined ? mode : 511\n      mode &= 511 | 512\n      mode |= 16384\n      return FS.mknod(path, mode, 0)\n    },\n    mkdirTree(path, mode) {\n      var dirs = path.split('/')\n      var d = ''\n      for (var i = 0; i < dirs.length; ++i) {\n        if (!dirs[i]) continue\n        d += '/' + dirs[i]\n        try {\n          FS.mkdir(d, mode)\n        } catch (e) {\n          if (e.errno != 20) throw e\n        }\n      }\n    },\n    mkdev(path, mode, dev) {\n      if (typeof dev == 'undefined') {\n        dev = mode\n        mode = 438\n      }\n      mode |= 8192\n      return FS.mknod(path, mode, dev)\n    },\n    symlink(oldpath, newpath) {\n      if (!PATH_FS.resolve(oldpath)) {\n        throw new FS.ErrnoError(44)\n      }\n      var lookup = FS.lookupPath(newpath, {\n        parent: true\n      })\n      var parent = lookup.node\n      if (!parent) {\n        throw new FS.ErrnoError(44)\n      }\n      var newname = PATH.basename(newpath)\n      var errCode = FS.mayCreate(parent, newname)\n      if (errCode) {\n        throw new FS.ErrnoError(errCode)\n      }\n      if (!parent.node_ops.symlink) {\n        throw new FS.ErrnoError(63)\n      }\n      return parent.node_ops.symlink(parent, newname, oldpath)\n    },\n    rename(old_path, new_path) {\n      var old_dirname = PATH.dirname(old_path)\n      var new_dirname = PATH.dirname(new_path)\n      var old_name = PATH.basename(old_path)\n      var new_name = PATH.basename(new_path)\n      var lookup, old_dir, new_dir\n      lookup = FS.lookupPath(old_path, {\n        parent: true\n      })\n      old_dir = lookup.node\n      lookup = FS.lookupPath(new_path, {\n        parent: true\n      })\n      new_dir = lookup.node\n      if (!old_dir || !new_dir) throw new FS.ErrnoError(44)\n      if (old_dir.mount !== new_dir.mount) {\n        throw new FS.ErrnoError(75)\n      }\n      var old_node = FS.lookupNode(old_dir, old_name)\n      var relative = PATH_FS.relative(old_path, new_dirname)\n      if (relative.charAt(0) !== '.') {\n        throw new FS.ErrnoError(28)\n      }\n      relative = PATH_FS.relative(new_path, old_dirname)\n      if (relative.charAt(0) !== '.') {\n        throw new FS.ErrnoError(55)\n      }\n      var new_node\n      try {\n        new_node = FS.lookupNode(new_dir, new_name)\n      } catch (e) {}\n      if (old_node === new_node) {\n        return\n      }\n      var isdir = FS.isDir(old_node.mode)\n      var errCode = FS.mayDelete(old_dir, old_name, isdir)\n      if (errCode) {\n        throw new FS.ErrnoError(errCode)\n      }\n      errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name)\n      if (errCode) {\n        throw new FS.ErrnoError(errCode)\n      }\n      if (!old_dir.node_ops.rename) {\n        throw new FS.ErrnoError(63)\n      }\n      if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {\n        throw new FS.ErrnoError(10)\n      }\n      if (new_dir !== old_dir) {\n        errCode = FS.nodePermissions(old_dir, 'w')\n        if (errCode) {\n          throw new FS.ErrnoError(errCode)\n        }\n      }\n      FS.hashRemoveNode(old_node)\n      try {\n        old_dir.node_ops.rename(old_node, new_dir, new_name)\n      } catch (e) {\n        throw e\n      } finally {\n        FS.hashAddNode(old_node)\n      }\n    },\n    rmdir(path) {\n      var lookup = FS.lookupPath(path, {\n        parent: true\n      })\n      var parent = lookup.node\n      var name = PATH.basename(path)\n      var node = FS.lookupNode(parent, name)\n      var errCode = FS.mayDelete(parent, name, true)\n      if (errCode) {\n        throw new FS.ErrnoError(errCode)\n      }\n      if (!parent.node_ops.rmdir) {\n        throw new FS.ErrnoError(63)\n      }\n      if (FS.isMountpoint(node)) {\n        throw new FS.ErrnoError(10)\n      }\n      parent.node_ops.rmdir(parent, name)\n      FS.destroyNode(node)\n    },\n    readdir(path) {\n      var lookup = FS.lookupPath(path, {\n        follow: true\n      })\n      var node = lookup.node\n      if (!node.node_ops.readdir) {\n        throw new FS.ErrnoError(54)\n      }\n      return node.node_ops.readdir(node)\n    },\n    unlink(path) {\n      var lookup = FS.lookupPath(path, {\n        parent: true\n      })\n      var parent = lookup.node\n      if (!parent) {\n        throw new FS.ErrnoError(44)\n      }\n      var name = PATH.basename(path)\n      var node = FS.lookupNode(parent, name)\n      var errCode = FS.mayDelete(parent, name, false)\n      if (errCode) {\n        throw new FS.ErrnoError(errCode)\n      }\n      if (!parent.node_ops.unlink) {\n        throw new FS.ErrnoError(63)\n      }\n      if (FS.isMountpoint(node)) {\n        throw new FS.ErrnoError(10)\n      }\n      parent.node_ops.unlink(parent, name)\n      FS.destroyNode(node)\n    },\n    readlink(path) {\n      var lookup = FS.lookupPath(path)\n      var link = lookup.node\n      if (!link) {\n        throw new FS.ErrnoError(44)\n      }\n      if (!link.node_ops.readlink) {\n        throw new FS.ErrnoError(28)\n      }\n      return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link))\n    },\n    stat(path, dontFollow) {\n      var lookup = FS.lookupPath(path, {\n        follow: !dontFollow\n      })\n      var node = lookup.node\n      if (!node) {\n        throw new FS.ErrnoError(44)\n      }\n      if (!node.node_ops.getattr) {\n        throw new FS.ErrnoError(63)\n      }\n      return node.node_ops.getattr(node)\n    },\n    lstat(path) {\n      return FS.stat(path, true)\n    },\n    chmod(path, mode, dontFollow) {\n      var node\n      if (typeof path == 'string') {\n        var lookup = FS.lookupPath(path, {\n          follow: !dontFollow\n        })\n        node = lookup.node\n      } else {\n        node = path\n      }\n      if (!node.node_ops.setattr) {\n        throw new FS.ErrnoError(63)\n      }\n      node.node_ops.setattr(node, {\n        mode: (mode & 4095) | (node.mode & ~4095),\n        timestamp: Date.now()\n      })\n    },\n    lchmod(path, mode) {\n      FS.chmod(path, mode, true)\n    },\n    fchmod(fd, mode) {\n      var stream = FS.getStreamChecked(fd)\n      FS.chmod(stream.node, mode)\n    },\n    chown(path, uid, gid, dontFollow) {\n      var node\n      if (typeof path == 'string') {\n        var lookup = FS.lookupPath(path, {\n          follow: !dontFollow\n        })\n        node = lookup.node\n      } else {\n        node = path\n      }\n      if (!node.node_ops.setattr) {\n        throw new FS.ErrnoError(63)\n      }\n      node.node_ops.setattr(node, {\n        timestamp: Date.now()\n      })\n    },\n    lchown(path, uid, gid) {\n      FS.chown(path, uid, gid, true)\n    },\n    fchown(fd, uid, gid) {\n      var stream = FS.getStreamChecked(fd)\n      FS.chown(stream.node, uid, gid)\n    },\n    truncate(path, len) {\n      if (len < 0) {\n        throw new FS.ErrnoError(28)\n      }\n      var node\n      if (typeof path == 'string') {\n        var lookup = FS.lookupPath(path, {\n          follow: true\n        })\n        node = lookup.node\n      } else {\n        node = path\n      }\n      if (!node.node_ops.setattr) {\n        throw new FS.ErrnoError(63)\n      }\n      if (FS.isDir(node.mode)) {\n        throw new FS.ErrnoError(31)\n      }\n      if (!FS.isFile(node.mode)) {\n        throw new FS.ErrnoError(28)\n      }\n      var errCode = FS.nodePermissions(node, 'w')\n      if (errCode) {\n        throw new FS.ErrnoError(errCode)\n      }\n      node.node_ops.setattr(node, {\n        size: len,\n        timestamp: Date.now()\n      })\n    },\n    ftruncate(fd, len) {\n      var stream = FS.getStreamChecked(fd)\n      if ((stream.flags & 2097155) === 0) {\n        throw new FS.ErrnoError(28)\n      }\n      FS.truncate(stream.node, len)\n    },\n    utime(path, atime, mtime) {\n      var lookup = FS.lookupPath(path, {\n        follow: true\n      })\n      var node = lookup.node\n      node.node_ops.setattr(node, {\n        timestamp: Math.max(atime, mtime)\n      })\n    },\n    open(path, flags, mode) {\n      if (path === '') {\n        throw new FS.ErrnoError(44)\n      }\n      flags = typeof flags == 'string' ? FS_modeStringToFlags(flags) : flags\n      mode = typeof mode == 'undefined' ? 438 : mode\n      if (flags & 64) {\n        mode = (mode & 4095) | 32768\n      } else {\n        mode = 0\n      }\n      var node\n      if (typeof path == 'object') {\n        node = path\n      } else {\n        path = PATH.normalize(path)\n        try {\n          var lookup = FS.lookupPath(path, {\n            follow: !(flags & 131072)\n          })\n          node = lookup.node\n        } catch (e) {}\n      }\n      var created = false\n      if (flags & 64) {\n        if (node) {\n          if (flags & 128) {\n            throw new FS.ErrnoError(20)\n          }\n        } else {\n          node = FS.mknod(path, mode, 0)\n          created = true\n        }\n      }\n      if (!node) {\n        throw new FS.ErrnoError(44)\n      }\n      if (FS.isChrdev(node.mode)) {\n        flags &= ~512\n      }\n      if (flags & 65536 && !FS.isDir(node.mode)) {\n        throw new FS.ErrnoError(54)\n      }\n      if (!created) {\n        var errCode = FS.mayOpen(node, flags)\n        if (errCode) {\n          throw new FS.ErrnoError(errCode)\n        }\n      }\n      if (flags & 512 && !created) {\n        FS.truncate(node, 0)\n      }\n      flags &= ~(128 | 512 | 131072)\n      var stream = FS.createStream({\n        node: node,\n        path: FS.getPath(node),\n        flags: flags,\n        seekable: true,\n        position: 0,\n        stream_ops: node.stream_ops,\n        ungotten: [],\n        error: false\n      })\n      if (stream.stream_ops.open) {\n        stream.stream_ops.open(stream)\n      }\n      if (Module['logReadFiles'] && !(flags & 1)) {\n        if (!FS.readFiles) FS.readFiles = {}\n        if (!(path in FS.readFiles)) {\n          FS.readFiles[path] = 1\n        }\n      }\n      return stream\n    },\n    close(stream) {\n      if (FS.isClosed(stream)) {\n        throw new FS.ErrnoError(8)\n      }\n      if (stream.getdents) stream.getdents = null\n      try {\n        if (stream.stream_ops.close) {\n          stream.stream_ops.close(stream)\n        }\n      } catch (e) {\n        throw e\n      } finally {\n        FS.closeStream(stream.fd)\n      }\n      stream.fd = null\n    },\n    isClosed(stream) {\n      return stream.fd === null\n    },\n    llseek(stream, offset, whence) {\n      if (FS.isClosed(stream)) {\n        throw new FS.ErrnoError(8)\n      }\n      if (!stream.seekable || !stream.stream_ops.llseek) {\n        throw new FS.ErrnoError(70)\n      }\n      if (whence != 0 && whence != 1 && whence != 2) {\n        throw new FS.ErrnoError(28)\n      }\n      stream.position = stream.stream_ops.llseek(stream, offset, whence)\n      stream.ungotten = []\n      return stream.position\n    },\n    read(stream, buffer, offset, length, position) {\n      if (length < 0 || position < 0) {\n        throw new FS.ErrnoError(28)\n      }\n      if (FS.isClosed(stream)) {\n        throw new FS.ErrnoError(8)\n      }\n      if ((stream.flags & 2097155) === 1) {\n        throw new FS.ErrnoError(8)\n      }\n      if (FS.isDir(stream.node.mode)) {\n        throw new FS.ErrnoError(31)\n      }\n      if (!stream.stream_ops.read) {\n        throw new FS.ErrnoError(28)\n      }\n      var seeking = typeof position != 'undefined'\n      if (!seeking) {\n        position = stream.position\n      } else if (!stream.seekable) {\n        throw new FS.ErrnoError(70)\n      }\n      var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position)\n      if (!seeking) stream.position += bytesRead\n      return bytesRead\n    },\n    write(stream, buffer, offset, length, position, canOwn) {\n      if (length < 0 || position < 0) {\n        throw new FS.ErrnoError(28)\n      }\n      if (FS.isClosed(stream)) {\n        throw new FS.ErrnoError(8)\n      }\n      if ((stream.flags & 2097155) === 0) {\n        throw new FS.ErrnoError(8)\n      }\n      if (FS.isDir(stream.node.mode)) {\n        throw new FS.ErrnoError(31)\n      }\n      if (!stream.stream_ops.write) {\n        throw new FS.ErrnoError(28)\n      }\n      if (stream.seekable && stream.flags & 1024) {\n        FS.llseek(stream, 0, 2)\n      }\n      var seeking = typeof position != 'undefined'\n      if (!seeking) {\n        position = stream.position\n      } else if (!stream.seekable) {\n        throw new FS.ErrnoError(70)\n      }\n      var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn)\n      if (!seeking) stream.position += bytesWritten\n      return bytesWritten\n    },\n    allocate(stream, offset, length) {\n      if (FS.isClosed(stream)) {\n        throw new FS.ErrnoError(8)\n      }\n      if (offset < 0 || length <= 0) {\n        throw new FS.ErrnoError(28)\n      }\n      if ((stream.flags & 2097155) === 0) {\n        throw new FS.ErrnoError(8)\n      }\n      if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {\n        throw new FS.ErrnoError(43)\n      }\n      if (!stream.stream_ops.allocate) {\n        throw new FS.ErrnoError(138)\n      }\n      stream.stream_ops.allocate(stream, offset, length)\n    },\n    mmap(stream, length, position, prot, flags) {\n      if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {\n        throw new FS.ErrnoError(2)\n      }\n      if ((stream.flags & 2097155) === 1) {\n        throw new FS.ErrnoError(2)\n      }\n      if (!stream.stream_ops.mmap) {\n        throw new FS.ErrnoError(43)\n      }\n      return stream.stream_ops.mmap(stream, length, position, prot, flags)\n    },\n    msync(stream, buffer, offset, length, mmapFlags) {\n      if (!stream.stream_ops.msync) {\n        return 0\n      }\n      return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags)\n    },\n    munmap: (stream) => 0,\n    ioctl(stream, cmd, arg) {\n      if (!stream.stream_ops.ioctl) {\n        throw new FS.ErrnoError(59)\n      }\n      return stream.stream_ops.ioctl(stream, cmd, arg)\n    },\n    readFile(path, opts = {}) {\n      opts.flags = opts.flags || 0\n      opts.encoding = opts.encoding || 'binary'\n      if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {\n        throw new Error(`Invalid encoding type \"${opts.encoding}\"`)\n      }\n      var ret\n      var stream = FS.open(path, opts.flags)\n      var stat = FS.stat(path)\n      var length = stat.size\n      var buf = new Uint8Array(length)\n      FS.read(stream, buf, 0, length, 0)\n      if (opts.encoding === 'utf8') {\n        ret = UTF8ArrayToString(buf, 0)\n      } else if (opts.encoding === 'binary') {\n        ret = buf\n      }\n      FS.close(stream)\n      return ret\n    },\n    writeFile(path, data, opts = {}) {\n      opts.flags = opts.flags || 577\n      var stream = FS.open(path, opts.flags, opts.mode)\n      if (typeof data == 'string') {\n        var buf = new Uint8Array(lengthBytesUTF8(data) + 1)\n        var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length)\n        FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn)\n      } else if (ArrayBuffer.isView(data)) {\n        FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn)\n      } else {\n        throw new Error('Unsupported data type')\n      }\n      FS.close(stream)\n    },\n    cwd: () => FS.currentPath,\n    chdir(path) {\n      var lookup = FS.lookupPath(path, {\n        follow: true\n      })\n      if (lookup.node === null) {\n        throw new FS.ErrnoError(44)\n      }\n      if (!FS.isDir(lookup.node.mode)) {\n        throw new FS.ErrnoError(54)\n      }\n      var errCode = FS.nodePermissions(lookup.node, 'x')\n      if (errCode) {\n        throw new FS.ErrnoError(errCode)\n      }\n      FS.currentPath = lookup.path\n    },\n    createDefaultDirectories() {\n      FS.mkdir('/tmp')\n      FS.mkdir('/home')\n      FS.mkdir('/home/web_user')\n    },\n    createDefaultDevices() {\n      FS.mkdir('/dev')\n      FS.registerDevice(FS.makedev(1, 3), {\n        read: () => 0,\n        write: (stream, buffer, offset, length, pos) => length\n      })\n      FS.mkdev('/dev/null', FS.makedev(1, 3))\n      TTY.register(FS.makedev(5, 0), TTY.default_tty_ops)\n      TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops)\n      FS.mkdev('/dev/tty', FS.makedev(5, 0))\n      FS.mkdev('/dev/tty1', FS.makedev(6, 0))\n      var randomBuffer = new Uint8Array(1024),\n        randomLeft = 0\n      var randomByte = () => {\n        if (randomLeft === 0) {\n          randomLeft = randomFill(randomBuffer).byteLength\n        }\n        return randomBuffer[--randomLeft]\n      }\n      FS.createDevice('/dev', 'random', randomByte)\n      FS.createDevice('/dev', 'urandom', randomByte)\n      FS.mkdir('/dev/shm')\n      FS.mkdir('/dev/shm/tmp')\n    },\n    createSpecialDirectories() {\n      FS.mkdir('/proc')\n      var proc_self = FS.mkdir('/proc/self')\n      FS.mkdir('/proc/self/fd')\n      FS.mount(\n        {\n          mount() {\n            var node = FS.createNode(proc_self, 'fd', 16384 | 511, 73)\n            node.node_ops = {\n              lookup(parent, name) {\n                var fd = +name\n                var stream = FS.getStreamChecked(fd)\n                var ret = {\n                  parent: null,\n                  mount: {\n                    mountpoint: 'fake'\n                  },\n                  node_ops: {\n                    readlink: () => stream.path\n                  }\n                }\n                ret.parent = ret\n                return ret\n              }\n            }\n            return node\n          }\n        },\n        {},\n        '/proc/self/fd'\n      )\n    },\n    createStandardStreams() {\n      if (Module['stdin']) {\n        FS.createDevice('/dev', 'stdin', Module['stdin'])\n      } else {\n        FS.symlink('/dev/tty', '/dev/stdin')\n      }\n      if (Module['stdout']) {\n        FS.createDevice('/dev', 'stdout', null, Module['stdout'])\n      } else {\n        FS.symlink('/dev/tty', '/dev/stdout')\n      }\n      if (Module['stderr']) {\n        FS.createDevice('/dev', 'stderr', null, Module['stderr'])\n      } else {\n        FS.symlink('/dev/tty1', '/dev/stderr')\n      }\n      var stdin = FS.open('/dev/stdin', 0)\n      var stdout = FS.open('/dev/stdout', 1)\n      var stderr = FS.open('/dev/stderr', 1)\n    },\n    ensureErrnoError() {\n      if (FS.ErrnoError) return\n      FS.ErrnoError = function ErrnoError(errno, node) {\n        this.name = 'ErrnoError'\n        this.node = node\n        this.setErrno = function (errno) {\n          this.errno = errno\n        }\n        this.setErrno(errno)\n        this.message = 'FS error'\n      }\n      FS.ErrnoError.prototype = new Error()\n      FS.ErrnoError.prototype.constructor = FS.ErrnoError\n      ;[44].forEach((code) => {\n        FS.genericErrors[code] = new FS.ErrnoError(code)\n        FS.genericErrors[code].stack = '<generic error, no stack>'\n      })\n    },\n    staticInit() {\n      FS.ensureErrnoError()\n      FS.nameTable = new Array(4096)\n      FS.mount(MEMFS, {}, '/')\n      FS.createDefaultDirectories()\n      FS.createDefaultDevices()\n      FS.createSpecialDirectories()\n      FS.filesystems = {\n        MEMFS: MEMFS\n      }\n    },\n    init(input, output, error) {\n      FS.init.initialized = true\n      FS.ensureErrnoError()\n      Module['stdin'] = input || Module['stdin']\n      Module['stdout'] = output || Module['stdout']\n      Module['stderr'] = error || Module['stderr']\n      FS.createStandardStreams()\n    },\n    quit() {\n      FS.init.initialized = false\n      for (var i = 0; i < FS.streams.length; i++) {\n        var stream = FS.streams[i]\n        if (!stream) {\n          continue\n        }\n        FS.close(stream)\n      }\n    },\n    findObject(path, dontResolveLastLink) {\n      var ret = FS.analyzePath(path, dontResolveLastLink)\n      if (!ret.exists) {\n        return null\n      }\n      return ret.object\n    },\n    analyzePath(path, dontResolveLastLink) {\n      try {\n        var lookup = FS.lookupPath(path, {\n          follow: !dontResolveLastLink\n        })\n        path = lookup.path\n      } catch (e) {}\n      var ret = {\n        isRoot: false,\n        exists: false,\n        error: 0,\n        name: null,\n        path: null,\n        object: null,\n        parentExists: false,\n        parentPath: null,\n        parentObject: null\n      }\n      try {\n        var lookup = FS.lookupPath(path, {\n          parent: true\n        })\n        ret.parentExists = true\n        ret.parentPath = lookup.path\n        ret.parentObject = lookup.node\n        ret.name = PATH.basename(path)\n        lookup = FS.lookupPath(path, {\n          follow: !dontResolveLastLink\n        })\n        ret.exists = true\n        ret.path = lookup.path\n        ret.object = lookup.node\n        ret.name = lookup.node.name\n        ret.isRoot = lookup.path === '/'\n      } catch (e) {\n        ret.error = e.errno\n      }\n      return ret\n    },\n    createPath(parent, path, canRead, canWrite) {\n      parent = typeof parent == 'string' ? parent : FS.getPath(parent)\n      var parts = path.split('/').reverse()\n      while (parts.length) {\n        var part = parts.pop()\n        if (!part) continue\n        var current = PATH.join2(parent, part)\n        try {\n          FS.mkdir(current)\n        } catch (e) {}\n        parent = current\n      }\n      return current\n    },\n    createFile(parent, name, properties, canRead, canWrite) {\n      var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name)\n      var mode = FS_getMode(canRead, canWrite)\n      return FS.create(path, mode)\n    },\n    createDataFile(parent, name, data, canRead, canWrite, canOwn) {\n      var path = name\n      if (parent) {\n        parent = typeof parent == 'string' ? parent : FS.getPath(parent)\n        path = name ? PATH.join2(parent, name) : parent\n      }\n      var mode = FS_getMode(canRead, canWrite)\n      var node = FS.create(path, mode)\n      if (data) {\n        if (typeof data == 'string') {\n          var arr = new Array(data.length)\n          for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i)\n          data = arr\n        }\n        FS.chmod(node, mode | 146)\n        var stream = FS.open(node, 577)\n        FS.write(stream, data, 0, data.length, 0, canOwn)\n        FS.close(stream)\n        FS.chmod(node, mode)\n      }\n      return node\n    },\n    createDevice(parent, name, input, output) {\n      var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name)\n      var mode = FS_getMode(!!input, !!output)\n      if (!FS.createDevice.major) FS.createDevice.major = 64\n      var dev = FS.makedev(FS.createDevice.major++, 0)\n      FS.registerDevice(dev, {\n        open(stream) {\n          stream.seekable = false\n        },\n        close(stream) {\n          if (output && output.buffer && output.buffer.length) {\n            output(10)\n          }\n        },\n        read(stream, buffer, offset, length, pos) {\n          var bytesRead = 0\n          for (var i = 0; i < length; i++) {\n            var result\n            try {\n              result = input()\n            } catch (e) {\n              throw new FS.ErrnoError(29)\n            }\n            if (result === undefined && bytesRead === 0) {\n              throw new FS.ErrnoError(6)\n            }\n            if (result === null || result === undefined) break\n            bytesRead++\n            buffer[offset + i] = result\n          }\n          if (bytesRead) {\n            stream.node.timestamp = Date.now()\n          }\n          return bytesRead\n        },\n        write(stream, buffer, offset, length, pos) {\n          for (var i = 0; i < length; i++) {\n            try {\n              output(buffer[offset + i])\n            } catch (e) {\n              throw new FS.ErrnoError(29)\n            }\n          }\n          if (length) {\n            stream.node.timestamp = Date.now()\n          }\n          return i\n        }\n      })\n      return FS.mkdev(path, mode, dev)\n    },\n    forceLoadFile(obj) {\n      if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true\n      if (typeof XMLHttpRequest != 'undefined') {\n        throw new Error(\n          'Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.'\n        )\n      } else if (read_) {\n        try {\n          obj.contents = intArrayFromString(read_(obj.url), true)\n          obj.usedBytes = obj.contents.length\n        } catch (e) {\n          throw new FS.ErrnoError(29)\n        }\n      } else {\n        throw new Error('Cannot load without read() or XMLHttpRequest.')\n      }\n    },\n    createLazyFile(parent, name, url, canRead, canWrite) {\n      function LazyUint8Array() {\n        this.lengthKnown = false\n        this.chunks = []\n      }\n      LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {\n        if (idx > this.length - 1 || idx < 0) {\n          return undefined\n        }\n        var chunkOffset = idx % this.chunkSize\n        var chunkNum = (idx / this.chunkSize) | 0\n        return this.getter(chunkNum)[chunkOffset]\n      }\n      LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {\n        this.getter = getter\n      }\n      LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {\n        var xhr = new XMLHttpRequest()\n        xhr.open('HEAD', url, false)\n        xhr.send(null)\n        if (!((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304))\n          throw new Error(\"Couldn't load \" + url + '. Status: ' + xhr.status)\n        var datalength = Number(xhr.getResponseHeader('Content-length'))\n        var header\n        var hasByteServing = (header = xhr.getResponseHeader('Accept-Ranges')) && header === 'bytes'\n        var usesGzip = (header = xhr.getResponseHeader('Content-Encoding')) && header === 'gzip'\n        var chunkSize = 1024 * 1024\n        if (!hasByteServing) chunkSize = datalength\n        var doXHR = (from, to) => {\n          if (from > to)\n            throw new Error('invalid range (' + from + ', ' + to + ') or no bytes requested!')\n          if (to > datalength - 1)\n            throw new Error('only ' + datalength + ' bytes available! programmer error!')\n          var xhr = new XMLHttpRequest()\n          xhr.open('GET', url, false)\n          if (datalength !== chunkSize) xhr.setRequestHeader('Range', 'bytes=' + from + '-' + to)\n          xhr.responseType = 'arraybuffer'\n          if (xhr.overrideMimeType) {\n            xhr.overrideMimeType('text/plain; charset=x-user-defined')\n          }\n          xhr.send(null)\n          if (!((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304))\n            throw new Error(\"Couldn't load \" + url + '. Status: ' + xhr.status)\n          if (xhr.response !== undefined) {\n            return new Uint8Array(xhr.response || [])\n          }\n          return intArrayFromString(xhr.responseText || '', true)\n        }\n        var lazyArray = this\n        lazyArray.setDataGetter((chunkNum) => {\n          var start = chunkNum * chunkSize\n          var end = (chunkNum + 1) * chunkSize - 1\n          end = Math.min(end, datalength - 1)\n          if (typeof lazyArray.chunks[chunkNum] == 'undefined') {\n            lazyArray.chunks[chunkNum] = doXHR(start, end)\n          }\n          if (typeof lazyArray.chunks[chunkNum] == 'undefined') throw new Error('doXHR failed!')\n          return lazyArray.chunks[chunkNum]\n        })\n        if (usesGzip || !datalength) {\n          chunkSize = datalength = 1\n          datalength = this.getter(0).length\n          chunkSize = datalength\n          out('LazyFiles on gzip forces download of the whole file when length is accessed')\n        }\n        this._length = datalength\n        this._chunkSize = chunkSize\n        this.lengthKnown = true\n      }\n      if (typeof XMLHttpRequest != 'undefined') {\n        if (!ENVIRONMENT_IS_WORKER)\n          throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc'\n        var lazyArray = new LazyUint8Array()\n        Object.defineProperties(lazyArray, {\n          length: {\n            get: function () {\n              if (!this.lengthKnown) {\n                this.cacheLength()\n              }\n              return this._length\n            }\n          },\n          chunkSize: {\n            get: function () {\n              if (!this.lengthKnown) {\n                this.cacheLength()\n              }\n              return this._chunkSize\n            }\n          }\n        })\n        var properties = {\n          isDevice: false,\n          contents: lazyArray\n        }\n      } else {\n        var properties = {\n          isDevice: false,\n          url: url\n        }\n      }\n      var node = FS.createFile(parent, name, properties, canRead, canWrite)\n      if (properties.contents) {\n        node.contents = properties.contents\n      } else if (properties.url) {\n        node.contents = null\n        node.url = properties.url\n      }\n      Object.defineProperties(node, {\n        usedBytes: {\n          get: function () {\n            return this.contents.length\n          }\n        }\n      })\n      var stream_ops = {}\n      var keys = Object.keys(node.stream_ops)\n      keys.forEach((key) => {\n        var fn = node.stream_ops[key]\n        stream_ops[key] = function forceLoadLazyFile() {\n          FS.forceLoadFile(node)\n          return fn.apply(null, arguments)\n        }\n      })\n      function writeChunks(stream, buffer, offset, length, position) {\n        var contents = stream.node.contents\n        if (position >= contents.length) return 0\n        var size = Math.min(contents.length - position, length)\n        if (contents.slice) {\n          for (var i = 0; i < size; i++) {\n            buffer[offset + i] = contents[position + i]\n          }\n        } else {\n          for (var i = 0; i < size; i++) {\n            buffer[offset + i] = contents.get(position + i)\n          }\n        }\n        return size\n      }\n      stream_ops.read = (stream, buffer, offset, length, position) => {\n        FS.forceLoadFile(node)\n        return writeChunks(stream, buffer, offset, length, position)\n      }\n      stream_ops.mmap = (stream, length, position, prot, flags) => {\n        FS.forceLoadFile(node)\n        var ptr = mmapAlloc(length)\n        if (!ptr) {\n          throw new FS.ErrnoError(48)\n        }\n        writeChunks(stream, HEAP8, ptr, length, position)\n        return {\n          ptr: ptr,\n          allocated: true\n        }\n      }\n      node.stream_ops = stream_ops\n      return node\n    }\n  }\n  var UTF8ToString = (ptr, maxBytesToRead) =>\n    ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : ''\n  var SYSCALLS = {\n    DEFAULT_POLLMASK: 5,\n    calculateAt(dirfd, path, allowEmpty) {\n      if (PATH.isAbs(path)) {\n        return path\n      }\n      var dir\n      if (dirfd === -100) {\n        dir = FS.cwd()\n      } else {\n        var dirstream = SYSCALLS.getStreamFromFD(dirfd)\n        dir = dirstream.path\n      }\n      if (path.length == 0) {\n        if (!allowEmpty) {\n          throw new FS.ErrnoError(44)\n        }\n        return dir\n      }\n      return PATH.join2(dir, path)\n    },\n    doStat(func, path, buf) {\n      try {\n        var stat = func(path)\n      } catch (e) {\n        if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {\n          return -54\n        }\n        throw e\n      }\n      HEAP32[buf >> 2] = stat.dev\n      HEAP32[(buf + 4) >> 2] = stat.mode\n      HEAPU32[(buf + 8) >> 2] = stat.nlink\n      HEAP32[(buf + 12) >> 2] = stat.uid\n      HEAP32[(buf + 16) >> 2] = stat.gid\n      HEAP32[(buf + 20) >> 2] = stat.rdev\n      ;(tempI64 = [\n        stat.size >>> 0,\n        ((tempDouble = stat.size),\n        +Math.abs(tempDouble) >= 1\n          ? tempDouble > 0\n            ? +Math.floor(tempDouble / 4294967296) >>> 0\n            : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0\n          : 0)\n      ]),\n        (HEAP32[(buf + 24) >> 2] = tempI64[0]),\n        (HEAP32[(buf + 28) >> 2] = tempI64[1])\n      HEAP32[(buf + 32) >> 2] = 4096\n      HEAP32[(buf + 36) >> 2] = stat.blocks\n      var atime = stat.atime.getTime()\n      var mtime = stat.mtime.getTime()\n      var ctime = stat.ctime.getTime()\n      ;(tempI64 = [\n        Math.floor(atime / 1e3) >>> 0,\n        ((tempDouble = Math.floor(atime / 1e3)),\n        +Math.abs(tempDouble) >= 1\n          ? tempDouble > 0\n            ? +Math.floor(tempDouble / 4294967296) >>> 0\n            : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0\n          : 0)\n      ]),\n        (HEAP32[(buf + 40) >> 2] = tempI64[0]),\n        (HEAP32[(buf + 44) >> 2] = tempI64[1])\n      HEAPU32[(buf + 48) >> 2] = (atime % 1e3) * 1e3\n      ;(tempI64 = [\n        Math.floor(mtime / 1e3) >>> 0,\n        ((tempDouble = Math.floor(mtime / 1e3)),\n        +Math.abs(tempDouble) >= 1\n          ? tempDouble > 0\n            ? +Math.floor(tempDouble / 4294967296) >>> 0\n            : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0\n          : 0)\n      ]),\n        (HEAP32[(buf + 56) >> 2] = tempI64[0]),\n        (HEAP32[(buf + 60) >> 2] = tempI64[1])\n      HEAPU32[(buf + 64) >> 2] = (mtime % 1e3) * 1e3\n      ;(tempI64 = [\n        Math.floor(ctime / 1e3) >>> 0,\n        ((tempDouble = Math.floor(ctime / 1e3)),\n        +Math.abs(tempDouble) >= 1\n          ? tempDouble > 0\n            ? +Math.floor(tempDouble / 4294967296) >>> 0\n            : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0\n          : 0)\n      ]),\n        (HEAP32[(buf + 72) >> 2] = tempI64[0]),\n        (HEAP32[(buf + 76) >> 2] = tempI64[1])\n      HEAPU32[(buf + 80) >> 2] = (ctime % 1e3) * 1e3\n      ;(tempI64 = [\n        stat.ino >>> 0,\n        ((tempDouble = stat.ino),\n        +Math.abs(tempDouble) >= 1\n          ? tempDouble > 0\n            ? +Math.floor(tempDouble / 4294967296) >>> 0\n            : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0\n          : 0)\n      ]),\n        (HEAP32[(buf + 88) >> 2] = tempI64[0]),\n        (HEAP32[(buf + 92) >> 2] = tempI64[1])\n      return 0\n    },\n    doMsync(addr, stream, len, flags, offset) {\n      if (!FS.isFile(stream.node.mode)) {\n        throw new FS.ErrnoError(43)\n      }\n      if (flags & 2) {\n        return 0\n      }\n      var buffer = HEAPU8.slice(addr, addr + len)\n      FS.msync(stream, buffer, offset, len, flags)\n    },\n    varargs: undefined,\n    get() {\n      var ret = HEAP32[SYSCALLS.varargs >> 2]\n      SYSCALLS.varargs += 4\n      return ret\n    },\n    getp() {\n      return SYSCALLS.get()\n    },\n    getStr(ptr) {\n      var ret = UTF8ToString(ptr)\n      return ret\n    },\n    getStreamFromFD(fd) {\n      var stream = FS.getStreamChecked(fd)\n      return stream\n    }\n  }\n  function ___syscall_fcntl64(fd, cmd, varargs) {\n    SYSCALLS.varargs = varargs\n    try {\n      var stream = SYSCALLS.getStreamFromFD(fd)\n      switch (cmd) {\n        case 0: {\n          var arg = SYSCALLS.get()\n          if (arg < 0) {\n            return -28\n          }\n          while (FS.streams[arg]) {\n            arg++\n          }\n          var newStream\n          newStream = FS.createStream(stream, arg)\n          return newStream.fd\n        }\n        case 1:\n        case 2:\n          return 0\n        case 3:\n          return stream.flags\n        case 4: {\n          var arg = SYSCALLS.get()\n          stream.flags |= arg\n          return 0\n        }\n        case 5: {\n          var arg = SYSCALLS.getp()\n          var offset = 0\n          HEAP16[(arg + offset) >> 1] = 2\n          return 0\n        }\n        case 6:\n        case 7:\n          return 0\n        case 16:\n        case 8:\n          return -28\n        case 9:\n          setErrNo(28)\n          return -1\n        default: {\n          return -28\n        }\n      }\n    } catch (e) {\n      if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e\n      return -e.errno\n    }\n  }\n  function ___syscall_ioctl(fd, op, varargs) {\n    SYSCALLS.varargs = varargs\n    try {\n      var stream = SYSCALLS.getStreamFromFD(fd)\n      switch (op) {\n        case 21509: {\n          if (!stream.tty) return -59\n          return 0\n        }\n        case 21505: {\n          if (!stream.tty) return -59\n          if (stream.tty.ops.ioctl_tcgets) {\n            var termios = stream.tty.ops.ioctl_tcgets(stream)\n            var argp = SYSCALLS.getp()\n            HEAP32[argp >> 2] = termios.c_iflag || 0\n            HEAP32[(argp + 4) >> 2] = termios.c_oflag || 0\n            HEAP32[(argp + 8) >> 2] = termios.c_cflag || 0\n            HEAP32[(argp + 12) >> 2] = termios.c_lflag || 0\n            for (var i = 0; i < 32; i++) {\n              HEAP8[(argp + i + 17) >> 0] = termios.c_cc[i] || 0\n            }\n            return 0\n          }\n          return 0\n        }\n        case 21510:\n        case 21511:\n        case 21512: {\n          if (!stream.tty) return -59\n          return 0\n        }\n        case 21506:\n        case 21507:\n        case 21508: {\n          if (!stream.tty) return -59\n          if (stream.tty.ops.ioctl_tcsets) {\n            var argp = SYSCALLS.getp()\n            var c_iflag = HEAP32[argp >> 2]\n            var c_oflag = HEAP32[(argp + 4) >> 2]\n            var c_cflag = HEAP32[(argp + 8) >> 2]\n            var c_lflag = HEAP32[(argp + 12) >> 2]\n            var c_cc = []\n            for (var i = 0; i < 32; i++) {\n              c_cc.push(HEAP8[(argp + i + 17) >> 0])\n            }\n            return stream.tty.ops.ioctl_tcsets(stream.tty, op, {\n              c_iflag: c_iflag,\n              c_oflag: c_oflag,\n              c_cflag: c_cflag,\n              c_lflag: c_lflag,\n              c_cc: c_cc\n            })\n          }\n          return 0\n        }\n        case 21519: {\n          if (!stream.tty) return -59\n          var argp = SYSCALLS.getp()\n          HEAP32[argp >> 2] = 0\n          return 0\n        }\n        case 21520: {\n          if (!stream.tty) return -59\n          return -28\n        }\n        case 21531: {\n          var argp = SYSCALLS.getp()\n          return FS.ioctl(stream, op, argp)\n        }\n        case 21523: {\n          if (!stream.tty) return -59\n          if (stream.tty.ops.ioctl_tiocgwinsz) {\n            var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty)\n            var argp = SYSCALLS.getp()\n            HEAP16[argp >> 1] = winsize[0]\n            HEAP16[(argp + 2) >> 1] = winsize[1]\n          }\n          return 0\n        }\n        case 21524: {\n          if (!stream.tty) return -59\n          return 0\n        }\n        case 21515: {\n          if (!stream.tty) return -59\n          return 0\n        }\n        default:\n          return -28\n      }\n    } catch (e) {\n      if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e\n      return -e.errno\n    }\n  }\n  function ___syscall_openat(dirfd, path, flags, varargs) {\n    SYSCALLS.varargs = varargs\n    try {\n      path = SYSCALLS.getStr(path)\n      path = SYSCALLS.calculateAt(dirfd, path)\n      var mode = varargs ? SYSCALLS.get() : 0\n      return FS.open(path, flags, mode).fd\n    } catch (e) {\n      if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e\n      return -e.errno\n    }\n  }\n  var __embind_register_bigint = (primitiveType, name, size, minRange, maxRange) => {}\n  var embind_init_charCodes = () => {\n    var codes = new Array(256)\n    for (var i = 0; i < 256; ++i) {\n      codes[i] = String.fromCharCode(i)\n    }\n    embind_charCodes = codes\n  }\n  var embind_charCodes = undefined\n  var readLatin1String = (ptr) => {\n    var ret = ''\n    var c = ptr\n    while (HEAPU8[c]) {\n      ret += embind_charCodes[HEAPU8[c++]]\n    }\n    return ret\n  }\n  var awaitingDependencies = {}\n  var registeredTypes = {}\n  var typeDependencies = {}\n  var BindingError = undefined\n  var throwBindingError = (message) => {\n    throw new BindingError(message)\n  }\n  var InternalError = undefined\n  function sharedRegisterType(rawType, registeredInstance, options = {}) {\n    var name = registeredInstance.name\n    if (!rawType) {\n      throwBindingError(`type \"${name}\"must have a positive integer typeid pointer`)\n    }\n    if (registeredTypes.hasOwnProperty(rawType)) {\n      if (options.ignoreDuplicateRegistrations) {\n        return\n      } else {\n        throwBindingError(`Cannot register type '${name}'twice`)\n      }\n    }\n    registeredTypes[rawType] = registeredInstance\n    delete typeDependencies[rawType]\n    if (awaitingDependencies.hasOwnProperty(rawType)) {\n      var callbacks = awaitingDependencies[rawType]\n      delete awaitingDependencies[rawType]\n      callbacks.forEach((cb) => cb())\n    }\n  }\n  function registerType(rawType, registeredInstance, options = {}) {\n    if (!('argPackAdvance' in registeredInstance)) {\n      throw new TypeError('registerType registeredInstance requires argPackAdvance')\n    }\n    return sharedRegisterType(rawType, registeredInstance, options)\n  }\n  var GenericWireTypeSize = 8\n  var __embind_register_bool = (rawType, name, trueValue, falseValue) => {\n    name = readLatin1String(name)\n    registerType(rawType, {\n      name: name,\n      fromWireType: function (wt) {\n        return !!wt\n      },\n      toWireType: function (destructors, o) {\n        return o ? trueValue : falseValue\n      },\n      argPackAdvance: GenericWireTypeSize,\n      readValueFromPointer: function (pointer) {\n        return this['fromWireType'](HEAPU8[pointer])\n      },\n      destructorFunction: null\n    })\n  }\n  function handleAllocatorInit() {\n    Object.assign(HandleAllocator.prototype, {\n      get(id) {\n        return this.allocated[id]\n      },\n      has(id) {\n        return this.allocated[id] !== undefined\n      },\n      allocate(handle) {\n        var id = this.freelist.pop() || this.allocated.length\n        this.allocated[id] = handle\n        return id\n      },\n      free(id) {\n        this.allocated[id] = undefined\n        this.freelist.push(id)\n      }\n    })\n  }\n  function HandleAllocator() {\n    this.allocated = [undefined]\n    this.freelist = []\n  }\n  var emval_handles = new HandleAllocator()\n  var __emval_decref = (handle) => {\n    if (handle >= emval_handles.reserved && 0 === --emval_handles.get(handle).refcount) {\n      emval_handles.free(handle)\n    }\n  }\n  var count_emval_handles = () => {\n    var count = 0\n    for (var i = emval_handles.reserved; i < emval_handles.allocated.length; ++i) {\n      if (emval_handles.allocated[i] !== undefined) {\n        ++count\n      }\n    }\n    return count\n  }\n  var init_emval = () => {\n    emval_handles.allocated.push(\n      {\n        value: undefined\n      },\n      {\n        value: null\n      },\n      {\n        value: true\n      },\n      {\n        value: false\n      }\n    )\n    emval_handles.reserved = emval_handles.allocated.length\n    Module['count_emval_handles'] = count_emval_handles\n  }\n  var Emval = {\n    toValue: (handle) => {\n      if (!handle) {\n        throwBindingError('Cannot use deleted val. handle = ' + handle)\n      }\n      return emval_handles.get(handle).value\n    },\n    toHandle: (value) => {\n      switch (value) {\n        case undefined:\n          return 1\n        case null:\n          return 2\n        case true:\n          return 3\n        case false:\n          return 4\n        default: {\n          return emval_handles.allocate({\n            refcount: 1,\n            value: value\n          })\n        }\n      }\n    }\n  }\n  function simpleReadValueFromPointer(pointer) {\n    return this['fromWireType'](HEAP32[pointer >> 2])\n  }\n  var __embind_register_emval = (rawType, name) => {\n    name = readLatin1String(name)\n    registerType(rawType, {\n      name: name,\n      fromWireType: (handle) => {\n        var rv = Emval.toValue(handle)\n        __emval_decref(handle)\n        return rv\n      },\n      toWireType: (destructors, value) => Emval.toHandle(value),\n      argPackAdvance: GenericWireTypeSize,\n      readValueFromPointer: simpleReadValueFromPointer,\n      destructorFunction: null\n    })\n  }\n  var floatReadValueFromPointer = (name, width) => {\n    switch (width) {\n      case 4:\n        return function (pointer) {\n          return this['fromWireType'](HEAPF32[pointer >> 2])\n        }\n      case 8:\n        return function (pointer) {\n          return this['fromWireType'](HEAPF64[pointer >> 3])\n        }\n      default:\n        throw new TypeError(`invalid float width($ {\n\t\t\t\twidth\n\t\t\t}):\n\t\t\t$ {\n\t\t\t\tname\n\t\t\t}`)\n    }\n  }\n  var __embind_register_float = (rawType, name, size) => {\n    name = readLatin1String(name)\n    registerType(rawType, {\n      name: name,\n      fromWireType: (value) => value,\n      toWireType: (destructors, value) => value,\n      argPackAdvance: GenericWireTypeSize,\n      readValueFromPointer: floatReadValueFromPointer(name, size),\n      destructorFunction: null\n    })\n  }\n  var integerReadValueFromPointer = (name, width, signed) => {\n    switch (width) {\n      case 1:\n        return signed ? (pointer) => HEAP8[pointer >> 0] : (pointer) => HEAPU8[pointer >> 0]\n      case 2:\n        return signed ? (pointer) => HEAP16[pointer >> 1] : (pointer) => HEAPU16[pointer >> 1]\n      case 4:\n        return signed ? (pointer) => HEAP32[pointer >> 2] : (pointer) => HEAPU32[pointer >> 2]\n      default:\n        throw new TypeError(`invalid integer width($ {\n\t\t\t\twidth\n\t\t\t}):\n\t\t\t$ {\n\t\t\t\tname\n\t\t\t}`)\n    }\n  }\n  var __embind_register_integer = (primitiveType, name, size, minRange, maxRange) => {\n    name = readLatin1String(name)\n    if (maxRange === -1) {\n      maxRange = 4294967295\n    }\n    var fromWireType = (value) => value\n    if (minRange === 0) {\n      var bitshift = 32 - 8 * size\n      fromWireType = (value) => (value << bitshift) >>> bitshift\n    }\n    var isUnsignedType = name.includes('unsigned')\n    var checkAssertions = (value, toTypeName) => {}\n    var toWireType\n    if (isUnsignedType) {\n      toWireType = function (destructors, value) {\n        checkAssertions(value, this.name)\n        return value >>> 0\n      }\n    } else {\n      toWireType = function (destructors, value) {\n        checkAssertions(value, this.name)\n        return value\n      }\n    }\n    registerType(primitiveType, {\n      name: name,\n      fromWireType: fromWireType,\n      toWireType: toWireType,\n      argPackAdvance: GenericWireTypeSize,\n      readValueFromPointer: integerReadValueFromPointer(name, size, minRange !== 0),\n      destructorFunction: null\n    })\n  }\n  var __embind_register_memory_view = (rawType, dataTypeIndex, name) => {\n    var typeMapping = [\n      Int8Array,\n      Uint8Array,\n      Int16Array,\n      Uint16Array,\n      Int32Array,\n      Uint32Array,\n      Float32Array,\n      Float64Array\n    ]\n    var TA = typeMapping[dataTypeIndex]\n    function decodeMemoryView(handle) {\n      var size = HEAPU32[handle >> 2]\n      var data = HEAPU32[(handle + 4) >> 2]\n      return new TA(HEAP8.buffer, data, size)\n    }\n    name = readLatin1String(name)\n    registerType(\n      rawType,\n      {\n        name: name,\n        fromWireType: decodeMemoryView,\n        argPackAdvance: GenericWireTypeSize,\n        readValueFromPointer: decodeMemoryView\n      },\n      {\n        ignoreDuplicateRegistrations: true\n      }\n    )\n  }\n  function readPointer(pointer) {\n    return this['fromWireType'](HEAPU32[pointer >> 2])\n  }\n  var stringToUTF8 = (str, outPtr, maxBytesToWrite) =>\n    stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite)\n  var __embind_register_std_string = (rawType, name) => {\n    name = readLatin1String(name)\n    var stdStringIsUTF8 = name === 'std::string'\n    registerType(rawType, {\n      name: name,\n      fromWireType: (value) => {\n        var length = HEAPU32[value >> 2]\n        var payload = value + 4\n        var str\n        if (stdStringIsUTF8) {\n          var decodeStartPtr = payload\n          for (var i = 0; i <= length; ++i) {\n            var currentBytePtr = payload + i\n            if (i == length || HEAPU8[currentBytePtr] == 0) {\n              var maxRead = currentBytePtr - decodeStartPtr\n              var stringSegment = UTF8ToString(decodeStartPtr, maxRead)\n              if (str === undefined) {\n                str = stringSegment\n              } else {\n                str += String.fromCharCode(0)\n                str += stringSegment\n              }\n              decodeStartPtr = currentBytePtr + 1\n            }\n          }\n        } else {\n          var a = new Array(length)\n          for (var i = 0; i < length; ++i) {\n            a[i] = String.fromCharCode(HEAPU8[payload + i])\n          }\n          str = a.join('')\n        }\n        _free(value)\n        return str\n      },\n      toWireType: (destructors, value) => {\n        if (value instanceof ArrayBuffer) {\n          value = new Uint8Array(value)\n        }\n        var length\n        var valueIsOfTypeString = typeof value == 'string'\n        if (\n          !(\n            valueIsOfTypeString ||\n            value instanceof Uint8Array ||\n            value instanceof Uint8ClampedArray ||\n            value instanceof Int8Array\n          )\n        ) {\n          throwBindingError('Cannot pass non-string to std::string')\n        }\n        if (stdStringIsUTF8 && valueIsOfTypeString) {\n          length = lengthBytesUTF8(value)\n        } else {\n          length = value.length\n        }\n        var base = _malloc(4 + length + 1)\n        var ptr = base + 4\n        HEAPU32[base >> 2] = length\n        if (stdStringIsUTF8 && valueIsOfTypeString) {\n          stringToUTF8(value, ptr, length + 1)\n        } else {\n          if (valueIsOfTypeString) {\n            for (var i = 0; i < length; ++i) {\n              var charCode = value.charCodeAt(i)\n              if (charCode > 255) {\n                _free(ptr)\n                throwBindingError('String has UTF-16 code units that do not fit in 8 bits')\n              }\n              HEAPU8[ptr + i] = charCode\n            }\n          } else {\n            for (var i = 0; i < length; ++i) {\n              HEAPU8[ptr + i] = value[i]\n            }\n          }\n        }\n        if (destructors !== null) {\n          destructors.push(_free, base)\n        }\n        return base\n      },\n      argPackAdvance: GenericWireTypeSize,\n      readValueFromPointer: readPointer,\n      destructorFunction: (ptr) => _free(ptr)\n    })\n  }\n  var UTF16Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf-16le') : undefined\n  var UTF16ToString = (ptr, maxBytesToRead) => {\n    var endPtr = ptr\n    var idx = endPtr >> 1\n    var maxIdx = idx + maxBytesToRead / 2\n    while (!(idx >= maxIdx) && HEAPU16[idx]) ++idx\n    endPtr = idx << 1\n    if (endPtr - ptr > 32 && UTF16Decoder) return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr))\n    var str = ''\n    for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {\n      var codeUnit = HEAP16[(ptr + i * 2) >> 1]\n      if (codeUnit == 0) break\n      str += String.fromCharCode(codeUnit)\n    }\n    return str\n  }\n  var stringToUTF16 = (str, outPtr, maxBytesToWrite) => {\n    if (maxBytesToWrite === undefined) {\n      maxBytesToWrite = 2147483647\n    }\n    if (maxBytesToWrite < 2) return 0\n    maxBytesToWrite -= 2\n    var startPtr = outPtr\n    var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length\n    for (var i = 0; i < numCharsToWrite; ++i) {\n      var codeUnit = str.charCodeAt(i)\n      HEAP16[outPtr >> 1] = codeUnit\n      outPtr += 2\n    }\n    HEAP16[outPtr >> 1] = 0\n    return outPtr - startPtr\n  }\n  var lengthBytesUTF16 = (str) => str.length * 2\n  var UTF32ToString = (ptr, maxBytesToRead) => {\n    var i = 0\n    var str = ''\n    while (!(i >= maxBytesToRead / 4)) {\n      var utf32 = HEAP32[(ptr + i * 4) >> 2]\n      if (utf32 == 0) break\n      ++i\n      if (utf32 >= 65536) {\n        var ch = utf32 - 65536\n        str += String.fromCharCode(55296 | (ch >> 10), 56320 | (ch & 1023))\n      } else {\n        str += String.fromCharCode(utf32)\n      }\n    }\n    return str\n  }\n  var stringToUTF32 = (str, outPtr, maxBytesToWrite) => {\n    if (maxBytesToWrite === undefined) {\n      maxBytesToWrite = 2147483647\n    }\n    if (maxBytesToWrite < 4) return 0\n    var startPtr = outPtr\n    var endPtr = startPtr + maxBytesToWrite - 4\n    for (var i = 0; i < str.length; ++i) {\n      var codeUnit = str.charCodeAt(i)\n      if (codeUnit >= 55296 && codeUnit <= 57343) {\n        var trailSurrogate = str.charCodeAt(++i)\n        codeUnit = (65536 + ((codeUnit & 1023) << 10)) | (trailSurrogate & 1023)\n      }\n      HEAP32[outPtr >> 2] = codeUnit\n      outPtr += 4\n      if (outPtr + 4 > endPtr) break\n    }\n    HEAP32[outPtr >> 2] = 0\n    return outPtr - startPtr\n  }\n  var lengthBytesUTF32 = (str) => {\n    var len = 0\n    for (var i = 0; i < str.length; ++i) {\n      var codeUnit = str.charCodeAt(i)\n      if (codeUnit >= 55296 && codeUnit <= 57343) ++i\n      len += 4\n    }\n    return len\n  }\n  var __embind_register_std_wstring = (rawType, charSize, name) => {\n    name = readLatin1String(name)\n    var decodeString, encodeString, getHeap, lengthBytesUTF, shift\n    if (charSize === 2) {\n      decodeString = UTF16ToString\n      encodeString = stringToUTF16\n      lengthBytesUTF = lengthBytesUTF16\n      getHeap = () => HEAPU16\n      shift = 1\n    } else if (charSize === 4) {\n      decodeString = UTF32ToString\n      encodeString = stringToUTF32\n      lengthBytesUTF = lengthBytesUTF32\n      getHeap = () => HEAPU32\n      shift = 2\n    }\n    registerType(rawType, {\n      name: name,\n      fromWireType: (value) => {\n        var length = HEAPU32[value >> 2]\n        var HEAP = getHeap()\n        var str\n        var decodeStartPtr = value + 4\n        for (var i = 0; i <= length; ++i) {\n          var currentBytePtr = value + 4 + i * charSize\n          if (i == length || HEAP[currentBytePtr >> shift] == 0) {\n            var maxReadBytes = currentBytePtr - decodeStartPtr\n            var stringSegment = decodeString(decodeStartPtr, maxReadBytes)\n            if (str === undefined) {\n              str = stringSegment\n            } else {\n              str += String.fromCharCode(0)\n              str += stringSegment\n            }\n            decodeStartPtr = currentBytePtr + charSize\n          }\n        }\n        _free(value)\n        return str\n      },\n      toWireType: (destructors, value) => {\n        if (!(typeof value == 'string')) {\n          throwBindingError(`Cannot pass non - string to C++string type $ {\n\t\t\t\t\t\tname\n\t\t\t\t\t}`)\n        }\n        var length = lengthBytesUTF(value)\n        var ptr = _malloc(4 + length + charSize)\n        HEAPU32[ptr >> 2] = length >> shift\n        encodeString(value, ptr + 4, length + charSize)\n        if (destructors !== null) {\n          destructors.push(_free, ptr)\n        }\n        return ptr\n      },\n      argPackAdvance: GenericWireTypeSize,\n      readValueFromPointer: simpleReadValueFromPointer,\n      destructorFunction: (ptr) => _free(ptr)\n    })\n  }\n  var __embind_register_void = (rawType, name) => {\n    name = readLatin1String(name)\n    registerType(rawType, {\n      isVoid: true,\n      name: name,\n      argPackAdvance: 0,\n      fromWireType: () => undefined,\n      toWireType: (destructors, o) => undefined\n    })\n  }\n  var _abort = () => {\n    abort('')\n  }\n  var _emscripten_get_now\n  _emscripten_get_now = () => performance.now()\n  var _emscripten_memcpy_big = (dest, src, num) => HEAPU8.copyWithin(dest, src, src + num)\n  var abortOnCannotGrowMemory = (requestedSize) => {\n    abort('OOM')\n  }\n  var _emscripten_resize_heap = (requestedSize) => {\n    var oldSize = HEAPU8.length\n    requestedSize >>>= 0\n    abortOnCannotGrowMemory(requestedSize)\n  }\n  var ENV = {}\n  var getExecutableName = () => thisProgram || './this.program'\n  var getEnvStrings = () => {\n    if (!getEnvStrings.strings) {\n      var lang =\n        (\n          (typeof navigator == 'object' && navigator.languages && navigator.languages[0]) ||\n          'C'\n        ).replace('-', '_') + '.UTF-8'\n      var env = {\n        USER: 'web_user',\n        LOGNAME: 'web_user',\n        PATH: '/',\n        PWD: '/',\n        HOME: '/home/web_user',\n        LANG: lang,\n        _: getExecutableName()\n      }\n      for (var x in ENV) {\n        if (ENV[x] === undefined) delete env[x]\n        else env[x] = ENV[x]\n      }\n      var strings = []\n      for (var x in env) {\n        strings.push(`$ {\n\t\t\t\t\tx\n\t\t\t\t} = $ {\n\t\t\t\t\tenv[x]\n\t\t\t\t}`)\n      }\n      getEnvStrings.strings = strings\n    }\n    return getEnvStrings.strings\n  }\n  var stringToAscii = (str, buffer) => {\n    for (var i = 0; i < str.length; ++i) {\n      HEAP8[buffer++ >> 0] = str.charCodeAt(i)\n    }\n    HEAP8[buffer >> 0] = 0\n  }\n  var _environ_get = (__environ, environ_buf) => {\n    var bufSize = 0\n    getEnvStrings().forEach((string, i) => {\n      var ptr = environ_buf + bufSize\n      HEAPU32[(__environ + i * 4) >> 2] = ptr\n      stringToAscii(string, ptr)\n      bufSize += string.length + 1\n    })\n    return 0\n  }\n  var _environ_sizes_get = (penviron_count, penviron_buf_size) => {\n    var strings = getEnvStrings()\n    HEAPU32[penviron_count >> 2] = strings.length\n    var bufSize = 0\n    strings.forEach((string) => (bufSize += string.length + 1))\n    HEAPU32[penviron_buf_size >> 2] = bufSize\n    return 0\n  }\n  function _fd_close(fd) {\n    try {\n      var stream = SYSCALLS.getStreamFromFD(fd)\n      FS.close(stream)\n      return 0\n    } catch (e) {\n      if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e\n      return e.errno\n    }\n  }\n  var doReadv = (stream, iov, iovcnt, offset) => {\n    var ret = 0\n    for (var i = 0; i < iovcnt; i++) {\n      var ptr = HEAPU32[iov >> 2]\n      var len = HEAPU32[(iov + 4) >> 2]\n      iov += 8\n      var curr = FS.read(stream, HEAP8, ptr, len, offset)\n      if (curr < 0) return -1\n      ret += curr\n      if (curr < len) break\n      if (typeof offset !== 'undefined') {\n        offset += curr\n      }\n    }\n    return ret\n  }\n  function _fd_read(fd, iov, iovcnt, pnum) {\n    try {\n      var stream = SYSCALLS.getStreamFromFD(fd)\n      var num = doReadv(stream, iov, iovcnt)\n      HEAPU32[pnum >> 2] = num\n      return 0\n    } catch (e) {\n      if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e\n      return e.errno\n    }\n  }\n  var convertI32PairToI53Checked = (lo, hi) =>\n    (hi + 2097152) >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN\n  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {\n    var offset = convertI32PairToI53Checked(offset_low, offset_high)\n    try {\n      if (isNaN(offset)) return 61\n      var stream = SYSCALLS.getStreamFromFD(fd)\n      FS.llseek(stream, offset, whence)\n      ;(tempI64 = [\n        stream.position >>> 0,\n        ((tempDouble = stream.position),\n        +Math.abs(tempDouble) >= 1\n          ? tempDouble > 0\n            ? +Math.floor(tempDouble / 4294967296) >>> 0\n            : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0\n          : 0)\n      ]),\n        (HEAP32[newOffset >> 2] = tempI64[0]),\n        (HEAP32[(newOffset + 4) >> 2] = tempI64[1])\n      if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null\n      return 0\n    } catch (e) {\n      if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e\n      return e.errno\n    }\n  }\n  var doWritev = (stream, iov, iovcnt, offset) => {\n    var ret = 0\n    for (var i = 0; i < iovcnt; i++) {\n      var ptr = HEAPU32[iov >> 2]\n      var len = HEAPU32[(iov + 4) >> 2]\n      iov += 8\n      var curr = FS.write(stream, HEAP8, ptr, len, offset)\n      if (curr < 0) return -1\n      ret += curr\n      if (typeof offset !== 'undefined') {\n        offset += curr\n      }\n    }\n    return ret\n  }\n  function _fd_write(fd, iov, iovcnt, pnum) {\n    try {\n      var stream = SYSCALLS.getStreamFromFD(fd)\n      var num = doWritev(stream, iov, iovcnt)\n      HEAPU32[pnum >> 2] = num\n      return 0\n    } catch (e) {\n      if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e\n      return e.errno\n    }\n  }\n  var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0)\n  var arraySum = (array, index) => {\n    var sum = 0\n    for (var i = 0; i <= index; sum += array[i++]) {}\n    return sum\n  }\n  var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n  var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n  var addDays = (date, days) => {\n    var newDate = new Date(date.getTime())\n    while (days > 0) {\n      var leap = isLeapYear(newDate.getFullYear())\n      var currentMonth = newDate.getMonth()\n      var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth]\n      if (days > daysInCurrentMonth - newDate.getDate()) {\n        days -= daysInCurrentMonth - newDate.getDate() + 1\n        newDate.setDate(1)\n        if (currentMonth < 11) {\n          newDate.setMonth(currentMonth + 1)\n        } else {\n          newDate.setMonth(0)\n          newDate.setFullYear(newDate.getFullYear() + 1)\n        }\n      } else {\n        newDate.setDate(newDate.getDate() + days)\n        return newDate\n      }\n    }\n    return newDate\n  }\n  var writeArrayToMemory = (array, buffer) => {\n    HEAP8.set(array, buffer)\n  }\n  var _strftime = (s, maxsize, format, tm) => {\n    var tm_zone = HEAPU32[(tm + 40) >> 2]\n    var date = {\n      tm_sec: HEAP32[tm >> 2],\n      tm_min: HEAP32[(tm + 4) >> 2],\n      tm_hour: HEAP32[(tm + 8) >> 2],\n      tm_mday: HEAP32[(tm + 12) >> 2],\n      tm_mon: HEAP32[(tm + 16) >> 2],\n      tm_year: HEAP32[(tm + 20) >> 2],\n      tm_wday: HEAP32[(tm + 24) >> 2],\n      tm_yday: HEAP32[(tm + 28) >> 2],\n      tm_isdst: HEAP32[(tm + 32) >> 2],\n      tm_gmtoff: HEAP32[(tm + 36) >> 2],\n      tm_zone: tm_zone ? UTF8ToString(tm_zone) : ''\n    }\n    var pattern = UTF8ToString(format)\n    var EXPANSION_RULES_1 = {\n      '%c': '%a %b %d %H:%M:%S %Y',\n      '%D': '%m/%d/%y',\n      '%F': '%Y-%m-%d',\n      '%h': '%b',\n      '%r': '%I:%M:%S %p',\n      '%R': '%H:%M',\n      '%T': '%H:%M:%S',\n      '%x': '%m/%d/%y',\n      '%X': '%H:%M:%S',\n      '%Ec': '%c',\n      '%EC': '%C',\n      '%Ex': '%m/%d/%y',\n      '%EX': '%H:%M:%S',\n      '%Ey': '%y',\n      '%EY': '%Y',\n      '%Od': '%d',\n      '%Oe': '%e',\n      '%OH': '%H',\n      '%OI': '%I',\n      '%Om': '%m',\n      '%OM': '%M',\n      '%OS': '%S',\n      '%Ou': '%u',\n      '%OU': '%U',\n      '%OV': '%V',\n      '%Ow': '%w',\n      '%OW': '%W',\n      '%Oy': '%y'\n    }\n    for (var rule in EXPANSION_RULES_1) {\n      pattern = pattern.replace(new RegExp(rule, 'g'), EXPANSION_RULES_1[rule])\n    }\n    var WEEKDAYS = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']\n    var MONTHS = [\n      'January',\n      'February',\n      'March',\n      'April',\n      'May',\n      'June',\n      'July',\n      'August',\n      'September',\n      'October',\n      'November',\n      'December'\n    ]\n    function leadingSomething(value, digits, character) {\n      var str = typeof value == 'number' ? value.toString() : value || ''\n      while (str.length < digits) {\n        str = character[0] + str\n      }\n      return str\n    }\n    function leadingNulls(value, digits) {\n      return leadingSomething(value, digits, '0')\n    }\n    function compareByDay(date1, date2) {\n      function sgn(value) {\n        return value < 0 ? -1 : value > 0 ? 1 : 0\n      }\n      var compare\n      if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {\n        if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {\n          compare = sgn(date1.getDate() - date2.getDate())\n        }\n      }\n      return compare\n    }\n    function getFirstWeekStartDate(janFourth) {\n      switch (janFourth.getDay()) {\n        case 0:\n          return new Date(janFourth.getFullYear() - 1, 11, 29)\n        case 1:\n          return janFourth\n        case 2:\n          return new Date(janFourth.getFullYear(), 0, 3)\n        case 3:\n          return new Date(janFourth.getFullYear(), 0, 2)\n        case 4:\n          return new Date(janFourth.getFullYear(), 0, 1)\n        case 5:\n          return new Date(janFourth.getFullYear() - 1, 11, 31)\n        case 6:\n          return new Date(janFourth.getFullYear() - 1, 11, 30)\n      }\n    }\n    function getWeekBasedYear(date) {\n      var thisDate = addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday)\n      var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4)\n      var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4)\n      var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear)\n      var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear)\n      if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {\n        if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {\n          return thisDate.getFullYear() + 1\n        }\n        return thisDate.getFullYear()\n      }\n      return thisDate.getFullYear() - 1\n    }\n    var EXPANSION_RULES_2 = {\n      '%a': (date) => WEEKDAYS[date.tm_wday].substring(0, 3),\n      '%A': (date) => WEEKDAYS[date.tm_wday],\n      '%b': (date) => MONTHS[date.tm_mon].substring(0, 3),\n      '%B': (date) => MONTHS[date.tm_mon],\n      '%C': (date) => {\n        var year = date.tm_year + 1900\n        return leadingNulls((year / 100) | 0, 2)\n      },\n      '%d': (date) => leadingNulls(date.tm_mday, 2),\n      '%e': (date) => leadingSomething(date.tm_mday, 2, ' '),\n      '%g': (date) => getWeekBasedYear(date).toString().substring(2),\n      '%G': (date) => getWeekBasedYear(date),\n      '%H': (date) => leadingNulls(date.tm_hour, 2),\n      '%I': (date) => {\n        var twelveHour = date.tm_hour\n        if (twelveHour == 0) twelveHour = 12\n        else if (twelveHour > 12) twelveHour -= 12\n        return leadingNulls(twelveHour, 2)\n      },\n      '%j': (date) =>\n        leadingNulls(\n          date.tm_mday +\n            arraySum(\n              isLeapYear(date.tm_year + 1900) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR,\n              date.tm_mon - 1\n            ),\n          3\n        ),\n      '%m': (date) => leadingNulls(date.tm_mon + 1, 2),\n      '%M': (date) => leadingNulls(date.tm_min, 2),\n      '%n': () => '\\n',\n      '%p': (date) => {\n        if (date.tm_hour >= 0 && date.tm_hour < 12) {\n          return 'AM'\n        }\n        return 'PM'\n      },\n      '%S': (date) => leadingNulls(date.tm_sec, 2),\n      '%t': () => '\\t',\n      '%u': (date) => date.tm_wday || 7,\n      '%U': (date) => {\n        var days = date.tm_yday + 7 - date.tm_wday\n        return leadingNulls(Math.floor(days / 7), 2)\n      },\n      '%V': (date) => {\n        var val = Math.floor((date.tm_yday + 7 - ((date.tm_wday + 6) % 7)) / 7)\n        if ((date.tm_wday + 371 - date.tm_yday - 2) % 7 <= 2) {\n          val++\n        }\n        if (!val) {\n          val = 52\n          var dec31 = (date.tm_wday + 7 - date.tm_yday - 1) % 7\n          if (dec31 == 4 || (dec31 == 5 && isLeapYear((date.tm_year % 400) - 1))) {\n            val++\n          }\n        } else if (val == 53) {\n          var jan1 = (date.tm_wday + 371 - date.tm_yday) % 7\n          if (jan1 != 4 && (jan1 != 3 || !isLeapYear(date.tm_year))) val = 1\n        }\n        return leadingNulls(val, 2)\n      },\n      '%w': (date) => date.tm_wday,\n      '%W': (date) => {\n        var days = date.tm_yday + 7 - ((date.tm_wday + 6) % 7)\n        return leadingNulls(Math.floor(days / 7), 2)\n      },\n      '%y': (date) => (date.tm_year + 1900).toString().substring(2),\n      '%Y': (date) => date.tm_year + 1900,\n      '%z': (date) => {\n        var off = date.tm_gmtoff\n        var ahead = off >= 0\n        off = Math.abs(off) / 60\n        off = (off / 60) * 100 + (off % 60)\n        return (ahead ? '+' : '-') + String('0000' + off).slice(-4)\n      },\n      '%Z': (date) => date.tm_zone,\n      '%%': () => '%'\n    }\n    pattern = pattern.replace(/%%/g, '\\0\\0')\n    for (var rule in EXPANSION_RULES_2) {\n      if (pattern.includes(rule)) {\n        pattern = pattern.replace(new RegExp(rule, 'g'), EXPANSION_RULES_2[rule](date))\n      }\n    }\n    pattern = pattern.replace(/\\0\\0/g, '%')\n    var bytes = intArrayFromString(pattern, false)\n    if (bytes.length > maxsize) {\n      return 0\n    }\n    writeArrayToMemory(bytes, s)\n    return bytes.length - 1\n  }\n  var _strftime_l = (s, maxsize, format, tm, loc) => _strftime(s, maxsize, format, tm)\n  var _proc_exit = (code) => {\n    EXITSTATUS = code\n    if (!keepRuntimeAlive()) {\n      if (Module['onExit']) Module['onExit'](code)\n      ABORT = true\n    }\n    quit_(code, new ExitStatus(code))\n  }\n  var exitJS = (status, implicit) => {\n    EXITSTATUS = status\n    _proc_exit(status)\n  }\n  var handleException = (e) => {\n    if (e instanceof ExitStatus || e == 'unwind') {\n      return EXITSTATUS\n    }\n    quit_(1, e)\n  }\n  var stringToUTF8OnStack = (str) => {\n    var size = lengthBytesUTF8(str) + 1\n    var ret = stackAlloc(size)\n    stringToUTF8(str, ret, size)\n    return ret\n  }\n  var uleb128Encode = (n, target) => {\n    if (n < 128) {\n      target.push(n)\n    } else {\n      target.push(n % 128 | 128, n >> 7)\n    }\n  }\n  var sigToWasmTypes = (sig) => {\n    var typeNames = {\n      i: 'i32',\n      j: 'i64',\n      f: 'f32',\n      d: 'f64',\n      p: 'i32'\n    }\n    var type = {\n      parameters: [],\n      results: sig[0] == 'v' ? [] : [typeNames[sig[0]]]\n    }\n    for (var i = 1; i < sig.length; ++i) {\n      type.parameters.push(typeNames[sig[i]])\n    }\n    return type\n  }\n  var generateFuncType = (sig, target) => {\n    var sigRet = sig.slice(0, 1)\n    var sigParam = sig.slice(1)\n    var typeCodes = {\n      i: 127,\n      p: 127,\n      j: 126,\n      f: 125,\n      d: 124\n    }\n    target.push(96)\n    uleb128Encode(sigParam.length, target)\n    for (var i = 0; i < sigParam.length; ++i) {\n      target.push(typeCodes[sigParam[i]])\n    }\n    if (sigRet == 'v') {\n      target.push(0)\n    } else {\n      target.push(1, typeCodes[sigRet])\n    }\n  }\n  var convertJsFunctionToWasm = (func, sig) => {\n    if (typeof WebAssembly.Function == 'function') {\n      return new WebAssembly.Function(sigToWasmTypes(sig), func)\n    }\n    var typeSectionBody = [1]\n    generateFuncType(sig, typeSectionBody)\n    var bytes = [0, 97, 115, 109, 1, 0, 0, 0, 1]\n    uleb128Encode(typeSectionBody.length, bytes)\n    bytes.push.apply(bytes, typeSectionBody)\n    bytes.push(2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0)\n    var module = new WebAssembly.Module(new Uint8Array(bytes))\n    var instance = new WebAssembly.Instance(module, {\n      e: {\n        f: func\n      }\n    })\n    var wrappedFunc = instance.exports['f']\n    return wrappedFunc\n  }\n  var wasmTableMirror = []\n  var getWasmTableEntry = (funcPtr) => {\n    var func = wasmTableMirror[funcPtr]\n    if (!func) {\n      if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1\n      wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr)\n    }\n    return func\n  }\n  var updateTableMap = (offset, count) => {\n    if (functionsInTableMap) {\n      for (var i = offset; i < offset + count; i++) {\n        var item = getWasmTableEntry(i)\n        if (item) {\n          functionsInTableMap.set(item, i)\n        }\n      }\n    }\n  }\n  var functionsInTableMap = undefined\n  var getFunctionAddress = (func) => {\n    if (!functionsInTableMap) {\n      functionsInTableMap = new WeakMap()\n      updateTableMap(0, wasmTable.length)\n    }\n    return functionsInTableMap.get(func) || 0\n  }\n  var freeTableIndexes = []\n  var getEmptyTableSlot = () => {\n    if (freeTableIndexes.length) {\n      return freeTableIndexes.pop()\n    }\n    try {\n      wasmTable.grow(1)\n    } catch (err) {\n      if (!(err instanceof RangeError)) {\n        throw err\n      }\n      throw 'Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.'\n    }\n    return wasmTable.length - 1\n  }\n  var setWasmTableEntry = (idx, func) => {\n    wasmTable.set(idx, func)\n    wasmTableMirror[idx] = wasmTable.get(idx)\n  }\n  var addFunction = (func, sig) => {\n    var rtn = getFunctionAddress(func)\n    if (rtn) {\n      return rtn\n    }\n    var ret = getEmptyTableSlot()\n    try {\n      setWasmTableEntry(ret, func)\n    } catch (err) {\n      if (!(err instanceof TypeError)) {\n        throw err\n      }\n      var wrapped = convertJsFunctionToWasm(func, sig)\n      setWasmTableEntry(ret, wrapped)\n    }\n    functionsInTableMap.set(func, ret)\n    return ret\n  }\n  var removeFunction = (index) => {\n    functionsInTableMap.delete(getWasmTableEntry(index))\n    freeTableIndexes.push(index)\n  }\n  var FSNode = function (parent, name, mode, rdev) {\n    if (!parent) {\n      parent = this\n    }\n    this.parent = parent\n    this.mount = parent.mount\n    this.mounted = null\n    this.id = FS.nextInode++\n    this.name = name\n    this.mode = mode\n    this.node_ops = {}\n    this.stream_ops = {}\n    this.rdev = rdev\n  }\n  var readMode = 292 | 73\n  var writeMode = 146\n  Object.defineProperties(FSNode.prototype, {\n    read: {\n      get: function () {\n        return (this.mode & readMode) === readMode\n      },\n      set: function (val) {\n        val ? (this.mode |= readMode) : (this.mode &= ~readMode)\n      }\n    },\n    write: {\n      get: function () {\n        return (this.mode & writeMode) === writeMode\n      },\n      set: function (val) {\n        val ? (this.mode |= writeMode) : (this.mode &= ~writeMode)\n      }\n    },\n    isFolder: {\n      get: function () {\n        return FS.isDir(this.mode)\n      }\n    },\n    isDevice: {\n      get: function () {\n        return FS.isChrdev(this.mode)\n      }\n    }\n  })\n  FS.FSNode = FSNode\n  FS.createPreloadedFile = FS_createPreloadedFile\n  FS.staticInit()\n  embind_init_charCodes()\n  BindingError = Module['BindingError'] = class BindingError extends Error {\n    constructor(message) {\n      super(message)\n      this.name = 'BindingError'\n    }\n  }\n  InternalError = Module['InternalError'] = class InternalError extends Error {\n    constructor(message) {\n      super(message)\n      this.name = 'InternalError'\n    }\n  }\n  handleAllocatorInit()\n  init_emval()\n  var wasmImports = {\n    k: ___cxa_throw,\n    j: ___syscall_fcntl64,\n    v: ___syscall_ioctl,\n    w: ___syscall_openat,\n    o: __embind_register_bigint,\n    m: __embind_register_bool,\n    l: __embind_register_emval,\n    g: __embind_register_float,\n    c: __embind_register_integer,\n    b: __embind_register_memory_view,\n    f: __embind_register_std_string,\n    d: __embind_register_std_wstring,\n    r: __embind_register_void,\n    a: _abort,\n    e: _emscripten_get_now,\n    x: _emscripten_memcpy_big,\n    t: _emscripten_resize_heap,\n    q: _environ_get,\n    s: _environ_sizes_get,\n    h: _fd_close,\n    u: _fd_read,\n    n: _fd_seek,\n    i: _fd_write,\n    p: _strftime_l\n  }\n  var wasmExports = createWasm()\n  var ___wasm_call_ctors = () => (___wasm_call_ctors = wasmExports['z'])()\n  var _main = (Module['_main'] = (a0, a1) => (_main = Module['_main'] = wasmExports['A'])(a0, a1))\n  var _CreateAiHowling = (Module['_CreateAiHowling'] = () =>\n    (_CreateAiHowling = Module['_CreateAiHowling'] = wasmExports['B'])())\n  var _SetNum = (Module['_SetNum'] = (a0, a1) =>\n    (_SetNum = Module['_SetNum'] = wasmExports['C'])(a0, a1))\n  var _SetThreshold = (Module['_SetThreshold'] = (a0, a1) =>\n    (_SetThreshold = Module['_SetThreshold'] = wasmExports['D'])(a0, a1))\n  var _SetPostThreshold = (Module['_SetPostThreshold'] = (a0, a1) =>\n    (_SetPostThreshold = Module['_SetPostThreshold'] = wasmExports['E'])(a0, a1))\n  var _Enable = (Module['_Enable'] = (a0, a1) =>\n    (_Enable = Module['_Enable'] = wasmExports['F'])(a0, a1))\n  var _is_enabled = (Module['_is_enabled'] = (a0) =>\n    (_is_enabled = Module['_is_enabled'] = wasmExports['G'])(a0))\n  var _Processing_Frame = (Module['_Processing_Frame'] = (a0, a1, a2) =>\n    (_Processing_Frame = Module['_Processing_Frame'] = wasmExports['H'])(a0, a1, a2))\n  var _DeleteAiHowliing = (Module['_DeleteAiHowliing'] = (a0) =>\n    (_DeleteAiHowliing = Module['_DeleteAiHowliing'] = wasmExports['I'])(a0))\n  var _GetThreshold = (Module['_GetThreshold'] = (a0) =>\n    (_GetThreshold = Module['_GetThreshold'] = wasmExports['K'])(a0))\n  var _GetNum = (Module['_GetNum'] = (a0) => (_GetNum = Module['_GetNum'] = wasmExports['L'])(a0))\n  var _GetPostThreshold = (Module['_GetPostThreshold'] = (a0) =>\n    (_GetPostThreshold = Module['_GetPostThreshold'] = wasmExports['M'])(a0))\n  var _RegisterAiHowlingCallback = (Module['_RegisterAiHowlingCallback'] = (a0, a1) =>\n    (_RegisterAiHowlingCallback = Module['_RegisterAiHowlingCallback'] = wasmExports['N'])(a0, a1))\n  var _DeregisterAiHowlingCallback = (Module['_DeregisterAiHowlingCallback'] = (a0) =>\n    (_DeregisterAiHowlingCallback = Module['_DeregisterAiHowlingCallback'] = wasmExports['O'])(a0))\n  var _aihowling_Malloc = (Module['_aihowling_Malloc'] = (a0) =>\n    (_aihowling_Malloc = Module['_aihowling_Malloc'] = wasmExports['P'])(a0))\n  var _malloc = (a0) => (_malloc = wasmExports['Q'])(a0)\n  var _aihowling_Free = (Module['_aihowling_Free'] = (a0) =>\n    (_aihowling_Free = Module['_aihowling_Free'] = wasmExports['R'])(a0))\n  var _free = (a0) => (_free = wasmExports['S'])(a0)\n  var ___getTypeName = (a0) => (___getTypeName = wasmExports['__getTypeName'])(a0)\n  var __embind_initialize_bindings = (Module['__embind_initialize_bindings'] = () =>\n    (__embind_initialize_bindings = Module['__embind_initialize_bindings'] = wasmExports['T'])())\n  var ___errno_location = () => (___errno_location = wasmExports['U'])()\n  var stackAlloc = (a0) => (stackAlloc = wasmExports['V'])(a0)\n  var ___cxa_is_pointer_type = (a0) => (___cxa_is_pointer_type = wasmExports['W'])(a0)\n  Module['addFunction'] = addFunction\n  Module['removeFunction'] = removeFunction\n  var calledRun\n  dependenciesFulfilled = function runCaller() {\n    if (!calledRun) run()\n    if (!calledRun) dependenciesFulfilled = runCaller\n  }\n  function callMain(args = []) {\n    var entryFunction = _main\n    args.unshift(thisProgram)\n    var argc = args.length\n    var argv = stackAlloc((argc + 1) * 4)\n    var argv_ptr = argv\n    args.forEach((arg) => {\n      HEAPU32[argv_ptr >> 2] = stringToUTF8OnStack(arg)\n      argv_ptr += 4\n    })\n    HEAPU32[argv_ptr >> 2] = 0\n    try {\n      var ret = entryFunction(argc, argv)\n      exitJS(ret, true)\n      return ret\n    } catch (e) {\n      return handleException(e)\n    }\n  }\n  function run(args = arguments_) {\n    if (runDependencies > 0) {\n      return\n    }\n    preRun()\n    if (runDependencies > 0) {\n      return\n    }\n    function doRun() {\n      if (calledRun) return\n      calledRun = true\n      Module['calledRun'] = true\n      if (ABORT) return\n      initRuntime()\n      preMain()\n      if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']()\n      if (shouldRunNow) callMain(args)\n      postRun()\n    }\n    if (Module['setStatus']) {\n      Module['setStatus']('Running...')\n      setTimeout(function () {\n        setTimeout(function () {\n          Module['setStatus']('')\n        }, 1)\n        doRun()\n      }, 1)\n    } else {\n      doRun()\n    }\n  }\n  if (Module['preInit']) {\n    if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']]\n    while (Module['preInit'].length > 0) {\n      Module['preInit'].pop()()\n    }\n  }\n  var shouldRunNow = true\n  if (Module['noInitialRun']) shouldRunNow = false\n  run()\n}\n\nlet global = {}\n\nregisterProcessor(\n  'aiHowlingWorkletAgentProcessor',\n  class extends AudioWorkletProcessor {\n    constructor() {\n      super()\n      this.audioProcess = new Howling()\n      global.port = this.port\n      this.port.onmessage = (event) => {\n        const { type } = event.data\n        switch (type) {\n          case 'init':\n            this.audioProcess.init(event.data.wasmBinary)\n            break\n        }\n      }\n    }\n\n    process(inputs, outputs) {\n      this.audioProcess.process(inputs[0])\n      return true\n    }\n  }\n)\n\nclass Howling {\n  isProcessing = false\n  buffer = []\n  buffer_length = 1\n  initMem = false\n  inLeftPtr = null\n  outLeftPtr = null\n  inRightPtr = null\n  outRightPtr = null\n  buffer_size = 128\n  inArrayPtr = null\n  outArrayPtr = null\n\n  howling = null\n\n  init(binary) {\n    Module = {\n      noInitialRun: true,\n      wasmBinary: binary,\n      onRuntimeInitialized: () => {\n        this.malloc()\n        this.howling = Module._CreateAiHowling()\n        Module._SetNum(this.howling, 16)\n        Module._SetThreshold(this.howling, 0.5)\n        Module._SetPostThreshold(this.howling, 1)\n        Module._Enable(this.howling, true)\n        const callbackPtr = Module.addFunction(this.handleHasHowling, 'vi')\n        Module._RegisterAiHowlingCallback(this.howling, callbackPtr)\n        this.initMem = true\n        this.handleInitFinished()\n      },\n      onAbort: (msg) => {\n        global.port.postMessage({ type: 'error', message: '' + msg })\n      }\n    }\n    createModule()\n  }\n\n  malloc() {\n    this.inLeftPtr = Module._aihowling_Malloc(this.buffer_size * 2)\n    this.inRightPtr = Module._aihowling_Malloc(this.buffer_size * 2)\n    this.inArrayPtr = Module._aihowling_Malloc(2)\n    Module.HEAP32.set([this.inLeftPtr, this.inRightPtr], this.inArrayPtr >> 2)\n  }\n\n  process(frame) {\n    if (!this.initMem) {\n      return\n    }\n\n    let leftData, rightData\n    if (frame.length == 2) {\n      leftData = Int16Array.from(frame[0], (x) => x * 32767)\n      rightData = Int16Array.from(frame[1], (x) => x * 32767)\n    } else if (frame.length == 1) {\n      leftData = Int16Array.from(frame[0], (x) => x * 32767)\n      rightData = Int16Array.from(frame[0], (x) => x * 32767)\n    } else {\n      //console.warn('音频源数据异常，长度-', frame.length)\n      this.buffer = []\n      this.isProcessing = false\n      return\n    }\n    Module.HEAP16.set(leftData, this.inLeftPtr >> 1)\n    Module.HEAP16.set(rightData, this.inRightPtr >> 1)\n    Module._Processing_Frame(this.howling, this.inArrayPtr, 2)\n  }\n\n  destroy() {\n    this.buffer.length = 0\n    if (this.inLeftPtr != null) {\n      Module._aihowling_Free(this.inLeftPtr)\n      this.inLeftPtr = null\n      Module._aihowling_Free(this.inRightPtr)\n      this.outRightPtr = null\n      Module._aihowling_Free(this.inArrayPtr)\n      this.inArrayPtr = null\n    }\n    this.howling = null\n    this.initMem = false\n  }\n\n  handleInitFinished() {\n    global.port.postMessage({\n      type: 'created',\n      value: 'AIhowling'\n    })\n  }\n\n  handleHasHowling = (result) => {\n    global.port.postMessage({\n      type: 'howlingState',\n      result\n    })\n  }\n}\n"}})}));