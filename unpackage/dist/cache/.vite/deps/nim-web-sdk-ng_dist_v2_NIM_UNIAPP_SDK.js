import {
  __commonJS
} from "./chunk-LQ2VYIYD.js";

// ../../../../../../Users/mac/production/workspace/im/node_modules/nim-web-sdk-ng/dist/v2/NIM_UNIAPP_SDK.js
var require_NIM_UNIAPP_SDK = __commonJS({
  "../../../../../../Users/mac/production/workspace/im/node_modules/nim-web-sdk-ng/dist/v2/NIM_UNIAPP_SDK.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = "undefined" != typeof globalThis ? globalThis : e || self).NIM = {});
    }(exports, function(e) {
      "use strict";
      "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self && self;
      function createCommonjsModule(e2) {
        var t2 = { exports: {} };
        return e2(t2, t2.exports), t2.exports;
      }
      var t, r, i, s, n, a, o, c, d, l, m, p, u, h, g, v, y, f, I, M, S, T, _, C, E, b, R, N, A, O, k, w, P, V, L, U, D, q, x, B, j, $, G, H, z, W, K, Y, J, Q, X, Z, ee, te, re, ie, se = createCommonjsModule(function(e2) {
        var t2 = Object.prototype.hasOwnProperty, r2 = "~";
        function Events() {
        }
        function EE(e3, t3, r3) {
          this.fn = e3, this.context = t3, this.once = r3 || false;
        }
        function addListener(e3, t3, i2, s2, n2) {
          if ("function" != typeof i2)
            throw new TypeError("The listener must be a function");
          var a2 = new EE(i2, s2 || e3, n2), o2 = r2 ? r2 + t3 : t3;
          return e3._events[o2] ? e3._events[o2].fn ? e3._events[o2] = [e3._events[o2], a2] : e3._events[o2].push(a2) : (e3._events[o2] = a2, e3._eventsCount++), e3;
        }
        function clearEvent(e3, t3) {
          0 == --e3._eventsCount ? e3._events = new Events() : delete e3._events[t3];
        }
        function EventEmitter() {
          this._events = new Events(), this._eventsCount = 0;
        }
        Object.create && (Events.prototype = /* @__PURE__ */ Object.create(null), new Events().__proto__ || (r2 = false)), EventEmitter.prototype.eventNames = function eventNames() {
          var e3, i2, s2 = [];
          if (0 === this._eventsCount)
            return s2;
          for (i2 in e3 = this._events)
            t2.call(e3, i2) && s2.push(r2 ? i2.slice(1) : i2);
          return Object.getOwnPropertySymbols ? s2.concat(Object.getOwnPropertySymbols(e3)) : s2;
        }, EventEmitter.prototype.listeners = function listeners(e3) {
          var t3 = r2 ? r2 + e3 : e3, i2 = this._events[t3];
          if (!i2)
            return [];
          if (i2.fn)
            return [i2.fn];
          for (var s2 = 0, n2 = i2.length, a2 = new Array(n2); s2 < n2; s2++)
            a2[s2] = i2[s2].fn;
          return a2;
        }, EventEmitter.prototype.listenerCount = function listenerCount(e3) {
          var t3 = r2 ? r2 + e3 : e3, i2 = this._events[t3];
          return i2 ? i2.fn ? 1 : i2.length : 0;
        }, EventEmitter.prototype.emit = function emit(e3, t3, i2, s2, n2, a2) {
          var o2 = r2 ? r2 + e3 : e3;
          if (!this._events[o2])
            return false;
          var c2, d2, l2 = this._events[o2], m2 = arguments.length;
          if (l2.fn) {
            switch (l2.once && this.removeListener(e3, l2.fn, void 0, true), m2) {
              case 1:
                return l2.fn.call(l2.context), true;
              case 2:
                return l2.fn.call(l2.context, t3), true;
              case 3:
                return l2.fn.call(l2.context, t3, i2), true;
              case 4:
                return l2.fn.call(l2.context, t3, i2, s2), true;
              case 5:
                return l2.fn.call(l2.context, t3, i2, s2, n2), true;
              case 6:
                return l2.fn.call(l2.context, t3, i2, s2, n2, a2), true;
            }
            for (d2 = 1, c2 = new Array(m2 - 1); d2 < m2; d2++)
              c2[d2 - 1] = arguments[d2];
            l2.fn.apply(l2.context, c2);
          } else {
            var p2, u2 = l2.length;
            for (d2 = 0; d2 < u2; d2++)
              switch (l2[d2].once && this.removeListener(e3, l2[d2].fn, void 0, true), m2) {
                case 1:
                  l2[d2].fn.call(l2[d2].context);
                  break;
                case 2:
                  l2[d2].fn.call(l2[d2].context, t3);
                  break;
                case 3:
                  l2[d2].fn.call(l2[d2].context, t3, i2);
                  break;
                case 4:
                  l2[d2].fn.call(l2[d2].context, t3, i2, s2);
                  break;
                default:
                  if (!c2)
                    for (p2 = 1, c2 = new Array(m2 - 1); p2 < m2; p2++)
                      c2[p2 - 1] = arguments[p2];
                  l2[d2].fn.apply(l2[d2].context, c2);
              }
          }
          return true;
        }, EventEmitter.prototype.on = function on(e3, t3, r3) {
          return addListener(this, e3, t3, r3, false);
        }, EventEmitter.prototype.once = function once(e3, t3, r3) {
          return addListener(this, e3, t3, r3, true);
        }, EventEmitter.prototype.removeListener = function removeListener(e3, t3, i2, s2) {
          var n2 = r2 ? r2 + e3 : e3;
          if (!this._events[n2])
            return this;
          if (!t3)
            return clearEvent(this, n2), this;
          var a2 = this._events[n2];
          if (a2.fn)
            a2.fn !== t3 || s2 && !a2.once || i2 && a2.context !== i2 || clearEvent(this, n2);
          else {
            for (var o2 = 0, c2 = [], d2 = a2.length; o2 < d2; o2++)
              (a2[o2].fn !== t3 || s2 && !a2[o2].once || i2 && a2[o2].context !== i2) && c2.push(a2[o2]);
            c2.length ? this._events[n2] = 1 === c2.length ? c2[0] : c2 : clearEvent(this, n2);
          }
          return this;
        }, EventEmitter.prototype.removeAllListeners = function removeAllListeners(e3) {
          var t3;
          return e3 ? (t3 = r2 ? r2 + e3 : e3, this._events[t3] && clearEvent(this, t3)) : (this._events = new Events(), this._eventsCount = 0), this;
        }, EventEmitter.prototype.off = EventEmitter.prototype.removeListener, EventEmitter.prototype.addListener = EventEmitter.prototype.on, EventEmitter.prefixed = r2, EventEmitter.EventEmitter = EventEmitter, e2.exports = EventEmitter;
      }), ne = createCommonjsModule(function(e2, t2) {
        e2.exports = function() {
          function _regeneratorRuntime() {
            _regeneratorRuntime = function() {
              return e4;
            };
            var e4 = {}, t4 = Object.prototype, r3 = t4.hasOwnProperty, i3 = "function" == typeof Symbol ? Symbol : {}, s3 = i3.iterator || "@@iterator", n2 = i3.asyncIterator || "@@asyncIterator", a2 = i3.toStringTag || "@@toStringTag";
            function define2(e5, t5, r4) {
              return Object.defineProperty(e5, t5, { value: r4, enumerable: true, configurable: true, writable: true }), e5[t5];
            }
            try {
              define2({}, "");
            } catch (e5) {
              define2 = function(e6, t5, r4) {
                return e6[t5] = r4;
              };
            }
            function wrap(e5, t5, r4, i4) {
              var s4 = t5 && t5.prototype instanceof Generator ? t5 : Generator, n3 = Object.create(s4.prototype), a3 = new Context(i4 || []);
              return n3._invoke = /* @__PURE__ */ function(e6, t6, r5) {
                var i5 = "suspendedStart";
                return function(s5, n4) {
                  if ("executing" === i5)
                    throw new Error("Generator is already running");
                  if ("completed" === i5) {
                    if ("throw" === s5)
                      throw n4;
                    return doneResult();
                  }
                  for (r5.method = s5, r5.arg = n4; ; ) {
                    var a4 = r5.delegate;
                    if (a4) {
                      var c3 = maybeInvokeDelegate(a4, r5);
                      if (c3) {
                        if (c3 === o2)
                          continue;
                        return c3;
                      }
                    }
                    if ("next" === r5.method)
                      r5.sent = r5._sent = r5.arg;
                    else if ("throw" === r5.method) {
                      if ("suspendedStart" === i5)
                        throw i5 = "completed", r5.arg;
                      r5.dispatchException(r5.arg);
                    } else
                      "return" === r5.method && r5.abrupt("return", r5.arg);
                    i5 = "executing";
                    var d3 = tryCatch(e6, t6, r5);
                    if ("normal" === d3.type) {
                      if (i5 = r5.done ? "completed" : "suspendedYield", d3.arg === o2)
                        continue;
                      return { value: d3.arg, done: r5.done };
                    }
                    "throw" === d3.type && (i5 = "completed", r5.method = "throw", r5.arg = d3.arg);
                  }
                };
              }(e5, r4, a3), n3;
            }
            function tryCatch(e5, t5, r4) {
              try {
                return { type: "normal", arg: e5.call(t5, r4) };
              } catch (e6) {
                return { type: "throw", arg: e6 };
              }
            }
            e4.wrap = wrap;
            var o2 = {};
            function Generator() {
            }
            function GeneratorFunction() {
            }
            function GeneratorFunctionPrototype() {
            }
            var c2 = {};
            define2(c2, s3, function() {
              return this;
            });
            var d2 = Object.getPrototypeOf, l2 = d2 && d2(d2(values([])));
            l2 && l2 !== t4 && r3.call(l2, s3) && (c2 = l2);
            var m2 = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c2);
            function defineIteratorMethods(e5) {
              ["next", "throw", "return"].forEach(function(t5) {
                define2(e5, t5, function(e6) {
                  return this._invoke(t5, e6);
                });
              });
            }
            function AsyncIterator(e5, t5) {
              function invoke(i5, s4, n3, a3) {
                var o3 = tryCatch(e5[i5], e5, s4);
                if ("throw" !== o3.type) {
                  var c3 = o3.arg, d3 = c3.value;
                  return d3 && "object" == typeof d3 && r3.call(d3, "__await") ? t5.resolve(d3.__await).then(function(e6) {
                    invoke("next", e6, n3, a3);
                  }, function(e6) {
                    invoke("throw", e6, n3, a3);
                  }) : t5.resolve(d3).then(function(e6) {
                    c3.value = e6, n3(c3);
                  }, function(e6) {
                    return invoke("throw", e6, n3, a3);
                  });
                }
                a3(o3.arg);
              }
              var i4;
              this._invoke = function(e6, r4) {
                function callInvokeWithMethodAndArg() {
                  return new t5(function(t6, i5) {
                    invoke(e6, r4, t6, i5);
                  });
                }
                return i4 = i4 ? i4.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
              };
            }
            function maybeInvokeDelegate(e5, t5) {
              var r4 = e5.iterator[t5.method];
              if (void 0 === r4) {
                if (t5.delegate = null, "throw" === t5.method) {
                  if (e5.iterator.return && (t5.method = "return", t5.arg = void 0, maybeInvokeDelegate(e5, t5), "throw" === t5.method))
                    return o2;
                  t5.method = "throw", t5.arg = new TypeError("The iterator does not provide a 'throw' method");
                }
                return o2;
              }
              var i4 = tryCatch(r4, e5.iterator, t5.arg);
              if ("throw" === i4.type)
                return t5.method = "throw", t5.arg = i4.arg, t5.delegate = null, o2;
              var s4 = i4.arg;
              return s4 ? s4.done ? (t5[e5.resultName] = s4.value, t5.next = e5.nextLoc, "return" !== t5.method && (t5.method = "next", t5.arg = void 0), t5.delegate = null, o2) : s4 : (t5.method = "throw", t5.arg = new TypeError("iterator result is not an object"), t5.delegate = null, o2);
            }
            function pushTryEntry(e5) {
              var t5 = { tryLoc: e5[0] };
              1 in e5 && (t5.catchLoc = e5[1]), 2 in e5 && (t5.finallyLoc = e5[2], t5.afterLoc = e5[3]), this.tryEntries.push(t5);
            }
            function resetTryEntry(e5) {
              var t5 = e5.completion || {};
              t5.type = "normal", delete t5.arg, e5.completion = t5;
            }
            function Context(e5) {
              this.tryEntries = [{ tryLoc: "root" }], e5.forEach(pushTryEntry, this), this.reset(true);
            }
            function values(e5) {
              if (e5) {
                var t5 = e5[s3];
                if (t5)
                  return t5.call(e5);
                if ("function" == typeof e5.next)
                  return e5;
                if (!isNaN(e5.length)) {
                  var i4 = -1, n3 = function next() {
                    for (; ++i4 < e5.length; )
                      if (r3.call(e5, i4))
                        return next.value = e5[i4], next.done = false, next;
                    return next.value = void 0, next.done = true, next;
                  };
                  return n3.next = n3;
                }
              }
              return { next: doneResult };
            }
            function doneResult() {
              return { value: void 0, done: true };
            }
            return GeneratorFunction.prototype = GeneratorFunctionPrototype, define2(m2, "constructor", GeneratorFunctionPrototype), define2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, a2, "GeneratorFunction"), e4.isGeneratorFunction = function(e5) {
              var t5 = "function" == typeof e5 && e5.constructor;
              return !!t5 && (t5 === GeneratorFunction || "GeneratorFunction" === (t5.displayName || t5.name));
            }, e4.mark = function(e5) {
              return Object.setPrototypeOf ? Object.setPrototypeOf(e5, GeneratorFunctionPrototype) : (e5.__proto__ = GeneratorFunctionPrototype, define2(e5, a2, "GeneratorFunction")), e5.prototype = Object.create(m2), e5;
            }, e4.awrap = function(e5) {
              return { __await: e5 };
            }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, n2, function() {
              return this;
            }), e4.AsyncIterator = AsyncIterator, e4.async = function(t5, r4, i4, s4, n3) {
              void 0 === n3 && (n3 = Promise);
              var a3 = new AsyncIterator(wrap(t5, r4, i4, s4), n3);
              return e4.isGeneratorFunction(r4) ? a3 : a3.next().then(function(e5) {
                return e5.done ? e5.value : a3.next();
              });
            }, defineIteratorMethods(m2), define2(m2, a2, "Generator"), define2(m2, s3, function() {
              return this;
            }), define2(m2, "toString", function() {
              return "[object Generator]";
            }), e4.keys = function(e5) {
              var t5 = [];
              for (var r4 in e5)
                t5.push(r4);
              return t5.reverse(), function next() {
                for (; t5.length; ) {
                  var r5 = t5.pop();
                  if (r5 in e5)
                    return next.value = r5, next.done = false, next;
                }
                return next.done = true, next;
              };
            }, e4.values = values, Context.prototype = { constructor: Context, reset: function(e5) {
              if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !e5)
                for (var t5 in this)
                  "t" === t5.charAt(0) && r3.call(this, t5) && !isNaN(+t5.slice(1)) && (this[t5] = void 0);
            }, stop: function() {
              this.done = true;
              var e5 = this.tryEntries[0].completion;
              if ("throw" === e5.type)
                throw e5.arg;
              return this.rval;
            }, dispatchException: function(e5) {
              if (this.done)
                throw e5;
              var t5 = this;
              function handle(r4, i5) {
                return n3.type = "throw", n3.arg = e5, t5.next = r4, i5 && (t5.method = "next", t5.arg = void 0), !!i5;
              }
              for (var i4 = this.tryEntries.length - 1; i4 >= 0; --i4) {
                var s4 = this.tryEntries[i4], n3 = s4.completion;
                if ("root" === s4.tryLoc)
                  return handle("end");
                if (s4.tryLoc <= this.prev) {
                  var a3 = r3.call(s4, "catchLoc"), o3 = r3.call(s4, "finallyLoc");
                  if (a3 && o3) {
                    if (this.prev < s4.catchLoc)
                      return handle(s4.catchLoc, true);
                    if (this.prev < s4.finallyLoc)
                      return handle(s4.finallyLoc);
                  } else if (a3) {
                    if (this.prev < s4.catchLoc)
                      return handle(s4.catchLoc, true);
                  } else {
                    if (!o3)
                      throw new Error("try statement without catch or finally");
                    if (this.prev < s4.finallyLoc)
                      return handle(s4.finallyLoc);
                  }
                }
              }
            }, abrupt: function(e5, t5) {
              for (var i4 = this.tryEntries.length - 1; i4 >= 0; --i4) {
                var s4 = this.tryEntries[i4];
                if (s4.tryLoc <= this.prev && r3.call(s4, "finallyLoc") && this.prev < s4.finallyLoc) {
                  var n3 = s4;
                  break;
                }
              }
              n3 && ("break" === e5 || "continue" === e5) && n3.tryLoc <= t5 && t5 <= n3.finallyLoc && (n3 = null);
              var a3 = n3 ? n3.completion : {};
              return a3.type = e5, a3.arg = t5, n3 ? (this.method = "next", this.next = n3.finallyLoc, o2) : this.complete(a3);
            }, complete: function(e5, t5) {
              if ("throw" === e5.type)
                throw e5.arg;
              return "break" === e5.type || "continue" === e5.type ? this.next = e5.arg : "return" === e5.type ? (this.rval = this.arg = e5.arg, this.method = "return", this.next = "end") : "normal" === e5.type && t5 && (this.next = t5), o2;
            }, finish: function(e5) {
              for (var t5 = this.tryEntries.length - 1; t5 >= 0; --t5) {
                var r4 = this.tryEntries[t5];
                if (r4.finallyLoc === e5)
                  return this.complete(r4.completion, r4.afterLoc), resetTryEntry(r4), o2;
              }
            }, catch: function(e5) {
              for (var t5 = this.tryEntries.length - 1; t5 >= 0; --t5) {
                var r4 = this.tryEntries[t5];
                if (r4.tryLoc === e5) {
                  var i4 = r4.completion;
                  if ("throw" === i4.type) {
                    var s4 = i4.arg;
                    resetTryEntry(r4);
                  }
                  return s4;
                }
              }
              throw new Error("illegal catch attempt");
            }, delegateYield: function(e5, t5, r4) {
              return this.delegate = { iterator: values(e5), resultName: t5, nextLoc: r4 }, "next" === this.method && (this.arg = void 0), o2;
            } }, e4;
          }
          function _typeof(e4) {
            return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e5) {
              return typeof e5;
            } : function(e5) {
              return e5 && "function" == typeof Symbol && e5.constructor === Symbol && e5 !== Symbol.prototype ? "symbol" : typeof e5;
            }, _typeof(e4);
          }
          function _classCallCheck(e4, t4) {
            if (!(e4 instanceof t4))
              throw new TypeError("Cannot call a class as a function");
          }
          function _defineProperties(e4, t4) {
            for (var r3 = 0; r3 < t4.length; r3++) {
              var i3 = t4[r3];
              i3.enumerable = i3.enumerable || false, i3.configurable = true, "value" in i3 && (i3.writable = true), Object.defineProperty(e4, i3.key, i3);
            }
          }
          function _createClass(e4, t4, r3) {
            return t4 && _defineProperties(e4.prototype, t4), r3 && _defineProperties(e4, r3), Object.defineProperty(e4, "prototype", { writable: false }), e4;
          }
          function __awaiter2(e4, t4, r3, i3) {
            function adopt(e5) {
              return e5 instanceof r3 ? e5 : new r3(function(t5) {
                t5(e5);
              });
            }
            return new (r3 || (r3 = Promise))(function(r4, s3) {
              function fulfilled(e5) {
                try {
                  step(i3.next(e5));
                } catch (e6) {
                  s3(e6);
                }
              }
              function rejected(e5) {
                try {
                  step(i3.throw(e5));
                } catch (e6) {
                  s3(e6);
                }
              }
              function step(e5) {
                e5.done ? r4(e5.value) : adopt(e5.value).then(fulfilled, rejected);
              }
              step((i3 = i3.apply(e4, t4 || [])).next());
            });
          }
          var e3 = { isDataReportEnable: true, maxSize: 100, msgListMaxSize: 1e3, cacheMaxSize: 1e3, maxDelay: 3e5, maxInterval: 3e4, minInterval: 1e4, timeout: 5e3, autoStart: true, loginFailIgnoreInterval: 72e5 }, t3 = 12, r2 = 8e3, i2 = function emptyFn() {
          }, s2 = function() {
            function Reporter(t4) {
              _classCallCheck(this, Reporter), this.isUploadEnable = true, this.serverAllowUpload = false, this.initConfigLoaded = false, this.loading = false, this.isDestroyed = false, this.reportConfig = e3, this.configPath = "dispatcher/req", this.dataReportPath = "statics/report/common/form", this.traceMsgCache = {}, this.reqRetryCount = 0, this.highPriorityMsgList = [], this.msgList = [], this.lowPriorityMsgList = [], this.cacheMsgList = [], this.lastReportTime = Date.now(), this.timer = null, this.endedAsyncMsgByModule = {}, this.lastFailLogin = {}, this.setConfig(t4), this.reportConfig.isDataReportEnable && this.reportConfig.autoStart && this.initUploadConfig();
            }
            return _createClass(Reporter, [{ key: "setConfig", value: function setConfig(e4) {
              var t4 = Object.assign({}, this.reportConfig.common, e4.common);
              this.reportConfig = Object.assign({}, this.reportConfig, e4), this.reportConfig.common = t4, this.reportConfig.common.sdk_type || (this.reportConfig.common.sdk_type = "im");
            } }, { key: "reportImmediately", value: function reportImmediately(e4, t4) {
              var r3 = this;
              this.reportConfig.isDataReportEnable && this.reportConfig.request(e4, Object.assign({ dataType: "json", method: "POST", timeout: this.reportConfig.timeout }, t4)).catch(function(e5) {
                var t5, i3;
                null === (i3 = null === (t5 = r3.reportConfig) || void 0 === t5 ? void 0 : t5.logger) || void 0 === i3 || i3.warn("Reporter immediately upload failed", e5);
              });
            } }, { key: "report", value: function report(t4, r3) {
              var i3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
              if (i3.priority || (i3.priority = this.getEventPriority(t4, r3)), this.reportConfig.isDataReportEnable && t4) {
                if ("login" === t4 && false === r3.succeed && r3.process_id) {
                  var s3 = r3.extension && r3.extension.find(function(e4) {
                    return "TCP" === e4.operation_type;
                  }), n2 = s3 && s3.target || "", a2 = r3.process_id + n2, o2 = this.lastFailLogin[a2] || 0;
                  if (r3.start_time - o2 < e3.loginFailIgnoreInterval)
                    return;
                  this.lastFailLogin[a2] = r3.start_time;
                }
                var c2 = Date.now();
                "HIGH" === i3.priority ? this.highPriorityMsgList.push({ module: t4, msg: r3, createTime: c2 }) : "NORMAL" === i3.priority ? this.msgList.push({ module: t4, msg: r3, createTime: c2 }) : "LOW" === i3.priority && this.lowPriorityMsgList.push({ module: t4, msg: r3, createTime: c2 }), this.highPriorityMsgList.length > this.reportConfig.msgListMaxSize && this.highPriorityMsgList.shift(), this.msgList.length > this.reportConfig.msgListMaxSize && this.msgList.shift(), this.lowPriorityMsgList.length > this.reportConfig.msgListMaxSize && this.lowPriorityMsgList.shift(), this.doReport();
              }
            } }, { key: "reportTraceStart", value: function reportTraceStart(e4, t4) {
              if (this.reportConfig.isDataReportEnable && e4 && !this.traceMsgCache[e4]) {
                var r3 = Object.assign(Object.assign({ start_time: Date.now() }, t4), { extension: [] });
                this.traceMsgCache[e4] = r3;
              }
            } }, { key: "reportTraceUpdate", value: function reportTraceUpdate(e4) {
            } }, { key: "reportTraceUpdateV2", value: function reportTraceUpdateV2(e4, t4, r3) {
              var i3, s3 = this;
              if (this.reportConfig.isDataReportEnable && this.traceMsgCache[e4]) {
                var n2 = this.traceMsgCache[e4].extension, a2 = n2.length, o2 = (/* @__PURE__ */ new Date()).getTime();
                0 === a2 ? t4.duration = o2 - this.traceMsgCache[e4].start_time : n2[a2 - 1].end_time ? t4.duration = o2 - n2[a2 - 1].end_time : t4.duration = o2 - this.traceMsgCache[e4].start_time, n2.push(Object.assign({ end_time: o2 }, t4));
                var c2 = n2.length - 1;
                (null == r3 ? void 0 : r3.asyncParams) && ((i3 = this.traceMsgCache[e4]).asyncPromiseArray || (i3.asyncPromiseArray = []), this.traceMsgCache[e4].asyncPromiseArray.push(r3.asyncParams.then(function(t5) {
                  s3.traceMsgCache[e4] && s3.traceMsgCache[e4].extension[c2] && Object.assign(s3.traceMsgCache[e4].extension[c2], t5);
                })));
              }
            } }, { key: "reportTraceEnd", value: function reportTraceEnd(e4) {
              var t4, r3 = this, i3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
              if (this.reportConfig.isDataReportEnable && this.traceMsgCache[e4])
                if ("nos" !== e4 || false === i3) {
                  "boolean" == typeof i3 ? this.traceMsgCache[e4].succeed = !!i3 : this.traceMsgCache[e4].state = i3, this.traceMsgCache[e4].duration = Date.now() - this.traceMsgCache[e4].start_time, this.traceMsgCache[e4].extension.forEach(function(e5) {
                    delete e5.end_time;
                  });
                  var s3 = this.traceMsgCache[e4];
                  if (this.traceMsgCache[e4] = null, s3.asyncPromiseArray) {
                    (t4 = this.endedAsyncMsgByModule)[e4] || (t4[e4] = []), this.endedAsyncMsgByModule[e4].push(s3);
                    var n2 = function asyncCallback() {
                      r3.endedAsyncMsgByModule[e4] && r3.endedAsyncMsgByModule[e4].includes(s3) && (delete s3.asyncPromiseArray, r3.report(e4, s3, { priority: r3.getEventPriority(e4, s3) }));
                    };
                    Promise.all(s3.asyncPromiseArray).then(n2).catch(n2);
                  } else
                    this.report(e4, s3, { priority: this.getEventPriority(e4, s3) });
                } else
                  this.traceMsgCache[e4] = null;
            } }, { key: "getEventPriority", value: function getEventPriority(e4, t4) {
              if ("exceptions" === e4) {
                if (0 === t4.action)
                  return "HIGH";
                if (2 === t4.action)
                  return "HIGH";
                if (1 === t4.action && 0 !== t4.exception_service)
                  return "HIGH";
              } else {
                if ("msgReceive" === e4)
                  return "LOW";
                if ("nim_api_trace" === e4)
                  return "LOW";
              }
              return "NORMAL";
            } }, { key: "reportTraceCancel", value: function reportTraceCancel(e4) {
              this.reportConfig.isDataReportEnable && (this.endedAsyncMsgByModule[e4] = [], this.traceMsgCache[e4] = null);
            } }, { key: "pause", value: function pause() {
              this.reportConfig.isDataReportEnable && (this.isUploadEnable = false);
            } }, { key: "restore", value: function restore() {
              this.reportConfig.isDataReportEnable && (this.isUploadEnable = true, this.initConfigLoaded || this.initUploadConfig());
            } }, { key: "destroy", value: function destroy() {
              var e4 = this;
              this.reportConfig.isDataReportEnable && (Object.keys(this.traceMsgCache).forEach(function(t4) {
                e4.reportTraceEnd(t4, 1);
              }), null !== this.timer && clearTimeout(this.timer), this.setConfig = i2, this.report = i2, this.reportTraceStart = i2, this.reportTraceUpdate = i2, this.reportTraceEnd = i2, this.pause = i2, this.restore = i2, this.destroy = i2, this.reqRetryCount = 0, this.cacheMsgList = [], this.traceMsgCache = {}, this.lowPriorityMsgList = [], this.msgList = [], this.highPriorityMsgList = [], this.reportConfig = {}, this.isDestroyed = true);
            } }, { key: "initUploadConfig", value: function initUploadConfig() {
              var e4, i3;
              return __awaiter2(this, void 0, void 0, _regeneratorRuntime().mark(function _callee() {
                var s3, n2, a2, o2, c2, d2 = this;
                return _regeneratorRuntime().wrap(function _callee$(l2) {
                  for (; ; )
                    switch (l2.prev = l2.next) {
                      case 0:
                        if (!this.loading) {
                          l2.next = 2;
                          break;
                        }
                        return l2.abrupt("return");
                      case 2:
                        this.loading = true, s3 = this.reportConfig.common || {}, n2 = this.reportConfig.compassDataEndpoint.split(",").map(function(e5) {
                          return "".concat(e5, "/").concat(d2.configPath);
                        }), a2 = _regeneratorRuntime().mark(function _loop(a3) {
                          return _regeneratorRuntime().wrap(function _loop$(o3) {
                            for (; ; )
                              switch (o3.prev = o3.next) {
                                case 0:
                                  if (!d2.initConfigLoaded && !d2.isDestroyed) {
                                    o3.next = 2;
                                    break;
                                  }
                                  return o3.abrupt("return", "break");
                                case 2:
                                  return o3.prev = 2, o3.next = 5, d2.reportConfig.request(n2[a3], { method: "GET", dataType: "json", params: { deviceId: s3.dev_id, sdkVer: s3.sdk_ver, platform: s3.platform, hostEnv: s3.host_env, appkey: s3.app_key }, timeout: d2.reportConfig.timeout }).then(function(e5) {
                                    var t4, r3;
                                    if (!d2.isDestroyed) {
                                      if (200 === e5.status && e5.data && 200 === e5.data.code) {
                                        d2.initConfigLoaded = true;
                                        var i4 = e5.data.data || {};
                                        d2.reportConfig.maxSize = i4.maxSize > 1e3 ? 1e3 : i4.maxSize, d2.reportConfig.maxInterval = i4.maxInterval > 1e4 ? 1e4 : i4.maxInterval, d2.reportConfig.maxInterval = i4.maxInterval < 10 ? 10 : i4.maxInterval, d2.reportConfig.minInterval = i4.minInterval < 2 ? 2 : i4.minInterval, d2.reportConfig.maxDelay = i4.maxDelay || 300, d2.reportConfig.maxInterval = 1e3 * d2.reportConfig.maxInterval, d2.reportConfig.minInterval = 1e3 * d2.reportConfig.minInterval, d2.reportConfig.maxDelay = 1e3 * d2.reportConfig.maxDelay, i4.endpoint ? d2.dataReportEndpoint = i4.endpoint : d2.dataReportEndpoint = n2[a3], d2.serverAllowUpload = true, d2.loading = false, d2.reportHeartBeat();
                                      } else
                                        200 === e5.status && (d2.initConfigLoaded = true);
                                      null === (r3 = null === (t4 = d2.reportConfig) || void 0 === t4 ? void 0 : t4.logger) || void 0 === r3 || r3.log("Get reporter upload config success");
                                    }
                                  }).catch(function(e5) {
                                    var i4, s4;
                                    d2.isDestroyed || (d2.loading = false, null === (s4 = null === (i4 = d2.reportConfig) || void 0 === i4 ? void 0 : i4.logger) || void 0 === s4 || s4.error("Get reporter upload config failed", e5), d2.reqRetryCount < t3 && (d2.reqRetryCount++, setTimeout(function() {
                                      d2.isDestroyed || d2.initUploadConfig();
                                    }, r2)));
                                  });
                                case 5:
                                  o3.next = 14;
                                  break;
                                case 7:
                                  if (o3.prev = 7, o3.t0 = o3.catch(2), !d2.isDestroyed) {
                                    o3.next = 11;
                                    break;
                                  }
                                  return o3.abrupt("return", { v: void 0 });
                                case 11:
                                  d2.loading = false, null === (i3 = null === (e4 = d2.reportConfig) || void 0 === e4 ? void 0 : e4.logger) || void 0 === i3 || i3.error("Exec reporter request failed", o3.t0), d2.reqRetryCount < t3 && (d2.reqRetryCount++, setTimeout(function() {
                                    d2.isDestroyed || d2.initUploadConfig();
                                  }, r2));
                                case 14:
                                case "end":
                                  return o3.stop();
                              }
                          }, _loop, null, [[2, 7]]);
                        }), o2 = 0;
                      case 7:
                        if (!(o2 < n2.length)) {
                          l2.next = 17;
                          break;
                        }
                        return l2.delegateYield(a2(o2), "t0", 9);
                      case 9:
                        if ("break" !== (c2 = l2.t0)) {
                          l2.next = 12;
                          break;
                        }
                        return l2.abrupt("break", 17);
                      case 12:
                        if ("object" !== _typeof(c2)) {
                          l2.next = 14;
                          break;
                        }
                        return l2.abrupt("return", c2.v);
                      case 14:
                        o2++, l2.next = 7;
                        break;
                      case 17:
                      case "end":
                        return l2.stop();
                    }
                }, _callee, this);
              }));
            } }, { key: "reportHeartBeat", value: function reportHeartBeat() {
              var e4 = this;
              this.isDestroyed || (this.timer = setTimeout(function() {
                e4.reportHeartBeat();
              }, this.reportConfig.minInterval), this.doReport());
            } }, { key: "doReport", value: function doReport() {
              if (!this.isDestroyed) {
                var e4 = this.highPriorityMsgList.length + this.msgList.length + this.lowPriorityMsgList.length + this.cacheMsgList.length > 2 * this.reportConfig.maxSize ? this.reportConfig.minInterval : this.reportConfig.maxInterval;
                Date.now() - this.lastReportTime >= e4 && this.upload();
              }
            } }, { key: "getUploadMsg", value: function getUploadMsg() {
              var e4 = this, t4 = {}, r3 = Date.now();
              this.highPriorityMsgList = this.highPriorityMsgList.filter(function(t5) {
                return r3 - t5.createTime < e4.reportConfig.maxDelay;
              }), this.msgList = this.msgList.filter(function(t5) {
                return r3 - t5.createTime < e4.reportConfig.maxDelay;
              }), this.lowPriorityMsgList = this.lowPriorityMsgList.filter(function(t5) {
                return r3 - t5.createTime < e4.reportConfig.maxDelay;
              }), this.cacheMsgList = this.cacheMsgList.filter(function(t5) {
                return r3 - t5.createTime < e4.reportConfig.maxDelay;
              });
              var i3 = this.highPriorityMsgList.slice(0, this.reportConfig.maxSize);
              if (this.highPriorityMsgList = this.highPriorityMsgList.slice(i3.length), i3.length < this.reportConfig.maxSize) {
                var s3 = this.reportConfig.maxSize - i3.length;
                i3 = i3.concat(this.msgList.slice(0, s3)), this.msgList = this.msgList.slice(s3);
              }
              if (i3.length < this.reportConfig.maxSize) {
                var n2 = this.reportConfig.maxSize - i3.length;
                i3 = i3.concat(this.lowPriorityMsgList.slice(0, n2)), this.lowPriorityMsgList = this.lowPriorityMsgList.slice(n2);
              }
              if (i3.length < this.reportConfig.maxSize) {
                var a2 = this.reportConfig.maxSize - i3.length;
                i3 = i3.concat(this.cacheMsgList.slice(0, a2)), this.cacheMsgList = this.cacheMsgList.slice(a2);
              }
              return i3.forEach(function(e5) {
                t4[e5.module] ? t4[e5.module].push(e5.msg) : t4[e5.module] = [e5.msg];
              }), { uploadMsgArr: i3, uploadMsg: t4 };
            } }, { key: "upload", value: function upload() {
              var e4, t4, r3 = this;
              if (this.isUploadEnable && this.serverAllowUpload && !(this.lastReportTime && Date.now() - this.lastReportTime < this.reportConfig.minInterval)) {
                var i3 = this.getUploadMsg(), s3 = i3.uploadMsgArr, n2 = i3.uploadMsg;
                if (s3.length) {
                  this.lastReportTime = Date.now();
                  try {
                    var a2 = "".concat(this.dataReportEndpoint, "/").concat(this.dataReportPath);
                    this.reportConfig.request(a2, { dataType: "json", method: "POST", data: { common: this.reportConfig.common, event: n2 }, headers: { sdktype: "im" }, timeout: this.reportConfig.timeout }).catch(function(e5) {
                      var t5, i4;
                      r3.cacheMsgList = r3.cacheMsgList.concat(s3).slice(0, r3.reportConfig.cacheMaxSize), null === (i4 = null === (t5 = r3.reportConfig) || void 0 === t5 ? void 0 : t5.logger) || void 0 === i4 || i4.warn("Reporter upload failed", e5);
                    });
                  } catch (r4) {
                    null === (t4 = null === (e4 = this.reportConfig) || void 0 === e4 ? void 0 : e4.logger) || void 0 === t4 || t4.warn("Exec reporter request failed", r4);
                  }
                  clearTimeout(this.timer), this.reportHeartBeat();
                }
              }
            } }]), Reporter;
          }();
          return s2;
        }();
      });
      !function(e2) {
        e2[e2.V2NIM_DATA_SYNC_TYPE_LEVEL_FULL = 0] = "V2NIM_DATA_SYNC_TYPE_LEVEL_FULL", e2[e2.V2NIM_DATA_SYNC_TYPE_LEVEL_BASIC = 1] = "V2NIM_DATA_SYNC_TYPE_LEVEL_BASIC";
      }(t || (t = {})), function(e2) {
        e2[e2.V2NIM_DATA_SYNC_TYPE_MAIN = 1] = "V2NIM_DATA_SYNC_TYPE_MAIN", e2[e2.V2NIM_DATA_SYNC_TYPE_TEAM_MEMBER = 2] = "V2NIM_DATA_SYNC_TYPE_TEAM_MEMBER", e2[e2.V2NIM_DATA_SYNC_TYPE_SUPER_TEAM_MEMBER = 3] = "V2NIM_DATA_SYNC_TYPE_SUPER_TEAM_MEMBER";
      }(r || (r = {})), function(e2) {
        e2[e2.V2NIM_DATA_SYNC_STATE_WAITING = 1] = "V2NIM_DATA_SYNC_STATE_WAITING", e2[e2.V2NIM_DATA_SYNC_STATE_SYNCING = 2] = "V2NIM_DATA_SYNC_STATE_SYNCING", e2[e2.V2NIM_DATA_SYNC_STATE_COMPLETED = 3] = "V2NIM_DATA_SYNC_STATE_COMPLETED";
      }(i || (i = {})), function(e2) {
        e2[e2.V2NIM_CONVERSATION_TYPE_UNKNOWN = 0] = "V2NIM_CONVERSATION_TYPE_UNKNOWN", e2[e2.V2NIM_CONVERSATION_TYPE_P2P = 1] = "V2NIM_CONVERSATION_TYPE_P2P", e2[e2.V2NIM_CONVERSATION_TYPE_TEAM = 2] = "V2NIM_CONVERSATION_TYPE_TEAM", e2[e2.V2NIM_CONVERSATION_TYPE_SUPER_TEAM = 3] = "V2NIM_CONVERSATION_TYPE_SUPER_TEAM";
      }(s || (s = {})), function(e2) {
        e2[e2.V2NIM_MESSAGE_STATUS_DEFAULT = 0] = "V2NIM_MESSAGE_STATUS_DEFAULT", e2[e2.V2NIM_MESSAGE_STATUS_REVOKE = 1] = "V2NIM_MESSAGE_STATUS_REVOKE", e2[e2.V2NIM_MESSAGE_STATUS_BACKFILL = 2] = "V2NIM_MESSAGE_STATUS_BACKFILL";
      }(n || (n = {})), function(e2) {
        e2[e2.V2NIM_FRIEND_MODE_TYPE_ADD = 1] = "V2NIM_FRIEND_MODE_TYPE_ADD", e2[e2.V2NIM_FRIEND_MODE_TYPE_APPLY = 2] = "V2NIM_FRIEND_MODE_TYPE_APPLY";
      }(a || (a = {})), function(e2) {
        e2[e2.V2NIM_FRIEND_ADD_APPLICATION_TYPE_RECEIVED = 1] = "V2NIM_FRIEND_ADD_APPLICATION_TYPE_RECEIVED", e2[e2.V2NIM_FRIEND_ADD_APPLICATION_TYPE_REJECTED = 2] = "V2NIM_FRIEND_ADD_APPLICATION_TYPE_REJECTED";
      }(o || (o = {})), function(e2) {
        e2[e2.V2NIM_FRIEND_ADD_APPLICATION_STATUS_INIT = 0] = "V2NIM_FRIEND_ADD_APPLICATION_STATUS_INIT", e2[e2.V2NIM_FRIEND_ADD_APPLICATION_STATUS_AGREED = 1] = "V2NIM_FRIEND_ADD_APPLICATION_STATUS_AGREED", e2[e2.V2NIM_FRIEND_ADD_APPLICATION_STATUS_REJECTED = 2] = "V2NIM_FRIEND_ADD_APPLICATION_STATUS_REJECTED", e2[e2.V2NIM_FRIEND_ADD_APPLICATION_STATUS_EXPIRED = 3] = "V2NIM_FRIEND_ADD_APPLICATION_STATUS_EXPIRED", e2[e2.V2NIM_FRIEND_ADD_APPLICATION_STATUS_DIRECT_ADD = 4] = "V2NIM_FRIEND_ADD_APPLICATION_STATUS_DIRECT_ADD";
      }(c || (c = {})), function(e2) {
        e2[e2.V2NIM_FRIEND_DELETION_TYPE_BY_SELF = 1] = "V2NIM_FRIEND_DELETION_TYPE_BY_SELF", e2[e2.V2NIM_FRIEND_DELETION_TYPE_BY_PEER = 2] = "V2NIM_FRIEND_DELETION_TYPE_BY_PEER";
      }(d || (d = {})), function(e2) {
        e2[e2.V2NIM_FRIEND_VERIFY_TYPE_ADD = 1] = "V2NIM_FRIEND_VERIFY_TYPE_ADD", e2[e2.V2NIM_FRIEND_VERIFY_TYPE_APPLY = 2] = "V2NIM_FRIEND_VERIFY_TYPE_APPLY", e2[e2.V2NIM_FRIEND_VERIFY_TYPE_ACCEPT = 3] = "V2NIM_FRIEND_VERIFY_TYPE_ACCEPT", e2[e2.V2NIM_FRIEND_VERIFY_TYPE_REJECT = 4] = "V2NIM_FRIEND_VERIFY_TYPE_REJECT";
      }(l || (l = {})), function(e2) {
        e2[e2.V2NIM_LOGIN_AUTH_TYPE_DEFAULT = 0] = "V2NIM_LOGIN_AUTH_TYPE_DEFAULT", e2[e2.V2NIM_LOGIN_AUTH_TYPE_DYNAMIC_TOKEN = 1] = "V2NIM_LOGIN_AUTH_TYPE_DYNAMIC_TOKEN", e2[e2.V2NIM_LOGIN_AUTH_TYPE_THIRD_PARTY = 2] = "V2NIM_LOGIN_AUTH_TYPE_THIRD_PARTY";
      }(m || (m = {})), function(e2) {
        e2[e2.V2NIM_LOGIN_STATUS_LOGOUT = 0] = "V2NIM_LOGIN_STATUS_LOGOUT", e2[e2.V2NIM_LOGIN_STATUS_LOGINED = 1] = "V2NIM_LOGIN_STATUS_LOGINED", e2[e2.V2NIM_LOGIN_STATUS_LOGINING = 2] = "V2NIM_LOGIN_STATUS_LOGINING", e2[e2.V2NIM_LOGIN_STATUS_UNLOGIN = 3] = "V2NIM_LOGIN_STATUS_UNLOGIN";
      }(p || (p = {})), function(e2) {
        e2[e2.V2NIM_LOGIN_CLIENT_TYPE_UNKNOWN = 0] = "V2NIM_LOGIN_CLIENT_TYPE_UNKNOWN", e2[e2.V2NIM_LOGIN_CLIENT_TYPE_ANDROID = 1] = "V2NIM_LOGIN_CLIENT_TYPE_ANDROID", e2[e2.V2NIM_LOGIN_CLIENT_TYPE_IOS = 2] = "V2NIM_LOGIN_CLIENT_TYPE_IOS", e2[e2.V2NIM_LOGIN_CLIENT_TYPE_PC = 4] = "V2NIM_LOGIN_CLIENT_TYPE_PC", e2[e2.V2NIM_LOGIN_CLIENT_TYPE_WP = 8] = "V2NIM_LOGIN_CLIENT_TYPE_WP", e2[e2.V2NIM_LOGIN_CLIENT_TYPE_WEB = 16] = "V2NIM_LOGIN_CLIENT_TYPE_WEB", e2[e2.V2NIM_LOGIN_CLIENT_TYPE_RESTFUL = 32] = "V2NIM_LOGIN_CLIENT_TYPE_RESTFUL", e2[e2.V2NIM_LOGIN_CLIENT_TYPE_MAC_OS = 64] = "V2NIM_LOGIN_CLIENT_TYPE_MAC_OS", e2[e2.V2NIM_LOGIN_CLIENT_TYPE_HARMONY_OS = 65] = "V2NIM_LOGIN_CLIENT_TYPE_HARMONY_OS";
      }(u || (u = {})), function(e2) {
        e2[e2.V2NIM_KICKED_OFFLINE_REASON_CLIENT_EXCLUSIVE = 1] = "V2NIM_KICKED_OFFLINE_REASON_CLIENT_EXCLUSIVE", e2[e2.V2NIM_KICKED_OFFLINE_REASON_SERVER = 2] = "V2NIM_KICKED_OFFLINE_REASON_SERVER", e2[e2.V2NIM_KICKED_OFFLINE_REASON_CLIENT = 3] = "V2NIM_KICKED_OFFLINE_REASON_CLIENT", e2[e2.V2NIM_KICKED_OFFLINE_REASON_CLIENT_QUIETLY = 4] = "V2NIM_KICKED_OFFLINE_REASON_CLIENT_QUIETLY";
      }(h || (h = {})), function(e2) {
        e2[e2.V2NIM_LOGIN_CLIENT_CHANGE_LIST = 1] = "V2NIM_LOGIN_CLIENT_CHANGE_LIST", e2[e2.V2NIM_LOGIN_CLIENT_CHANGE_LOGIN = 2] = "V2NIM_LOGIN_CLIENT_CHANGE_LOGIN", e2[e2.V2NIM_LOGIN_CLIENT_CHANGE_LOGOUT = 3] = "V2NIM_LOGIN_CLIENT_CHANGE_LOGOUT";
      }(g || (g = {})), function(e2) {
        e2[e2.V2NIM_CONNECT_STATUS_DISCONNECTED = 0] = "V2NIM_CONNECT_STATUS_DISCONNECTED", e2[e2.V2NIM_CONNECT_STATUS_CONNECTED = 1] = "V2NIM_CONNECT_STATUS_CONNECTED", e2[e2.V2NIM_CONNECT_STATUS_CONNECTING = 2] = "V2NIM_CONNECT_STATUS_CONNECTING", e2[e2.V2NIM_CONNECT_STATUS_WAITING = 3] = "V2NIM_CONNECT_STATUS_WAITING";
      }(v || (v = {})), function(e2) {
        e2[e2.NIM_MESSAGE_AI_STREAM_STATUS_STREAMING = -1] = "NIM_MESSAGE_AI_STREAM_STATUS_STREAMING", e2[e2.NIM_MESSAGE_AI_STREAM_STATUS_NONE = 0] = "NIM_MESSAGE_AI_STREAM_STATUS_NONE", e2[e2.NIM_MESSAGE_AI_STREAM_STATUS_PLACEHOLDER = 1] = "NIM_MESSAGE_AI_STREAM_STATUS_PLACEHOLDER", e2[e2.NIM_MESSAGE_AI_STREAM_STATUS_CANCEL = 2] = "NIM_MESSAGE_AI_STREAM_STATUS_CANCEL", e2[e2.NIM_MESSAGE_AI_STREAM_STATUS_UPDATE = 3] = "NIM_MESSAGE_AI_STREAM_STATUS_UPDATE", e2[e2.NIM_MESSAGE_AI_STREAM_STATUS_COMPLETE = 4] = "NIM_MESSAGE_AI_STREAM_STATUS_COMPLETE", e2[e2.NIM_MESSAGE_AI_STREAM_STATUS_EXCEPTION = 5] = "NIM_MESSAGE_AI_STREAM_STATUS_EXCEPTION";
      }(y || (y = {})), function(e2) {
        e2[e2.V2NIM_MESSAGE_AI_STREAM_STOP_OP_DEFAULT = 0] = "V2NIM_MESSAGE_AI_STREAM_STOP_OP_DEFAULT", e2[e2.V2NIM_MESSAGE_AI_STREAM_STOP_OP_REVOKE = 1] = "V2NIM_MESSAGE_AI_STREAM_STOP_OP_REVOKE", e2[e2.V2NIM_MESSAGE_AI_STREAM_STOP_OP_UPDATE = 2] = "V2NIM_MESSAGE_AI_STREAM_STOP_OP_UPDATE";
      }(f || (f = {})), function(e2) {
        e2[e2.V2NIM_MESSAGE_AI_REGEN_OP_UPDATE = 1] = "V2NIM_MESSAGE_AI_REGEN_OP_UPDATE", e2[e2.V2NIM_MESSAGE_AI_REGEN_OP_NEW = 2] = "V2NIM_MESSAGE_AI_REGEN_OP_NEW";
      }(I || (I = {})), function(e2) {
        e2[e2.V2NIM_MESSAGE_AI_STATUS_UNKNOW = 0] = "V2NIM_MESSAGE_AI_STATUS_UNKNOW", e2[e2.V2NIM_MESSAGE_AI_STATUS_AT = 1] = "V2NIM_MESSAGE_AI_STATUS_AT", e2[e2.V2NIM_MESSAGE_AI_STATUS_RESPONSE = 2] = "V2NIM_MESSAGE_AI_STATUS_RESPONSE";
      }(M || (M = {})), function(e2) {
        e2[e2.V2NIM_MESSAGE_TYPE_INVALID = -1] = "V2NIM_MESSAGE_TYPE_INVALID", e2[e2.V2NIM_MESSAGE_TYPE_TEXT = 0] = "V2NIM_MESSAGE_TYPE_TEXT", e2[e2.V2NIM_MESSAGE_TYPE_IMAGE = 1] = "V2NIM_MESSAGE_TYPE_IMAGE", e2[e2.V2NIM_MESSAGE_TYPE_AUDIO = 2] = "V2NIM_MESSAGE_TYPE_AUDIO", e2[e2.V2NIM_MESSAGE_TYPE_VIDEO = 3] = "V2NIM_MESSAGE_TYPE_VIDEO", e2[e2.V2NIM_MESSAGE_TYPE_LOCATION = 4] = "V2NIM_MESSAGE_TYPE_LOCATION", e2[e2.V2NIM_MESSAGE_TYPE_NOTIFICATION = 5] = "V2NIM_MESSAGE_TYPE_NOTIFICATION", e2[e2.V2NIM_MESSAGE_TYPE_FILE = 6] = "V2NIM_MESSAGE_TYPE_FILE", e2[e2.V2NIM_MESSAGE_TYPE_AVCHAT = 7] = "V2NIM_MESSAGE_TYPE_AVCHAT", e2[e2.V2NIM_MESSAGE_TYPE_TIPS = 10] = "V2NIM_MESSAGE_TYPE_TIPS", e2[e2.V2NIM_MESSAGE_TYPE_ROBOT = 11] = "V2NIM_MESSAGE_TYPE_ROBOT", e2[e2.V2NIM_MESSAGE_TYPE_CALL = 12] = "V2NIM_MESSAGE_TYPE_CALL", e2[e2.V2NIM_MESSAGE_TYPE_CUSTOM = 100] = "V2NIM_MESSAGE_TYPE_CUSTOM";
      }(S || (S = {})), function(e2) {
        e2[e2.V2NIM_SEARCH_KEYWORD_MATCH_TYPE_OR = 0] = "V2NIM_SEARCH_KEYWORD_MATCH_TYPE_OR", e2[e2.V2NIM_SEARCH_KEYWORD_MATCH_TYPE_AND = 1] = "V2NIM_SEARCH_KEYWORD_MATCH_TYPE_AND";
      }(T || (T = {})), function(e2) {
        e2[e2.V2NIM_SEARCH_DIRECTION_BACKWARD = 0] = "V2NIM_SEARCH_DIRECTION_BACKWARD", e2[e2.V2NIM_SEARCH_DIRECTION_FORWARD = 1] = "V2NIM_SEARCH_DIRECTION_FORWARD";
      }(_ || (_ = {})), function(e2) {
        e2[e2.V2NIM_MESSAGE_NOTIFICATION_TYPE_UNDEFINED = -1] = "V2NIM_MESSAGE_NOTIFICATION_TYPE_UNDEFINED", e2[e2.V2NIM_MESSAGE_NOTIFICATION_TYPE_TEAM_INVITE = 0] = "V2NIM_MESSAGE_NOTIFICATION_TYPE_TEAM_INVITE", e2[e2.V2NIM_MESSAGE_NOTIFICATION_TYPE_TEAM_KICK = 1] = "V2NIM_MESSAGE_NOTIFICATION_TYPE_TEAM_KICK", e2[e2.V2NIM_MESSAGE_NOTIFICATION_TYPE_TEAM_LEAVE = 2] = "V2NIM_MESSAGE_NOTIFICATION_TYPE_TEAM_LEAVE", e2[e2.V2NIM_MESSAGE_NOTIFICATION_TYPE_TEAM_UPDATE_TINFO = 3] = "V2NIM_MESSAGE_NOTIFICATION_TYPE_TEAM_UPDATE_TINFO", e2[e2.V2NIM_MESSAGE_NOTIFICATION_TYPE_TEAM_DISMISS = 4] = "V2NIM_MESSAGE_NOTIFICATION_TYPE_TEAM_DISMISS", e2[e2.V2NIM_MESSAGE_NOTIFICATION_TYPE_TEAM_APPLY_PASS = 5] = "V2NIM_MESSAGE_NOTIFICATION_TYPE_TEAM_APPLY_PASS", e2[e2.V2NIM_MESSAGE_NOTIFICATION_TYPE_TEAM_OWNER_TRANSFER = 6] = "V2NIM_MESSAGE_NOTIFICATION_TYPE_TEAM_OWNER_TRANSFER", e2[e2.V2NIM_MESSAGE_NOTIFICATION_TYPE_TEAM_ADD_MANAGER = 7] = "V2NIM_MESSAGE_NOTIFICATION_TYPE_TEAM_ADD_MANAGER", e2[e2.V2NIM_MESSAGE_NOTIFICATION_TYPE_TEAM_REMOVE_MANAGER = 8] = "V2NIM_MESSAGE_NOTIFICATION_TYPE_TEAM_REMOVE_MANAGER", e2[e2.V2NIM_MESSAGE_NOTIFICATION_TYPE_TEAM_INVITE_ACCEPT = 9] = "V2NIM_MESSAGE_NOTIFICATION_TYPE_TEAM_INVITE_ACCEPT", e2[e2.V2NIM_MESSAGE_NOTIFICATION_TYPE_TEAM_BANNED_TEAM_MEMBER = 10] = "V2NIM_MESSAGE_NOTIFICATION_TYPE_TEAM_BANNED_TEAM_MEMBER", e2[e2.V2NIM_MESSAGE_NOTIFICATION_TYPE_SUPER_TEAM_INVITE = 401] = "V2NIM_MESSAGE_NOTIFICATION_TYPE_SUPER_TEAM_INVITE", e2[e2.V2NIM_MESSAGE_NOTIFICATION_TYPE_SUPER_TEAM_KICK = 402] = "V2NIM_MESSAGE_NOTIFICATION_TYPE_SUPER_TEAM_KICK", e2[e2.V2NIM_MESSAGE_NOTIFICATION_TYPE_SUPER_TEAM_LEAVE = 403] = "V2NIM_MESSAGE_NOTIFICATION_TYPE_SUPER_TEAM_LEAVE", e2[e2.V2NIM_MESSAGE_NOTIFICATION_TYPE_SUPER_TEAM_UPDATE_TINFO = 404] = "V2NIM_MESSAGE_NOTIFICATION_TYPE_SUPER_TEAM_UPDATE_TINFO", e2[e2.V2NIM_MESSAGE_NOTIFICATION_TYPE_SUPER_TEAM_DISMISS = 405] = "V2NIM_MESSAGE_NOTIFICATION_TYPE_SUPER_TEAM_DISMISS", e2[e2.V2NIM_MESSAGE_NOTIFICATION_TYPE_SUPER_TEAM_APPLY_PASS = 410] = "V2NIM_MESSAGE_NOTIFICATION_TYPE_SUPER_TEAM_APPLY_PASS", e2[e2.V2NIM_MESSAGE_NOTIFICATION_TYPE_SUPER_TEAM_OWNER_TRANSFER = 406] = "V2NIM_MESSAGE_NOTIFICATION_TYPE_SUPER_TEAM_OWNER_TRANSFER", e2[e2.V2NIM_MESSAGE_NOTIFICATION_TYPE_SUPER_TEAM_ADD_MANAGER = 407] = "V2NIM_MESSAGE_NOTIFICATION_TYPE_SUPER_TEAM_ADD_MANAGER", e2[e2.V2NIM_MESSAGE_NOTIFICATION_TYPE_SUPER_TEAM_REMOVE_MANAGER = 408] = "V2NIM_MESSAGE_NOTIFICATION_TYPE_SUPER_TEAM_REMOVE_MANAGER", e2[e2.V2NIM_MESSAGE_NOTIFICATION_TYPE_SUPER_TEAM_INVITE_ACCEPT = 411] = "V2NIM_MESSAGE_NOTIFICATION_TYPE_SUPER_TEAM_INVITE_ACCEPT", e2[e2.V2NIM_MESSAGE_NOTIFICATION_TYPE_SUPER_TEAM_BANNED_TEAM_MEMBER = 409] = "V2NIM_MESSAGE_NOTIFICATION_TYPE_SUPER_TEAM_BANNED_TEAM_MEMBER";
      }(C || (C = {})), function(e2) {
        e2[e2.V2NIM_MESSAGE_ATTACHMENT_UPLOAD_STATE_UNKNOWN = 0] = "V2NIM_MESSAGE_ATTACHMENT_UPLOAD_STATE_UNKNOWN", e2[e2.V2NIM_MESSAGE_ATTACHMENT_UPLOAD_STATE_SUCCESS = 1] = "V2NIM_MESSAGE_ATTACHMENT_UPLOAD_STATE_SUCCESS", e2[e2.V2NIM_MESSAGE_ATTACHMENT_UPLOAD_STATE_FAILED = 2] = "V2NIM_MESSAGE_ATTACHMENT_UPLOAD_STATE_FAILED", e2[e2.V2NIM_MESSAGE_ATTACHMENT_UPLOAD_STATE_UPLOADING = 3] = "V2NIM_MESSAGE_ATTACHMENT_UPLOAD_STATE_UPLOADING";
      }(E || (E = {})), function(e2) {
        e2[e2.V2NIM_MESSAGE_SENDING_STATE_UNKNOWN = 0] = "V2NIM_MESSAGE_SENDING_STATE_UNKNOWN", e2[e2.V2NIM_MESSAGE_SENDING_STATE_SUCCEEDED = 1] = "V2NIM_MESSAGE_SENDING_STATE_SUCCEEDED", e2[e2.V2NIM_MESSAGE_SENDING_STATE_FAILED = 2] = "V2NIM_MESSAGE_SENDING_STATE_FAILED", e2[e2.V2NIM_MESSAGE_SENDING_STATE_SENDING = 3] = "V2NIM_MESSAGE_SENDING_STATE_SENDING";
      }(b || (b = {})), function(e2) {
        e2[e2.V2NIM_QUERY_DIRECTION_DESC = 0] = "V2NIM_QUERY_DIRECTION_DESC", e2[e2.V2NIM_QUERY_DIRECTION_ASC = 1] = "V2NIM_QUERY_DIRECTION_ASC";
      }(R || (R = {})), function(e2) {
        e2[e2.V2NIM_CLEAR_HISTORY_MODE_ALL = 0] = "V2NIM_CLEAR_HISTORY_MODE_ALL", e2[e2.V2NIM_CLEAR_HISTORY_MODE_LOCAL = 1] = "V2NIM_CLEAR_HISTORY_MODE_LOCAL", e2[e2.V2NIM_CLEAR_HISTORY_MODE_LOCAL_IRREPARABLY = 2] = "V2NIM_CLEAR_HISTORY_MODE_LOCAL_IRREPARABLY";
      }(N || (N = {})), function(e2) {
        e2[e2.V2NIM_MESSAGE_REVOKE_TYPE_UNDEFINED = 0] = "V2NIM_MESSAGE_REVOKE_TYPE_UNDEFINED", e2[e2.V2NIM_MESSAGE_REVOKE_TYPE_P2P_BOTHWAY = 1] = "V2NIM_MESSAGE_REVOKE_TYPE_P2P_BOTHWAY", e2[e2.V2NIM_MESSAGE_REVOKE_TYPE_TEAM_BOTHWAY = 2] = "V2NIM_MESSAGE_REVOKE_TYPE_TEAM_BOTHWAY", e2[e2.V2NIM_MESSAGE_REVOKE_TYPE_SUPERTEAM_BOTHWAY = 3] = "V2NIM_MESSAGE_REVOKE_TYPE_SUPERTEAM_BOTHWAY", e2[e2.V2NIM_MESSAGE_REVOKE_TYPE_P2P_ONEWAY = 4] = "V2NIM_MESSAGE_REVOKE_TYPE_P2P_ONEWAY", e2[e2.V2NIM_MESSAGE_REVOKE_TYPE_TEAM_ONEWAY = 5] = "V2NIM_MESSAGE_REVOKE_TYPE_TEAM_ONEWAY";
      }(A || (A = {})), function(e2) {
        e2[e2.V2NIM_MESSAGE_PIN_STATE_NOT_PINNED = 0] = "V2NIM_MESSAGE_PIN_STATE_NOT_PINNED", e2[e2.V2NIM_MESSAGE_PIN_STATE_PINNED = 1] = "V2NIM_MESSAGE_PIN_STATE_PINNED", e2[e2.V2NIM_MESSAGE_PIN_STATE_UPDATED = 2] = "V2NIM_MESSAGE_PIN_STATE_UPDATED";
      }(O || (O = {})), function(e2) {
        e2[e2.V2NIM_QUICK_COMMENT_STATE_ADD = 1] = "V2NIM_QUICK_COMMENT_STATE_ADD", e2[e2.V2NIM_QUICK_COMMENT_STATE_REMOVE = 2] = "V2NIM_QUICK_COMMENT_STATE_REMOVE";
      }(k || (k = {})), function(e2) {
        e2[e2.V2NIM_CLIENT_ANTISPAM_OPERATE_NONE = 0] = "V2NIM_CLIENT_ANTISPAM_OPERATE_NONE", e2[e2.V2NIM_CLIENT_ANTISPAM_OPERATE_REPLACE = 1] = "V2NIM_CLIENT_ANTISPAM_OPERATE_REPLACE", e2[e2.V2NIM_CLIENT_ANTISPAM_OPERATE_CLIENT_SHIELD = 2] = "V2NIM_CLIENT_ANTISPAM_OPERATE_CLIENT_SHIELD", e2[e2.V2NIM_CLIENT_ANTISPAM_OPERATE_SERVER_SHIELD = 3] = "V2NIM_CLIENT_ANTISPAM_OPERATE_SERVER_SHIELD";
      }(w || (w = {})), function(e2) {
        e2[e2.V2NIM_SORT_ORDER_DESC = 0] = "V2NIM_SORT_ORDER_DESC", e2[e2.V2NIM_SORT_ORDER_ASC = 1] = "V2NIM_SORT_ORDER_ASC";
      }(P || (P = {})), function(e2) {
        e2[e2.P2P_DELETE_MSG = 7] = "P2P_DELETE_MSG", e2[e2.TEAM_DELETE_MSG = 8] = "TEAM_DELETE_MSG", e2[e2.SUPERTEAM_DELETE_MSG = 12] = "SUPERTEAM_DELETE_MSG", e2[e2.P2P_ONE_WAY_DELETE_MSG = 13] = "P2P_ONE_WAY_DELETE_MSG", e2[e2.TEAM_ONE_WAY_DELETE_MSG = 14] = "TEAM_ONE_WAY_DELETE_MSG", e2[e2.CUSTOM_P2P_MSG = 100] = "CUSTOM_P2P_MSG", e2[e2.CUSTOM_TEAM_MSG = 101] = "CUSTOM_TEAM_MSG", e2[e2.CUSTOM_SUPERTEAM_MSG = 103] = "CUSTOM_SUPERTEAM_MSG";
      }(V || (V = {})), function(e2) {
        e2[e2.NIM_MESSAGE_STREAM_STATUS_STREAMING = -1] = "NIM_MESSAGE_STREAM_STATUS_STREAMING", e2[e2.NIM_MESSAGE_STREAM_STATUS_NONE = 0] = "NIM_MESSAGE_STREAM_STATUS_NONE", e2[e2.NIM_MESSAGE_STREAM_STATUS_PLACEHOLDER = 1] = "NIM_MESSAGE_STREAM_STATUS_PLACEHOLDER", e2[e2.NIM_MESSAGE_STREAM_STATUS_CANCEL = 2] = "NIM_MESSAGE_STREAM_STATUS_CANCEL", e2[e2.NIM_MESSAGE_AI_STREAM_STATUS_UPDATE = 3] = "NIM_MESSAGE_AI_STREAM_STATUS_UPDATE", e2[e2.NIM_MESSAGE_STREAM_STATUS_COMPLETE = 4] = "NIM_MESSAGE_STREAM_STATUS_COMPLETE", e2[e2.NIM_MESSAGE_STREAM_STATUS_EXCEPTION = 5] = "NIM_MESSAGE_STREAM_STATUS_EXCEPTION";
      }(L || (L = {})), function(e2) {
        e2[e2.V2NIM_MESSAGE_SOURCE_UNKNOWN = 0] = "V2NIM_MESSAGE_SOURCE_UNKNOWN", e2[e2.V2NIM_MESSAGE_SOURCE_ONLINE = 1] = "V2NIM_MESSAGE_SOURCE_ONLINE", e2[e2.V2NIM_MESSAGE_SOURCE_OFFLINE = 2] = "V2NIM_MESSAGE_SOURCE_OFFLINE", e2[e2.V2NIM_MESSAGE_SOURCE_ROAMING = 3] = "V2NIM_MESSAGE_SOURCE_ROAMING";
      }(U || (U = {})), function(e2) {
        e2[e2.V2NIM_TEAM_MESSAGE_MUTE_MODE_OFF = 0] = "V2NIM_TEAM_MESSAGE_MUTE_MODE_OFF", e2[e2.V2NIM_TEAM_MESSAGE_MUTE_MODE_ON = 1] = "V2NIM_TEAM_MESSAGE_MUTE_MODE_ON", e2[e2.V2NIM_TEAM_MESSAGE_MUTE_MODE_NORMAL_ON = 2] = "V2NIM_TEAM_MESSAGE_MUTE_MODE_NORMAL_ON";
      }(D || (D = {})), function(e2) {
        e2[e2.V2NIM_P2P_MESSAGE_MUTE_MODE_OFF = 0] = "V2NIM_P2P_MESSAGE_MUTE_MODE_OFF", e2[e2.V2NIM_P2P_MESSAGE_MUTE_MODE_ON = 1] = "V2NIM_P2P_MESSAGE_MUTE_MODE_ON";
      }(q || (q = {})), function(e2) {
        e2[e2.V2NIM_TEAM_MEMBER_ROLE_QUERY_TYPE_ALL = 0] = "V2NIM_TEAM_MEMBER_ROLE_QUERY_TYPE_ALL", e2[e2.V2NIM_TEAM_MEMBER_ROLE_QUERY_TYPE_NORMAL = 1] = "V2NIM_TEAM_MEMBER_ROLE_QUERY_TYPE_NORMAL", e2[e2.V2NIM_TEAM_MEMBER_ROLE_QUERY_TYPE_MANAGER = 2] = "V2NIM_TEAM_MEMBER_ROLE_QUERY_TYPE_MANAGER";
      }(x || (x = {})), function(e2) {
        e2[e2.V2NIM_TEAM_TYPE_INVALID = 0] = "V2NIM_TEAM_TYPE_INVALID", e2[e2.V2NIM_TEAM_TYPE_ADVANCED = 1] = "V2NIM_TEAM_TYPE_ADVANCED", e2[e2.V2NIM_TEAM_TYPE_SUPER = 2] = "V2NIM_TEAM_TYPE_SUPER";
      }(B || (B = {})), function(e2) {
        e2[e2.V2NIM_TEAM_JOIN_MODE_FREE = 0] = "V2NIM_TEAM_JOIN_MODE_FREE", e2[e2.V2NIM_TEAM_JOIN_MODE_APPLY = 1] = "V2NIM_TEAM_JOIN_MODE_APPLY", e2[e2.V2NIM_TEAM_JOIN_MODE_INVITE = 2] = "V2NIM_TEAM_JOIN_MODE_INVITE";
      }(j || (j = {})), function(e2) {
        e2[e2.V2NIM_TEAM_AGREE_MODE_AUTH = 0] = "V2NIM_TEAM_AGREE_MODE_AUTH", e2[e2.V2NIM_TEAM_AGREE_MODE_NO_AUTH = 1] = "V2NIM_TEAM_AGREE_MODE_NO_AUTH";
      }($ || ($ = {})), function(e2) {
        e2[e2.V2NIM_TEAM_INVITE_MODE_MANAGER = 0] = "V2NIM_TEAM_INVITE_MODE_MANAGER", e2[e2.V2NIM_TEAM_INVITE_MODE_ALL = 1] = "V2NIM_TEAM_INVITE_MODE_ALL";
      }(G || (G = {})), function(e2) {
        e2[e2.V2NIM_TEAM_UPDATE_INFO_MODE_MANAGER = 0] = "V2NIM_TEAM_UPDATE_INFO_MODE_MANAGER", e2[e2.V2NIM_TEAM_UPDATE_INFO_MODE_ALL = 1] = "V2NIM_TEAM_UPDATE_INFO_MODE_ALL";
      }(H || (H = {})), function(e2) {
        e2[e2.V2NIM_TEAM_CHAT_BANNED_MODE_UNBAN = 0] = "V2NIM_TEAM_CHAT_BANNED_MODE_UNBAN", e2[e2.V2NIM_TEAM_CHAT_BANNED_MODE_BANNED_NORMAL = 1] = "V2NIM_TEAM_CHAT_BANNED_MODE_BANNED_NORMAL", e2[e2.V2NIM_TEAM_CHAT_BANNED_MODE_BANNED_ALL = 3] = "V2NIM_TEAM_CHAT_BANNED_MODE_BANNED_ALL";
      }(z || (z = {})), function(e2) {
        e2[e2.V2NIM_TEAM_UPDATE_EXTENSION_MODE_MANAGER = 0] = "V2NIM_TEAM_UPDATE_EXTENSION_MODE_MANAGER", e2[e2.V2NIM_TEAM_UPDATE_EXTENSION_MODE_ALL = 1] = "V2NIM_TEAM_UPDATE_EXTENSION_MODE_ALL";
      }(W || (W = {})), function(e2) {
        e2[e2.V2NIM_TEAM_MEMBER_ROLE_NORMAL = 0] = "V2NIM_TEAM_MEMBER_ROLE_NORMAL", e2[e2.V2NIM_TEAM_MEMBER_ROLE_OWNER = 1] = "V2NIM_TEAM_MEMBER_ROLE_OWNER", e2[e2.V2NIM_TEAM_MEMBER_ROLE_MANAGER = 2] = "V2NIM_TEAM_MEMBER_ROLE_MANAGER";
      }(K || (K = {})), function(e2) {
        e2[e2.V2NIM_TEAM_JOIN_ACTION_TYPE_APPLICATION = 0] = "V2NIM_TEAM_JOIN_ACTION_TYPE_APPLICATION", e2[e2.V2NIM_TEAM_JOIN_ACTION_TYPE_REJECT_APPLICATION = 1] = "V2NIM_TEAM_JOIN_ACTION_TYPE_REJECT_APPLICATION", e2[e2.V2NIM_TEAM_JOIN_ACTION_TYPE_INVITATION = 2] = "V2NIM_TEAM_JOIN_ACTION_TYPE_INVITATION", e2[e2.V2NIM_TEAM_JOIN_ACTION_TYPE_REJECT_INVITATION = 3] = "V2NIM_TEAM_JOIN_ACTION_TYPE_REJECT_INVITATION";
      }(Y || (Y = {})), function(e2) {
        e2[e2.V2NIM_TEAM_JOIN_ACTION_STATUS_INIT = 0] = "V2NIM_TEAM_JOIN_ACTION_STATUS_INIT", e2[e2.V2NIM_TEAM_JOIN_ACTION_STATUS_AGREED = 1] = "V2NIM_TEAM_JOIN_ACTION_STATUS_AGREED", e2[e2.V2NIM_TEAM_JOIN_ACTION_STATUS_REJECTED = 2] = "V2NIM_TEAM_JOIN_ACTION_STATUS_REJECTED", e2[e2.V2NIM_TEAM_JOIN_ACTION_STATUS_EXPIRED = 3] = "V2NIM_TEAM_JOIN_ACTION_STATUS_EXPIRED";
      }(J || (J = {})), function(e2) {
        e2[e2.teamApply = 0] = "teamApply", e2[e2.teamApplyReject = 1] = "teamApplyReject", e2[e2.teamInvite = 2] = "teamInvite", e2[e2.teamInviteReject = 3] = "teamInviteReject", e2[e2.tlistUpdate = 4] = "tlistUpdate", e2[e2.superTeamApply = 15] = "superTeamApply", e2[e2.superTeamApplyReject = 16] = "superTeamApplyReject", e2[e2.superTeamInvite = 17] = "superTeamInvite", e2[e2.superTeamInviteReject = 18] = "superTeamInviteReject";
      }(Q || (Q = {})), function(e2) {
        e2[e2.V2NIM_AI_MODEL_TYPE_UNKNOW = 0] = "V2NIM_AI_MODEL_TYPE_UNKNOW", e2[e2.V2NIM_AI_MODEL_TYPE_QWEN = 1] = "V2NIM_AI_MODEL_TYPE_QWEN", e2[e2.V2NIM_AI_MODEL_TYPE_AZURE = 2] = "V2NIM_AI_MODEL_TYPE_AZURE", e2[e2.V2NIM_AI_MODEL_TYPE_PRIVATE = 3] = "V2NIM_AI_MODEL_TYPE_PRIVATE";
      }(X || (X = {})), function(e2) {
        e2[e2.V2NIM_AI_MODEL_STREAM_CALL_STATUS_NONE = 0] = "V2NIM_AI_MODEL_STREAM_CALL_STATUS_NONE", e2[e2.V2NIM_AI_MODEL_STREAM_CALL_STATUS_CANCEL = 2] = "V2NIM_AI_MODEL_STREAM_CALL_STATUS_CANCEL", e2[e2.V2NIM_AI_MODEL_STREAM_CALL_STATUS_COMPLETE = 4] = "V2NIM_AI_MODEL_STREAM_CALL_STATUS_COMPLETE", e2[e2.V2NIM_AI_MODEL_STREAM_CALL_STATUS_EXCEPTION = 5] = "V2NIM_AI_MODEL_STREAM_CALL_STATUS_EXCEPTION";
      }(Z || (Z = {})), function(e2) {
        e2.V2NIM_AI_MODEL_ROLE_TYPE_SYSTEM = "system", e2.V2NIM_AI_MODEL_ROLE_TYPE_USER = "user", e2.V2NIM_AI_MODEL_ROLE_TYPE_ASSISTANT = "assistant";
      }(ee || (ee = {})), function(e2) {
        e2[e2.V2NIM_SIGNALLING_EVENT_TYPE_UNKNOWN = 0] = "V2NIM_SIGNALLING_EVENT_TYPE_UNKNOWN", e2[e2.V2NIM_SIGNALLING_EVENT_TYPE_CLOSE = 1] = "V2NIM_SIGNALLING_EVENT_TYPE_CLOSE", e2[e2.V2NIM_SIGNALLING_EVENT_TYPE_JOIN = 2] = "V2NIM_SIGNALLING_EVENT_TYPE_JOIN", e2[e2.V2NIM_SIGNALLING_EVENT_TYPE_INVITE = 3] = "V2NIM_SIGNALLING_EVENT_TYPE_INVITE", e2[e2.V2NIM_SIGNALLING_EVENT_TYPE_CANCEL_INVITE = 4] = "V2NIM_SIGNALLING_EVENT_TYPE_CANCEL_INVITE", e2[e2.V2NIM_SIGNALLING_EVENT_TYPE_REJECT = 5] = "V2NIM_SIGNALLING_EVENT_TYPE_REJECT", e2[e2.V2NIM_SIGNALLING_EVENT_TYPE_ACCEPT = 6] = "V2NIM_SIGNALLING_EVENT_TYPE_ACCEPT", e2[e2.V2NIM_SIGNALLING_EVENT_TYPE_LEAVE = 7] = "V2NIM_SIGNALLING_EVENT_TYPE_LEAVE", e2[e2.V2NIM_SIGNALLING_EVENT_TYPE_CONTROL = 8] = "V2NIM_SIGNALLING_EVENT_TYPE_CONTROL", e2[e2.V2NIM_SIGNALLING_EVENT_TYPE_KICK = 9] = "V2NIM_SIGNALLING_EVENT_TYPE_KICK";
      }(te || (te = {})), function(e2) {
        e2[e2.V2NIM_SIGNALLING_CHANNEL_TYPE_AUDIO = 1] = "V2NIM_SIGNALLING_CHANNEL_TYPE_AUDIO", e2[e2.V2NIM_SIGNALLING_CHANNEL_TYPE_VIDEO = 2] = "V2NIM_SIGNALLING_CHANNEL_TYPE_VIDEO", e2[e2.V2NIM_SIGNALLING_CHANNEL_TYPE_CUSTOM = 3] = "V2NIM_SIGNALLING_CHANNEL_TYPE_CUSTOM";
      }(re || (re = {})), function(e2) {
        e2[e2.V2NIM_USER_STATUS_TYPE_UNKNOWN = 0] = "V2NIM_USER_STATUS_TYPE_UNKNOWN", e2[e2.V2NIM_USER_STATUS_TYPE_LOGIN = 1] = "V2NIM_USER_STATUS_TYPE_LOGIN", e2[e2.V2NIM_USER_STATUS_TYPE_LOGOUT = 2] = "V2NIM_USER_STATUS_TYPE_LOGOUT", e2[e2.V2NIM_USER_STATUS_TYPE_DISCONNECT = 3] = "V2NIM_USER_STATUS_TYPE_DISCONNECT";
      }(ie || (ie = {}));
      var ae = { V2NIM_ERROR_CODE_UNKNOWN: { code: 0, message: "unknown error" }, V2NIM_ERROR_CODE_SUCCESS: { code: 200, message: "success" }, V2NIM_ERROR_CODE_HANDSHAKE: { code: 201, message: "handshake error" }, V2NIM_ERROR_CODE_REQUEST_TEMPERARY_FORBIDDEN: { code: 398, message: "request temprary forbidden" }, V2NIM_ERROR_CODE_SERVER_UNIT_ERROR: { code: 399, message: "server unit error" }, V2NIM_ERROR_CODE_FORBIDDEN: { code: 403, message: "forbidden" }, V2NIM_ERROR_CODE_NOT_FOUND: { code: 404, message: "not found" }, V2NIM_ERROR_CODE_PARAMETER_ERROR: { code: 414, message: "parameter error" }, V2NIM_ERROR_CODE_RATE_LIMIT_REACHED: { code: 416, message: "rate limit reached" }, V2NIM_ERROR_CODE_MULTI_LOGIN_FORBIDDEN: { code: 417, message: "multi login forbidden" }, V2NIM_ERROR_CODE_SERVER_INTERNAL_ERROR: { code: 500, message: "server internal error" }, V2NIM_ERROR_CODE_SERVER_BUSY: { code: 503, message: "server busy" }, V2NIM_ERROR_CODE_APP_UNREACHABLE: { code: 511, message: "app server unreachable" }, V2NIM_ERROR_CODE_SERVICE_UNAVAILABLE: { code: 514, message: "service unavailable" }, V2NIM_ERROR_CODE_PROTOCOL_BLACKHOLE_FILTERED: { code: 599, message: "protocol filtered by blackhole rule" }, V2NIM_ERROR_CODE_NO_PERMISSION: { code: 997, message: "appid has no permission to call the protocol" }, V2NIM_ERROR_CODE_UNPACK_ERROR: { code: 998, message: "unpack error" }, V2NIM_ERROR_CODE_PACK_ERROR: { code: 999, message: "pack error" }, V2NIM_ERROR_CODE_IM_DISABLED: { code: 101301, message: "IM disabled" }, V2NIM_ERROR_CODE_SERVICE_ADDRESS_INVALID: { code: 101302, message: "service address invalid" }, V2NIM_ERROR_CODE_APPKEY_NOT_EXIST: { code: 101303, message: "appkey not exist" }, V2NIM_ERROR_CODE_BUNDLEID_CHECK_FAILED: { code: 101304, message: "bundleid check failed" }, V2NIM_ERROR_CODE_APPKEY_BLOCKED: { code: 101403, message: "appkey blocked" }, V2NIM_ERROR_CODE_INVALID_TOKEN: { code: 102302, message: "invalid token" }, V2NIM_ERROR_CODE_ROBOT_NOT_ALLOWED: { code: 102303, message: "robot not allowed" }, V2NIM_ERROR_CODE_ACCOUNT_NOT_EXIST: { code: 102404, message: "account not exist" }, V2NIM_ERROR_CODE_ACCOUNT_CHAT_BANNED: { code: 102421, message: "account chat banned" }, V2NIM_ERROR_CODE_ACCOUNT_BANNED: { code: 102422, message: "account banned" }, V2NIM_ERROR_CODE_ACCOUNT_IN_BLOCK_LIST: { code: 102426, message: "account in block list" }, V2NIM_ERROR_CODE_USER_PROFILE_NOT_EXIST: { code: 103404, message: "user profile not exist" }, V2NIM_ERROR_CODE_USER_PROFILE_HIT_ANTISPAM: { code: 103451, message: "user profile hit antispam" }, V2NIM_ERROR_CODE_PEER_FRIEND_LIMIT: { code: 104301, message: "peer friend limit" }, V2NIM_ERROR_CODE_FRIEND_APPLICATION_NOT_EXIST: { code: 104302, message: "friend application not exist" }, V2NIM_ERROR_CODE_FRIEND_NOT_EXIST: { code: 104404, message: "friend not exist" }, V2NIM_ERROR_CODE_FRIEND_ALREADY_EXIST: { code: 104405, message: "friend already exist" }, V2NIM_ERROR_CODE_SELF_FRIEND_OPERATION_NOT_ALLOWED: { code: 104429, message: "self friend operation not allowed" }, V2NIM_ERROR_CODE_FRIEND_LIMIT: { code: 104435, message: "friend limit" }, V2NIM_ERROR_CODE_FRIEND_OPERATION_RATE_LIMIT: { code: 104449, message: "friend operation rate limit" }, V2NIM_ERROR_CODE_FRIEND_HIT_ANTISPAM: { code: 104451, message: "friend hit antispam" }, V2NIM_ERROR_CODE_SELF_MUTE_OPERATION_NOT_ALLOWED: { code: 105429, message: "self mute operation not allowed" }, V2NIM_ERROR_CODE_MUTE_LIST_LIMIT: { code: 105435, message: "mute list limit" }, V2NIM_ERROR_CODE_SELF_BLOCK_LIST_OPERATION_NOT_ALLOWED: { code: 106429, message: "self block list operation not allowed" }, V2NIM_ERROR_CODE_BLOCK_LIST_LIMIT: { code: 106435, message: "block list limit" }, V2NIM_ERROR_CODE_REVOKE_THIRD_PARTY_MESSAGE_NOT_ALLOWED: { code: 107301, message: "revoke third party message not allowed" }, V2NIM_ERROR_CODE_SHORT_TO_LONG_URL_FAILED: { code: 107307, message: "short to long URL failed" }, V2NIM_ERROR_CODE_URL_INVALID: { code: 107308, message: "URL invalid" }, V2NIM_ERROR_CODE_DURATION_OUT_OF_RANGE: { code: 107309, message: "duration out of range" }, V2NIM_ERROR_CODE_GET_FILE_META_INFO_FAILED: { code: 107310, message: "get file meta info failed" }, V2NIM_ERROR_CODE_AUDIO_FILE_SIZE_LIMIT: { code: 107311, message: "audio file size limit" }, V2NIM_ERROR_CODE_VOICE_TO_TEXT_TIMEOUT: { code: 107312, message: "voice to text timeout" }, V2NIM_ERROR_CODE_VOICE_TO_TEXT_FAILED: { code: 107313, message: "voice to text failed" }, V2NIM_ERROR_CODE_REVOKE_EXCEED_TIME_LIMIT: { code: 107314, message: "revoke message exceed time limit" }, V2NIM_ERROR_CODE_REVOKE_MESSAGE_NOT_ALLOWED: { code: 107315, message: "revoke specific message not allowed" }, V2NIM_ERROR_CODE_FORCE_PUSH_LIST_LIMIT: { code: 107316, message: "force push list limit" }, V2NIM_ERROR_CODE_TEAM_MESSAGE_RECEIPT_RATE_LIMIT: { code: 107317, message: "team message receipt rate limit" }, V2NIM_ERROR_CODE_SNAPSHOT_NOT_EXIST: { code: 107318, message: "snapshot not exist" }, V2NIM_ERROR_CODE_PIN_LIMIT: { code: 107319, message: "pin limit" }, V2NIM_ERROR_CODE_PIN_NOT_EXIST: { code: 107320, message: "pin not exist" }, V2NIM_ERROR_CODE_QUICK_COMMENT_LIMIT: { code: 107321, message: "quick comment limit" }, V2NIM_ERROR_CODE_PIN_ALREADY_EXIST: { code: 107322, message: "pin already exist" }, V2NIM_ERROR_CODE_VOICE_TO_TEXT_FUNCTION_DISABLED: { code: 107333, message: "voice to text function disabled" }, V2NIM_ERROR_CODE_CLOUD_SEARCH_FUNCTION_DISABLED: { code: 107334, message: "cloud search function disabled" }, V2NIM_ERROR_CODE_ONE_WAY_DELETE_FUNCTION_DISABLED: { code: 107335, message: "one-way delete function disabled" }, V2NIM_ERRPR_CODE_ONEWAY_DELETION_NOT_ALLOW_FOR_TARGET_MESSAGES: { code: 107338, message: "one-way deletion is not allowed for target messages" }, V2NIM_ERRPR_CODE_SENDER_CANNOT_INCLUDED_IN_TARGET_LIST: { code: 107339, message: "The message sender cannot be included in the target list" }, V2NIM_ERROR_CODE_ROBOT_CANNOT_SEND_TARGET_MESSAGE: { code: 107340, message: "Robot can not send target message" }, V2NIM_ERROR_CODE_PIN_TARGET_MESSAGE_NOT_ALLOWED: { code: 107345, message: "Pin target message is not allowed" }, V2NIM_ERROR_CODE_TARGET_MESSAGE_NOT_ALLOWED_REPLY: { code: 107346, message: "Target message not allowed reply" }, V2NIM_ERROR_CODE_TARGET_MESSAGE_NOT_ALLOWED_QUICK_COMMENT: { code: 107347, message: "Target message not allowed quick comment" }, V2NIM_ERROR_CODE_REVOKE_MESSAGE_TO_SELF_NOT_ALLOWED: { code: 107429, message: "revoke message to self not allowed" }, V2NIM_ERROR_CODE_APP_CHAT_BANNED: { code: 107410, message: "app chat banned" }, V2NIM_ERROR_CODE_QUICK_COMMENT_FUNCTION_DISABLED: { code: 107326, message: "quick comment function disabled" }, V2NIM_ERROR_CODE_PIN_FUNCTION_DISABLED: { code: 107327, message: "PIN function disabled" }, V2NIM_ERROR_CODE_TEAM_READ_RECEIPT_FUNCTION_DISABLED: { code: 107324, message: "read receipt for team messages function disabled" }, V2NIM_ERROR_CODE_P2P_READ_RECEIPT_FUNCTION_DISABLED: { code: 107325, message: "read receipt for p2p messages function disabled" }, V2NIM_ERROR_CODE_RATE_LIMIT_FOR_MESSAGING_REACHED: { code: 107323, message: "rate limit for messaging reached" }, V2NIM_ERROR_CODE_MESSAGE_HIT_ANTISPAM: { code: 107451, message: "message hit antispam" }, V2NIM_ERROR_CODE_MESSAGE_NOT_EXIST: { code: 107404, message: "message not exist" }, V2NIM_ERROR_CODE_UNSENDING_MESSAGE_EXPIRED: { code: 107406, message: "unsending message expired" }, V2NIM_ERROR_CODE_TEAM_MARK_READ_FAILED: { code: 107302, message: "sending message failed for marking message read failed for too many team members" }, V2NIM_ERROR_CODE_SENDER_OR_MANAGER_PERMISSION_ONLY_REVOKE: { code: 107303, message: "only sender or manager can revoke message" }, V2NIM_ERROR_CODE_DELETE_SELF_MESSAGE_NOT_ALLOWED: { code: 107328, message: "delete self message not allowed" }, V2NIM_ERROR_CODE_NOT_CHATBOT_ACCOUNT: { code: 107329, message: "is not chatbot account" }, V2NIM_ERROR_CODE_MESSAGE_SENSE_REQUIRED: { code: 107330, message: "sender or receiver must sense message" }, V2NIM_ERROR_CODE_HIGH_PRIORITY_MESSAGE_RATE_LIMIT: { code: 107304, message: "rate limit of high-priority messages exceeded" }, ACK_MESSAGE_BE_HIGH_PRIORITY: { code: 107305, message: "ack message should be high-priority" }, V2NIM_ERROR_CODE_DUPLICATE_CLIENT_MESSAGE_ID: { code: 107306, message: "duplicate client message ID" }, V2NIM_ERROR_CODE_INVALID_TIME_RANGE: { code: 107439, message: "invalid time range" }, V2NIM_ERROR_CODE_NOT_ADVANCED_TEAM: { code: 108302, message: "not advanced team" }, V2NIM_ERROR_CODE_TEAM_MANAGER_LIMIT: { code: 108303, message: "team manager limit" }, V2NIM_ERROR_CODE_JOINED_TEAM_LIMIT: { code: 108305, message: "joined team limit" }, V2NIM_ERROR_CODE_TEAM_NORMAL_MEMBER_CHAT_BANNED: { code: 108306, message: "team normal member chat banned" }, V2NIM_ERROR_CODE_INVITED_ACCOUNT_NOT_FRIEND: { code: 108307, message: "invited account not friend" }, V2NIM_ERROR_CODE_REJECT_ALL_TEAM_APPLICATIONS: { code: 108308, message: "reject all team applications" }, V2NIM_ERROR_CODE_TARGETING_MESSAGE_FOR_TEAM_DISABLED: { code: 108318, message: "Targeting messages for group chat is disabled" }, V2NIM_ERROR_CODE_INCLUSIVE_AS_FALSE_NOT_ALLOWED_FOR_SUPER_TEAM: { code: 108319, message: 'Setting "inclusive" to false for super teams is not allowed' }, V2NIM_ERROR_CODE_CANNOT_MAKE_SUPER_TEAM_MESSAGE_VISIBLE_TO_NEW_MEMBERS: { code: 108320, message: "Cannot make super team targeted messages visible to new members" }, V2NIM_ERROR_CODE_CANNOT_ALLOW_TARGETED_MESSAGES_INCLUSIVE_TO_NEW_MEMBERS: { code: 108321, message: "Cannot allow targeted messages inclusive to new members" }, V2NIM_ERROR_CODE_TEAM_NOT_EXIST: { code: 108404, message: "team not exist" }, V2NIM_ERROR_CODE_TEAM_ALREADY_CHAT_BANNED: { code: 108420, message: "team already chat banned" }, V2NIM_ERROR_CODE_ALL_TEAM_MEMBER_CHAT_BANNED: { code: 108423, message: "all team member chat banned" }, V2NIM_ERROR_CODE_EXTENDED_SUPER_TEAM_LIMIT: { code: 108434, message: "extended super team limit" }, V2NIM_ERROR_CODE_CREATED_TEAM_LIMIT: { code: 108435, message: "created team limit" }, V2NIM_ERROR_CODE_TEAM_INVITATION_LIMIT: { code: 108437, message: "team invitation limit" }, V2NIM_ERROR_CODE_TEAM_HIT_ANTISPAM: { code: 108451, message: "team hit antispam" }, V2NIM_ERROR_CODE_EXTENDED_SUPER_TEAM_LIMIT_NOT_CONFIGURED: { code: 108304, message: "extended super team limit not configured" }, V2NIM_ERROR_CODE_SUPER_TEAM_SERVICE_DISABLED: { code: 108311, message: "super team service disabled" }, V2NIM_ERROR_CODE_TEAM_READ_RECEIPT_RECORD_NOT_FOUND: { code: 108301, message: "read receipt record for the team message not found" }, V2NIM_ERROR_CODE_NOT_MANAGER: { code: 108430, message: "unable to assign owner manager" }, V2NIM_ERROR_CODE_ONLINE_MEMBER_COUNT_DISABLED: { code: 108406, message: "number of online users service disabled" }, V2NIM_ERROR_CODE_TRANSFER_DISABLED: { code: 108310, message: "unable to transfer the ownership to owner" }, V2NIM_ERROR_CODE_CREATE_TEAM_DISABLED: { code: 108309, message: "unable to create team with more than %s people" }, V2NIM_ERROR_CODE_EXTENDED_SUPER_TEAM_CREATE_FAILED: { code: 108313, message: "/ extended super team creation faileduse open api to create the team" }, V2NIM_ERROR_CODE_TEAM_MESSAGE_READ_RECEIPT_DISABLED: { code: 108312, message: "read receipt for team messages function disabled" }, V2NIM_ERROR_CODE_RETRY: { code: 108449, message: "an error occurred, try again" }, V2NIM_ERROR_CODE_CHAT_BAN_LIST_CONTAIN_NOT_TEAM_MEMBER: { code: 109301, message: "list of chat banned users contains non team members" }, V2NIM_ERROR_CODE_CHAT_BAN_LIST_CONTAIN_OPERATOR: { code: 109303, message: "list of chat banned users contains the operator" }, V2NIM_ERROR_CODE_CHAT_BAN_LIST_CONTAIN_TEAM_OWNER: { code: 109304, message: "list of chat banned users contains the team owner" }, V2NIM_ERROR_CODE_OPERATION_ON_TEAM_MANAGER_NOT_ALLOWED: { code: 109305, message: "operation on team manager not allowed" }, V2NIM_ERROR_CODE_NO_TEAM_INVITE_PERMISSION: { code: 109306, message: "no team invite permission" }, V2NIM_ERROR_CODE_TEAM_OWNER_QUIT_NOT_ALLOWED: { code: 109307, message: "team owner quit not allowed" }, V2NIM_ERROR_CODE_TEAM_OWNER_IN_KICK_LIST: { code: 109308, message: "list of kicked user contains the team owner" }, V2NIM_ERROR_CODE_INVITE_ROBOT_ACCOUNT_NOT_ALLOWED: { code: 109309, message: "invite robot account not allowed" }, V2NIM_ERROR_CODE_KICK_OPERATOR_NOT_ALLOWED: { code: 109310, message: "kick operator not allowed" }, V2NIM_ERROR_CODE_TEAM_MEMBER_ALREADY_EXIST: { code: 109311, message: "team member already exist" }, V2NIM_ERROR_CODE_TEAM_INVITATION_OR_APPLICATION_NOT_EXIST: { code: 109313, message: "team invitation or application not exist" }, V2NIM_ERROR_CODE_OPERATION_ON_TEAM_OWNER_NOT_ALLOWED: { code: 109314, message: "operation on team owner not allowed" }, V2NIM_ERROR_CODE_FORCED_PUSH_LIST_INCLUDES_NON_TARGETED_ACCOUNTS: { code: 109318, message: "The forced push list includes non-targeted accounts" }, V2NIM_ERROR_CODE_TEAM_MEMBER_NOT_EXIST: { code: 109404, message: "team member not exist" }, V2NIM_ERROR_CODE_TEAM_MEMBER_CHAT_BANNED: { code: 109424, message: "team member chat banned" }, V2NIM_ERROR_CODE_TEAM_OWNER_OPERATION_PERMISSION_REQUIRED: { code: 109427, message: "team owner operation permission required" }, V2NIM_ERROR_CODE_TEAM_OWNER_OR_MANAGER_OPERATION_PERMISSION_REQUIRED: { code: 109432, message: "team owner or manager operation permission required" }, V2NIM_ERROR_CODE_TEAM_MEMBER_CONCURRENT_OPERATION_FAILED: { code: 109449, message: "team member concurrent operation failed" }, V2NIM_ERROR_CODE_TEAM_MEMBER_HIT_ANTISPAM: { code: 109451, message: "team member hit antispam" }, V2NIM_ERROR_CODE_CONVERSATION_AND_ACCOUNT_MISMATCH: { code: 110302, message: "conversation and account mismatch" }, V2NIM_ERROR_CODE_CONVERSATION_STICK_TOP_LIMIT: { code: 110303, message: "conversation stick top limit" }, V2NIM_ERROR_CODE_CONVERSATION_BELONGED_GROUP_LIMIT: { code: 110304, message: "conversation belonged group limit" }, V2NIM_ERROR_CODE_CONVERSATION_IS_NOT_STICK_TOP: { code: 110305, message: "conversation is not stick top" }, V2NIM_ERROR_CODE_STICK_TOP_DISABLED: { code: 110306, message: "conversation stick top disabled" }, V2NIM_ERROR_CODE_CONVERSATION_NOT_EXIST: { code: 110404, message: "conversation not exist" }, V2NIM_ERROR_CODE_CHATROOM_LINK_UNAVAILABLE: { code: 113304, message: "chatroom link unavailable" }, V2NIM_ERROR_CODE_IM_CONNECTION_ABNORMAL: { code: 113305, message: "IM connection abnormal" }, V2NIM_ERROR_CODE_CHATROOM_NOT_EXIST: { code: 113404, message: "chatroom not exist" }, V2NIM_ERROR_CODE_CHATROOM_CLOSED: { code: 113406, message: "chatroom closed" }, V2NIM_ERROR_CODE_CHATROOM_REPEATED_OPERATION: { code: 113409, message: "chatroom repeated operation" }, V2NIM_ERROR_CODE_CHATROOM_DISABLED: { code: 113410, message: "chatroom disabled" }, V2NIM_ERROR_CODE_ALL_CHATROOM_MEMBER_CHAT_BANNED: { code: 113423, message: "all chatroom member chat banned" }, V2NIM_ERROR_CODE_CHATROOM_HIT_ANTISPAM: { code: 113451, message: "chatroom hit antispam" }, V2NIM_ERROR_CODE_ANONYMOUS_MEMBER_FORBIDDEN: { code: 114303, message: "anonymous member forbidden" }, V2NIM_ERROR_CODE_CHATROOM_MEMBER_NOT_EXIST: { code: 114404, message: "chatroom member not exist" }, V2NIM_ERROR_CODE_CHATROOM_MEMBER_REPEATED_OPERATION: { code: 114405, message: "chatroom member repeated operation" }, V2NIM_ERROR_CODE_CHATROOM_MEMBER_CHAT_BANNED: { code: 114421, message: "chatroom member chat banned" }, V2NIM_ERROR_CODE_ACCOUNT_IN_CHATROOM_BLOCK_LIST: { code: 114426, message: "account in chatroom block list" }, V2NIM_ERROR_CODE_CHATROOM_OWNER_OPERATION_PERMISSION_REQUIRED: { code: 114427, message: "chatroom owner operation permission required" }, V2NIM_ERROR_CODE_SELF_IN_CHATROOM_MEMBER_OPERATION_LIST: { code: 114429, message: "self in chatroom member operation list" }, V2NIM_ERROR_CODE_CHATROOM_OWNER_OR_MANAGER_OPERATION_PERMISSION_REQUIRED: { code: 114432, message: "chatroom owner or manager operation permission required" }, V2NIM_ERROR_CODE_CHATROOM_MEMBER_LIMIT: { code: 114437, message: "chatroom member limit" }, V2NIM_ERROR_CODE_CHATROOM_MEMBER_CONCURRENT_OPERATION_FAILED: { code: 114449, message: "chatroom member concurrent operation failed" }, V2NIM_ERROR_CODE_CHATROOM_MEMBER_HIT_ANTISPAM: { code: 114451, message: "chatroom member hit antispam" }, V2NIM_ERROR_CODE_CONVERSATION_GROUP_NOT_EXIST: { code: 116404, message: "conversation group not exist" }, V2NIM_ERROR_CODE_CONVERSATION_GROUP_LIMIT: { code: 116435, message: "conversation group limit" }, V2NIM_ERROR_CODE_CONVERSATIONS_IN_GROUP_LIMIT: { code: 116437, message: "conversations in group limit" }, V2NIM_ERROR_CODE_COLLECTION_LIMIT: { code: 189301, message: "collection limit" }, V2NIM_ERROR_CODE_COLLECTION_NOT_EXIST: { code: 189302, message: "collection not exist" }, V2NIM_ERROR_CODE_COLLECTION_CONCURRENT_OPERATION_FAILED: { code: 189449, message: "collection concurrent operation failed" }, V2NIM_ERROR_CODE_INTERNAL: { code: 190001, message: "internal error" }, V2NIM_ERROR_CODE_ILLEGAL_STATE: { code: 190002, message: "illegal state" }, V2NIM_ERROR_CODE_MISUSE: { code: 191001, message: "misuse" }, V2NIM_ERROR_CODE_CANCELLED: { code: 191002, message: "operation cancelled" }, V2NIM_ERROR_CODE_CALLBACK_FAILED: { code: 191003, message: "callback failed" }, V2NIM_ERROR_CODE_INVALID_PARAMETER: { code: 191004, message: "invalid parameter" }, V2NIM_ERROR_CODE_TIMEOUT: { code: 191005, message: "timeout" }, V2NIM_ERROR_CODE_RESOURCE_NOT_EXIST: { code: 191006, message: "resource not exist" }, V2NIM_ERROR_CODE_RESOURCE_ALREADY_EXIST: { code: 191007, message: "resource already exist" }, V2NIM_ERROR_CODE_CONNECT_FAILED: { code: 192001, message: "connect failed" }, V2NIM_ERROR_CODE_CONNECT_TIMEOUT: { code: 192002, message: "connect timeout" }, V2NIM_ERROR_CODE_DISCONNECT: { code: 192003, message: "disconnect" }, V2NIM_ERROR_CODE_PROTOCOL_TIMEOUT: { code: 192004, message: "protocol timeout" }, V2NIM_ERROR_CODE_PROTOCOL_SEND_FAILED: { code: 192005, message: "protocol send failed" }, V2NIM_ERROR_CODE_REQUEST_FAILED: { code: 192006, message: "request failed" }, V2NIM_ERROR_CODE_FILE_NOT_FOUND: { code: 194001, message: "file not found" }, V2NIM_ERROR_CODE_FILE_CREATE_FAILED: { code: 194002, message: "file create failed" }, V2NIM_ERROR_CODE_FILE_OPEN_FAILED: { code: 194003, message: "file open failed" }, V2NIM_ERROR_CODE_FILE_WRITE_FAILED: { code: 194004, message: "file write failed" }, V2NIM_ERROR_CODE_FILE_READ_FAILED: { code: 194005, message: "file read failed" }, V2NIM_ERROR_CODE_FILE_UPLOAD_FAILED: { code: 194006, message: "file upload failed" }, V2NIM_ERROR_CODE_FILE_DOWNLOAD_FAILED: { code: 194007, message: "file download failed" }, V2NIM_ERROR_CODE_CLIENT_ANTISPAM: { code: 195001, message: "client anti-spam" }, V2NIM_ERROR_CODE_SERVER_ANTISPAM: { code: 195002, message: "server anti-spam" }, V2NIM_ERROR_CODE_STREAM_OUTPUT_STOPPED: { code: 189318, message: "Streaming text response stopped" }, V2NIM_ERROR_CODE_STREAM_OUTPUT_GENERATED: { code: 189319, message: "Streaming text response generated" }, V2NIM_ERROR_CODE_STREAM_OUTPUT_ABORTED: { code: 189320, message: "Streaming text response aborted due to exception" }, V2NIM_ERROR_CODE_INTERRUPTION_REJECTED: { code: 189321, message: "Non-streaming messages cannot be interrupted" } }, oe = Object.keys(ae), ce = oe.reduce(function(e2, t2) {
        var r2 = ae[t2];
        return e2[t2] = r2.code, e2;
      }, {}), de = oe.reduce(function(e2, t2) {
        var r2 = ae[t2];
        return e2[r2.code] = r2.message, e2;
      }, {}), le = Object.freeze({ __proto__: null, V2NIMErrorCode: ce, V2NIMErrorDesc: de, get V2NIMDataSyncLevel() {
        return t;
      }, get V2NIMDataSyncType() {
        return r;
      }, get V2NIMDataSyncState() {
        return i;
      }, get V2NIMConversationType() {
        return s;
      }, get V2NIMLastMessageState() {
        return n;
      }, get V2NIMFriendAddMode() {
        return a;
      }, get V2NIMFriendAddApplicationType() {
        return o;
      }, get V2NIMFriendAddApplicationStatus() {
        return c;
      }, get V2NIMFriendDeletionType() {
        return d;
      }, get V2NIMFriendVerifyType() {
        return l;
      }, get V2NIMLoginAuthType() {
        return m;
      }, get V2NIMLoginStatus() {
        return p;
      }, get V2NIMLoginClientType() {
        return u;
      }, get V2NIMKickedOfflineReason() {
        return h;
      }, get V2NIMLoginClientChange() {
        return g;
      }, get V2NIMConnectStatus() {
        return v;
      }, get V2NIMMessageType() {
        return S;
      }, get V2NIMMessageNotificationType() {
        return C;
      }, get V2NIMMessageAttachmentUploadState() {
        return E;
      }, get V2NIMMessageSendingState() {
        return b;
      }, get V2NIMQueryDirection() {
        return R;
      }, get V2NIMMessageRevokeType() {
        return A;
      }, get V2NIMMessagePinState() {
        return O;
      }, get V2NIMMessageQuickCommentType() {
        return k;
      }, get V2NIMClientAntispamOperateType() {
        return w;
      }, get V2NIMSortOrder() {
        return P;
      }, get V2NIMSystemMessageType() {
        return V;
      }, get V2NIMMessageAIStreamStatus() {
        return y;
      }, get V2NIMMessageAIStreamStopOpType() {
        return f;
      }, get V2NIMMessageAIRegenOpType() {
        return I;
      }, get V2NIMMessageAIStatus() {
        return M;
      }, get V2NIMSearchKeywordMatchType() {
        return T;
      }, get V2NIMClearHistoryMode() {
        return N;
      }, get V2NIMMessageStreamStatus() {
        return L;
      }, get V2NIMTeamMessageMuteMode() {
        return D;
      }, get V2NIMP2PMessageMuteMode() {
        return q;
      }, get V2NIMTeamMemberRoleQueryType() {
        return x;
      }, get V2NIMTeamType() {
        return B;
      }, get V2NIMTeamJoinMode() {
        return j;
      }, get V2NIMTeamAgreeMode() {
        return $;
      }, get V2NIMTeamInviteMode() {
        return G;
      }, get V2NIMTeamUpdateInfoMode() {
        return H;
      }, get V2NIMTeamChatBannedMode() {
        return z;
      }, get V2NIMTeamUpdateExtensionMode() {
        return W;
      }, get V2NIMTeamJoinActionType() {
        return Y;
      }, get V2NIMTeamJoinActionStatus() {
        return J;
      }, get V2NIMTeamNotificationType() {
        return Q;
      }, get V2NIMTeamMemberRole() {
        return K;
      }, get V2NIMAIModelRoleType() {
        return ee;
      }, get V2NIMAIModelType() {
        return X;
      }, get V2NIMAIModelStreamCallStatus() {
        return Z;
      }, get V2NIMSignallingChannelType() {
        return re;
      }, get V2NIMSignallingEventType() {
        return te;
      }, get V2NIMUserStatusType() {
        return ie;
      } });
      class V2NIMErrorImpl extends Error {
        constructor(e2) {
          super(e2.desc), this.name = "V2NIMError", this.code = e2.code || 0, this.desc = e2.desc || de[this.code] || me[this.code] || "", this.message = this.desc, this.detail = e2.detail || {};
        }
        toString() {
          var e2, t2 = `${this.name}
 code: ${this.code}
 message: "${this.message}"
 detail: ${this.detail ? JSON.stringify(this.detail) : ""}`;
          return (null === (e2 = null == this ? void 0 : this.detail) || void 0 === e2 ? void 0 : e2.rawError) && (t2 += `
 rawError: ${this.detail.rawError.message}`), t2;
        }
      }
      class ValidateError extends V2NIMErrorImpl {
        constructor(e2, t2 = {}, r2) {
          super({ code: ce.V2NIM_ERROR_CODE_PARAMETER_ERROR, detail: { reason: e2, rules: r2, data: t2 } }), this.name = "validateError", this.message = this.message + "\n" + JSON.stringify(this.detail, null, 2), this.data = t2, this.rules = r2;
        }
      }
      class ValidateErrorV2 extends V2NIMErrorImpl {
        constructor(e2) {
          var t2, r2, i2;
          super({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: null === (t2 = e2.detail) || void 0 === t2 ? void 0 : t2.reason, rules: null === (r2 = e2.detail) || void 0 === r2 ? void 0 : r2.rules, data: null === (i2 = e2.detail) || void 0 === i2 ? void 0 : i2.data } }), this.name = "ValidateErrorV2";
        }
      }
      class FormatError extends V2NIMErrorImpl {
        constructor(e2, t2, r2) {
          super({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: e2, key: t2, rules: r2 } }), this.name = "formatError";
        }
      }
      class UploadError extends V2NIMErrorImpl {
        constructor(e2) {
          super(Object.assign({ code: 400 }, e2)), this.desc = this.desc || "upload file error", this.message = this.desc, this.name = "uploadError";
        }
      }
      class CustomError extends V2NIMErrorImpl {
        constructor(e2, t2 = {}, r2 = 400) {
          super({ code: r2, desc: e2, detail: t2 }), this.name = "customError", this.data = t2;
        }
      }
      var me = { 200: null, 406: null, 808: null, 810: null, 302: "The user name or password is incorrect.", 405: "Parameter length too long", 408: "Client request timed out", 415: "Client network unavailable", 422: "Account disabled", 508: "Expiration date", 509: "Invalid", 7101: "Be pulled black", 700: "Partial failure of batch operation", 801: "The number of people in the team has reached the upper limit", 802: "No permission", 803: "The team does not exist or has not changed", 804: "The user is not in the team", 805: "Team type mismatch", 806: "The number of teams created has reached the limit", 807: "Team member not valid", 809: "Already in the team", 811: "The number of accounts in the forced push list exceeds the limit", 812: "The team is muted", 813: "Due to the limited number of team, some pull people successfully", 814: "Disable team message read service", 815: "Maximum number of team administrators", 816: "Batch operation partial failure", 9102: "Channel failure", 9103: "This call has been answered / rejected at another end", 10201: "Signaling: target NIM client is offline", 10202: "Signaling: push is unreachable", 10404: "Signaling: channel not exists", 10405: "Signaling: channel already exists", 10406: "Signaling: member of channel not exists", 10407: "Signaling: member of channel already exists", 10408: "Signaling: the invitation request does not exist or has expired", 10409: "Signaling: the invitation request has been rejected", 10410: "Signaling: the invitation request has been accepted", 10414: "Signaling: request parameter error", 10417: "Signaling: uid conflict", 10419: "Signaling: the number of members of channel exceed the limit", 10420: "Signaling: member is already in the channel on other client", 10700: "Signaling: phased success", 13002: "Abnormal chatroom status", 13003: "In the blacklist", 13004: "In the mute list", 13006: "All members are muted, and only the administrator can speak" };
      function difference(e2, t2) {
        return t2 = t2 || [], (e2 = e2 || []).filter((e3) => -1 === t2.indexOf(e3));
      }
      function replacer(e2, t2) {
        return t2 instanceof RegExp ? "__REGEXP " + t2.toString() : t2;
      }
      function validate(e2, t2 = {}, r2, i2 = false) {
        var s2 = {};
        return Object.keys(e2).forEach((n2) => {
          var a2 = e2[n2].type, o2 = r2 ? `In ${r2}, ` : "";
          if (null == t2) {
            var c2 = `${o2}param is null or undefined`;
            throw i2 ? new ValidateErrorV2({ detail: { reason: c2, data: { key: n2 }, rules: "required" } }) : new ValidateError(c2, { key: n2 }, "required");
          }
          if (void 0 === t2[n2]) {
            if (false === e2[n2].required)
              return void (s2[n2] = t2[n2]);
            var d2 = `${o2}param '${n2}' is required`;
            throw i2 ? new ValidateErrorV2({ detail: { reason: d2, data: { key: n2 }, rules: "required" } }) : new ValidateError(d2, { key: n2 }, "required");
          }
          var l2 = pe[a2];
          if (l2 && !l2(t2, n2, e2[n2], i2)) {
            var m2 = `${o2}param '${n2}' unexpected`, p2 = { key: n2, value: t2[n2] };
            throw i2 ? new ValidateErrorV2({ detail: { reason: m2, data: p2, rules: JSON.stringify(e2[n2], replacer) } }) : new ValidateError(m2, p2, JSON.stringify(e2[n2], replacer));
          }
          s2[n2] = t2[n2];
        }), s2;
      }
      var pe = { string: function(e2, t2, r2) {
        var { allowEmpty: i2, max: s2, min: n2, regExp: a2 } = r2, o2 = e2[t2];
        return "string" == typeof o2 && ((false !== i2 || "" !== o2) && (!("number" == typeof s2 && o2.length > s2) && (!("number" == typeof n2 && o2.length < n2) && !(function isRegExp(e3) {
          return "[object RegExp]" === Object.prototype.toString.call(e3);
        }(a2) && !a2.test(o2)))));
      }, number: function(e2, t2, r2) {
        var { min: i2, max: s2 } = r2, n2 = e2[t2];
        return "number" == typeof n2 && (!("number" == typeof i2 && n2 < i2) && !("number" == typeof s2 && n2 > s2));
      }, boolean: function(e2, t2) {
        return "boolean" == typeof e2[t2];
      }, file: function(e2, t2) {
        return true;
      }, enum: function(e2, t2, r2) {
        var { values: i2 } = r2, s2 = e2[t2];
        return !i2 || i2.indexOf(s2) > -1;
      }, jsonstr: function(e2, t2) {
        try {
          var r2 = JSON.parse(e2[t2]);
          return "object" == typeof r2 && null !== r2;
        } catch (e3) {
          return false;
        }
      }, func: function(e2, t2) {
        return "function" == typeof e2[t2];
      }, array: function(e2, t2, r2, i2 = false) {
        var { itemType: s2, itemRules: n2, rules: a2, min: o2, max: c2, values: d2 } = r2, l2 = e2[t2];
        if (!Array.isArray(l2))
          return false;
        if ("number" == typeof c2 && l2.length > c2)
          return false;
        if ("number" == typeof o2 && l2.length < o2)
          return false;
        if (n2)
          l2.forEach((e3, r3) => {
            validate({ [r3]: n2 }, { [r3]: e3 }, `${t2}[${r3}]`, i2);
          });
        else if (a2)
          l2.forEach((e3, r3) => validate(a2, e3, `${t2}[${r3}]`, i2));
        else if ("enum" === s2) {
          if (d2 && difference(l2, d2).length)
            return false;
        } else if (s2 && !l2.every((e3) => typeof e3 === s2))
          return false;
        return true;
      }, object: function(e2, t2, r2, i2 = false) {
        var { rules: s2, allowEmpty: n2 } = r2, a2 = e2[t2];
        if ("object" != typeof a2 || null === a2)
          return false;
        if (s2) {
          var o2 = Object.keys(s2), c2 = Object.keys(a2).filter((e3) => o2.indexOf(e3) > -1);
          if (false === n2 && 0 === c2.length)
            return false;
          validate(s2, a2, t2, i2);
        }
        return true;
      } };
      function validateConversationId(e2, t2) {
        if (!e2)
          throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_ILLEGAL_STATE });
        validate({ conversationId: { type: "string", allowEmpty: false, regExp: new RegExp(`^${e2}\\|[1-3]\\|`) } }, { conversationId: t2 }, "", true);
      }
      class TimerManager {
        constructor() {
          this.timerList = [], this.id = 1, this.timer = null, this.timeout = 0;
        }
        addTimer(e2, t2 = 0, r2 = 1) {
          var i2 = (/* @__PURE__ */ new Date()).getTime(), s2 = this.id;
          return this.timerList.push({ id: s2, loop: r2, count: 0, timeout: i2 + t2, interval: t2, callback: e2 }), this.id++, this.checkTimer(i2), s2;
        }
        checkTimer(e2 = (/* @__PURE__ */ new Date()).getTime()) {
          if (this.removeFinished(), 0 !== this.timerList.length || null == this.timer) {
            var t2 = 0;
            for (var r2 of this.timerList)
              (0 === t2 || t2 > r2.timeout) && (t2 = r2.timeout);
            0 !== this.timerList.length && (null === this.timer || t2 < this.timeout || this.timeout < e2) && (this.timer = setTimeout(this.nowTime.bind(this), t2 - e2), this.timeout = t2);
          }
        }
        nowTime() {
          var e2 = (/* @__PURE__ */ new Date()).getTime();
          for (var t2 of this.timerList)
            e2 >= t2.timeout && (t2.callback(), t2.count++, t2.timeout = e2 + t2.interval);
          this.clerTime(), this.checkTimer(e2);
        }
        clerTime() {
          null !== this.timer && (clearTimeout(this.timer), this.timer = null);
        }
        deleteTimer(e2) {
          for (var t2 = this.timerList.length - 1; t2 >= 0; t2--) {
            this.timerList[t2].id === e2 && this.timerList.splice(t2, 1);
          }
        }
        removeFinished() {
          for (var e2 = this.timerList.length - 1; e2 >= 0; e2--) {
            var t2 = this.timerList[e2];
            t2.loop >= 0 && t2.count >= t2.loop && this.timerList.splice(e2, 1);
          }
        }
        destroy() {
          this.clerTime(), this.timerList = [], this.id = 1, this.timer = null;
        }
      }
      function __rest(e2, t2) {
        var r2 = {};
        for (var i2 in e2)
          Object.prototype.hasOwnProperty.call(e2, i2) && t2.indexOf(i2) < 0 && (r2[i2] = e2[i2]);
        if (null != e2 && "function" == typeof Object.getOwnPropertySymbols) {
          var s2 = 0;
          for (i2 = Object.getOwnPropertySymbols(e2); s2 < i2.length; s2++)
            t2.indexOf(i2[s2]) < 0 && Object.prototype.propertyIsEnumerable.call(e2, i2[s2]) && (r2[i2[s2]] = e2[i2[s2]]);
        }
        return r2;
      }
      function __awaiter(e2, t2, r2, i2) {
        return new (r2 || (r2 = Promise))(function(s2, n2) {
          function fulfilled(e3) {
            try {
              step(i2.next(e3));
            } catch (e4) {
              n2(e4);
            }
          }
          function rejected(e3) {
            try {
              step(i2.throw(e3));
            } catch (e4) {
              n2(e4);
            }
          }
          function step(e3) {
            e3.done ? s2(e3.value) : function adopt(e4) {
              return e4 instanceof r2 ? e4 : new r2(function(t3) {
                t3(e4);
              });
            }(e3.value).then(fulfilled, rejected);
          }
          step((i2 = i2.apply(e2, t2 || [])).next());
        });
      }
      function isPlainObject(e2) {
        return null != e2 && "object" == typeof e2 && Object.getPrototypeOf(e2) == Object.prototype;
      }
      function merge(e2, t2) {
        var r2 = isPlainObject(e2) || Array.isArray(e2), i2 = isPlainObject(t2) || Array.isArray(t2);
        if (r2 && i2) {
          for (var s2 in t2) {
            var n2 = merge(e2[s2], t2[s2]);
            void 0 !== n2 && (e2[s2] = n2);
          }
          return e2;
        }
        return t2;
      }
      var ue = { getNetworkStatus: () => Promise.resolve({ net_type: 0, net_connect: true }), onNetworkStatusChange(e2) {
      }, offNetworkStatusChange() {
      } }, he = { isActive: () => true, getStatus: () => 0, setStatus(e2) {
      }, destroy() {
      } };
      var ge = { setLogger: function(e2) {
        throw new Error("setLogger not implemented.");
      }, platform: "", WebSocket: class AdapterSocket {
        constructor(e2, t2) {
          throw this.CONNECTING = 0, this.OPEN = 1, this.CLOSING = 2, this.CLOSED = 3, this.binaryType = "", new Error("Method not implemented.");
        }
        close(e2, t2) {
          throw new Error("Method not implemented.");
        }
        send(e2) {
          throw new Error("Method not implemented.");
        }
        onclose(e2) {
          throw new Error("Method not implemented.");
        }
        onerror(e2) {
          throw new Error("Method not implemented.");
        }
        onmessage(e2) {
          throw new Error("Method not implemented.");
        }
        onopen(e2) {
          throw new Error("Method not implemented.");
        }
      }, localStorage: {}, request: function(e2, t2) {
        throw new Error("request not implemented.");
      }, uploadFile: function(e2) {
        throw new Error("uploadFile not implemented.");
      }, getSystemInfo: function() {
        throw new Error("getSystemInfo not implemented.");
      }, getFileUploadInformation(e2) {
        throw new Error("getFileUploadInformation not implemented.");
      }, envPayload: {}, net: ue, powerMonitor: he, logStorage: class AdapterLogStorageImpl {
        constructor(e2) {
        }
        open() {
          return Promise.resolve();
        }
        close() {
        }
        addLogs(e2) {
          return Promise.resolve();
        }
        extractLogs() {
          return Promise.resolve();
        }
        afterUpload() {
          return Promise.resolve();
        }
      } };
      var ve = ["error", "warn", "log", "debug"], emptyFunc$1 = function() {
      }, ye = ["off", "error", "warn", "log", "debug"];
      class Logger {
        constructor(e2, t2 = {}) {
          this.storageArr = [], this.debugLevel = "off", this.timer = 0, this.strategies = { debug: { name: "debg", func: console.log }, log: { name: "info", func: console.log }, warn: { name: "warn", func: console.warn }, error: { name: "erro", func: console.error } }, this.debug = emptyFunc$1, this.log = emptyFunc$1, this.warn = emptyFunc$1, this.error = emptyFunc$1, this.iid = Math.round(1e3 * Math.random()), this.debugLevel = ye.includes(e2) ? e2 : "off", t2.debugLevel && (this.debugLevel = ye.includes(t2.debugLevel) ? t2.debugLevel : this.debugLevel), this.logStorage = false === t2.storageEnable ? null : new ge.logStorage(null == t2 ? void 0 : t2.storageName), this.setOptions(t2), this.setLogFunc(this.debugLevel), this.setTimer(), ge.setLogger(this), this.open();
        }
        getDebugMode() {
          return "debug" === this.debugLevel;
        }
        open() {
          this.logStorage && this.logStorage.open().then(() => {
            this.log("Logger::open success");
          }).catch((e2) => {
            this.warn("Logger::open failed", e2);
          });
        }
        setOptions(e2) {
          if (e2 && e2.logFunc) {
            var t2 = e2.logFunc;
            for (var r2 in t2) {
              var i2 = r2, s2 = t2[i2];
              s2 && (this.strategies[i2].func = s2);
            }
          }
        }
        setLogFunc(e2, t2 = "log") {
          var r2 = ve.findIndex((t3) => t3 === e2), i2 = ve.findIndex((e3) => e3 === t2);
          ve.forEach((e3, t3) => {
            this[e3] = function() {
              if (!(t3 > r2 && t3 > i2)) {
                var s2 = Array.prototype.slice.call(arguments), n2 = this.strategies[e3], a2 = this.formatArgs(s2, n2.name);
                t3 <= i2 && this.logStorage && this.prepareSaveLog(a2, e3), t3 <= r2 && n2.func(a2);
              }
            };
          });
        }
        extractLogs() {
          var e2;
          return this.logStorage ? null === (e2 = this.logStorage) || void 0 === e2 ? void 0 : e2.extractLogs() : Promise.resolve("");
        }
        afterUpload() {
          var e2;
          return this.logStorage ? null === (e2 = this.logStorage) || void 0 === e2 ? void 0 : e2.afterUpload() : Promise.resolve("");
        }
        prepareSaveLog(e2, t2) {
          this.storageArr.push({ text: e2, level: t2, time: Date.now(), iid: this.iid }), this.timer || this.setTimer(), this.storageArr.length >= 100 && (this.triggerTimer(), this.storageArr = []);
        }
        saveLogs() {
          return __awaiter(this, void 0, void 0, function* () {
            if (this.logStorage) {
              var e2 = this.storageArr;
              this.storageArr = [];
              try {
                yield this.logStorage.addLogs(e2);
              } catch (e3) {
              }
            }
          });
        }
        clearTimer() {
          this.timer && clearTimeout(this.timer), this.timer = 0;
        }
        setTimer() {
          this.clearTimer(), this.timer = setTimeout(this.triggerTimer.bind(this), 5e3);
        }
        triggerTimer() {
          this.clearTimer(), this.saveLogs();
        }
        formatArgs(e2, t2) {
          var r2 = /* @__PURE__ */ new Date();
          return `[NIM ${this.iid} ${t2} ${`${r2.getMonth() + 1}-${r2.getDate()} ${r2.getHours()}:${r2.getMinutes()}:${r2.getSeconds()}:${r2.getMilliseconds()}`}] ` + e2.map((e3) => e3 instanceof V2NIMErrorImpl ? e3.toString() : e3 instanceof Error ? e3 && e3.message ? e3.message : e3 : "object" == typeof e3 ? JSON.stringify(e3) : e3).join(" ");
        }
        destroy() {
          this.debug = emptyFunc$1, this.log = emptyFunc$1, this.warn = emptyFunc$1, this.error = emptyFunc$1, this.saveLogs(), this.clearTimer(), this.storageArr = [], this.logStorage && this.logStorage.close();
        }
      }
      function get(e2, t2) {
        if ("object" != typeof e2 || null === e2)
          return e2;
        for (var r2 = (t2 = t2 || "").split("."), i2 = 0; i2 < r2.length; i2++) {
          var s2 = r2[i2], n2 = e2[s2], a2 = s2.indexOf("["), o2 = s2.indexOf("]");
          if (-1 !== a2 && -1 !== o2 && a2 < o2) {
            var c2 = s2.slice(0, a2), d2 = parseInt(s2.slice(a2 + 1, o2));
            n2 = e2[c2], n2 = Array.isArray(n2) ? n2[d2] : void 0;
          }
          if (null == n2)
            return n2;
          e2 = n2;
        }
        return e2;
      }
      var fe, Ie = (fe = function() {
        return (65536 * (1 + Math.random()) | 0).toString(16).substring(1);
      }, function() {
        return fe() + fe() + fe() + fe() + fe() + fe() + fe() + fe();
      });
      function getEnumKeys(e2) {
        return Object.keys(e2).filter((e3) => !(+e3 >= 0));
      }
      function getEnumKeyByEnumValue(e2, t2) {
        var r2 = Object.keys(e2).filter((r3) => e2[r3] == t2);
        return r2.length > 0 ? r2[0] : void 0;
      }
      function getAccountFromSessionId(e2, t2 = "-") {
        if (!e2)
          throw new CustomError("No sessionId", {}, 400);
        var r2 = e2.indexOf(t2);
        if (-1 === r2)
          throw new CustomError("Can not find conjunctions", {}, 400);
        var i2 = e2.slice(0, r2);
        return { accid: e2.slice(r2 + 1), scene: "super_team" === i2 ? "superTeam" : i2 };
      }
      function pendingIsMiniappEnv() {
        var { hostEnvEnum: e2 } = ge.getSystemInfo();
        return 6 === e2 || 102 === e2 || 103 === e2 || 104 === e2;
      }
      function assignOptions(e2, t2) {
        return function assignWith(e3, t3, r2, i2) {
          for (var s2 in e3 = e3 || {}, r2 = r2 || {}, i2 = i2 || (() => {
          }), t3 = t3 || {}) {
            var n2 = i2(e3[s2], t3[s2]);
            e3[s2] = void 0 === n2 ? t3[s2] : n2;
          }
          for (var a2 in r2) {
            var o2 = i2(e3[a2], r2[a2]);
            e3[a2] = void 0 === o2 ? r2[a2] : o2;
          }
          return e3;
        }({}, e2, t2, function(e3, t3) {
          return void 0 === t3 ? e3 : t3;
        });
      }
      function emptyFuncWithPromise() {
        return Promise.resolve();
      }
      function emptyFunc() {
      }
      function getFileExtension(e2) {
        var t2 = e2.lastIndexOf("."), r2 = t2 > -1 ? e2.slice(t2 + 1) : "";
        return /^\d+$/.test(r2.trim()) && (r2 = ""), r2;
      }
      function findIndexWithinTargetValue(e2, t2, r2) {
        return 0 === e2.length || e2[0][t2] <= r2 ? 0 : e2[e2.length - 1][t2] > r2 ? e2.length : e2.findIndex((i2, s2) => {
          if (e2[s2 - 1] && e2[s2 - 1][t2] > r2 && r2 >= i2[t2])
            return true;
        });
      }
      function fillIdServer(e2, t2, r2, i2) {
        var s2 = "number" == typeof get(e2, "raw.r[0]") ? `${e2.raw.r[0]}` : void 0;
        return t2[r2] = t2[r2] || s2 || i2, t2;
      }
      class CoreAdapters {
        constructor(e2) {
          this.lastSuccUploadHost = "", this.core = e2;
        }
        getFileUploadInformation(e2) {
          return ge.getFileUploadInformation(e2);
        }
        request(e2, t2, r2) {
          var i2 = (/* @__PURE__ */ new Date()).getTime(), s2 = (null == r2 ? void 0 : r2.exception_service) || 0;
          return ge.request(e2, t2).catch((r3) => {
            var n2, a2, o2, c2, d2 = r3;
            throw this.core.reporter.reportTraceStart("exceptions", { user_id: this.core.options.account || (null === (a2 = null === (n2 = this.core) || void 0 === n2 ? void 0 : n2.auth) || void 0 === a2 ? void 0 : a2.account), trace_id: null === (c2 = null === (o2 = this.core.clientSocket) || void 0 === o2 ? void 0 : o2.socket) || void 0 === c2 ? void 0 : c2.sessionId, start_time: i2, action: 1, exception_service: s2 }), this.core.reporter.reportTraceUpdateV2("exceptions", { code: "number" == typeof d2.code ? d2.code : 0, description: d2.message || `${d2.code}`, operation_type: 0, target: e2, context: t2 ? JSON.stringify(t2) : "" }, { asyncParams: ge.net.getNetworkStatus() }), this.core.reporter.reportTraceEnd("exceptions", 1), r3;
          });
        }
        uploadFile(e2) {
          var t2, r2, i2, s2;
          return __awaiter(this, void 0, void 0, function* () {
            for (var n2 = "BROWSER" === ge.platform, a2 = n2 ? e2.chunkUploadHostBackupList : e2.commonUploadHostBackupList, o2 = n2 ? e2.chunkUploadHost : e2.commonUploadHost, c2 = a2.indexOf(o2), d2 = -1 === c2 ? [o2, ...a2] : [o2, ...a2.slice(0, c2), ...a2.slice(c2 + 1)], l2 = Math.max(d2.indexOf(this.lastSuccUploadHost), 0), m2 = null, p2 = 0; p2 < d2.length; p2++) {
              var u2 = (/* @__PURE__ */ new Date()).getTime(), h2 = d2[(p2 + l2) % d2.length];
              try {
                var g2 = yield ge.uploadFile(Object.assign(Object.assign({}, e2), n2 ? { chunkUploadHost: h2 } : { commonUploadHost: h2 }));
                return this.lastSuccUploadHost = h2, "string" == typeof g2.size && (g2.size = parseInt(g2.size)), "string" == typeof g2.dur && (g2.dur = parseInt(g2.dur)), "string" == typeof g2.w && (g2.w = parseInt(g2.w)), "string" == typeof g2.h && (g2.h = parseInt(g2.h)), g2;
              } catch (e3) {
                this.core.cloudStorage.nos.nosErrorCount--, m2 = e3;
                var v2 = e3;
                this.core.reporter.reportTraceStart("exceptions", { user_id: this.core.options.account || (null === (r2 = null === (t2 = this.core) || void 0 === t2 ? void 0 : t2.auth) || void 0 === r2 ? void 0 : r2.account), trace_id: null === (s2 = null === (i2 = this.core.clientSocket) || void 0 === i2 ? void 0 : i2.socket) || void 0 === s2 ? void 0 : s2.sessionId, start_time: u2, action: 1, exception_service: 3 }), this.core.reporter.reportTraceUpdateV2("exceptions", { code: "number" == typeof v2.code ? v2.code : 0, description: v2.message || `${v2.code}`, operation_type: 1, target: h2 }, { asyncParams: ge.net.getNetworkStatus() }), this.core.reporter.reportTraceEnd("exceptions", 1), this._uploadFileErrHanler(e3);
              }
            }
            throw m2;
          });
        }
        _uploadFileErrHanler(e2) {
          if (e2 && (e2.code > 200 || e2.errCode > 200))
            throw e2;
        }
      }
      var Me = "weblink.netease.im:443", Se = ["https://lbs.netease.im/lbs/webconf.jsp"], Te = "https://abt-online.netease.im/v1/api/abt/client/getExperimentInfo", _e = "imElite_sdk_abtest_web";
      class ABTest {
        constructor(e2, t2) {
          this.abtInfo = {}, this.core = e2, this.config = assignOptions({ isAbtestEnable: true, abtestUrl: Te, abtestProjectKey: _e }, t2);
        }
        setOptions(e2) {
          this.config = assignOptions(this.config, e2);
        }
        abtRequest() {
          var e2, t2;
          return __awaiter(this, void 0, void 0, function* () {
            if (this.config.isAbtestEnable && !this.abtInfo.experiments && this.config.abtestUrl) {
              var r2;
              try {
                r2 = yield this.core.adapters.request(this.config.abtestUrl, { method: "POST", dataType: "json", headers: { sdktype: "ABTest" }, data: { clientInfo: { projectKey: this.config.abtestProjectKey, appKey: this.core.options.appkey, osType: "Web", sdkVersion: "10.9.41", deviceId: this.core.config.deviceId }, useLocalCache: true } }, { exception_service: 7 });
              } catch (e3) {
                this.core.logger.warn("ABTest request failed");
              }
              this.abtInfo = (null === (t2 = null === (e2 = null == r2 ? void 0 : r2.data) || void 0 === e2 ? void 0 : e2.data) || void 0 === t2 ? void 0 : t2.abtInfo) || {};
            }
          });
        }
      }
      class PromiseManager {
        constructor() {
          this.abortFns = [];
        }
        add(e2) {
          var t2 = function getPromiseWithAbort(e3) {
            var t3 = {}, r2 = new Promise(function(e4, r3) {
              t3.abort = r3;
            });
            return t3.promise = Promise.race([e3, r2]), t3;
          }(e2);
          return this.abortFns.push(t2.abort), t2.promise;
        }
        clear(e2) {
          this.abortFns.forEach((t2) => t2(e2 || new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_CANCELLED, detail: { reason: "Aborted" } }))), this.abortFns = [];
        }
        destroy() {
          this.clear();
        }
      }
      var Ce = { tolerantRTT: 3e3, bestRTT: 100, maxChances: 5, enable: true }, Ee = { timestamp: 0, rtt: 0, baseClock: 0, baseTime: 0 };
      class TimeOrigin {
        constructor(e2, t2, r2 = "getServerTime") {
          this.serverOrigin = Ee, this.config = Ce, this.isSettingNTP = false, this.currentChance = 0, this.failedDelay = 2e3, this.successDelay = 3e5, this.timer = 0, this.cmdName = "getServerTime", this.core = e2, this.logger = e2.logger, this.promiseManager = new PromiseManager(), this.cmdName = r2, t2 && this.setOptions(t2);
        }
        setOptions(e2) {
          this.config = Object.assign({}, Ce, this.config, e2);
        }
        reset() {
          this.timer && clearTimeout(this.timer), this.promiseManager.clear(), this.serverOrigin = Ee, this.currentChance = 0;
        }
        setOriginTimetick() {
          return __awaiter(this, void 0, void 0, function* () {
            if (this.config.enable && !(this.isSettingNTP || this.currentChance >= this.config.maxChances)) {
              var e2 = get(this.core, "auth.status"), t2 = get(this.core, "status"), r2 = get(this.core, "V2NIMLoginService.lifeCycle.loginStatus");
              if ("logined" === e2 || "logined" === t2 || 1 === r2) {
                this.isSettingNTP = true, this.currentChance++, this.timer && clearTimeout(this.timer), this.timer = 0;
                var i2, s2 = "TimeOrigin::setOriginTimetick:", n2 = Date.now();
                this.core.logger.debug(`${s2} getServerTime start, times ${this.currentChance}`);
                try {
                  i2 = get(yield this.promiseManager.add(this.core.sendCmd(this.cmdName)), "content.time"), this.isSettingNTP = false;
                } catch (e3) {
                  var a2 = e3;
                  return this.isSettingNTP = false, this.logger.warn(`${s2} Calculate Delay time, getServerTime error`, a2), void (a2.code !== ce.V2NIM_ERROR_CODE_CANCELLED && (clearTimeout(this.timer), this.timer = setTimeout(this.setOriginTimetick.bind(this), this.failedDelay)));
                }
                if (!i2)
                  return this.core.logger.warn(`${s2} Calculate Delay time incorrect format`), void (this.config.enable = false);
                var o2 = Date.now() - n2;
                this.doSet(i2, o2);
              }
            }
          });
        }
        doSet(e2, t2) {
          var r2 = "TimeOrigin::setOriginTimetick:";
          t2 > this.config.tolerantRTT ? (this.logger.warn(`${r2} denied RTT:${t2}`), clearTimeout(this.timer), this.timer = setTimeout(this.setOriginTimetick.bind(this), this.failedDelay)) : t2 > this.config.bestRTT ? (this.serverOrigin.rtt && t2 >= this.serverOrigin.rtt ? this.logger.warn(`${r2} ignore RTT:${t2}`) : (this.setServerOrigin(t2, e2), this.logger.log(`${r2} accept reluctantly RTT:${t2}`)), clearTimeout(this.timer), this.timer = setTimeout(this.setOriginTimetick.bind(this), this.failedDelay)) : (this.setServerOrigin(t2, e2), this.logger.debug(`${r2} accept best RTT:${t2}`), this.currentChance = 0, clearTimeout(this.timer), this.timer = setTimeout(this.setOriginTimetick.bind(this), this.successDelay));
        }
        getNTPTime(e2) {
          if (void 0 === e2 && (e2 = this.getTimeNode()), this.checkNodeReliable(e2)) {
            var t2 = Math.floor(e2.time - this.serverOrigin.baseTime);
            return this.serverOrigin.timestamp + t2;
          }
          return Date.now();
        }
        checkNodeReliable(e2) {
          if (void 0 === e2 && (e2 = this.getTimeNode()), this.serverOrigin.timestamp) {
            if (0 === this.serverOrigin.baseClock)
              return true;
            var t2 = e2.clock - this.serverOrigin.baseClock, r2 = e2.time - this.serverOrigin.baseTime;
            return Math.abs(r2 - t2) < 500;
          }
          return false;
        }
        checkPerformance() {
          return "BROWSER" === ge.platform && !("undefined" == typeof performance || !performance.now);
        }
        static checkPerformance() {
          return "BROWSER" === ge.platform && !("undefined" == typeof performance || !performance.now);
        }
        getTimeNode() {
          return { clock: this.checkPerformance() ? performance.now() : 0, time: Date.now() };
        }
        static getTimeNode() {
          return { clock: TimeOrigin.checkPerformance() ? performance.now() : 0, time: Date.now() };
        }
        setServerOrigin(e2, t2) {
          this.serverOrigin = { timestamp: t2 + Math.floor(e2 / 2), rtt: e2, baseClock: this.checkPerformance() ? performance.now() : 0, baseTime: Date.now() };
        }
      }
      var be = { user_id: "", trace_id: "", action: 7, exception_service: 6, duration: 0, start_time: 0, state: 1, extension: [] };
      class ReporterHookLinkKeep {
        constructor(e2, t2) {
          this.traceData = be, this.core = e2, this.traceData = Object.assign({}, be, t2), this.traceData.extension = [];
        }
        reset() {
          this.traceData = Object.assign({}, be), this.traceData.extension = [];
        }
        start() {
          var e2, t2;
          this.reset(), this.traceData.user_id = this.core.account, this.traceData.trace_id = (null === (t2 = null === (e2 = this.core.clientSocket) || void 0 === e2 ? void 0 : e2.socket) || void 0 === t2 ? void 0 : t2.sessionId) || "", this.traceData.start_time = (/* @__PURE__ */ new Date()).getTime();
        }
        update(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            var { net_type: t2, net_connect: r2 } = yield ge.net.getNetworkStatus();
            this.traceData.extension.push(Object.assign({ code: 0, foreground: true, foreg_backg_switch: false, net_type: t2, net_connect: r2 }, e2));
          });
        }
        end(e2) {
          var t2 = this.traceData.extension[0], r2 = this.traceData.extension[1];
          if (t2 && 0 === t2.operation_type && r2 && 1 === r2.operation_type) {
            var i2 = t2.net_type !== r2.net_type || t2.net_connect !== r2.net_connect;
            if (e2 || !i2)
              return this.traceData.duration = (/* @__PURE__ */ new Date()).getTime() - this.traceData.start_time, this.core.reporter.report("exceptions", this.traceData), void this.reset();
            this.reset();
          } else
            this.reset();
        }
      }
      var Re = { user_id: "", trace_id: "", net_connect: true, net_type: 0, duration: 0, start_time: 0, history: [], succeed: false };
      class ReporterHookLBS {
        constructor(e2) {
          this.traceData = Re, this.core = e2, this.reset();
        }
        reset() {
          this.traceData = Object.assign({}, Re), this.traceData.history = [];
        }
        start(e2) {
          this.reset(), this.traceData.user_id = e2, this.traceData.start_time = Date.now();
        }
        updateBegin(e2) {
          this.traceData.history.push(Object.assign({ head: "", body: "", start_time: Date.now(), httpdns: false, index: 0 }, e2));
        }
        updateComplete(e2) {
          this.traceData.history.forEach((t2) => {
            t2.target === e2.target && (Object.assign(t2, e2), t2.duration = Date.now() - t2.start_time);
          });
        }
        end(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            if (this.traceData.succeed = e2, this.traceData.history = this.traceData.history.filter((e3) => void 0 !== e3.code), 0 !== this.traceData.history.length) {
              this.traceData.duration = Date.now() - this.traceData.start_time;
              var { net_type: t2, net_connect: r2 } = yield ge.net.getNetworkStatus();
              this.traceData.net_type = t2, this.traceData.net_connect = r2, this.core.reporter.report("nim_sdk_lbs_records", this.traceData), this.reset();
            } else
              this.reset();
          });
        }
      }
      function getIsDataReportEnable(e2) {
        var t2, r2, i2 = true;
        return "boolean" == typeof (null === (t2 = null == e2 ? void 0 : e2.reporterConfig) || void 0 === t2 ? void 0 : t2.enableCompass) ? i2 = e2.reporterConfig.enableCompass : "boolean" == typeof (null === (r2 = null == e2 ? void 0 : e2.reporterConfig) || void 0 === r2 ? void 0 : r2.isDataReportEnable) && (i2 = e2.reporterConfig.isDataReportEnable), i2;
      }
      var Ne = { user_id: "", trace_id: "", action: 0, state: 0, duration: 0, start_time: 0, offset: 0, full_size: 0, transferred_size: 0, operation_type: 0, remote_addr: "" }, Ae = "ReporterHook::setMonitorForResources:";
      class ReporterHookCloudStorage {
        constructor(e2, t2) {
          this.traceData = Ne, this.core = e2, this.traceData = Object.assign({}, Ne, t2);
        }
        reset() {
          this.traceData = Object.assign({}, Ne);
        }
        start() {
          var e2, t2;
          this.reset(), this.traceData.user_id = this.core.account, this.traceData.trace_id = (null === (t2 = null === (e2 = this.core.clientSocket) || void 0 === e2 ? void 0 : e2.socket) || void 0 === t2 ? void 0 : t2.sessionId) || "", this.traceData.start_time = "timeOrigin" in this.core ? this.core.timeOrigin.getNTPTime() : Date.now();
        }
        update(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.traceData.user_id && (this.core.logger.log(`${Ae} upload update`, e2), Object.assign(this.traceData, e2));
          });
        }
        end(e2) {
          this.traceData.user_id && (this.core.logger.log(`${Ae} upload end cause of ${e2}`), this.traceData.state = e2, this.traceData.duration = ("timeOrigin" in this.core ? this.core.timeOrigin.getNTPTime() : Date.now()) - this.traceData.start_time, this.core.reporter.report("nim_sdk_resources", this.traceData), this.traceData = Ne);
        }
      }
      var Oe = {}, ke = {}, we = {}, Pe = { apiVersion: "v1", debugLevel: "off", needReconnect: true, reconnectionAttempts: Number.MAX_SAFE_INTEGER, lbsUrls: Se, linkUrl: Me, abtestUrl: Te, isAbtestEnable: true };
      class NIM extends se {
        constructor(e2, t2 = {}) {
          if (super(), this.instanceName = "NIM", this.pluginMap = {}, this.eventBus = new se(), this.options = {}, this.V2NIMConversationIdUtil = {}, this.V2NIMMessageCreator = {}, this.V2NIMMessageAttachmentCreator = {}, this.V2NIMClientAntispamUtil = {}, this.DataStructureConverter = {}, this.V2NIMMessageConverter = {}, this.V2NIMMessageLogUtil = {}, this.V2NIMMessageExtendUtil = {}, this.V2NIMStorageUtil = {}, this.V2NIMNotificationService = {}, this.V2NIMStorageService = {}, this.auth = {}, this.V1NIMLoginService = {}, this.V2NIMLoginService = {}, this.clientSocket = {}, this.V2NIMSyncService = {}, this.V2NIMLocalConversationService = {}, this.V2NIMConversationService = {}, this.V2NIMConversationGroupService = {}, this.V2NIMMessageService = {}, this.V2NIMTeamService = {}, this.V2NIMUserService = {}, this.V2NIMFriendService = {}, this.V2NIMSettingService = {}, this.V2NIMAIService = {}, this.V2NIMSignallingService = {}, this.V2NIMSubscriptionService = {}, this.V2NIMPassthroughService = {}, this.YSFService = {}, this.offlinePush = {}, this.sync = {}, this.msg = {}, this.msgLog = {}, this.session = {}, this.cloudSession = {}, this.misc = {}, this.user = {}, this.friend = {}, this.systemMessage = {}, this.team = {}, this.event = {}, this.msgExtend = {}, this.cloudStorage = {}, this.passThrough = {}, this.superTeam = {}, this.plugin = {}, this.signaling = {}, this.qchatChannel = {}, this.qchatMedia = {}, this.qchatMsg = {}, this.qchatRole = {}, this.qchatServer = {}, this.pluginMap = we, this.logger = new Logger(e2.debugLevel, t2.loggerConfig), t2.privateConf) {
            var { authConfig: r2, cloudStorageConfig: i2, reporterConfig: s2 } = this.getConfigFromPrivate(t2.privateConf);
            Object.assign(e2, r2), this.setInitOptions(e2), this.otherOptions = Object.assign(Object.assign({}, t2), { cloudStorageConfig: Object.assign(Object.assign({ storageKeyPrefix: "NIM" }, t2.cloudStorageConfig), i2), reporterConfig: Object.assign(Object.assign({}, t2.reporterConfig), s2), V1NIMLoginServiceConfig: Object.assign(Object.assign(Object.assign({}, e2), t2.V1NIMLoginServiceConfig), r2), V2NIMLoginServiceConfig: Object.assign(Object.assign({}, t2.V2NIMLoginServiceConfig), r2) });
          } else
            this.setInitOptions(e2), this.otherOptions = Object.assign(Object.assign({}, t2), { V1NIMLoginServiceConfig: Object.assign(Object.assign({}, e2), t2.V1NIMLoginServiceConfig), cloudStorageConfig: Object.assign({ storageKeyPrefix: "NIM" }, t2.cloudStorageConfig) });
          this.timerManager = new TimerManager(), this.timeOrigin = new TimeOrigin(this), this.adapters = new CoreAdapters(this), this.abtest = new ABTest(this, Object.assign(Object.assign({ isAbtestEnable: this.options.isAbtestEnable, abtestUrl: this.options.abtestUrl }, this.otherOptions.abtestConfig), { abtestProjectKey: _e }));
          var n2 = ge.getSystemInfo(), a2 = function getCompassDataEndpoint(e3, t3) {
            var r3, i3, s3 = null === (r3 = null == t3 ? void 0 : t3.reporterConfig) || void 0 === r3 ? void 0 : r3.compassDataEndpoint, n3 = null === (i3 = null == t3 ? void 0 : t3.reporterConfig) || void 0 === i3 ? void 0 : i3.reportConfigUrl;
            if (s3)
              return s3;
            if (n3) {
              var a3 = n3.match(/^https:\/\/([^/]+)\/*/);
              if (Array.isArray(a3) && a3.length >= 1)
                return `https://${a3[1]}`;
              e3.error(`Invalid reportConfigUrl: ${n3}`);
            }
            return pendingIsMiniappEnv() ? "https://statistic.live.126.net" : "https://statistic.live.126.net,https://statistic-overseas.yunxinfw.com";
          }(this.logger, this.otherOptions);
          this.reporter = new ne(Object.assign(Object.assign({}, a2 ? { compassDataEndpoint: a2 } : {}), { isDataReportEnable: getIsDataReportEnable(this.otherOptions), common: { app_key: e2.appkey, dev_id: "", platform: "Web", sdk_ver: "10.9.41", env: "online", os_name: n2.os, os_ver: n2.osVer, lib_env: n2.libEnv, host_env: n2.hostEnv, host_env_ver: n2.hostEnvVer, manufactor: n2.manufactor, model: n2.model, v2: "v1" !== this.options.apiVersion }, request: ge.request, logger: this.logger, autoStart: true })), this.reporterHookLinkKeep = new ReporterHookLinkKeep(this), this.reporterHookCloudStorage = new ReporterHookCloudStorage(this), this.reporterHookLBS = new ReporterHookLBS(this), this.getServiceKeys(Object.keys(Oe)).forEach((e3) => {
            if (!this[e3] || !this[e3].name) {
              var t3 = Oe[e3];
              this[e3] = new t3(this);
            }
          }), Object.keys(Oe).forEach((e3) => {
            this.callSetOptions(e3);
          }), Object.keys(ke).forEach((e3) => {
            var t3 = ke[e3];
            void 0 !== t3 && (this[e3] = new t3(this));
          }), NIM.instance = this, this.logger.log(`NIM init, version:10.9.41, sdk version:100941, appkey:${e2.appkey}`);
        }
        getServiceKeys(e2) {
          var t2 = e2.findIndex((e3) => "V1NIMLoginService" === e3);
          if (t2 > -1) {
            var r2 = e2[t2];
            e2.splice(t2, 1), "v1" === this.options.apiVersion && e2.unshift(r2);
          }
          var i2 = e2.findIndex((e3) => "V2NIMLoginService" === e3);
          if (i2 > -1) {
            var s2 = e2[i2];
            e2.splice(i2, 1), "v2" === this.options.apiVersion && e2.unshift(s2);
          }
          var n2 = e2.findIndex((e3) => "sync" === e3);
          if (n2 > -1) {
            var a2 = e2[n2];
            e2.splice(n2, 1), "v1" === this.options.apiVersion && e2.push(a2);
          }
          var o2 = e2.findIndex((e3) => "V2NIMSyncService" === e3);
          if (o2 > -1) {
            var c2 = e2[o2];
            e2.splice(o2, 1), "v2" === this.options.apiVersion && e2.push(c2);
          }
          return e2;
        }
        static getInstance(e2, t2) {
          if (!NIM.instance) {
            if (e2)
              return new NIM(e2, t2);
            throw new Error("Instance not exist, please input options");
          }
          if (e2) {
            if (NIM.instance.options.account === e2.account && NIM.instance.options.appkey === e2.appkey)
              return NIM.instance.setOptions(e2), NIM.instance;
            throw new Error("Unexpected login");
          }
          return NIM.instance;
        }
        setInitOptions(e2) {
          validate({ appkey: { type: "string" }, apiVersion: { type: "enum", values: ["v1", "v2"], required: false }, binaryWebsocket: { type: "boolean", required: false }, needReconnect: { type: "boolean", required: false }, reconnectionAttempts: { type: "number", required: false }, customClientType: { type: "number", min: 1, required: false }, authType: { type: "number", min: 0, max: 2, required: false }, lbsUrls: { type: "array", itemType: "string", min: 1, required: false }, linkUrl: { type: "string", allowEmpty: false, required: false } }, e2), this.options = Object.assign(Object.assign({}, Pe), e2);
        }
        getConfigFromPrivate(e2) {
          var t2;
          return e2 ? { authConfig: JSON.parse(JSON.stringify({ appkey: e2.appkey || void 0, lbsUrls: e2.weblbsUrl ? [e2.weblbsUrl] : void 0, linkUrl: e2.link_web || void 0, linkSSL: null !== (t2 = e2.websdkSsl) && void 0 !== t2 ? t2 : void 0 })), cloudStorageConfig: JSON.parse(JSON.stringify({ chunkUploadHost: e2.nos_uploader || void 0, commonUploadHost: e2.nos_uploader || void 0, commonUploadHostBackupList: e2.nos_uploader ? [e2.nos_uploader] : void 0, chunkUploadHostBackupList: e2.nos_uploader ? [e2.nos_uploader] : void 0, uploadReplaceFormat: e2.nos_downloader_v2 ? `${e2.nosSsl ? "https://" : "http://"}${e2.nos_downloader_v2}` : void 0, downloadUrl: void 0 !== e2.nos_accelerate ? e2.nos_accelerate : void 0, downloadHostList: "" === e2.nos_accelerate_host ? [] : "string" == typeof e2.nos_accelerate_host ? [e2.nos_accelerate_host] : Array.isArray(e2.nos_accelerate_host) ? e2.nos_accelerate_host : void 0 })), reporterConfig: JSON.parse(JSON.stringify({ enableCompass: "boolean" == typeof e2.enableCompass ? e2.enableCompass : void 0, compassDataEndpoint: e2.compassDataEndpoint || void 0 })) } : { authConfig: {}, cloudStorageConfig: {}, reporterConfig: {} };
        }
        connect(e2 = {}) {
          return this.V1NIMLoginService.login(e2);
        }
        setOptions(e2) {
          if ("object" == typeof e2 && null !== e2) {
            if (Object.prototype.hasOwnProperty.call(e2, "account") && e2.account !== this.options.account || Object.prototype.hasOwnProperty.call(e2, "appkey") && e2.appkey !== this.options.appkey)
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_MISUSE, detail: { reason: "NIM::setOptions account and appkey is not allowed to reset" } });
            if (Object.prototype.hasOwnProperty.call(e2, "apiVersion") && e2.apiVersion !== this.options.apiVersion)
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_MISUSE, detail: { reason: "NIM::setOptions apiVersion is not allowed to reset" } });
            if (Object.prototype.hasOwnProperty.call(e2, "binaryWebsocket") && e2.binaryWebsocket !== this.options.binaryWebsocket)
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_MISUSE, detail: { reason: "NIM::setOptions binaryWebsocket is not allowed to reset" } });
            validate({ token: { type: "string", required: false }, needReconnect: { type: "boolean", required: false }, reconnectionAttempts: { type: "number", required: false }, customClientType: { type: "number", min: 1, required: false }, authType: { type: "number", min: 0, max: 2, required: false }, lbsUrls: { type: "array", itemType: "string", min: 1, required: false }, linkUrl: { type: "string", allowEmpty: false, required: false } }, e2), this.logger.log("NIM::setOptions options is", e2), this.options = Object.assign(Object.assign({}, this.options), e2), this.V1NIMLoginService.setOptions && this.V1NIMLoginService.setOptions(this.options);
          }
        }
        getOptions() {
          return this.options;
        }
        disconnect() {
          return this.V1NIMLoginService.logout();
        }
        _disconnect() {
          return "v1" === this.options.apiVersion ? this.V1NIMLoginService.logout() : "v2" === this.options.apiVersion ? 0 === get(this.V2NIMLoginService, "lifeCycle.connectStatus") && 0 === get(this.V2NIMLoginService, "lifeCycle.loginStatus") ? Promise.resolve() : this.V2NIMLoginService.logout() : Promise.resolve();
        }
        destroy() {
          return NIM.instance = void 0, this._disconnect().then(() => {
            this.status = "destroyed", this.removeAllListeners(), this.eventBus.removeAllListeners(), this.logger.destroy(), this.reporter.destroy(), this.timerManager.destroy(), this._clearModuleData("destroy"), this._removeAllModuleListeners(), this.connect = emptyFuncWithPromise, this.disconnect = emptyFuncWithPromise, this._disconnect = emptyFuncWithPromise, this.destroy = emptyFuncWithPromise;
          });
        }
        _clearModuleData(e2 = "logout") {
          Object.values(this).forEach((t2) => {
            t2 && "function" == typeof t2.reset && t2.reset(e2);
          });
        }
        _removeAllModuleListeners() {
          Object.values(this).forEach((e2) => {
            e2 && "function" == typeof e2.removeAllListeners && e2.removeAllListeners();
          });
        }
        kick(e2) {
          return this.V1NIMLoginService.kick(e2);
        }
        sendCmd(e2, t2, r2) {
          return this.clientSocket.sendCmd(e2, t2, r2);
        }
        emit(e2, ...t2) {
          try {
            var r2 = Date.now(), i2 = super.emit(e2, ...t2), s2 = Date.now() - r2;
            return s2 >= 10 && this.logger.warn(`Core::emit event: ${e2} process takes: ${s2}ms`), i2;
          } catch (t3) {
            return this.logger.error(`Core::emit event: ${e2}. Error: ${t3}`), setTimeout(() => {
              throw this.logger.error(`Core::emit throw error in setTimeout. event: ${e2}. Error: ${t3}`), t3;
            }, 0), false;
          }
        }
        get account() {
          return this.auth.account;
        }
        get status() {
          return this.V1NIMLoginService.status;
        }
        set status(e2) {
          this.V1NIMLoginService.status = e2;
        }
        get config() {
          return { timeout: 8e3, deviceId: this.auth.deviceId };
        }
        _registerDep(e2, t2) {
          this[t2] && this[t2].name || (this[t2] = new e2(this), this.callSetOptions(t2));
        }
        callSetOptions(e2) {
          var t2 = `${e2}Config`, r2 = `${e2}Options`, i2 = this.otherOptions[t2] || this.otherOptions[r2] || {}, s2 = get(this, `${e2}.setOptions`);
          "function" == typeof s2 && ("cloudStorage" === e2 && (i2 = this.otherOptions[t2] || this.otherOptions.serverConfig || {}), s2.call(this[e2], i2));
        }
        static registerService(e2, t2) {
          Oe[t2] = e2;
        }
        static registerPrivateService(e2, t2) {
          ke[t2] = e2;
        }
        static registerPlugin(e2, t2) {
          we[t2] = e2;
        }
      }
      NIM.sdkVersion = 100941, NIM.sdkVersionFormat = "10.9.41";
      var Ve = { debug(...e2) {
      }, log(...e2) {
      }, warn(...e2) {
      }, error(...e2) {
      } };
      function setLogger(e2) {
        Ve = e2;
      }
      function getLogger() {
        return Ve;
      }
      function base64ToArrayBuffer(e2) {
        for (var t2 = function base64Decode(e3) {
          var t3 = String(e3).replace(/[=]+$/, "");
          if (t3.length % 4 == 1)
            throw new Error("'atob' failed: The string to be decoded is not correctly encoded.");
          for (var r3, i3 = "", s3 = 0, n2 = 0, a2 = 0; r3 = t3.charAt(a2++); ~r3 && (n2 = s3 % 4 ? 64 * n2 + r3 : r3, s3++ % 4) ? i3 += String.fromCharCode(255 & n2 >> (-2 * s3 & 6)) : 0)
            r3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(r3);
          return i3;
        }(e2), r2 = t2.length, i2 = new Uint8Array(r2), s2 = 0; s2 < r2; s2++)
          i2[s2] = t2.charCodeAt(s2);
        return i2.buffer;
      }
      var Le = { clear() {
        uni.clearStorageSync();
      }, getItem: (e2) => uni.getStorageSync(e2), setItem: (e2, t2) => uni.setStorageSync(e2, t2), removeItem: (e2) => uni.removeStorageSync(e2) };
      class LogStorageImpl {
        constructor(e2 = "nim_logs") {
          this.dirPath = "", this.filePath = "", this.copyFilePath = "", this.enable = false, this.maxCapacity = 26214400, this.remainCapacity = 8388608, this.count = 0, this.maxCount = 100, this.lastErrorMsg = void 0;
          var t2 = uni.getSystemInfoSync(), r2 = "mp-weixin" === t2.uniPlatform || "mp-alipay" === t2.uniPlatform;
          if (this.enable = r2, r2) {
            var i2 = this.getAPIEnv();
            i2 && (this.dirPath = `${i2.env.USER_DATA_PATH}/__nim`, this.filePath = `${this.dirPath}/${e2}.log`, this.copyFilePath = `${this.dirPath}/${e2}_copy.log`);
          }
        }
        getAPIEnv() {
          if (!("undefined" != typeof tt && tt.getSystemInfoSync || "undefined" != typeof swan && swan.getSystemInfoSync))
            return "undefined" != typeof my && my.getSystemInfoSync ? my : "undefined" != typeof wx && wx.getAppBaseInfo ? wx : void 0;
        }
        makeDir() {
          if (this.enable) {
            var e2 = this.getAPIEnv();
            if (e2) {
              var t2 = getLogger(), r2 = e2.getFileSystemManager();
              try {
                var i2 = r2.accessSync(this.dirPath);
                t2.log("logStorage::access dir:", i2), ("object" == typeof i2 && null !== i2 ? i2.error || i2.errno || i2.errCode || i2.errNo : 0) > 200 && r2.mkdirSync(this.dirPath, true);
              } catch (e3) {
                r2.mkdirSync(this.dirPath, true);
              }
              try {
                var s2 = r2.accessSync(this.filePath);
                t2.log("logStorage::access file:", s2), ("object" == typeof s2 && null !== s2 ? s2.error || s2.errno || s2.errCode || s2.errNo : 0) > 200 && r2.writeFileSync(this.filePath, "===", "utf8");
              } catch (e3) {
                r2.writeFileSync(this.filePath, "===", "utf8");
              }
            }
          }
        }
        open() {
          return __awaiter(this, void 0, void 0, function* () {
            if (this.enable) {
              var e2 = getLogger();
              try {
                this.makeDir(), e2.log(`logStorage::open log file success:${this.filePath}`);
              } catch (t2) {
                e2.warn(`logStorage::open log file failed:${this.filePath}`, t2);
              }
              yield this.checkCapacity(this.remainCapacity);
            }
          });
        }
        checkCapacity(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            if (this.enable) {
              var t2 = this.getAPIEnv();
              if (t2) {
                var r2 = getLogger(), i2 = t2.getFileSystemManager(), s2 = this.getSize();
                if (s2 > this.maxCapacity) {
                  r2.log(`logStorage::checksize:exceed,${s2} byte`);
                  var n2 = "";
                  try {
                    n2 = yield this.readLogs(s2 - e2);
                  } catch (e3) {
                    return void r2.log("logStorage::checkCapacity:read failed", e3);
                  }
                  r2.log(`logStorage::checksize:read success ${s2 - e2} byte`);
                  try {
                    i2.unlinkSync(this.filePath);
                  } catch (e3) {
                    return void r2.log("logStorage::checkCapacity:unlink failed", e3);
                  }
                  try {
                    i2.writeFileSync(this.filePath, n2, "utf8");
                  } catch (e3) {
                    return void r2.log("logStorage::checkCapacity:write failed", e3);
                  }
                } else
                  r2.log(`logStorage::checkCapacity:not exceeding,${s2} byte`);
              }
            }
          });
        }
        getSize() {
          var e2;
          if (!this.enable)
            return 0;
          var t2 = this.getAPIEnv();
          if (!t2)
            return 0;
          var r2, i2 = getLogger(), s2 = t2.getFileSystemManager();
          try {
            r2 = s2.statSync(this.filePath, false);
          } catch (e3) {
            return i2.warn("logStorage::stat failed", e3), 0;
          }
          return r2.size || (null === (e2 = r2.stats) || void 0 === e2 ? void 0 : e2.size);
        }
        readLogs(e2 = 0) {
          if (!this.enable)
            return Promise.resolve("");
          var t2 = this.getAPIEnv();
          if (!t2)
            return Promise.resolve("");
          var r2 = getLogger(), i2 = t2.getFileSystemManager();
          return new Promise((t3, s2) => {
            i2.readFile({ filePath: this.filePath, encoding: "utf8", position: e2, success: (e3) => {
              var i3 = e3.data;
              "string" == typeof i3 ? (r2.warn(`logStorage::readLogs success ${i3.length}`), t3(i3)) : (r2.warn("logStorage::readLogs empty"), s2(new Error("logStorage::readLogs empty")));
            }, fail: (e3) => {
              var t4 = e3.errMsg || e3.errorMessage || e3.message;
              r2.warn(`logStorage::readLogs failed ${t4}`);
              var i3 = { code: e3.errCode || 0, message: t4 };
              s2(i3);
            } });
          });
        }
        close() {
        }
        addLogs(e2) {
          if (!this.enable)
            return Promise.resolve();
          var t2 = this.getAPIEnv();
          if (!t2)
            return Promise.resolve();
          var r2 = getLogger(), i2 = e2.map((e3) => e3.text).concat("").join("\n");
          try {
            t2.getFileSystemManager().appendFileSync(this.filePath, i2, "utf8");
          } catch (e3) {
            var s2 = e3.errMsg || e3.errorMessage || e3.message;
            this.lastErrorMsg !== s2 && r2.warn("logStorage::append failed", e3), this.lastErrorMsg = s2;
          }
          return this.count += 1, this.count > this.maxCount && (this.count = 0, this.checkCapacity(this.remainCapacity)), Promise.resolve();
        }
        extractLogs() {
          return __awaiter(this, void 0, void 0, function* () {
            if (this.enable) {
              var e2 = this.getAPIEnv();
              if (e2) {
                var t2 = getLogger(), r2 = e2.getFileSystemManager();
                if (this.getSize() > 0) {
                  try {
                    r2.copyFileSync(this.filePath, this.copyFilePath);
                  } catch (e3) {
                    return void t2.warn("logStorage::copyFileSync failed", e3);
                  }
                  return this.copyFilePath;
                }
                t2.warn("logStorage::extractLogs empty");
              }
            }
          });
        }
        afterUpload() {
          return __awaiter(this, void 0, void 0, function* () {
            if (this.enable) {
              var e2 = this.getAPIEnv();
              if (e2) {
                var t2 = getLogger(), r2 = e2.getFileSystemManager();
                try {
                  r2.unlinkSync(this.copyFilePath);
                } catch (e3) {
                  return void t2.log("logStorage::delete copyFilePath failed", e3);
                }
              }
            }
          });
        }
      }
      var Ue = { wifi: 2, "2g": 3, "3g": 4, "4g": 5, "5g": 6, ethernet: 1, unknown: 0, none: 0, notreachable: 0, wwan: 0 }, De = { __onNetworkStatusChangeFn: null, getNetworkStatus() {
        var e2 = uni.getSystemInfoSync() || {};
        return "app" === e2.uniPlatform && "harmonyos" === e2.osName ? Promise.resolve({ net_type: 0, net_connect: true }) : new Promise((e3, t2) => {
          uni.getNetworkType({ success: function(t3) {
            var r2 = false;
            r2 = "boolean" == typeof t3.networkAvailable ? t3.networkAvailable : "none" !== t3.networkType.toLowerCase(), e3({ net_type: Ue[t3.networkType.toLowerCase()], net_connect: r2 });
          }, fail: function() {
            t2(new Error("getNetworkType failed"));
          } });
        });
      }, onNetworkStatusChange(e2) {
        this.offNetworkStatusChange(), uni.onNetworkStatusChange && (this.__onNetworkStatusChangeFn = function(t2) {
          var r2 = t2.networkType.toLowerCase();
          e2({ isConnected: t2.isConnected || "none" !== r2, networkType: Ue[r2] });
        }, uni.onNetworkStatusChange(this.__onNetworkStatusChangeFn));
      }, offNetworkStatusChange() {
        uni.offNetworkStatusChange && (this.__onNetworkStatusChangeFn && uni.offNetworkStatusChange(this.__onNetworkStatusChangeFn), this.__onNetworkStatusChangeFn = null);
      } }, qe = getLogger();
      class PowerMonitor extends se {
        constructor() {
          super(), this.status = 0, this.appShowListener = null, this.appHideListener = null, this.flag = false, this._initAppLifecycleListener();
        }
        isActive() {
          return 0 === this.status;
        }
        getStatus() {
          return this.status;
        }
        setStatus(e2) {
          var t2 = this.status;
          e2 !== t2 && (this.status = e2, 0 === e2 && 1 === t2 && this.emit("onPowerMonitorTurnActive"), qe.log("Adapter powerMonitor::setStatus: ", e2));
        }
        destroy() {
          this.status = 0, this.flag = false, this._canIUse() && (this.appShowListener && (uni.offAppShow(this.appShowListener), this.appShowListener = null), this.appHideListener && (uni.offAppHide(this.appHideListener), this.appHideListener = null));
        }
        _initAppLifecycleListener() {
          this.flag || (false !== this._canIUse() ? (this.appShowListener = () => {
            var e2 = this.status;
            this.status = 0, 1 === e2 && this.emit("onPowerMonitorTurnActive"), qe.log("Adapter powerMonitor::onAppShow status:", this.status);
          }, this.appHideListener = () => {
            this.status = 1, qe.log("Adapter powerMonitor::onAppHide status:", this.status);
          }, uni.onAppShow(this.appShowListener), uni.onAppHide(this.appHideListener), this.flag = true, qe.log("Adapter powerMonitor::_initAppLifecycleListener success")) : qe.warn("Adapter powerMonitor::_initAppLifecycleListener env.onAppShow/env.onAppHide not available"));
        }
        _canIUse() {
          return "undefined" != typeof uni && "function" == typeof uni.onAppShow && "function" == typeof uni.onAppHide && "function" == typeof uni.offAppShow && "function" == typeof uni.offAppHide;
        }
      }
      function requestFn(e2, t2) {
        return t2 && (t2.data = t2.data || (null == t2 ? void 0 : t2.params) || {}), new Promise((r2, i2) => {
          uni.request(Object.assign(Object.assign({ method: "GET", url: e2 }, t2), { success: function(t3) {
            "number" == typeof (t3 = t3 || {}).statusCode && t3.statusCode.toString().startsWith("2") ? (t3 = { data: t3.data, status: t3.statusCode, errMsg: t3.errMsg, header: t3.header }, r2(t3)) : i2({ code: t3.statusCode || 0, message: t3.data || `uniApp request fail. url: ${e2}` });
          }, fail: function(t3) {
            var r3 = `uniApp request fail. url: ${e2}`;
            i2(t3 ? { code: t3.errCode || 0, message: t3.errMsg || r3 } : { code: 0, message: r3 });
          } }));
        });
      }
      var getUserAgent = function() {
        var e2 = uni.getSystemInfoSync() || {};
        if ("mp-weixin" === e2.uniPlatform && "undefined" != typeof wx && wx.getAppBaseInfo) {
          var t2 = wx.getAppBaseInfo();
          return `NIM/Web/UNIAPP(${e2.uniRuntimeVersion})/WeChatMiniApp(${t2.SDKVersion})/V10.9.41/{{appkey}}`;
        }
        if ("undefined" != typeof tt && tt.getSystemInfoSync) {
          var r2 = tt.getSystemInfoSync();
          return `NIM/Web/UNIAPP(${e2.uniRuntimeVersion})/TiktokMiniApp(${r2.SDKVersion})/V10.9.41/{{appkey}}`;
        }
        if ("undefined" != typeof swan && swan.getSystemInfoSync) {
          var i2 = swan.getSystemInfoSync();
          return `NIM/Web/UNIAPP(${e2.uniRuntimeVersion})/BaiduMiniApp(${i2.SDKVersion})/V10.9.41/{{appkey}}`;
        }
        if ("undefined" != typeof my && my.getSystemInfoSync) {
          var s2 = my.getSystemInfoSync();
          return `NIM/Web/UNIAPP(${e2.uniRuntimeVersion})/AliMiniApp(${s2.SDKVersion})/V10.9.41/{{appkey}}`;
        }
        if (navigator && navigator.userAgent)
          return navigator.userAgent;
        if (e2.ua)
          return e2.ua;
        var n2 = uni.getSystemInfoSync();
        return `NIM/Web/UNIAPP(${n2.uniRuntimeVersion})/${n2.osName}(${n2.osVersion})/V10.9.41/{{appkey}}`;
      }, getHostEnvVer = function() {
        var e2 = uni.getSystemInfoSync() || {};
        if ("mp-weixin" === e2.uniPlatform && "undefined" != typeof wx && wx.getAppBaseInfo) {
          var t2 = wx.getAppBaseInfo();
          return `${e2.uniRuntimeVersion}/${t2.version}`;
        }
        if ("undefined" != typeof tt && tt.getSystemInfoSync) {
          var r2 = tt.getSystemInfoSync();
          return `${e2.uniRuntimeVersion}/${r2.version}`;
        }
        if ("undefined" != typeof swan && swan.getSystemInfoSync) {
          var i2 = swan.getSystemInfoSync();
          return `${e2.uniRuntimeVersion}/${i2.version}`;
        }
        if ("undefined" != typeof my && my.getSystemInfoSync) {
          var s2 = my.getSystemInfoSync();
          return `${e2.uniRuntimeVersion}/${s2.version}`;
        }
        return `${e2.uniRuntimeVersion}`;
      }, getModel = function() {
        var e2 = uni.getSystemInfoSync() || {};
        if ("mp-weixin" === e2.uniPlatform && "undefined" != typeof wx && wx.getAppBaseInfo) {
          var t2 = wx.getAppBaseInfo();
          return `${e2.uniRuntimeVersion}/${t2.SDKVersion}`;
        }
        if ("undefined" != typeof tt && tt.getSystemInfoSync) {
          var r2 = tt.getSystemInfoSync();
          return `${e2.uniRuntimeVersion}/${r2.SDKVersion}`;
        }
        if ("undefined" != typeof swan && swan.getSystemInfoSync) {
          var i2 = swan.getSystemInfoSync();
          return `${e2.uniRuntimeVersion}/${i2.SDKVersion}`;
        }
        return "undefined" != typeof my && my.getSystemInfoSync ? (my.getSystemInfoSync(), `${e2.uniRuntimeVersion}/${my.SDKVersion}`) : `${e2.uniRuntimeVersion}`;
      };
      function getSystemInfoFn() {
        var e2, t2 = "app" === (e2 = (uni.getSystemInfoSync() || {}).uniPlatform) ? [110, "APP"] : "web" === e2 || "h5" === e2 ? [101, "H5"] : "mp-weixin" === e2 ? [6, "WeiXin"] : "mp-alipay" === e2 ? [102, "Ali"] : "mp-baidu" === e2 ? [103, "Baidu"] : "mp-toutiao" === e2 ? [104, "Tiktok"] : 0 === e2.indexOf("mp-") || 0 === e2.indexOf("quickapp") ? [105, "OtherMiniProgram"] : [0, "Unset"], r2 = uni.getSystemInfoSync() || {};
        return { os: r2.osName || "UNIAPP_UNKNOW", osVer: r2.osVersion, browser: r2.browserName || "", browserVer: r2.browserVersion || "", libEnv: "UNIAPP", hostEnv: t2[1], hostEnvEnum: t2[0], hostEnvVer: getHostEnvVer(), userAgent: getUserAgent(), model: getModel(), manufactor: t2[1], pushDeviceInfo: { PRODUCT: r2.model, DEVICE: r2.model, MANUFACTURER: r2.brand } };
      }
      function uploadFileFn(e2) {
        var t2 = getLogger(), r2 = e2.headers || {};
        return e2.md5 && (r2["Content-MD5"] = e2.md5), new Promise((i2, s2) => {
          var n2 = uni.uploadFile(Object.assign(Object.assign({ url: `${e2.commonUploadHost}/${e2.nosToken.bucket}` }, Object.keys(r2).length > 0 ? { header: r2 } : {}), { formData: { Object: decodeURIComponent(e2.nosToken.objectName), "x-nos-token": e2.nosToken.token, "x-nos-entity-type": "json" }, name: "file", fileType: e2.type, filePath: e2.filePath, success(t3) {
            if (200 == t3.statusCode)
              try {
                var r3;
                try {
                  r3 = JSON.parse(t3.data);
                } catch (e3) {
                  r3 = {};
                }
                r3.name = e2.filePath, r3.ext = r3.name.lastIndexOf(".") > -1 ? r3.name.slice(r3.name.lastIndexOf(".") + 1).toLowerCase() : "", i2(r3);
              } catch (e3) {
                s2({ code: t3.statusCode, message: t3.errMsg, rawData: t3.data });
              }
            else
              s2({ code: t3.statusCode, message: t3.errMsg, rawData: t3.data });
          }, fail(e3) {
            "uploadFile:fail abort" === e3.errMsg && (e3.code = ce.V2NIM_ERROR_CODE_CANCELLED), e3.message = e3.errMsg, s2(e3);
          } }));
          try {
            e2.onUploadStart && e2.onUploadStart(n2);
          } catch (e3) {
            t2.error("Adapter uploadFile: options.onUploadStart error", e3 && e3.message), n2.abort(), s2(e3);
          }
          e2.onUploadProgress && n2.onProgressUpdate(function(t3) {
            e2.onUploadProgress && e2.onUploadProgress({ total: t3.totalBytesExpectedToSend, loaded: t3.totalBytesSent, percentage: parseFloat((t3.totalBytesSent / t3.totalBytesExpectedToSend).toFixed(2)), percentageText: t3.progress + "%" });
          });
        });
      }
      function getFileUploadInformationFn(e2) {
        return null;
      }
      class WebsocketFn {
        constructor(e2, t2 = "") {
          if (this.CONNECTING = 0, this.OPEN = 1, this.CLOSING = 2, this.CLOSED = 3, this.binaryType = "", this.onclose = function(e3) {
            getLogger().log("Adapter uniapp: sockets on close ", e3);
          }, this.onerror = function(e3) {
            getLogger().error("Adapter uniapp: sockets error ", e3);
          }, this.onmessage = function(e3) {
          }, this.onopen = function() {
          }, !e2)
            throw new Error("Failed to construct 'socket': url required");
          this.url = e2.replace(/:443(\/|$)/, "$1"), this.protocol = t2, this.readyState = this.CONNECTING;
          var r2 = this.protocol ? { protocols: this.protocol } : {};
          this.socketTask = uni.connectSocket(Object.assign(Object.assign({ url: this.url }, r2), { multiple: true, fail: (e3) => {
            this.errorHandler(e3);
          } })), this.socketTask.onOpen((e3) => {
            getLogger().log("Adapter uniapp:: onOpen. event: ", e3), this.readyState = this.OPEN, this.binaryType ? this.onopen() : this.onmessage && this.onmessage({ type: "open", header: e3 });
          }), this.socketTask.onError((e3) => {
            getLogger().log("Adapter uniapp:: onError. event: ", e3), this.errorHandler(e3);
          }), this.socketTask.onClose((e3) => {
            (this.readyState = this.CLOSED, "function" == typeof this.onclose) && (this.onclose && this.onclose(e3), getLogger().log("Adapter uniapp:: onClose. event: ", e3));
            this.socketTask = null;
          }), this.socketTask.onMessage((e3) => {
            var t3;
            t3 = "string" == typeof e3.data || e3.data instanceof ArrayBuffer ? e3.data : e3.data.isBuffer && "string" == typeof e3.data.data ? base64ToArrayBuffer(e3.data.data) : e3.data.data, this.onmessage && this.onmessage({ data: t3 });
          });
        }
        close() {
          getLogger().log("Adapter uniapp:: close uni socket actively"), this.socketTask.close({ code: 1e3, reason: "user force close websocket", complete: () => {
            this.socketTask = null;
          } });
        }
        send(e2) {
          if (this.readyState !== this.OPEN)
            throw new Error(`Adapter uniapp:: socket sendMsg when readyState=${this.readyState}`);
          if (!("string" == typeof e2 || e2 instanceof ArrayBuffer))
            throw new TypeError("Adapter uniapp:: socket sendMsg only String/ArrayBuffer supported");
          this.socketTask.send({ data: e2 });
        }
        errorHandler(e2) {
          getLogger().error("Adapter uniapp:: errorHandler. event: ", e2), this.readyState = this.CLOSED, this.onerror && this.onerror({ type: "error", message: e2 && e2.errMsg }), e2.errMsg && "[object Array]" === Object.prototype.toString.call(e2.errMsg) && (e2.errMsg.indexOf("") > 0 || e2.errMsg.indexOf("broken pipe") > 0) && this.onclose && this.onclose(e2);
        }
      }
      var xe = {}, Be = {};
      function createCmd(e2, t2, r2, i2) {
        var s2 = xe[e2];
        if (!s2)
          return r2.error("createCmd:: can not find cmd config: ", e2), null;
        var n2 = { SER: t2, SID: s2.sid, CID: s2.cid, Q: [] };
        return s2.params && i2 && s2.params.forEach(function(e3) {
          var t3 = i2[e3.name];
          if (null != t3) {
            var r3 = e3.type, { reflectMapper: s3, select: a2 } = e3;
            switch (e3.type) {
              case "PropertyArray":
                r3 = "ArrayMable", t3 = t3.map((e4) => ({ t: "Property", v: s3 ? serialize(e4, s3, a2) : e4 }));
                break;
              case "Property":
                t3 = s3 ? serialize(t3, s3, a2) : t3;
                break;
              case "Bool":
                t3 = t3 ? "true" : "false";
            }
            n2.Q.push({ t: r3, v: t3 });
          }
        }), { packet: n2, hasPacketResponse: "boolean" != typeof s2.hasPacketResponse || s2.hasPacketResponse, hasPacketTimer: "boolean" != typeof s2.hasPacketTimer || s2.hasPacketTimer };
      }
      function parseCmd(e2, t2) {
        var r2;
        try {
          r2 = JSON.parse(e2);
        } catch (r3) {
          return void t2.error(`Parse command error:"${e2}"`);
        }
        var i2 = r2.sid + "_" + r2.cid, s2 = r2.r;
        if (["4_1", "4_2", "4_10", "4_11"].includes(i2)) {
          var n2 = r2.r[1].headerPacket;
          i2 = `${n2.sid}_${n2.cid}`, r2.sid = n2.sid, r2.cid = n2.cid, s2 = r2.r[1].body;
        }
        var a2 = Be[i2], o2 = [];
        if (a2 && a2.length > 0) {
          for (var c2 of a2)
            o2.push(parseEachCmd(r2, c2.config, c2.cmd, s2, t2));
          return o2;
        }
        t2.error("parseCmd:: mapper not exist", i2, r2.code);
      }
      function parseEachCmd(e2, t2, r2, i2, s2) {
        var n2, a2 = { cmd: r2, raw: e2, error: null, service: null == t2 ? void 0 : t2.service, content: {}, __receiveTimeNode: TimeOrigin.getTimeNode() };
        (18 === t2.sid || t2.sid >= 26 && t2.sid < 100) && (e2.code = function toReadableCode(e3) {
          if ("number" != typeof e3 || e3 != e3)
            throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INTERNAL, detail: { reason: "Read code failed", rawData: `${e3}` } });
          if (e3 < 0 || e3 >= 0 && e3 < 1e3 || e3 >= 2e4 && e3 <= 20099)
            return e3;
          var t3 = (65535 & e3) >> 9;
          t3 -= t3 <= 38 ? 1 : 2;
          return 1e5 + 1e3 * t3 + (511 & e3);
        }(e2.code));
        var o2 = function genCmdError(e3, t3) {
          var r3 = de[e3], i3 = me[e3];
          return null === i3 ? null : new V2NIMErrorImpl({ code: e3, desc: r3 || i3 || e3, detail: { cmd: t3, timetag: Date.now() } });
        }(e2.code, r2);
        if (a2.error = o2, a2.error) {
          if (a2.error.detail.cmd = r2, !(null === (n2 = null == t2 ? void 0 : t2.ignoreErrCodes) || void 0 === n2 ? void 0 : n2.includes(e2.code)))
            return a2;
          s2.warn("parseCmd:: ignore error ", a2.error), a2.error.detail.ignore = true;
        }
        return t2.response && t2.response.forEach((e3, t3) => {
          var r3 = i2[t3], s3 = e3.type, n3 = e3.name, o3 = e3.reflectMapper;
          if (void 0 !== r3)
            switch (s3) {
              case "Property":
                a2.content[n3] = o3 ? deserialize(r3, o3) : r3;
                break;
              case "PropertyArray":
                a2.content[n3] = r3.map((e4) => o3 ? deserialize(e4, o3) : e4);
                break;
              case "Int":
              case "Long":
              case "Byte":
                a2.content[n3] = +r3;
                break;
              case "Bool":
                a2.content[n3] = "true" === r3 || true === r3 || 1 === r3;
                break;
              default:
                a2.content[n3] = r3;
            }
        }), a2;
      }
      function serialize(e2, t2, r2) {
        var i2 = {};
        for (var s2 in e2 = function flattenObjByMapper(e3, t3) {
          var r3 = {};
          for (var i3 in t3) {
            var s3 = t3[i3], n3 = "number" == typeof s3 ? i3 : s3.access ? s3.access : i3, a3 = n3.split("."), o3 = e3;
            for (var c2 of a3) {
              if (void 0 === o3[c2] || null === o3[c2]) {
                o3 = void 0;
                break;
              }
              o3 = o3[c2];
            }
            void 0 !== o3 && (r3[n3] = o3);
          }
          return r3;
        }(e2, t2), t2) {
          var n2 = t2[s2], a2 = "number" == typeof n2 ? s2 : n2.access ? n2.access : s2;
          if (!r2 || r2.includes(s2))
            if (a2 in e2) {
              if ("number" == typeof n2)
                i2[n2] = e2[a2];
              else if ("object" == typeof n2)
                if (n2.converter) {
                  var o2 = n2.converter(e2[a2], e2);
                  void 0 !== o2 && (i2[n2.id] = o2);
                } else
                  i2[n2.id] = e2[a2];
            } else
              "object" == typeof n2 && n2.def && ("function" == typeof n2.def ? i2[n2.id] = n2.def(e2) : i2[n2.id] = n2.def);
        }
        return i2;
      }
      function deserialize(e2, t2) {
        var r2 = {};
        for (var i2 in e2) {
          var s2 = t2[i2];
          if ("string" == typeof s2)
            r2[s2] = e2[i2];
          else if ("object" == typeof s2 && "prop" in s2) {
            var n2 = s2.access ? s2.access : s2.prop;
            if (s2.converter) {
              var a2 = s2.converter(e2[i2], e2);
              void 0 !== a2 && (r2[n2] = a2);
            } else
              s2.type && "number" === s2.type ? r2[n2] = +e2[i2] : s2.type && "boolean" === s2.type ? r2[n2] = !("0" === e2[i2] || !e2[i2]) : r2[n2] = e2[i2];
          }
        }
        for (var o2 in t2) {
          var c2 = t2[o2];
          if (c2 && void 0 !== c2.def) {
            var d2 = c2.access ? c2.access : c2.prop;
            d2 in r2 || ("function" == typeof c2.def ? r2[d2] = c2.def(e2) : r2[d2] = c2.def);
          }
        }
        return r2 = function unflattenObj(e3) {
          var t3 = {}, _loop = function(r4) {
            var i3 = r4.split(".");
            i3.reduce(function(t4, s3, n3) {
              return t4[s3] || (t4[s3] = isNaN(Number(i3[n3 + 1])) ? i3.length - 1 == n3 ? e3[r4] : {} : []);
            }, t3);
          };
          for (var r3 in e3)
            _loop(r3);
          return t3;
        }(r2), r2;
      }
      function registerParser(e2) {
        for (var t2 in Object.assign(xe, e2.cmdConfig), e2.cmdMap) {
          var r2 = e2.cmdMap[t2], i2 = e2.cmdConfig[r2];
          if (i2)
            if (Array.isArray(Be[t2])) {
              var s2 = false;
              for (var n2 of Be[t2])
                if (n2.cmd === r2 && n2.config.service === i2.service) {
                  s2 = true;
                  break;
                }
              s2 || Be[t2].push({ config: i2, cmd: r2 });
            } else
              Be[t2] = [{ config: i2, cmd: r2 }];
        }
      }
      function invertSerializeMap(e2) {
        var t2 = {};
        return Object.keys(e2).forEach((r2) => {
          t2[r2] = invertSerializeItem(e2[r2]);
        }), t2;
      }
      function invertSerializeItem(e2) {
        var t2 = {};
        for (var r2 in e2) {
          var i2 = e2[r2];
          "number" == typeof i2 ? t2[i2] = r2 : "object" == typeof i2 && (t2[i2.id] = { prop: r2, type: i2.retType, access: i2.retAccess ? i2.retAccess : i2.access ? i2.access : r2, def: i2.retDef, converter: i2.retConverter });
        }
        return t2;
      }
      function boolToInt(e2) {
        return e2 ? 1 : 0;
      }
      function intToBool(e2) {
        return 1 === parseInt(e2);
      }
      function objectToJSONString(e2) {
        if (e2 && "object" == typeof e2)
          try {
            return JSON.stringify(e2);
          } catch (e3) {
            return;
          }
      }
      function stringToJSONObject(e2) {
        if (e2 && "string" == typeof e2)
          try {
            return JSON.parse(e2);
          } catch (e3) {
            return;
          }
      }
      var Fe, je, $e, Ge, He, ze = { "1_2": "heartbeat", "2_3": "login", "2_5": "kicked", "2_6": "logout", "2_7": "nimLoginClientChange", "2_8": "kick" }, We = { login: { clientType: 3, os: 4, sdkVersion: 6, appLogin: 8, protocolVersion: 9, pushTokenName: 10, pushToken: 11, deviceId: 13, appkey: 18, account: 19, browser: 24, clientSession: 26, deviceInfo: 32, isReactNative: 112, token: 1e3, customTag: 38, customClientType: 39, sdkHumanVersion: 40, hostEnv: 41, userAgent: 42, libEnv: 44, authType: 115, loginExt: 116 }, loginRes: { lastLoginDeviceId: 17, customTag: 38, connectionId: 102, ip: 103, port: 104, country: 106, loginTime: 109, hasXMPush: 111 }, loginPort: { type: 3, os: 4, mac: 5, deviceId: 13, account: 19, deviceInfo: 32, customTag: 38, customClientType: 39, connectionId: 102, ip: 103, port: 104, time: 109, pushType: 110, hasTokenPreviously: 111 }, aosPushInfo: { pushType: 110, hasTokenPreviously: 111 } }, Ke = invertSerializeMap(We), Ye = { login: { sid: 2, cid: 3, service: "auth", params: [{ type: "Property", name: "login", reflectMapper: We.login }], response: [{ type: "Property", name: "loginRes", reflectMapper: Ke.loginRes }, { type: "PropertyArray", name: "loginPorts", reflectMapper: Ke.loginPort }, { type: "Property", name: "aosPushInfo", reflectMapper: Ke.aosPushInfo }] }, logout: { sid: 2, cid: 6, service: "auth" }, heartbeat: { sid: 1, cid: 2, service: "auth" }, kicked: { sid: 2, cid: 5, service: "auth", response: [{ type: "Int", name: "clientType" }, { type: "Int", name: "reason" }, { type: "String", name: "ext" }, { type: "Int", name: "customClientType" }] }, nimLoginClientChange: { sid: 2, cid: 7, service: "auth", response: [{ type: "Byte", name: "state" }, { type: "PropertyArray", name: "datas", reflectMapper: Ke.loginPort }] }, kick: { sid: 2, cid: 8, service: "auth", params: [{ type: "StrArray", name: "deviceIds" }], response: [{ type: "StrArray", name: "deviceIds" }] } };
      function format(e2, t2) {
        if (!isPlainObject(t2))
          return {};
        var r2 = JSON.parse(JSON.stringify(t2)), i2 = doFormat(e2, r2);
        return JSON.parse(JSON.stringify(Object.assign(Object.assign({}, r2), i2)));
      }
      function doFormat(e2, t2) {
        if (!isPlainObject(t2))
          return {};
        var r2 = {};
        return Object.keys(e2).forEach((i2) => {
          var s2 = e2[i2].type;
          if ("string" != typeof s2) {
            var n2 = doFormat(e2[i2], t2);
            Object.keys(n2).length > 0 && (r2[i2] = n2);
          } else {
            var a2 = e2[i2], o2 = a2.rawKey || i2, c2 = Je[s2](t2, o2, a2);
            void 0 !== c2 && (t2[o2] = void 0, r2[i2] = c2);
          }
        }), r2;
      }
      !function(e2) {
        e2[e2.text = 0] = "text", e2[e2.image = 1] = "image", e2[e2.audio = 2] = "audio", e2[e2.video = 3] = "video", e2[e2.geo = 4] = "geo", e2[e2.notification = 5] = "notification", e2[e2.file = 6] = "file", e2[e2.tip = 10] = "tip", e2[e2.robot = 11] = "robot", e2[e2.g2 = 12] = "g2", e2[e2.custom = 100] = "custom";
      }(Fe || (Fe = {})), function(e2) {
        e2[e2.p2p = 0] = "p2p", e2[e2.team = 1] = "team", e2[e2.superTeam = 5] = "superTeam";
      }(je || (je = {})), function(e2) {
        e2[e2.Android = 1] = "Android", e2[e2.iOS = 2] = "iOS", e2[e2.PC = 4] = "PC", e2[e2.WindowsPhone = 8] = "WindowsPhone", e2[e2.Web = 16] = "Web", e2[e2.Server = 32] = "Server", e2[e2.Mac = 64] = "Mac", e2[e2.HarmonyOS = 65] = "HarmonyOS";
      }($e || ($e = {})), function(e2) {
        e2[e2.unread = 1] = "unread", e2[e2.read = 2] = "read", e2[e2.deleted = 3] = "deleted", e2[e2.sending = 4] = "sending", e2[e2.sendFailed = 5] = "sendFailed", e2[e2.sent = 6] = "sent", e2[e2.receipt = 7] = "receipt", e2[e2.refused = 10] = "refused";
      }(Ge || (Ge = {})), function(e2) {
        e2[e2.default = 0] = "default", e2[e2.leave = 1] = "leave", e2[e2.roam = 2] = "roam";
      }(He || (He = {}));
      var Je = { number: function(e2, t2) {
        if (void 0 !== e2[t2])
          return +e2[t2];
      }, string: function(e2, t2) {
        if (void 0 !== e2[t2])
          return e2[t2];
      }, boolean: function(e2, t2) {
        return +e2[t2] > 0 || 0 != +e2[t2] && void 0;
      }, enum: function(e2, t2, r2) {
        return r2.values[e2[t2]];
      }, object: function(e2, t2) {
        if (void 0 !== e2[t2])
          try {
            return JSON.parse(e2[t2]);
          } catch (e3) {
            return {};
          }
      } };
      function formatReverse(e2, t2) {
        if (!isPlainObject(t2))
          return {};
        var r2 = JSON.parse(JSON.stringify(t2)), i2 = doFormatReverse(e2, r2);
        return JSON.parse(JSON.stringify(Object.assign(Object.assign({}, r2), i2)));
      }
      function doFormatReverse(e2, t2) {
        if (!isPlainObject(t2))
          return Object.keys(e2).reduce((t3, r3) => (t3[e2[r3].rawKey || r3] = void 0, t3), {});
        var r2 = {};
        return Object.keys(e2).forEach((i2) => {
          var s2 = e2[i2].type;
          if ("string" != typeof s2) {
            var n2 = doFormatReverse(e2[i2], t2[i2]);
            return Object.assign(r2, n2), void (t2[i2] = void 0);
          }
          var a2 = e2[i2], o2 = a2.rawKey || i2, c2 = Qe[s2](t2, i2, a2);
          t2[o2] = void 0, r2[o2] = c2;
        }), r2;
      }
      var Qe = { number: function(e2, t2) {
        return e2[t2];
      }, string: function(e2, t2) {
        return e2[t2];
      }, boolean: function(e2, t2) {
        return true === e2[t2] ? 1 : false === e2[t2] ? 0 : void 0;
      }, enum: function(e2, t2, r2) {
        return r2.values[e2[t2]];
      }, object: function(e2, t2) {
        if (void 0 !== e2[t2])
          try {
            return JSON.stringify(e2[t2]);
          } catch (e3) {
            return "";
          }
      } }, Xe = Qe;
      function formatMultiPortLoginInfo(e2, t2) {
        return e2 && e2.length > 0 ? e2.map((e3) => Object.assign(Object.assign({}, e3), { account: e3.account, connectionId: e3.connectionId, deviceId: e3.deviceId, ip: e3.ip, mac: e3.mac, os: e3.os, type: getEnumKeyByEnumValue($e, e3.type) || e3.type, time: parseInt(e3.time), online: 3 !== t2 })) : [];
      }
      var Ze = { 1: { reason: "samePlatformKick", message: "The same account is not allowed to multiple login at the same time" }, 2: { reason: "serverKick", message: "Kicked out by IM server" }, 3: { reason: "otherPlatformKick", message: "Kicked out by other client of your account" }, 4: { reason: "silentlyKick", message: "Quietly kicked" } };
      var et = Backoff;
      function Backoff(e2) {
        e2 = e2 || {}, this.ms = e2.min || 100, this.max = e2.max || 1e4, this.factor = e2.factor || 2, this.jitter = e2.jitter > 0 && e2.jitter <= 1 ? e2.jitter : 0, this.attempts = 0;
      }
      Backoff.prototype.duration = function() {
        var e2 = this.ms * Math.pow(this.factor, this.attempts++);
        if (this.jitter) {
          var t2 = Math.random(), r2 = Math.floor(t2 * this.jitter * e2);
          e2 = 0 == (1 & Math.floor(10 * t2)) ? e2 - r2 : e2 + r2;
        }
        return 0 | Math.min(e2, this.max);
      }, Backoff.prototype.reset = function() {
        this.attempts = 0;
      }, Backoff.prototype.setMin = function(e2) {
        this.ms = e2;
      }, Backoff.prototype.setMax = function(e2) {
        this.max = e2;
      }, Backoff.prototype.setJitter = function(e2) {
        this.jitter = e2;
      };
      var rt, it = ["disconnect", "connect", "heartbeat", "message", "json", "event", "ack", "error", "noop"], st = ["transport not supported", "client not handshaken", "unauthorized"], nt = ["reconnect"];
      class BaseWebsocket$1 extends se {
        constructor(e2, t2, r2) {
          super(), this.websocket = null, this.socketConnectTimer = 0, this.url = "", this.linkSSL = true, this.core = e2, this.url = t2, this.linkSSL = r2, this.status = "disconnected", this.logger = e2.logger, this.connect();
        }
        connect() {
          "connecting" !== this.status && "connected" !== this.status ? (this.status = "connecting", this.core.adapters.request(`${this.linkSSL ? "https" : "http"}://${this.url}/socket.io/1/?t=${Date.now()}`, { method: "GET", dataType: "text", timeout: this.core.options.xhrConnectTimeout || 8e3 }, { exception_service: 6 }).then((e2) => {
            if ("connecting" === this.status) {
              var [t2, r2] = e2.data.split(":");
              return this.sessionId = t2, this.logger.log(`imsocket::XHR success. status ${this.status}, ${"connecting" === this.status ? "continue websocket connection" : "stop websocket connection"}`), this._createWebsocket(`${this.linkSSL ? "wss" : "ws"}://${this.url}/socket.io/1/websocket/${t2}`);
            }
          }).catch((e2) => {
            if ("connecting" === this.status) {
              var t2 = `imsocket::XHR fail. raw message: "${(e2 = e2 || {}).message}", code: "${e2.code}"`, r2 = e2.code;
              r2 = "v2" === get(this.core, "options.apiVersion") ? e2.code === ce.V2NIM_ERROR_CODE_CONNECT_TIMEOUT ? ce.V2NIM_ERROR_CODE_CONNECT_TIMEOUT : ce.V2NIM_ERROR_CODE_CONNECT_FAILED : 408 === e2.code ? 408 : 415;
              var i2 = new V2NIMErrorImpl({ code: r2, detail: { reason: t2, rawError: e2 } });
              this.logger.error(t2), this.status = "disconnected", this.emit("handshakeFailed", i2);
            }
          })) : this.logger.warn("imsocket::socket is connecting or connected", this.status);
        }
        close() {
          if (this.status = "disconnected", this.websocket) {
            this.logger.log("imsocket:: close websocket");
            try {
              this.websocket.send(this.encodePacket({ type: "disconnect" }));
            } catch (e2) {
              this.logger.warn("imsocket::attempt to send encodePacket error", e2);
            }
            try {
              this.websocket.close();
            } catch (e2) {
              this.logger.warn("imsocket::attempt to close websocket error", e2);
            }
            this.clean(), this.emit("disconnect", { code: 0, reason: "Active close websocket" });
          }
        }
        clean() {
          this.status = "disconnected", clearTimeout(this.socketConnectTimer), this.websocket && (this.socketUrl = void 0, this.websocket.onmessage = null, this.websocket.onopen = null, this.websocket.onerror = null, this.websocket.onclose = null, this.websocket = null);
        }
        onConnect() {
          this.status = "connected", this.emit("connect"), clearTimeout(this.socketConnectTimer);
        }
        _createWebsocket(e2) {
          this.socketConnectTimer = setTimeout(() => {
            this.logger.error("imsocket::Websocket connect timeout. url: ", this.socketUrl), this.emit("handshakeFailed", new V2NIMErrorImpl({ code: "v2" === get(this.core, "options.apiVersion") ? ce.V2NIM_ERROR_CODE_CONNECT_TIMEOUT : 415, detail: { reason: `imsocket::Websocket connect timeout. url: ${this.socketUrl}` } }));
          }, this.core.options.socketConnectTimeout || 8e3), this.socketUrl = e2, this.websocket = new ge.WebSocket(e2), this.websocket.onmessage = this.onMessage.bind(this), this.websocket.onclose = (e3) => {
            e3 = e3 || {}, this.logger.log(`imsocket::Websocket onclose done ${e3.wasClean}/${e3.code}/${e3.reason}`), this.clean(), this.emit("disconnect", { code: e3.code || 0, reason: e3.reason });
          }, this.websocket.onerror = (e3) => {
            this.logger.error("imsocket::Websocket onerror", e3), "logined" === this.core.status && this.core.clientSocket.ping();
          };
        }
        onMessage(e2) {
          var t2, r2 = this.decodePacket(e2.data);
          if (r2)
            switch (r2.type) {
              case "connect":
                this.onConnect();
                break;
              case "disconnect":
                this.close(), this.emit("disconnect", { code: 0, reason: "MessageEvent type disconnect" });
                break;
              case "message":
              case "json":
                this.emit("message", r2.data);
                break;
              case "event":
                r2.name && this.emit(r2.name, r2.args);
                break;
              case "error":
                "unauthorized" === r2.reason ? this.emit("connect_failed", r2.reason) : this.emit("error", r2.reason), this.logger.error("imsocket::Websocket connect failed, onmessage type error. url: ", this.socketUrl), clearTimeout(this.socketConnectTimer), this.emit("handshakeFailed", new V2NIMErrorImpl({ code: "v2" === get(this.core, "options.apiVersion") ? ce.V2NIM_ERROR_CODE_CONNECT_FAILED : 408, detail: { reason: `imsocket::Websocket connect failed, onMessage socket error. url: ${this.socketUrl}` } }));
                break;
              case "heartbeat":
                null === (t2 = this.websocket) || void 0 === t2 || t2.send(this.encodePacket({ type: "heartbeat" }));
                break;
              default:
                this.logger.warn("imsocket::Websocket no handler type", r2.type);
            }
        }
        encodePacket(e2) {
          var t2, r2, { type: i2, id: s2 = "", endpoint: n2 = "", ack: a2 } = e2, o2 = null;
          if (!i2)
            return "";
          switch (i2) {
            case "error":
              t2 = e2.reason ? st.indexOf(e2.reason) : "", r2 = e2.advice ? nt.indexOf(e2.advice) : "", "" === t2 && "" === r2 || (o2 = t2 + ("" !== r2 ? "+" + r2 : ""));
              break;
            case "message":
              "" !== e2.data && (o2 = e2.data);
              break;
            case "event":
              t2 = { name: e2.name }, t2 = e2.args && e2.args.length ? { name: e2.name, args: e2.args } : { name: e2.name }, o2 = JSON.stringify(t2);
              break;
            case "json":
              o2 = JSON.stringify(e2.data);
              break;
            case "connect":
              e2.qs && (o2 = e2.qs);
              break;
            case "ack":
              o2 = e2.ackId + (e2.args && e2.args.length ? "+" + JSON.stringify(e2.args) : "");
          }
          var c2 = [it.indexOf(i2), s2 + ("data" === a2 ? "+" : ""), n2];
          return null != o2 && c2.push(o2), c2.join(":");
        }
        decodePacket(e2) {
          if (e2)
            if ("" != e2.charAt(0)) {
              var t2 = e2.match(/([^:]+):([0-9]+)?(\+)?:([^:]+)?:?([\s\S]*)?/);
              if (t2) {
                var r2, [, i2, s2, n2, a2, o2] = t2, c2 = { type: it[+i2], endpoint: a2 };
                switch (s2 && (c2.id = s2, c2.ack = !n2 || "data"), c2.type) {
                  case "error":
                    r2 = o2.split("+"), c2.reason = st[+r2[0]] || "";
                    break;
                  case "message":
                    c2.data = o2 || "";
                    break;
                  case "connect":
                    c2.qs = o2 || "";
                    break;
                  case "event":
                    try {
                      var d2 = JSON.parse(o2);
                      c2.name = d2.name, c2.args = d2.args;
                    } catch (e3) {
                      this.logger.error("imsocket::parseData::type::event error", e3);
                    }
                    c2.args = c2.args || [];
                    break;
                  case "json":
                    try {
                      c2.data = JSON.parse(o2);
                    } catch (e3) {
                      this.logger.error("imsocket::parseData::type::json error", e3);
                    }
                    break;
                  case "ack":
                    if ((r2 = o2.match(/^([0-9]+)(\+)?(.*)/)) && (c2.ackId = r2[1], c2.args = [], r2[3]))
                      try {
                        c2.args = r2[3] ? JSON.parse(r2[3]) : [];
                      } catch (e3) {
                        this.logger.error("imsocket::parseData::type::ack error", e3);
                      }
                }
                return c2;
              }
            } else
              this.logger.error("imsocket::unrecognize dataStr", e2.slice(0, 20));
        }
        send(e2) {
          var t2, r2 = { data: e2, type: "message", endpoint: "" };
          null === (t2 = this.websocket) || void 0 === t2 || t2.send(this.encodePacket(r2));
        }
      }
      function uniq(e2) {
        e2 = e2 || [];
        for (var t2 = [], r2 = 0; r2 < e2.length; r2++)
          -1 === t2.indexOf(e2[r2]) && t2.push(e2[r2]);
        return t2;
      }
      !function(e2) {
        e2[e2.ACTIVE = 1] = "ACTIVE", e2[e2.KICKED = 2] = "KICKED", e2[e2.OFFLINE = 3] = "OFFLINE";
      }(rt || (rt = {}));
      class V1ClientSocket {
        constructor(e2, t2) {
          this.linkUrls = [], this.isAutoReconnect = false, this.packetTimeout = 3e4, this.linkSSL = true, this.packetSer = 1, this.retryCount = 0, this.reconnectTimer = 0, this.backoff = new et({ max: 8e3, min: 1600, jitter: 0.01 }), this.sendingCmdMap = /* @__PURE__ */ new Map(), this.pingTimer = 0, this.hasNetworkListener = false, this.core = e2, t2 && (this.auth = t2), this.logger = e2.logger, this.reporter = e2.reporter, this.timerManager = e2.timerManager;
        }
        setSessionId(e2) {
        }
        setLinkSSL(e2) {
          this.linkSSL = e2;
        }
        connect(e2 = {}, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            if (validate({ linkUrls: { type: "array", itemType: "string", required: false } }, e2), !/^(unconnected|waitReconnect)$/.test(this.core.status)) {
              var r2 = `Core socket status is ${this.core.status}, and would not connect`;
              return this.logger.warn(r2), Promise.reject(r2);
            }
            this.core.status = "connecting", e2.linkUrls && e2.linkUrls.length > 0 && (this.linkUrls = e2.linkUrls.concat(this.linkUrls), this.linkUrls = uniq(this.linkUrls)), 0 === this.linkUrls.length && this.linkUrls.push(Me);
            for (var i2 = 0; i2 < this.linkUrls.length; i2++) {
              var s2 = this.linkUrls[i2], n2 = (/* @__PURE__ */ new Date()).getTime();
              try {
                return yield this.doConnect(s2), this.core.status = "connected", this.logger.log(`clientsocketV1::connect success with url: ${s2}`), s2;
              } catch (e3) {
                var a2 = e3;
                t2 && t2(a2, s2), this.reporter.reportTraceStart("exceptions", { user_id: this.core.options.account, start_time: n2, action: 0, exception_service: 6 }), this.reporter.reportTraceUpdateV2("exceptions", { code: "number" == typeof a2.code ? a2.code : 0, description: a2.message || `${a2.code}`, operation_type: 0, target: s2 }, { asyncParams: ge.net.getNetworkStatus() }), this.reporter.reportTraceEnd("exceptions", 1), this.logger.warn(`clientsocketV1::connect failed with url: ${s2}`, e3);
              }
            }
            throw 0 === this.retryCount ? this.doDisconnect(rt.ACTIVE, "SocketHandshakeFailed") : this.doDisconnect(rt.OFFLINE, "ReconnectHadRetryAllLinks"), new Error("clientSocketV1::socket xhr or socket connect failed");
          });
        }
        doConnect(e2) {
          var t2 = false;
          return new Promise((r2, i2) => {
            this.socket = new BaseWebsocket$1(this.core, e2, this.linkSSL), this.socket.on("connect", () => {
              this.logger.log("clientSocketV1::on connect", e2), this.core.reporterHookLinkKeep && (this.core.reporterHookLinkKeep.start(), this.core.reporterHookLinkKeep.update({ code: 0, description: "connection begin", operation_type: 0, target: e2 })), t2 = true, r2();
            }), this.socket.on("message", this.onMessage.bind(this)), this.socket.on("disconnect", (r3) => __awaiter(this, void 0, void 0, function* () {
              this.logger.log("clientSocketV1::socket on disconnect", r3), this.core.reporterHookLinkKeep && (yield this.core.reporterHookLinkKeep.update({ code: (null == r3 ? void 0 : r3.code) || 0, description: (null == r3 ? void 0 : r3.reason) || "socket on disconnect", operation_type: 1, target: e2 }), this.core.reporterHookLinkKeep.end(false)), t2 = true, this.doDisconnect(rt.OFFLINE, "SocketOnDisconnect");
            })), this.socket.on("handshakeFailed", (e3) => {
              t2 ? this.ping() : (this.logger.error(`clientsocketV1::handshake failed: "${e3 && e3.message}"`), this.cleanSocket()), t2 = true, i2(e3);
            });
          });
        }
        cleanSocket() {
          this.socket && ("function" == typeof this.socket.removeAllListeners && this.socket.removeAllListeners(), "function" == typeof this.socket.close && this.socket.close(), this.socket = void 0);
        }
        beforeConnect() {
          this.reconnectTimer && clearTimeout(this.reconnectTimer);
        }
        resetConnectStatus() {
          clearTimeout(this.reconnectTimer), this.backoff.reset(), this.retryCount = 0, this.initOnlineListener();
        }
        doDisconnect(e2, t2, r2) {
          var i2, s2, n2, a2, o2;
          if (this.logger.log(`doDisconnect:type:${e2},description:${t2}`), "unconnected" !== this.core.status) {
            var c2 = { 1: "close", 2: "kicked", 3: "broken" }[e2] || "";
            this.markAllCmdInvaild(new V2NIMErrorImpl({ code: 415, desc: "Packet timeout due to instance disconnect", detail: { reason: "Packet timeout due to instance disconnect", disconnect_reason: c2 } })), this.timerManager.destroy(), clearTimeout(this.pingTimer), this.cleanSocket();
            var d2 = !this.core.options.needReconnect || this.retryCount >= this.core.options.reconnectionAttempts;
            if (e2 === rt.ACTIVE || d2)
              this.logger.log("doDisconnect: emit disconnect, type " + e2, d2), this.core.status = "unconnected", this.reconnectTimer && clearTimeout(this.reconnectTimer), this.core.eventBus.emit("disconnect"), this.core.emit("disconnect"), null === (i2 = this.auth) || void 0 === i2 || i2.emit("disconnect"), this.destroyOnlineListener();
            else if (e2 === rt.KICKED) {
              this.logger.log("doDisconnect: kicked"), this.core.status = "unconnected", this.reconnectTimer && clearTimeout(this.reconnectTimer);
              var l2 = "string" == typeof t2 ? { reason: "unknow", message: t2 } : t2;
              this.core.eventBus.emit("kicked", l2), this.core.emit("kicked", l2), null === (s2 = this.auth) || void 0 === s2 || s2.emit("kicked", l2), this.destroyOnlineListener();
            } else
              e2 === rt.OFFLINE && this.core.V1NIMLoginService.isManualLoginAttempt ? (this.logger.log("doDisconnect: offline in manual login phase. no reconnect"), this.core.status = "unconnected", this.reconnectTimer && clearTimeout(this.reconnectTimer), this.destroyOnlineListener()) : e2 === rt.OFFLINE && (null === (a2 = null === (n2 = this.auth) || void 0 === n2 ? void 0 : n2.authenticator) || void 0 === a2 ? void 0 : a2.checkLoginTerminalCode(null == r2 ? void 0 : r2.code)) ? (this.logger.log(`doDisconnect: login terminal code ${null == r2 ? void 0 : r2.code}, no reconnect`), this.core.status = "unconnected", this.reconnectTimer && clearTimeout(this.reconnectTimer), this.destroyOnlineListener(), this.core.eventBus.emit("disconnect"), this.core.emit("disconnect"), null === (o2 = this.auth) || void 0 === o2 || o2.emit("disconnect")) : e2 === rt.OFFLINE ? (this.logger.log("doDisconnect: start to reconnect"), this.attempToReconnect()) : this.logger.log("doDisconnect: nothing to do");
          } else
            this.logger.warn("doDisconnect:already unconnected");
        }
        attempToReconnect() {
          var e2, t2;
          if ("waitReconnect" !== this.core.status) {
            0 === this.retryCount && (this.core.eventBus.emit("disconnect"), this.core.emit("disconnect"), null === (e2 = this.auth) || void 0 === e2 || e2.emit("disconnect"));
            var r2 = this.backoff.duration();
            this.retryCount++, this.logger.log(`willReconnect ${this.retryCount} ${r2}`), this.core.eventBus.emit("willReconnect", { retryCount: this.retryCount, duration: r2 }), this.core.emit("willReconnect", { retryCount: this.retryCount, duration: r2 }), null === (t2 = this.auth) || void 0 === t2 || t2.emit("willReconnect", { retryCount: this.retryCount, duration: r2 }), this.core.status = "waitReconnect", this.reconnectTimer && clearTimeout(this.reconnectTimer), this.reconnectTimer = setTimeout(() => __awaiter(this, void 0, void 0, function* () {
              "waitReconnect" === this.core.status ? false === (yield ge.net.getNetworkStatus()).net_connect ? (this.logger.log("doDisconnect: skip this reconnection attempt because network is offline"), this.core.status = "connecting", this.retryCount >= this.core.options.reconnectionAttempts ? this.doDisconnect(rt.OFFLINE, "MaxReconnectionAttemptExceed") : this.attempToReconnect()) : this.core.V1NIMLoginService.login({ isAutoReconnect: true }).catch(() => {
                this.logger.error(`clientsocketV1::attempToReconnect failed ${this.retryCount}`);
              }) : this.logger.warn(`doDisconnect: reconnectTimer status is ${this.core.status}, would not go on reconnecting`);
            }), r2);
          } else
            this.logger.warn("doDisconnect: already is waiting reconnect");
        }
        sendCmd(e2, t2, r2) {
          if ("logined" !== this.core.status && "login" !== e2 && "chatroomLogin" !== e2 && "qchatLogin" !== e2)
            return this.logger.warn(`instance status is ${this.core.status}, so can not sendCmd ${e2}`), Promise.reject({ cmd: e2, error: { code: "No_connected", message: "Connection not established", timetag: (/* @__PURE__ */ new Date()).getTime() } });
          if (!this.socket || !this.socket.send)
            return Promise.reject("No_socket");
          var i2 = "heartbeat" !== e2, s2 = i2 ? this.packetSer++ : 0, n2 = createCmd(e2, s2, this.logger, t2);
          if (!n2) {
            var a2 = `SendCmd ${s2} ${e2} error`;
            return this.logger.error(a2), Promise.reject(new Error(a2));
          }
          var { packet: o2, hasPacketResponse: c2, hasPacketTimer: d2 } = n2, l2 = JSON.stringify(o2);
          i2 && (this.logger.getDebugMode() ? this.logger.debug("clientsocketV1::sendCmd", e2, `ser:${s2}`, l2) : this.logger.log("clientsocketV1::sendCmd", e2, `ser:${s2}`));
          var m2 = (/* @__PURE__ */ new Date()).getTime();
          return new Promise((i3, n3) => {
            c2 && this.sendingCmdMap.set(s2, { cmd: e2, params: t2, callback: [i3, n3], timer: d2 ? setTimeout(() => {
              var t3 = new V2NIMErrorImpl({ code: 408, desc: "Packet Timeout", detail: { reason: "Packet Timeout", cmd: e2, ser: s2, timetag: Date.now() } });
              this.markCmdInvalid(s2, t3, e2);
            }, r2 && r2.timeout ? r2.timeout : this.core.config.timeout) : null });
            try {
              this.socket.send(l2), c2 || i3(o2);
            } catch (t3) {
              var a3 = new V2NIMErrorImpl({ code: 415, detail: { reason: t3 && t3.message || "Unable to send packet", cmd: e2, ser: s2, timetag: Date.now(), rawError: t3 } });
              this.markCmdInvalid(s2, a3, e2), n3(t3);
            }
          }).catch((e3) => {
            var t3;
            if (![408, 415].includes(e3.code))
              return Promise.reject(e3);
            this.reporter.reportTraceStart("exceptions", { user_id: this.core.options.account, trace_id: null === (t3 = this.socket) || void 0 === t3 ? void 0 : t3.sessionId, start_time: m2, action: 2, exception_service: 6 });
            var r3 = get(e3, "data.disconnect_reason") || "", i3 = 408 === e3.code ? "Send failed due to timeout" : "Send failed. Reason unknown";
            return i3 = 415 === e3.code ? JSON.stringify({ disconnect_reason: r3 }) : i3, this.reporter.reportTraceUpdateV2("exceptions", { code: e3.code || 415, description: i3, operation_type: 1, target: `${o2.SID}-${o2.CID}`, context: `${o2.SER}` }, { asyncParams: ge.net.getNetworkStatus() }), this.reporter.reportTraceEnd("exceptions", 1), Promise.reject(e3);
          });
        }
        onMessage(e2) {
          var t2 = parseCmd(e2, this.logger);
          if (t2 && t2.length > 0) {
            var r2 = t2[0], i2 = r2.raw.ser;
            for (var s2 of (r2.error && this.logger.error("core:onMessage packet error", `${r2.raw.sid}_${r2.raw.cid}, ser:${i2},`, r2.error), "heartbeat" !== r2.cmd && (this.logger.getDebugMode() ? this.logger.debug(`imsocket::recvCmd ser:${i2}`, r2.cmd, r2.content) : this.logger.log(`imsocket::recvCmd ser:${i2}`, r2.cmd)), t2))
              this.packetHandler(s2);
          }
        }
        packetHandler(e2) {
          var t2, r2, i2, s2;
          if (e2) {
            var n2 = e2.raw.ser, a2 = this.sendingCmdMap.get(n2);
            if (a2 && a2.cmd === e2.cmd) {
              var { callback: o2, timer: c2, params: d2 } = a2;
              if (clearTimeout(c2), e2.params = d2, this.sendingCmdMap.delete(n2), "heartbeat" === e2.cmd)
                return void o2[0]();
              var l2 = null === (r2 = null === (t2 = this.core[e2.service]) || void 0 === t2 ? void 0 : t2.process) || void 0 === r2 ? void 0 : r2.call(t2, e2);
              l2 && "function" == typeof l2.then ? l2.then((e3) => {
                o2[0](e3);
              }).catch((e3) => {
                o2[1](e3);
              }) : (this.logger.log("imsocket:: handlerFn without promise", e2.service, e2.cmd), o2[0]());
            } else {
              var m2 = null === (s2 = null === (i2 = this.core[e2.service]) || void 0 === i2 ? void 0 : i2.process) || void 0 === s2 ? void 0 : s2.call(i2, e2);
              m2 && "function" == typeof m2.then && m2.catch((e3) => {
                this.logger.error("imsocket::no obj cache, no process handler", e3);
              });
            }
          }
        }
        markCmdInvalid(e2, t2, r2) {
          var i2 = this.sendingCmdMap.get(e2);
          if (i2) {
            var { callback: s2, timer: n2 } = i2;
            n2 && clearTimeout(n2), this.sendingCmdMap.delete(e2), this.logger.warn(`packet ${e2}, ${r2} is invalid:`, t2), s2[1](t2);
          }
        }
        markAllCmdInvaild(e2) {
          this.logger.log("markAllCmdInvaild", e2), this.sendingCmdMap.forEach((t2) => {
            var { callback: r2, timer: i2, cmd: s2 } = t2;
            this.logger.log(`markAllCmdInvaild:: cmd "${s2}"`), i2 && clearTimeout(i2), r2[1](e2);
          }), this.sendingCmdMap.clear();
        }
        ping() {
          var e2;
          return __awaiter(this, void 0, void 0, function* () {
            clearTimeout(this.pingTimer);
            try {
              yield this.sendCmd("heartbeat");
            } catch (t2) {
              if (yield this.testHeartBeat5Timeout())
                return this.core.reporterHookLinkKeep && (yield this.core.reporterHookLinkKeep.update({ code: 0, description: "Heartbeat-discovered link failure", operation_type: 1, target: null === (e2 = this.socket) || void 0 === e2 ? void 0 : e2.url }), this.core.reporterHookLinkKeep.end(true)), void this.doDisconnect(rt.OFFLINE, "PingError");
            }
            this.pingTimer = setTimeout(() => {
              this.ping();
            }, 3e4);
          });
        }
        testHeartBeat5Timeout() {
          return __awaiter(this, void 0, void 0, function* () {
            clearTimeout(this.pingTimer);
            for (var e2 = 0; e2 < 5; e2++)
              try {
                return yield this.sendCmd("heartbeat", {}, { timeout: 3e3 }), false;
              } catch (t2) {
                this.logger.log(`clientsocketV1:: test heartbeat ${e2} Timeout`);
              }
            return true;
          });
        }
        initOnlineListener() {
          this.hasNetworkListener || (this.logger.log("clientsocketV1::onlineListener:init"), this.hasNetworkListener = true, ge.net.onNetworkStatusChange((e2) => {
            this.logger.log("clientsocketV1::onlineListener:network change", e2), e2.isConnected && "logined" === this.core.status ? this.ping() : e2.isConnected && "waitReconnect" === this.core.status ? (this.reconnectTimer && clearTimeout(this.reconnectTimer), this.core.V1NIMLoginService.login({ isAutoReconnect: true }).catch(() => {
              this.logger.error(`clientsocketV1::attempToReconnect failed ${this.retryCount}`);
            })) : e2.isConnected || this.doDisconnect(rt.OFFLINE, "OfflineListener");
          }));
        }
        destroyOnlineListener() {
          this.logger.log("clientsocketV1::onlineListener:destroy"), ge.net.offNetworkStatusChange(), this.hasNetworkListener = false;
        }
        disconnect() {
          switch (this.core.status) {
            case "connected":
            case "logined":
            case "connecting":
            case "waitReconnect":
              return this.doDisconnect(rt.ACTIVE, "UserActiveDisconnect"), Promise.resolve();
            default:
              return Promise.resolve();
          }
        }
      }
      class V1NIMLoginLbs {
        constructor(e2) {
          this.socketLinkUrls = [], this.timer = 0, this.failedCount = 0, this.core = e2, this.auth = e2.V1NIMLoginService, this.logger = this.core.logger;
        }
        getLbsInfos() {
          return __awaiter(this, void 0, void 0, function* () {
            if (this.socketLinkUrls.length > 0) {
              var e2 = this.socketLinkUrls;
              return this.socketLinkUrls = [], this.core.logger.log("V1NIMLoginService::getLbsInfos:use cache link", e2), Promise.resolve(e2);
            }
            this.core.reporterHookLBS.start(this.core.account);
            var t2 = uniq(this.auth.config.lbsUrls);
            try {
              var r2 = yield this.ladderLoad(t2);
              if (200 !== r2.status || !r2.data)
                throw this.core.logger.error("V1NIMLoginService::getLbsInfos:error status", r2.status, r2), new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INTERNAL, detail: { reason: `V1NIMLoginService::getLbsInfos failed, status ${r2.status}` } });
              this.success(r2);
            } catch (e3) {
              var i2 = e3;
              if (this.core.logger.error(`V1NIMLoginService::lbs getLbsInfos error, use default link: ${this.auth.config.linkUrl}. error:`, e3), this.reportForFail(t2[0], i2.code, i2.message), this.checkTerminator(i2.code))
                throw e3;
              this.socketLinkUrls = [this.auth.config.linkUrl];
            }
            return this.socketLinkUrls;
          });
        }
        checkTerminator(e2) {
          return e2 === ce.V2NIM_ERROR_CODE_CANCELLED || e2 === ce.V2NIM_ERROR_CODE_TIMEOUT;
        }
        generateUrl(e2) {
          var t2 = (e2 = this.processLbsUrl(e2)).indexOf("?") > -1 ? "&" : "?";
          return e2 + t2 + "k=" + this.core.options.appkey + "&id=" + this.core.auth.getLoginUser() + "&sv=180&pv=1&networkType=0&lv=1";
        }
        processLbsUrl(e2) {
          return pendingIsMiniappEnv() ? e2.replace("/webconf", "/wxwebconf") : e2;
        }
        requstLbs(e2) {
          return this.auth.doLoginStepsManager.add(this.core.adapters.request(this.generateUrl(e2), { method: "GET", dataType: "json", timeout: 8e3 }));
        }
        setLadderTimer(e2, t2, r2, i2) {
          this.timer && clearTimeout(this.timer);
          var s2 = e2[t2];
          this.timer = setTimeout(() => {
            s2 && (this.setLadderTimer(e2, t2 + 1, r2, i2), this.core.logger.log(`V1NIMLoginService::getLbsInfos ${t2}:`, this.processLbsUrl(s2)), this.reportForLbsStart(s2, t2), this.requstLbs(s2).then((e3) => {
              this.reset(), r2(Object.assign(Object.assign({}, e3), { url: s2 }));
            }).catch((r3) => {
              var n2;
              if (this.core.logger.warn(`V1NIMLoginService::getLbsInfos ${t2} failed:`, r3), this.failedCount += 1, this.reportForFailOnce(s2, r3.code, (null === (n2 = r3.detail) || void 0 === n2 ? void 0 : n2.reason) || r3.message), this.failedCount >= e2.length || this.checkTerminator(r3.code))
                return this.reset(), void i2(r3);
            }));
          }, 2e3);
        }
        ladderLoad(e2) {
          return new Promise((t2, r2) => {
            e2.length > 1 && this.setLadderTimer(e2, 1, t2, r2);
            var i2 = e2[0];
            this.core.logger.log("V1NIMLoginService::getLbsInfos 0:", i2), this.reportForLbsStart(i2, 0), this.requstLbs(i2).then((e3) => {
              this.reset(), t2(Object.assign(Object.assign({}, e3), { url: i2 }));
            }).catch((t3) => {
              var s2;
              this.failedCount += 1, this.core.logger.warn("V1NIMLoginService::getLbsInfos 0 failed:", t3), this.reportForFailOnce(i2, t3.code, (null === (s2 = t3.detail) || void 0 === s2 ? void 0 : s2.reason) || t3.message), (this.failedCount >= e2.length || this.checkTerminator(t3.code)) && (this.reset(), r2(t3));
            });
          });
        }
        success(e2) {
          var t2, r2, i2 = e2.data, s2 = [this.auth.config.linkUrl];
          get(i2, "common.link") && (s2 = get(i2, "common.link").concat(s2)), get(i2, 'common["link.default"]') && (s2 = s2.concat(get(i2, 'common["link.default"]'))), this.socketLinkUrls = s2, i2["nos-chunk"] && (this.logger.log("getLbsInfos success. lbs.nos-chunk", i2["nos-chunk"]), null === (t2 = this.core.cloudStorage) || void 0 === t2 || t2.setOptions({ chunkUploadHost: i2["nos-chunk"] })), Array.isArray(i2.nosup) && i2.nosup.length > 0 && (this.logger.log("getLbsInfos success. lbs.nosup", i2.nosup), null === (r2 = this.core.cloudStorage) || void 0 === r2 || r2.setOptions({ commonUploadHostBackupList: i2.nosup, commonUploadHost: i2.nosup[0] })), this.core.logger.log("V1NIMLoginService::getLbsInfos success, socket link:", this.socketLinkUrls.slice(0), "chunkUploadHost: ", e2.data["nos-chunk"]), this.reportForLbsSuccess(e2.url, e2.data);
        }
        reportForLbsStart(e2, t2) {
          this.core.reporterHookLBS.updateBegin({ target: e2, index: t2 });
        }
        reportForLbsSuccess(e2, t2) {
          this.core.reporterHookLBS.updateComplete({ target: e2, code: 200, body: JSON.stringify(t2) }), this.core.reporterHookLBS.end(true), this.core.reporter.reportTraceUpdateV2("login", { operation_type: "HTTP", target: e2, code: 200, succeed: true }, { asyncParams: ge.net.getNetworkStatus() });
        }
        reportForFailOnce(e2, t2, r2) {
          this.core.reporterHookLBS.updateComplete({ target: e2, code: t2, body: r2 });
        }
        reportForFail(e2, t2, r2) {
          this.core.reporterHookLBS.end(false), this.core.reporter.reportTraceUpdateV2("login", { operation_type: "HTTP", target: e2, description: r2, code: t2, succeed: false }, { asyncParams: ge.net.getNetworkStatus() });
        }
        reset() {
          this.socketLinkUrls = [], this.failedCount = 0, clearTimeout(this.timer);
        }
      }
      class V1NIMLoginAuthenticator {
        constructor(e2) {
          this.core = e2;
        }
        verifyAuthentication(e2 = false) {
          var t2, r2, i2;
          return __awaiter(this, void 0, void 0, function* () {
            var s2 = this.core.options, n2 = ge.getSystemInfo(), a2 = Object.assign(Object.assign({}, s2), { appLogin: e2 ? 0 : 1, appkey: s2.appkey, account: s2.account, token: s2.token, deviceId: this.core.auth.deviceId, clientSession: this.core.auth.clientSession, clientType: 16, protocolVersion: 1, sdkVersion: 100941, sdkHumanVersion: "10.9.41", os: n2.os, browser: n2.browser, userAgent: this.core.options.loginSDKTypeParamCompat ? "Native/10.9.41" : n2.userAgent.replace("{{appkey}}", s2.appkey).slice(0, 299), libEnv: this.core.options.loginSDKTypeParamCompat ? void 0 : n2.libEnv, hostEnv: this.core.options.loginSDKTypeParamCompat ? 0 : n2.hostEnvEnum }), o2 = n2.os.toLowerCase();
            if ("UNIAPP" === ge.platform && ("ios" === o2 || "android" === o2)) {
              a2.isReactNative = 1, a2.clientType = "ios" === o2 ? 2 : 1;
              var c2 = !!(null === (t2 = this.core.offlinePush.authConfig) || void 0 === t2 ? void 0 : t2.honorCertificateName);
              n2.pushDeviceInfo && n2.pushDeviceInfo.MANUFACTURER && (a2.deviceInfo = JSON.stringify(Object.assign({ IS_SUPPORT_HONOR: c2 }, n2.pushDeviceInfo)));
            }
            this.core.logger.log(`clientSocketV1::do login,accid:${s2.account};clientSession:${null === (i2 = null === (r2 = this.core.clientSocket) || void 0 === r2 ? void 0 : r2.socket) || void 0 === i2 ? void 0 : i2.sessionId}`);
            var d2 = yield this.core.clientSocket.sendCmd("login", { login: a2 });
            if (d2.error)
              throw d2.error;
            var { loginRes: l2, loginPorts: m2, aosPushInfo: p2 } = d2.content, u2 = formatMultiPortLoginInfo(m2, 2);
            return (u2 = u2.filter((e3) => e3.connectionId !== l2.connectionId)).length > 0 && this.core.emit("multiPortLogin", u2), Object.assign(Object.assign({}, l2), { aosPushInfo: p2 });
          });
        }
        checkLoginTerminalCode(e2) {
          if (void 0 === e2)
            return false;
          return [201, 302, 317, 403, 404, 417, 422].includes(e2);
        }
      }
      class V2Service extends se {
        constructor(e2, t2) {
          super(), this.name = e2, this.logger = t2.logger, this.core = t2;
        }
        checkV2() {
          var e2 = this.core.options.apiVersion;
          if ("v2" === e2)
            return true;
          throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_MISUSE, detail: { reason: `The version "${e2}" of client is not supported.` } });
        }
        checkLogin() {
          if (0 === this.core.V2NIMLoginService.getLoginStatus())
            throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_ILLEGAL_STATE, detail: { reason: "Client logout." } });
        }
        emit(e2, ...t2) {
          this.logger.debug(`${this.name}::emit event: '${e2.toString()}',`, void 0 !== t2[0] ? t2[0] : "", void 0 !== t2[1] ? t2[1] : "", void 0 !== t2[2] ? t2[2] : "");
          try {
            return super.emit(e2, ...t2);
          } catch (t3) {
            return setTimeout(() => {
              throw this.logger.error(`${this.name}::emit throw error in setTimeout. event: ${e2.toString()}. Error`, t3), t3;
            }, 0), false;
          }
        }
        process(e2) {
          var t2 = this[e2.cmd + "Handler"], r2 = this.handler && this.handler[e2.cmd + "Handler"];
          if ("function" == typeof t2 || "function" == typeof r2) {
            if (e2.error)
              return this.logger.error(`${e2.cmd}::recvError`, e2.error), Promise.reject(e2.error);
            try {
              var i2 = t2 ? t2.call(this, e2) : r2.call(this.handler, e2);
              return Promise.resolve(i2);
            } catch (e3) {
              return Promise.reject(e3);
            }
          }
          var s2 = get(e2, "error.detail.ignore");
          return e2.error && !s2 ? Promise.reject(e2.error) : Promise.resolve(e2);
        }
      }
      class Service$1 {
        constructor(e2, t2) {
          this.name = e2, this.core = t2, this.name = e2, this.logger = t2.logger, this.core = t2;
        }
        process(e2) {
          var t2 = this[e2.cmd + "Handler"];
          if ("function" == typeof t2)
            return t2.call(this, e2);
          var r2 = get(e2, "error.detail.ignore");
          return e2.error && !r2 ? Promise.reject(e2.error) : Promise.resolve(e2);
        }
      }
      var at = { "6_3": "notifylog", "6_4": "uploadLog", "6_23": "getServerTime", "6_31": "notifyDetect", "6_32": "uploadDetect", "6_37": "wsDetect" }, ot = { type: 1, params: 2, result: 3, t1: 100, t2: 101, t3: 102, t4: 103, t5: 104, t6: 105 }, ct = { k1: 1, k2: 2, k3: 3, k4: 4, k5: 5, k6: 6, k7: 7, k8: 8, k9: 9, k10: 10 }, dt = { notifylog: { sid: 6, cid: 3, service: "misc" }, uploadLog: { sid: 6, cid: 4, service: "misc", hasPacketResponse: false, params: [{ type: "String", name: "url" }, { type: "Property", name: "data", reflectMapper: { type: 1, content: 2 } }] }, getServerTime: { sid: 6, cid: 23, service: "misc", response: [{ type: "Long", name: "time" }] }, notifyDetect: { sid: 6, cid: 31, service: "misc", response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(ot) }] }, uploadDetect: { sid: 6, cid: 32, service: "misc", hasPacketResponse: false, params: [{ type: "Property", name: "data", reflectMapper: ot }] }, wsDetect: { sid: 6, cid: 37, service: "misc", params: [{ type: "Property", name: "tag", reflectMapper: ct }], response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(ct) }] } }, lt = { type: { type: "number" }, t1: { type: "number" }, t2: { type: "number" }, t3: { type: "number" }, t4: { type: "number" }, t5: { type: "number" }, t6: { type: "number" } };
      class MiscService extends Service$1 {
        constructor(e2) {
          super("misc", e2), this.logLock = false, this.core = e2, registerParser({ cmdMap: at, cmdConfig: dt }), this.setListener();
        }
        setListener() {
          this.core.eventBus.on("BinaryClientSocket/unpackError", this.wsDetect.bind(this)), this.core.eventBus.on("V2NIMLoginService/loginLifeCycleLoginSucc", () => {
            this.core.timeOrigin.setOriginTimetick();
          }), this.core.eventBus.on("logined", () => {
            this.core.timeOrigin.setOriginTimetick();
          });
        }
        getServerTime() {
          return __awaiter(this, void 0, void 0, function* () {
            var e2 = yield this.core.clientSocket.sendCmd("getServerTime");
            return parseInt(e2.content.time);
          });
        }
        wsDetect(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            var t2 = Object.assign({ k1: "val1", k2: "val2" }, e2), r2 = null;
            try {
              r2 = (yield this.core.clientSocket.sendCmd("wsDetect", { tag: t2 })).content.data;
            } catch (e3) {
              var i2 = e3;
              return void (i2.code === ce.V2NIM_ERROR_CODE_UNPACK_ERROR ? (this.logger.warn("misc::wsDetect:998"), this.wsDetectUnreliable(), this.reportBinarySocketDetectResult("packet 998")) : this.logger.warn(`misc::wsDetect:failed ${i2.code}`));
            }
            r2 && JSON.stringify(r2) !== JSON.stringify(t2) ? (this.logger.warn("misc::wsDetect:content unreliable"), this.wsDetectUnreliable(), this.reportBinarySocketDetectResult("content unreliable")) : this.logger.log("misc::wsDetect:success");
          });
        }
        wsDetectUnreliable() {
          this.core.clientSocket.doDisconnect(3, "WSDetectUnreliable");
        }
        reportBinarySocketDetectResult(e2) {
          var t2;
          this.core.reporter.reportTraceStart("exceptions", { user_id: this.core.account, trace_id: null === (t2 = this.core.clientSocket.socket) || void 0 === t2 ? void 0 : t2.sessionId, start_time: Date.now(), action: 2, exception_service: 9 }), this.core.reporter.reportTraceUpdateV2("exceptions", { code: 998, description: `wsDetect::reconnect cause: ${e2}`, operation_type: "5", target: "6-37" }), this.core.reporter.reportTraceEnd("exceptions", 1);
        }
        notifyDetectHandler(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            var t2 = function formatNotifyDetectTag(e3) {
              return format(lt, e3);
            }(e2.content.data);
            t2.t3 = e2.__receiveTimeNode.time, t2.t4 = Date.now();
            try {
              yield this.core.clientSocket.sendCmd("uploadDetect", { data: t2 });
            } catch (e3) {
              this.core.logger.warn("misc::notifyDetectHandler:upload failed", e3);
            }
          });
        }
        notifylogHandler() {
          return __awaiter(this, void 0, void 0, function* () {
            var e2 = void 0;
            if (this.logLock)
              this.core.logger.warn("misc::notifylogHandler:locked");
            else {
              this.logLock = true;
              try {
                e2 = yield this.core.logger.extractLogs();
              } catch (e3) {
                return void (this.logLock = false);
              }
              if (e2) {
                var t2 = "";
                try {
                  t2 = (yield this.core.cloudStorage.uploadFile("string" == typeof e2 ? { type: "file", filePath: e2 } : { type: "file", file: e2 })).url;
                } catch (e3) {
                  return void (this.logLock = false);
                }
                if (t2) {
                  t2 += (t2.indexOf("?") > 0 ? "&" : "?") + "download=" + (/* @__PURE__ */ new Date()).getTime() + "_web.log";
                  try {
                    yield this.core.clientSocket.sendCmd("uploadLog", { url: t2 });
                  } catch (e3) {
                    return void (this.logLock = false);
                  }
                  try {
                    yield this.logger.afterUpload();
                  } catch (e3) {
                  }
                  this.logLock = false;
                } else
                  this.logLock = false;
              } else
                this.logLock = false;
            }
          });
        }
      }
      var mt = { needReconnect: true, reconnectionAttempts: Number.MAX_SAFE_INTEGER, lbsUrls: Se, linkUrl: Me, xhrConnectTimeout: 8e3, socketConnectTimeout: 8e3, linkSSL: true };
      function formatLoginInfo(e2) {
        return format({ type: { type: "number" }, port: { type: "number" }, customClientType: { type: "number" }, timestamp: { type: "number" }, loginType: { type: "number" } }, e2);
      }
      var pt = { "26_3": "v2Login", "26_5": "v2Logout", "26_8": "v2KickOffline", "26_9": "v2BeKicked", "26_10": "v2LoginClientChange", "36_1": "v2GetChatroomLinkAddress" }, ut = { "1_2": "heartbeat", "2_7": "nimLoginClientChange", "24_8": "qchatLoginClientChange" }, ht = { webLoginReqTag: { clientType: 3, os: 4, sdkVersion: 6, appLogin: 8, protocolVersion: 9, pushTokenName: 10, pushToken: 11, clientId: 13, appkey: 18, account: 19, browser: 24, clientSession: 26, deviceInfo: 32, isReactNative: 112, customTag: 38, customClientType: 39, sdkHumanVersion: 40, hostEnv: 41, userAgent: 42, libEnv: 44, authType: 115, thirdPartyExtension: 116, env: 119, isRoutable: 120, token: 1e3 }, mixAuthRepTag: { clientId: 1, consid: 2, clientIP: 3, port: 4, type: 5, customClientType: 6, timestamp: 7, customTag: 8, os: 9, pushType: 10, hasTokenPreviously: 11, loginType: 12 }, nimAuthRepTag: { type: 3, os: 4, mac: 5, clientId: 13, account: 19, deviceInfo: 32, customTag: 38, customClientType: 39, consid: 102, clientIP: 103, port: 104, timestamp: 109, pushType: 110, hasTokenPreviously: 111 }, qchatAuthRepTag: { clientId: 8, consid: 102, clientIP: 103, port: 104, type: 6, customClientType: 13, timestamp: 105, os: 30, pushType: 100, hasTokenPreviously: 101 } }, gt = { v2Login: { sid: 26, cid: 3, service: "auth", params: [{ type: "Property", name: "tag", reflectMapper: ht.webLoginReqTag }], response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(ht.mixAuthRepTag) }, { type: "PropertyArray", name: "loginClients", reflectMapper: invertSerializeItem(ht.mixAuthRepTag) }] }, v2Logout: { sid: 26, cid: 5, service: "auth" }, v2KickOffline: { sid: 26, cid: 8, service: "auth", params: [{ type: "StrArray", name: "clientIds" }], response: [{ type: "StrArray", name: "clientIds" }] }, v2BeKicked: { sid: 26, cid: 9, service: "auth", response: [{ type: "Int", name: "clientType" }, { type: "Int", name: "reason" }, { type: "String", name: "reasonDesc" }, { type: "Int", name: "customClientType" }] }, v2LoginClientChange: { sid: 26, cid: 10, service: "auth", response: [{ type: "Byte", name: "state" }, { type: "PropertyArray", name: "datas", reflectMapper: invertSerializeItem(ht.mixAuthRepTag) }] }, v2GetChatroomLinkAddress: { sid: 36, cid: 1, service: "auth", params: [{ type: "Long", name: "roomId" }, { type: "Bool", name: "miniProgram" }], response: [{ type: "StrArray", name: "linkAddress" }] } }, vt = { heartbeat: { sid: 1, cid: 2, service: "auth" }, nimLoginClientChange: { sid: 2, cid: 7, service: "auth", response: [{ type: "Byte", name: "state" }, { type: "PropertyArray", name: "datas", reflectMapper: invertSerializeItem(ht.nimAuthRepTag) }] }, qchatLoginClientChange: { sid: 24, cid: 8, service: "auth", response: [{ type: "Byte", name: "state" }, { type: "Property", name: "data", reflectMapper: invertSerializeItem(ht.qchatAuthRepTag) }] } }, abs = function(e2) {
        var t2;
        if (void 0 !== e2)
          return (t2 = BigNumber(e2)).sign = 1, t2;
      }, isArray = function(e2) {
        return "[object Array]" === Object.prototype.toString.call(e2);
      }, isValidType = function(e2) {
        return ["number" == typeof e2, "string" == typeof e2 && e2.length > 0, isArray(e2) && e2.length > 0, e2 instanceof BigNumber].some(function(e3) {
          return true === e3;
        });
      }, yt = "Invalid Number", ft = "Invalid Number - Division By Zero";
      function BigNumber(e2) {
        var t2;
        if (!(this instanceof BigNumber))
          return new BigNumber(e2);
        if (this.number = [], this.sign = 1, this.rest = 0, isValidType(e2)) {
          if (isArray(e2)) {
            for ((e2.length && "-" === e2[0] || "+" === e2[0]) && (this.sign = "+" === e2[0] ? 1 : -1, e2.shift(0)), t2 = e2.length - 1; t2 >= 0; t2--)
              if (!this.addDigit(e2[t2]))
                return;
          } else
            for ("-" !== (e2 = e2.toString()).charAt(0) && "+" !== e2.charAt(0) || (this.sign = "+" === e2.charAt(0) ? 1 : -1, e2 = e2.substring(1)), t2 = e2.length - 1; t2 >= 0; t2--)
              if (!this.addDigit(parseInt(e2.charAt(t2), 10)))
                return;
        } else
          this.number = yt;
      }
      BigNumber.prototype.addDigit = function(e2) {
        return function(e3) {
          return /^\d$/.test(e3);
        }(e2) ? (this.number.push(e2), this) : (this.number = yt, false);
      }, BigNumber.prototype._compare = function(e2) {
        var t2, r2;
        if (!isValidType(e2))
          return null;
        if (t2 = BigNumber(e2), this.sign !== t2.sign)
          return this.sign;
        if (this.number.length > t2.number.length)
          return this.sign;
        if (this.number.length < t2.number.length)
          return -1 * this.sign;
        for (r2 = this.number.length - 1; r2 >= 0; r2--) {
          if (this.number[r2] > t2.number[r2])
            return this.sign;
          if (this.number[r2] < t2.number[r2])
            return -1 * this.sign;
        }
        return 0;
      }, BigNumber.prototype.gt = function(e2) {
        return this._compare(e2) > 0;
      }, BigNumber.prototype.gte = function(e2) {
        return this._compare(e2) >= 0;
      }, BigNumber.prototype.equals = function(e2) {
        return 0 === this._compare(e2);
      }, BigNumber.prototype.lte = function(e2) {
        return this._compare(e2) <= 0;
      }, BigNumber.prototype.lt = function(e2) {
        return this._compare(e2) < 0;
      }, BigNumber.prototype.subtract = function(e2) {
        var t2;
        return void 0 === e2 ? this : (t2 = BigNumber(e2), this.sign !== t2.sign ? (this.number = BigNumber._add(this, t2), this) : (this.sign = this.lt(t2) ? -1 : 1, this.number = abs(this).lt(abs(t2)) ? BigNumber._subtract(t2, this) : BigNumber._subtract(this, t2), this));
      }, BigNumber._add = function(e2, t2) {
        var r2, i2 = 0, s2 = Math.max(e2.number.length, t2.number.length);
        for (r2 = 0; r2 < s2 || i2 > 0; r2++)
          e2.number[r2] = (i2 += (e2.number[r2] || 0) + (t2.number[r2] || 0)) % 10, i2 = Math.floor(i2 / 10);
        return e2.number;
      }, BigNumber._subtract = function(e2, t2) {
        var r2, i2 = 0, s2 = e2.number.length;
        for (r2 = 0; r2 < s2; r2++)
          e2.number[r2] -= (t2.number[r2] || 0) + i2, e2.number[r2] += 10 * (i2 = e2.number[r2] < 0 ? 1 : 0);
        for (r2 = 0, s2 = e2.number.length - 1; 0 === e2.number[s2 - r2] && s2 - r2 > 0; )
          r2++;
        return r2 > 0 && e2.number.splice(-r2), e2.number;
      }, BigNumber.prototype.multiply = function(e2) {
        if (void 0 === e2)
          return this;
        var t2, r2, i2 = BigNumber(e2), s2 = 0, n2 = [];
        if (this.isZero() || i2.isZero())
          return BigNumber(0);
        for (this.sign *= i2.sign, t2 = 0; t2 < this.number.length; t2++)
          for (s2 = 0, r2 = 0; r2 < i2.number.length || s2 > 0; r2++)
            n2[t2 + r2] = (s2 += (n2[t2 + r2] || 0) + this.number[t2] * (i2.number[r2] || 0)) % 10, s2 = Math.floor(s2 / 10);
        return this.number = n2, this;
      }, BigNumber.prototype.divide = function(e2) {
        if (void 0 === e2)
          return this;
        var t2, r2, i2 = BigNumber(e2), s2 = [], n2 = BigNumber(0);
        if (i2.isZero())
          return this.number = ft, this;
        if (this.isZero())
          return this.rest = BigNumber(0), this;
        if (this.sign *= i2.sign, i2.sign = 1, 1 === i2.number.length && 1 === i2.number[0])
          return this.rest = BigNumber(0), this;
        for (t2 = this.number.length - 1; t2 >= 0; t2--)
          for (n2.multiply(10), n2.number[0] = this.number[t2], s2[t2] = 0; i2.lte(n2); )
            s2[t2]++, n2.subtract(i2);
        for (t2 = 0, r2 = s2.length - 1; 0 === s2[r2 - t2] && r2 - t2 > 0; )
          t2++;
        return t2 > 0 && s2.splice(-t2), this.rest = n2, this.number = s2, this;
      }, BigNumber.prototype.mod = function(e2) {
        return this.divide(e2).rest;
      }, BigNumber.prototype.isZero = function() {
        var e2;
        for (e2 = 0; e2 < this.number.length; e2++)
          if (0 !== this.number[e2])
            return false;
        return true;
      }, BigNumber.prototype.toString = function() {
        var e2, t2 = "";
        if ("string" == typeof this.number)
          return this.number;
        for (e2 = this.number.length - 1; e2 >= 0; e2--)
          t2 += this.number[e2];
        return this.sign > 0 ? t2 : "-" + t2;
      };
      var It, Mt, St = Math.pow(2, 32);
      function varintToBytes(e2) {
        for (var t2 = new Uint8Array(5), r2 = new DataView(t2.buffer), i2 = 0; 0 != (4294967168 & e2); )
          r2.setUint8(i2++, 127 & e2 | 128), e2 >>>= 7;
        return r2.setUint8(i2++, 127 & e2), t2.slice(0, i2);
      }
      function decodeText(e2) {
        return "function" == typeof TextDecoder ? new TextDecoder("utf-8").decode(e2) : function textDecoder(e3) {
          for (var t2 = "", r2 = 0; r2 < e3.length; ) {
            var i2 = e3[r2], s2 = 0, n2 = 0;
            if (i2 <= 127 ? (s2 = 0, n2 = 255 & i2) : i2 <= 223 ? (s2 = 1, n2 = 31 & i2) : i2 <= 239 ? (s2 = 2, n2 = 15 & i2) : i2 <= 244 && (s2 = 3, n2 = 7 & i2), e3.length - r2 - s2 > 0)
              for (var a2 = 0; a2 < s2; )
                n2 = n2 << 6 | 63 & (i2 = e3[r2 + a2 + 1]), a2 += 1;
            else
              n2 = 65533, s2 = e3.length - r2;
            t2 += String.fromCodePoint(n2), r2 += s2 + 1;
          }
          return t2;
        }(e2);
      }
      class Unpack {
        constructor(e2) {
          this.offset = 0, this.buffer = new Uint8Array(e2), this.view = new DataView(e2);
        }
        checkBufferBoundaryAccess() {
          return this.offset >= this.buffer.byteLength;
        }
        length() {
          var e2;
          return (null === (e2 = this.view) || void 0 === e2 ? void 0 : e2.byteLength) || 0;
        }
        getBuffer() {
          return this.view.buffer;
        }
        getOffset() {
          return this.offset;
        }
        popRaw(e2) {
          try {
            var t2 = this.buffer.slice(this.offset, this.offset + e2);
            return this.offset += e2, t2;
          } catch (e3) {
            throw new Error(`UnpackException raw ${e3 && e3.message}`);
          }
        }
        popByte() {
          try {
            var e2 = this.view.getUint8(this.offset);
            return this.offset += 1, e2;
          } catch (e3) {
            throw new Error(`UnpackException byte ${e3 && e3.message}`);
          }
        }
        popVarbin() {
          return this.popRaw(this.popVarInt());
        }
        popString() {
          try {
            return decodeText(this.popVarbin());
          } catch (e2) {
            throw new Error(`UnpackException string ${e2 && e2.message}`);
          }
        }
        popInt() {
          try {
            var e2 = this.view.getUint32(this.offset, true);
            return this.offset += 4, e2;
          } catch (e3) {
            throw new Error(`UnpackException int ${e3 && e3.message}`);
          }
        }
        popVarInt() {
          var e2 = 1, t2 = 0, r2 = 0, i2 = 0;
          do {
            if (t2 += (127 & (r2 = this.popByte())) * e2, e2 *= 128, (i2 += 1) > 5)
              throw new Error("Variable length quantity is too long");
          } while (0 != (128 & r2));
          return t2;
        }
        popLong() {
          try {
            var e2 = function getBigUint64(e3, t2 = false) {
              var r2 = new DataView(e3.buffer), [i2, s2] = t2 ? [4, 0] : [0, 4], n2 = r2.getUint32(i2, t2), a2 = r2.getUint32(s2, t2);
              return n2 > 0 ? n2 * St + a2 : a2;
            }(this.buffer.slice(this.offset, this.offset + 8), true);
            return this.offset += 8, Number(e2);
          } catch (e3) {
            throw new Error(`UnpackException long ${e3 && e3.message}`);
          }
        }
        popShort() {
          try {
            var e2 = this.view.getUint16(this.offset, true);
            return this.offset += 2, e2;
          } catch (e3) {
            throw new Error(`UnpackException short ${e3 && e3.message}`);
          }
        }
        popBoolean() {
          return this.popByte() > 0;
        }
        toString() {
          return Array.from(new Uint8Array(this.buffer)).toString();
        }
        reset() {
          this.offset = 0, this.buffer = null, this.view = null;
        }
      }
      class PacketDecoder {
        constructor(e2) {
          this.packetLength = 0, this.serviceId = 0, this.commandId = 0, this.serialId = 0, this.tag = 0, this.resCode = 200, this.innerHeader = null, this.msgId = 0, this.bodyArr = [], this.unpack = new Unpack(e2);
        }
        reset() {
          this.innerHeader = null, this.bodyArr = [], this.unpack.reset();
        }
        getBodyDetail() {
          return this.bodyArr.join("");
        }
        unmarshalHeader() {
          var e2 = this._unmarshalHeader();
          this.packetLength = e2.packetLength, this.serviceId = e2.serviceId, this.commandId = e2.commandId, this.serialId = e2.serialId, this.tag = e2.tag, this.resCode = e2.resCode, 4 === e2.serviceId && [1, 2, 10, 11].includes(e2.commandId) && (this.msgId = this.unmarshalLong(), this.innerHeader = this._unmarshalHeader());
        }
        _unmarshalHeader() {
          var e2 = this.unpack.popVarInt(), t2 = this.unpack.popByte(), r2 = this.unpack.popByte(), i2 = this.unpack.popShort(), s2 = this.unpack.popByte(), n2 = 200;
          return this.hasRescode(s2) && (n2 = this.unpack.popShort()), { packetLength: e2, serviceId: t2, commandId: r2, serialId: i2, tag: s2, resCode: n2 };
        }
        hasRescode(e2) {
          return 0 != ((e2 = e2 || this.tag) & PacketDecoder.RES_CODE);
        }
        getHeader() {
          return { packetLength: this.packetLength, sid: this.serviceId, cid: this.commandId, ser: this.serialId, code: this.resCode };
        }
        getInnerHeader() {
          return this.innerHeader ? { sid: this.innerHeader.serviceId, cid: this.innerHeader.commandId } : null;
        }
        unmarshalProperty() {
          var e2 = this.unpack.popVarInt(), t2 = {};
          this.bodyArr.push(`
Property(${e2}) {`);
          for (var r2 = 0; r2 < e2; r2++) {
            var i2 = this.unpack.popVarInt();
            this.bodyArr.push(`${i2}:`);
            var s2 = this.unpack.popString();
            this.bodyArr.push(`"${s2.length} ${this.unpack.getOffset()}",`), t2[i2] = s2;
          }
          return this.bodyArr.push("},"), t2;
        }
        unmarshalPropertyArray() {
          var e2 = this.unpack.popVarInt(), t2 = [];
          this.bodyArr.push(`
PropertyArray(${e2}) [`);
          for (var r2 = 0; r2 < e2; r2++)
            t2.push(this.unmarshalProperty());
          return this.bodyArr.push("],"), t2;
        }
        unmarshalLong() {
          var e2 = this.unpack.popLong();
          return this.bodyArr.push(`
Long:${e2}`), e2;
        }
        unmarshalLongArray() {
          var e2 = this.unpack.popVarInt(), t2 = [];
          this.bodyArr.push(`
LongArray ${e2}:`);
          for (var r2 = 0; r2 < e2; r2++) {
            var i2 = this.unpack.popLong();
            this.bodyArr.push(`${i2},`), t2.push(i2);
          }
          return t2;
        }
        unmarshalStrArray() {
          var e2 = this.unpack.popVarInt(), t2 = [];
          this.bodyArr.push(`
StrArray ${e2}:`);
          for (var r2 = 0; r2 < e2; r2++) {
            var i2 = this.unpack.popString();
            this.bodyArr.push(`${i2},`), t2.push(i2);
          }
          return t2;
        }
        unmarshalStrLongMap() {
          var e2 = this.unpack.popVarInt(), t2 = {};
          this.bodyArr.push(`
StrLongMap ${e2}:`);
          for (var r2 = 0; r2 < e2; r2++) {
            var i2 = this.unpack.popString();
            this.bodyArr.push(`${i2},`);
            var s2 = this.unpack.popLong();
            this.bodyArr.push(`${s2};`), t2[i2] = s2;
          }
          return t2;
        }
        unmarshalStrStrMap() {
          var e2 = this.unpack.popVarInt(), t2 = {};
          this.bodyArr.push(`
StrStrMap ${e2}:`);
          for (var r2 = 0; r2 < e2; r2++) {
            var i2 = this.unpack.popString();
            this.bodyArr.push(`${i2},`);
            var s2 = this.unpack.popString();
            this.bodyArr.push(`${s2};`), t2[i2] = s2;
          }
          return t2;
        }
        unmarshalLongLongMap() {
          var e2 = this.unpack.popVarInt(), t2 = {};
          this.bodyArr.push(`
StrLongLongMap ${e2}:`);
          for (var r2 = 0; r2 < e2; r2++) {
            var i2 = this.unpack.popLong();
            this.bodyArr.push(`${i2},`);
            var s2 = this.unpack.popLong();
            this.bodyArr.push(`${s2};`), t2[i2] = s2;
          }
          return { m_map: t2 };
        }
        unmarshalKVArray() {
          var e2 = this.unpack.popVarInt(), t2 = [];
          this.bodyArr.push(`
KVArray ${e2}:`);
          for (var r2 = 0; r2 < e2; r2++)
            t2.push(this.unmarshalStrStrMap());
          return t2;
        }
        unmarshal(e2) {
          var t2 = Object.assign(Object.assign({}, this.getHeader()), { r: [] });
          if (this.innerHeader && (t2.r[0] = this.msgId, t2.r[1] = { body: [], headerPacket: this.getInnerHeader() }), ![200, 406, 808, 810, 7101].includes(t2.code))
            return JSON.stringify(t2);
          if (this.packetLength > 0 && this.packetLength > this.unpack.length())
            throw new Error(`UnpackException packetLength(${this.packetLength}) greater than bufferLength(${this.unpack.length()})`);
          var r2 = [];
          return e2 && e2.forEach((e3) => {
            if (!this.unpack.checkBufferBoundaryAccess())
              switch (e3.type) {
                case "PropertyArray":
                  r2.push(this.unmarshalPropertyArray());
                  break;
                case "Property":
                  r2.push(this.unmarshalProperty());
                  break;
                case "Byte":
                  r2.push(this.unpack.popByte());
                  break;
                case "Int":
                  r2.push(this.unpack.popInt());
                  break;
                case "Bool":
                  r2.push(this.unpack.popBoolean());
                  break;
                case "Long":
                  r2.push(this.unmarshalLong());
                  break;
                case "LongArray":
                  r2.push(this.unmarshalLongArray());
                  break;
                case "String":
                  r2.push(this.unpack.popString());
                  break;
                case "StrArray":
                  r2.push(this.unmarshalStrArray());
                  break;
                case "StrStrMap":
                  r2.push(this.unmarshalStrStrMap());
                  break;
                case "StrLongMap":
                  r2.push(this.unmarshalStrLongMap());
                  break;
                case "LongLongMap":
                  r2.push(this.unmarshalLongLongMap());
                  break;
                case "KVArray":
                  r2.push(this.unmarshalKVArray());
              }
          }), this.innerHeader ? t2.r[1].body = r2 : t2.r = r2, JSON.stringify(t2);
        }
      }
      PacketDecoder.RES_CODE = 2;
      class Pack {
        constructor() {
          this.offset = 0, this.pageSize = 1024, this.capacity = 1048576, this.buffer = new Uint8Array(this.pageSize), this.view = new DataView(this.buffer.buffer);
        }
        reset() {
          this.offset = 0, this.buffer = null, this.view = null;
        }
        size() {
          return this.offset;
        }
        getBuffer() {
          return this.buffer.slice(0, this.offset).buffer;
        }
        ensureCapacity(e2) {
          var t2 = this.offset + e2;
          if (t2 > this.capacity)
            throw new Error("PackException over limit");
          if (t2 > this.buffer.byteLength) {
            var r2 = Math.ceil(t2 / this.pageSize) * this.pageSize, i2 = new Uint8Array(r2);
            i2.set(this.buffer), this.buffer = i2, this.view = new DataView(this.buffer.buffer);
          }
        }
        putRaw(e2) {
          this.ensureCapacity(e2.length);
          try {
            this.buffer.set(e2, this.offset), this.offset += e2.length;
          } catch (e3) {
            throw new Error("PackException raw");
          }
        }
        putByte(e2) {
          this.ensureCapacity(1);
          try {
            this.view.setUint8(this.offset++, e2);
          } catch (e3) {
            throw new Error("PackException byte");
          }
        }
        putString(e2) {
          try {
            var t2 = function encodeText(e3) {
              if ("function" == typeof TextEncoder)
                return new TextEncoder().encode(e3);
              var t3 = function textEncoder(e4) {
                for (var t4 = [], r2 = e4.length, i2 = 0; i2 < r2; ) {
                  var s2 = e4.codePointAt(i2), n2 = 0, a2 = 0;
                  for (s2 <= 127 ? (n2 = 0, a2 = 0) : s2 <= 2047 ? (n2 = 6, a2 = 192) : s2 <= 65535 ? (n2 = 12, a2 = 224) : s2 <= 2097151 && (n2 = 18, a2 = 240), t4.push(a2 | s2 >> n2), n2 -= 6; n2 >= 0; )
                    t4.push(128 | s2 >> n2 & 63), n2 -= 6;
                  i2 += s2 >= 65536 ? 2 : 1;
                }
                return t4;
              }(e3);
              return new Uint8Array(t3);
            }(e2);
            this.putVarbin(t2);
          } catch (e3) {
            throw new Error("PackException string");
          }
        }
        putInt(e2) {
          this.ensureCapacity(4);
          try {
            this.view.setInt32(this.offset, e2, true), this.offset += 4;
          } catch (e3) {
            throw new Error("PackException int");
          }
        }
        putVarInt(e2) {
          var t2 = varintToBytes(e2);
          this.putRaw(t2);
        }
        putBoolean(e2) {
          this.ensureCapacity(1);
          try {
            this.view.setUint8(this.offset++, e2 ? 1 : 0);
          } catch (e3) {
            throw new Error("PackException boolean");
          }
        }
        putLong(e2) {
          this.ensureCapacity(8);
          try {
            var t2 = function setBigUint64(e3, t3 = false) {
              var r2 = new Uint8Array(8), i2 = new DataView(r2.buffer), s2 = Number(e3 > St - 1 ? e3 / St : 0), n2 = Number(4294967295 & e3), [a2, o2] = t3 ? [4, 0] : [0, 4];
              return i2.setUint32(a2, s2, t3), i2.setUint32(o2, n2, t3), r2;
            }(e2, true);
            this.buffer.set(t2, this.offset), this.offset += 8;
          } catch (e3) {
            throw new Error("PackException long");
          }
        }
        putStringAsLong(e2) {
          this.ensureCapacity(8);
          try {
            var t2 = function setBigUint64ForNumberOverflow(e3, t3 = false) {
              var r2 = new Uint8Array(8), i2 = new DataView(r2.buffer), s2 = BigNumber(e3).divide(St).number.reverse().join(""), n2 = BigNumber(e3).mod(St).number.reverse().join(""), a2 = Number(s2), o2 = Number(n2), [c2, d2] = t3 ? [4, 0] : [0, 4];
              return i2.setUint32(c2, a2, t3), i2.setUint32(d2, o2, t3), r2;
            }(e2, true);
            this.buffer.set(t2, this.offset), this.offset += 8;
          } catch (e3) {
            throw new Error("PackException stringAsLong");
          }
        }
        putShort(e2) {
          this.ensureCapacity(2);
          try {
            this.view.setInt16(this.offset, e2, true), this.offset += 2;
          } catch (e3) {
            throw new Error("PackException short");
          }
        }
        putVarbin(e2) {
          if (!e2)
            return this.ensureCapacity(1), this.putVarInt(0);
          if (e2.byteLength > Math.pow(2, 31) - 2)
            throw new Error("PackException varbin. too long");
          var t2 = varintToBytes(e2.length);
          this.ensureCapacity(t2.length + e2.length);
          try {
            this.buffer.set(t2, this.offset), this.offset += t2.length, this.buffer.set(e2, this.offset), this.offset += e2.length;
          } catch (e3) {
            throw new Error("PackException varbin");
          }
        }
      }
      function isConvertibleToNumber(e2) {
        if ("number" != typeof e2) {
          if (null == e2)
            return false;
          e2 = Number(e2);
        }
        if (isNaN(e2))
          throw new Error("Number type conversion error");
        return true;
      }
      function isUndefinedOrNull(e2) {
        return null == e2;
      }
      class PacketEncoder {
        constructor(e2, t2, r2) {
          this.pack = new Pack(), this.packetLength = 0, this.serviceId = 0, this.commandId = 0, this.serialId = 0, this.tag = 0, this.serviceId = e2, this.commandId = t2, this.serialId = r2;
        }
        marshalHeader() {
          this.pack.putVarInt(this.packetLength), this.pack.putByte(this.serviceId), this.pack.putByte(this.commandId), this.pack.putShort(this.serialId), this.pack.putByte(this.tag);
        }
        marshalProperty(e2) {
          var t2 = Object.keys(e2).filter((e3) => !isUndefinedOrNull(e3));
          this.pack.putVarInt(t2.length), t2.forEach((t3) => {
            this.pack.putVarInt(Number(t3)), Array.isArray(e2[t3]) || "[object Object]" === Object.prototype.toString.call(e2[t3]) ? this.pack.putString(JSON.stringify(e2[t3])) : this.pack.putString(String(e2[t3]));
          });
        }
        marshalPropertyArray(e2) {
          var t2 = e2.length;
          this.pack.putVarInt(t2), e2.forEach((e3) => {
            this.marshalProperty(null == e3 ? void 0 : e3.v);
          });
        }
        marshalStrArray(e2) {
          var t2 = e2.filter((e3) => !isUndefinedOrNull(e3)), r2 = t2.length;
          this.pack.putVarInt(r2), t2.forEach((e3) => {
            this.pack.putString(String(e3));
          });
        }
        marshalLongArray(e2) {
          var t2 = e2.filter((e3) => isConvertibleToNumber(e3)), r2 = t2.length;
          this.pack.putVarInt(r2), t2.forEach((e3) => {
            this.putLong(e3);
          });
        }
        marshalStrStrMap(e2) {
          var t2 = Object.keys(e2).filter((t3) => !isUndefinedOrNull(e2[t3]) && !isUndefinedOrNull(t3));
          this.pack.putVarInt(t2.length), t2.forEach((t3) => {
            this.pack.putString(String(t3)), this.pack.putString(String(e2[t3]));
          });
        }
        marshalStrLongMap(e2) {
          var t2 = Object.keys(e2).filter((t3) => isConvertibleToNumber(e2[t3]) && !isUndefinedOrNull(t3));
          this.pack.putVarInt(t2.length), t2.forEach((t3) => {
            this.pack.putString(String(t3)), this.putLong(e2[t3]);
          });
        }
        marshalLongLongMap(e2) {
          var t2 = Object.keys(e2).filter((t3) => {
            var r2 = Number(t3);
            return isConvertibleToNumber(r2) && isConvertibleToNumber(e2[r2]);
          });
          this.pack.putVarInt(t2.length), t2.forEach((t3) => {
            var r2 = Number(t3);
            this.putLong(r2), this.putLong(e2[r2]);
          });
        }
        marshalKVArray(e2) {
          var t2 = e2.length;
          this.pack.putVarInt(t2), e2.forEach((e3) => {
            this.marshalStrStrMap(e3);
          });
        }
        putLong(e2) {
          "string" == typeof e2 && e2.length > 15 ? this.pack.putStringAsLong(e2) : this.pack.putLong(Number(e2));
        }
        marshal(e2, t2) {
          return this.marshalHeader(), t2 && t2.forEach((t3, r2) => {
            var i2, s2 = t3.type, n2 = null === (i2 = e2[r2]) || void 0 === i2 ? void 0 : i2.v;
            if (!isUndefinedOrNull(n2))
              switch (s2) {
                case "PropertyArray":
                  this.marshalPropertyArray(n2);
                  break;
                case "Property":
                  this.marshalProperty(n2);
                  break;
                case "Byte":
                  if (!isConvertibleToNumber(n2))
                    return;
                  this.pack.putByte(Number(n2));
                  break;
                case "Int":
                  if (!isConvertibleToNumber(n2))
                    return;
                  this.pack.putInt(Number(n2));
                  break;
                case "Bool":
                  "false" === n2 ? n2 = false : "true" === n2 && (n2 = true), this.pack.putBoolean(n2);
                  break;
                case "Long":
                  if (!isConvertibleToNumber(n2))
                    return;
                  this.putLong(n2);
                  break;
                case "LongArray":
                  this.marshalLongArray(n2);
                  break;
                case "String":
                  this.pack.putString(String(n2));
                  break;
                case "StrArray":
                  this.marshalStrArray(n2);
                  break;
                case "StrStrMap":
                  this.marshalStrStrMap(n2);
                  break;
                case "StrLongMap":
                  this.marshalStrLongMap(n2);
                  break;
                case "LongLongMap":
                  this.marshalLongLongMap(n2);
                  break;
                case "KVArray":
                  this.marshalKVArray(n2);
              }
          }), this.pack.getBuffer();
        }
        reset() {
          this.pack.reset();
        }
      }
      class BaseWebsocket extends se {
        constructor(e2, t2, r2) {
          super(), this.websocket = null, this.socketConnectTimer = 0, this.linkSSL = true, this.url = "", this.core = e2, this.url = t2, this.linkSSL = r2, this.status = "disconnected", this.logger = e2.logger, this.connect();
        }
        connect() {
          "connecting" !== this.status && "connected" !== this.status ? (this.status = "connecting", this._createWebsocket(`${this.linkSSL ? "wss" : "ws"}://${this.url}/websocket`)) : this.logger.warn("imsocket::socket is connecting or connected", this.status);
        }
        close() {
          if (this.status = "disconnected", this.websocket) {
            this.logger.log("imsocket:: close websocket");
            try {
              this.websocket.close();
            } catch (e2) {
              this.logger.warn("imsocket::attempt to close websocket error", e2);
            }
            this.clean(), this.emit("disconnect");
          }
        }
        clean() {
          this.status = "disconnected", clearTimeout(this.socketConnectTimer), this.websocket && (this.socketUrl = void 0, this.websocket.onmessage = null, this.websocket.onopen = null, this.websocket.onerror = null, this.websocket.onclose = null, this.websocket = null);
        }
        onConnect() {
          this.status = "connected", this.emit("connect"), clearTimeout(this.socketConnectTimer);
        }
        _createWebsocket(e2) {
          this.socketConnectTimer = setTimeout(() => {
            this.logger.error("imsocket::Websocket connect timeout. url: ", e2), this.emit("connectFailed", new V2NIMErrorImpl({ code: "v2" === get(this.core, "options.apiVersion") ? ce.V2NIM_ERROR_CODE_CONNECT_TIMEOUT : 415, detail: { reason: `imsocket::Websocket connect timeout. url: ${e2}` } }));
          }, this.core.options.socketConnectTimeout || 8e3), this.socketUrl = e2, this.websocket = new ge.WebSocket(e2), this.websocket.binaryType = "arraybuffer", this.websocket.onmessage = this.onMessage.bind(this), this.websocket.onclose = (e3) => {
            e3 = e3 || {}, this.logger.log(`imsocket::Websocket onclose done ${e3.wasClean}/${e3.code}/${e3.reason}`), "connected" === this.status ? (this.clean(), this.emit("disconnect")) : (this.clean(), this.emit("connectFailed", new V2NIMErrorImpl({ code: "v2" === get(this.core, "options.apiVersion") ? ce.V2NIM_ERROR_CODE_CONNECT_FAILED : 414, detail: { reason: "imsocket::Websocket onclose done" } })));
          }, this.websocket.onerror = (e3) => {
            this.logger.error("imsocket::Websocket onerror", e3), "connected" === this.status ? (this.clean(), this.emit("disconnect")) : (this.clean(), this.emit("connectFailed", new V2NIMErrorImpl({ code: "v2" === get(this.core, "options.apiVersion") ? ce.V2NIM_ERROR_CODE_CONNECT_FAILED : 414, detail: { reason: "imsocket::Websocket onerror." } })));
          }, this.websocket.onopen = () => {
            this.onConnect();
          };
        }
        onMessage(e2) {
          if (e2.data) {
            var t2 = new PacketDecoder(e2.data), r2 = { sid: -1, cid: -1, ser: -1, packetLength: -1 }, i2 = null;
            try {
              t2.unmarshalHeader(), r2 = t2.getHeader(), i2 = t2.getInnerHeader();
            } catch (t3) {
              this.reportBinaryError({ err: t3, sid: i2 ? i2.sid : null == r2 ? void 0 : r2.sid, cid: i2 ? i2.cid : null == r2 ? void 0 : r2.cid, rawBuf: e2.data, type: "decode" });
            }
            var s2 = i2 ? i2.sid : r2.sid, n2 = i2 ? i2.cid : r2.cid, a2 = `${s2}_${n2}`, o2 = Be[a2];
            if (o2 && o2.length > 0) {
              var c2, d2 = o2[0].config;
              try {
                c2 = t2.unmarshal(d2.response);
              } catch (i3) {
                var l2 = t2.getBodyDetail();
                this.reportBinaryError({ err: i3, rawBuf: e2.data, sid: s2, cid: n2, parseDetail: l2, type: "decode" }), t2.reset();
                var m2 = Object.assign(Object.assign({}, r2), { sid: s2, cid: n2, code: ce.V2NIM_ERROR_CODE_UNPACK_ERROR });
                return this.logger.error(`imsocket::onMessage "${m2.sid}_${m2.cid}", ser ${m2.ser}, packetLength ${m2.packetLength} unmarshal error. ${l2} 
`, i3), void this.emit("message", JSON.stringify(m2));
              }
              this.emit("message", c2);
            } else
              this.core.logger.warn("imsocket::onMessage cmd not found", a2);
            t2.reset();
          }
        }
        send(e2, t2, r2, i2, s2) {
          var n2, a2, o2 = new PacketEncoder(e2, t2, r2), c2 = xe[i2], d2 = "";
          try {
            d2 = JSON.stringify(s2), a2 = o2.marshal(JSON.parse(d2), c2.params);
          } catch (i3) {
            throw this.reportBinaryError({ err: i3, sid: e2, cid: t2, rawStr: d2, type: "encode" }), o2.reset(), new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_PACK_ERROR, detail: { reason: `${e2}-${t2}, ser ${r2} marshal error`, rawError: i3 } });
          }
          null === (n2 = this.websocket) || void 0 === n2 || n2.send(a2), o2.reset();
        }
        reportBinaryError(e2) {
          var t2, r2, i2, { err: s2, rawStr: n2, sid: a2, cid: o2, type: c2, parseDetail: d2 } = e2, l2 = e2.rawBuf;
          if (l2) {
            try {
              i2 = function arrayBufferToBase64(e3) {
                if ("function" != typeof btoa)
                  return "";
                for (var t3 = "", r3 = new Uint8Array(e3), i3 = r3.byteLength, s3 = 0; s3 < i3; s3++)
                  t3 += String.fromCharCode(r3[s3]);
                return r3 = null, btoa(t3);
              }(l2);
            } catch (e3) {
              i2 = `reportBinaryError::arrayBufferToBase64 parsing failed, error: ${null == e3 ? void 0 : e3.message}, sid: ${a2}, cid: ${o2}`, this.core.logger.error(i2);
            }
            l2 = null;
          }
          this.core.reporter.reportTraceStart("exceptions", { user_id: null === (t2 = this.core.auth) || void 0 === t2 ? void 0 : t2.account, trace_id: null === (r2 = this.core.clientSocket.socket) || void 0 === r2 ? void 0 : r2.sessionId, start_time: Date.now(), action: 2, exception_service: 9 });
          var m2 = s2 ? (`${s2.message};;;` || `${s2.code};;;`) + (d2 ? `parseDetail: ${d2};;;` : "") + (n2 ? ` rawStr: ${n2}` : "") + (i2 ? ` rawBuf: ${i2}` : "") : "";
          this.core.reporter.reportTraceUpdateV2("exceptions", { code: "encode" === c2 ? ce.V2NIM_ERROR_CODE_PACK_ERROR : ce.V2NIM_ERROR_CODE_UNPACK_ERROR, description: m2, operation_type: "encode" === c2 ? 3 : 4, target: `${a2}-${o2}` }, { asyncParams: ge.net.getNetworkStatus() }), this.core.reporter.reportTraceEnd("exceptions", 1);
        }
      }
      !function(e2) {
        e2[e2.ACTIVE = 1] = "ACTIVE", e2[e2.KICKED = 2] = "KICKED", e2[e2.OFFLINE = 3] = "OFFLINE";
      }(It || (It = {}));
      class V2BinaryClientSocket {
        constructor(e2) {
          this.isReconnect = false, this.packetTimeout = 8e3, this.linkSSL = true, this.packetSer = 1, this.backoff = new et({ max: 8e3, min: 1600, jitter: 0.01 }), this.sendingCmdMap = /* @__PURE__ */ new Map(), this.pingTimer = 0, this.hasNetworkListener = false, this.core = e2, this.auth = e2.auth, this.logger = e2.logger, this.reporter = e2.reporter, this.timerManager = e2.timerManager, this.eventBus = e2.eventBus, this.setListener();
        }
        setListener() {
          this.core.eventBus.on("V2NIMLoginService/loginLifeCycleLoginSucc", () => {
            this.isReconnect = true;
          });
        }
        setSessionId(e2) {
          this.socket && (this.socket.sessionId = e2);
        }
        setLinkSSL(e2) {
          this.linkSSL = e2;
        }
        connect(e2, t2 = false) {
          var r2, i2;
          return __awaiter(this, void 0, void 0, function* () {
            this.isReconnect = t2;
            var s2 = this.core.auth.getConnectStatus();
            if (1 === s2) {
              var n2 = `clientSocket::connect status is ${s2}, and would not repeat connect`, a2 = new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_ILLEGAL_STATE, detail: { reason: n2 } });
              return this.logger.warn(n2), Promise.reject(a2);
            }
            this.auth.lifeCycle.processEvent("connect");
            try {
              yield this.auth.doLoginStepsManager.add(this.doConnect(e2)), this.logger.log(`clientSocketV2:: connect success with link url: ${e2}, isReconnect: ${t2}`), this.core.reporter.reportTraceUpdateV2("login", { operation_type: "TCP", target: e2, code: 200, mixlink: true, succeed: true }, { asyncParams: ge.net.getNetworkStatus() }), this.auth.lifeCycle.processEvent("connectSucc");
            } catch (t3) {
              var o2 = t3;
              if (this.core.reporter.reportTraceUpdateV2("login", { operation_type: "TCP", target: e2, code: o2.code || 0, description: `connectFailed:${o2.message}`, mixlink: true, succeed: false }, { asyncParams: ge.net.getNetworkStatus() }), o2.code === ce.V2NIM_ERROR_CODE_CANCELLED || o2.code === ce.V2NIM_ERROR_CODE_TIMEOUT)
                throw null === (r2 = this.socket) || void 0 === r2 || r2.close(), null === (i2 = this.socket) || void 0 === i2 || i2.removeAllListeners(), this.socket = void 0, t3;
              throw this.logger.warn(`clientSocketV2::connect failed with link url: ${e2}`, o2), this.auth.lifeCycle.processEvent("connectFail", o2), t3;
            }
          });
        }
        doConnect(e2) {
          var t2 = false;
          return new Promise((r2, i2) => {
            this.socket = new BaseWebsocket(this.core, e2, this.linkSSL), this.socket.on("connect", () => {
              this.logger.log("clientSocketV2::socket on connect", e2), this.core.reporterHookLinkKeep.start(), this.core.reporterHookLinkKeep.update({ code: 0, description: "connection begin", operation_type: 0, target: e2 }), t2 = true, r2();
            }), this.socket.on("message", this.onMessage.bind(this)), this.socket.on("disconnect", (r3) => __awaiter(this, void 0, void 0, function* () {
              t2 = true, this.logger.log(`clientSocketV2::socket on disconnect ${e2}`, r3), yield this.core.reporterHookLinkKeep.update({ code: (null == r3 ? void 0 : r3.code) || 0, description: (null == r3 ? void 0 : r3.reason) || "socket on disconnect", operation_type: 1, target: e2 }), this.core.reporterHookLinkKeep.end(false), this.doDisconnect(It.OFFLINE, "SocketOnDisconnect");
            })), this.socket.on("connectFailed", (r3) => {
              t2 ? this.ping() : (this.logger.error(`clientSocketV2::connectFailed:${e2}, reason:${r3 && r3.message}`), this.cleanSocket()), t2 = true, i2(r3);
            });
          });
        }
        cleanSocket() {
          this.socket && ("function" == typeof this.socket.removeAllListeners && this.socket.removeAllListeners(), "function" == typeof this.socket.close && this.socket.close(), this.socket = void 0);
        }
        resetSocketConfig() {
          this.backoff.reset(), this.initOnlineListener();
        }
        doDisconnect(e2, t2) {
          if (this.logger.log(`clientSocketV2::doDisconnect:type:${e2},reason:`, t2), 0 !== this.core.auth.getConnectStatus()) {
            var r2 = { 1: "close", 2: "kicked", 3: "broken" }[e2] || "";
            this.markAllCmdInvaild(new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_DISCONNECT, detail: { reason: "Packet timeout due to instance disconnect", disconnect_reason: r2 } })), this.timerManager.destroy(), clearTimeout(this.pingTimer), this.cleanSocket(), e2 === It.ACTIVE || e2 === It.KICKED ? this.destroyOnlineListener() : e2 === It.OFFLINE && (this.auth.lifeCycle.processEvent("connectionBroken", new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_DISCONNECT, detail: { reason: "connection broken due to internal reasons" } })), this.logger.log(`clientSocketV2::doDisconnect: pending reconnect ${this.isReconnect}`), this.isReconnect && this.auth.lifeCycle.processEvent("waiting"));
          } else
            this.logger.warn("clientSocketV2::doDisconnect:already disconnected");
        }
        sendCmd(e2, t2, r2) {
          var i2 = this.core.auth.getLoginStatus(), s2 = { cmd: e2 };
          if (1 !== i2 && !["v2Login", "login", "chatroomLogin", "v2ChatroomLogin"].includes(e2))
            return this.logger.warn(`clientSocketV2::NIM login status is ${i2}, so can not sendCmd ${e2}`), Promise.reject(new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_ILLEGAL_STATE, detail: Object.assign({ reason: "Can not sendCmd due to no logined" }, s2) }));
          var n2 = "heartbeat" !== e2, a2 = n2 ? this.packetSer++ : 0, o2 = createCmd(e2, a2, this.logger, t2);
          if (!o2) {
            var c2 = new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INTERNAL, detail: Object.assign(Object.assign({}, s2), { reason: `SendCmd::createCmd error: ${a2} ${e2}` }) });
            return this.logger.error(c2), Promise.reject(c2);
          }
          var { packet: d2, hasPacketResponse: l2, hasPacketTimer: m2 } = o2, p2 = JSON.stringify(d2);
          n2 && (this.logger.getDebugMode() ? this.logger.debug(`clientSocketV2::sendCmd: ${d2.SID}_${d2.CID},${e2},ser:${a2}`, p2) : this.logger.log(`clientSocketV2::sendCmd: ${d2.SID}_${d2.CID},${e2},ser:${a2}`));
          var u2 = (/* @__PURE__ */ new Date()).getTime();
          return new Promise((i3, n3) => {
            l2 && this.sendingCmdMap.set(a2, { cmd: e2, params: t2, callback: [i3, n3], timer: m2 ? setTimeout(() => {
              var t3 = new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_PROTOCOL_TIMEOUT, detail: Object.assign({ ser: a2, reason: `Packet Timeout: ser ${a2} cmd ${e2}`, timetag: (/* @__PURE__ */ new Date()).getTime() }, s2) });
              this.markCmdInvalid(a2, t3, e2);
            }, r2 && r2.timeout ? r2.timeout : this.packetTimeout) : null });
            try {
              this.socket.send(d2.SID, d2.CID, a2, e2, d2.Q), l2 || i3(d2);
            } catch (t3) {
              var o3 = new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_PROTOCOL_SEND_FAILED, detail: Object.assign({ ser: a2, reason: "Unable to send packet" + (t3 && t3.message ? ": " + t3.message : ""), timetag: (/* @__PURE__ */ new Date()).getTime(), rawError: t3 }, s2) });
              this.markCmdInvalid(a2, o3, e2), n3(o3);
            }
          }).catch((e3) => __awaiter(this, void 0, void 0, function* () {
            var t3 = e3;
            return [ce.V2NIM_ERROR_CODE_DISCONNECT, ce.V2NIM_ERROR_CODE_PROTOCOL_TIMEOUT, ce.V2NIM_ERROR_CODE_PROTOCOL_SEND_FAILED].includes(t3.code) ? (this.reportSendCmdFailed(t3, { sid: d2.SID, cid: d2.CID, ser: a2 }, u2), Promise.reject(t3)) : Promise.reject(t3);
          }));
        }
        reportSendCmdFailed(e2, t2, r2) {
          var i2;
          this.reporter.reportTraceStart("exceptions", { user_id: this.core.auth.getLoginUser(), trace_id: null === (i2 = this.socket) || void 0 === i2 ? void 0 : i2.sessionId, start_time: r2, action: 2, exception_service: 6 });
          var s2 = get(e2, "detail.disconnect_reason") || "", n2 = e2.code === ce.V2NIM_ERROR_CODE_DISCONNECT ? JSON.stringify({ disconnect_reason: s2 }) : e2.detail.reason;
          this.reporter.reportTraceUpdateV2("exceptions", { code: e2.code, description: n2, operation_type: 1, target: `${t2.sid}-${t2.cid}`, context: `${t2.ser}` }, { asyncParams: ge.net.getNetworkStatus() }), this.reporter.reportTraceEnd("exceptions", 1);
        }
        onMessage(e2) {
          var t2 = parseCmd(e2, this.logger);
          if (t2 && t2.length > 0) {
            var r2 = t2[0], i2 = r2.raw.ser;
            for (var s2 of (r2.error && (this.logger.error("clientSocketV2::onMessage packet error", `${r2.raw.sid}_${r2.raw.cid}, ser:${i2},`, r2.error), r2.error.code === ce.V2NIM_ERROR_CODE_UNPACK_ERROR && this.core.eventBus.emit("BinaryClientSocket/unpackError")), "heartbeat" !== r2.cmd && (this.logger.getDebugMode() ? this.logger.debug(`clientSocketV2::recvCmd ${r2.raw.sid}_${r2.raw.cid},${r2.cmd},ser:${i2}`, e2) : this.logger.log(`clientSocketV2::recvCmd ${r2.raw.sid}_${r2.raw.cid},${r2.cmd},ser:${i2},code:${r2.raw.code}`)), t2))
              this.packetHandler(s2);
          }
        }
        packetHandler(e2) {
          var t2, r2, i2, s2;
          if (e2) {
            var n2 = e2.raw.ser, a2 = this.sendingCmdMap.get(n2);
            if (a2 && a2.cmd === e2.cmd) {
              var { callback: o2, timer: c2, params: d2 } = a2;
              if (clearTimeout(c2), e2.params = d2, this.sendingCmdMap.delete(n2), "heartbeat" === e2.cmd)
                return void o2[0]();
              var l2 = null === (r2 = null === (t2 = this.core[e2.service]) || void 0 === t2 ? void 0 : t2.process) || void 0 === r2 ? void 0 : r2.call(t2, e2);
              l2 && "function" == typeof l2.then ? l2.then((e3) => {
                o2[0](e3);
              }).catch((e3) => {
                o2[1](e3);
              }) : (this.logger.log("clientSocketV2::handlerFn without promise", e2.service, e2.cmd), o2[0](e2));
            } else {
              var m2 = null === (s2 = null === (i2 = this.core[e2.service]) || void 0 === i2 ? void 0 : i2.process) || void 0 === s2 ? void 0 : s2.call(i2, e2);
              m2 && "function" == typeof m2.then && m2.catch((e3) => {
                this.logger.error("clientSocketV2::no obj cache, no process handler", e3);
              });
            }
          }
        }
        markCmdInvalid(e2, t2, r2) {
          var i2 = this.sendingCmdMap.get(e2);
          if (i2) {
            var { callback: s2, timer: n2 } = i2;
            n2 && clearTimeout(n2), this.sendingCmdMap.delete(e2), this.logger.warn(`clientSocketV2::packet ${e2}, ${r2} is invalid:`, t2), s2[1](t2);
          }
        }
        markAllCmdInvaild(e2) {
          this.logger.log("markAllCmdInvaild", e2), this.sendingCmdMap.forEach((t2) => {
            var { callback: r2, timer: i2, cmd: s2 } = t2;
            this.logger.log(`clientSocketV2::markAllCmdInvaild:cmd ${s2}`), i2 && clearTimeout(i2), r2[1](e2);
          }), this.sendingCmdMap.clear();
        }
        ping() {
          var e2;
          return __awaiter(this, void 0, void 0, function* () {
            clearTimeout(this.pingTimer);
            try {
              yield this.sendCmd("heartbeat");
            } catch (t2) {
              if (t2.code === ce.V2NIM_ERROR_CODE_DISCONNECT)
                return;
              if (yield this.testHeartBeat5Timeout())
                return yield this.core.reporterHookLinkKeep.update({ code: 0, description: "Heartbeat-discovered link failure", operation_type: 1, target: null === (e2 = this.socket) || void 0 === e2 ? void 0 : e2.url }), this.core.reporterHookLinkKeep.end(true), void this.doDisconnect(It.OFFLINE, "PingError");
            }
            this.pingTimer = setTimeout(() => {
              this.ping();
            }, 3e4);
          });
        }
        testHeartBeat5Timeout() {
          return __awaiter(this, void 0, void 0, function* () {
            clearTimeout(this.pingTimer);
            for (var e2 = 0; e2 < 5; e2++)
              try {
                return yield this.sendCmd("heartbeat", {}, { timeout: 3e3 }), false;
              } catch (t2) {
                this.logger.log(`clientSocketV2::test heartbeat ${e2} Timeout`);
              }
            return true;
          });
        }
        initOnlineListener() {
          this.hasNetworkListener || (this.logger.log("clientSocketV2::onlineListener:init"), this.hasNetworkListener = true, ge.net.onNetworkStatusChange((e2) => {
            this.logger.log("clientSocketV2::onlineListener:network change", e2);
            var t2 = this.auth.getLoginStatus();
            e2.isConnected && 1 === t2 ? this.ping() : e2.isConnected && 3 === t2 ? (this.logger.log("clientSocketV2::onlineListener:online and connectStatus is waiting, do reLogin"), this.auth.reconnect.clearReconnectTimer(), this.auth.reconnect.doReLogin()) : e2.isConnected || this.doDisconnect(It.OFFLINE, "OfflineListener");
          }));
        }
        destroyOnlineListener() {
          this.logger.log("clientSocketV2::onlineListener:destroy"), ge.net.offNetworkStatusChange(), this.hasNetworkListener = false;
        }
      }
      !function(e2) {
        e2[e2.ACTIVE = 1] = "ACTIVE", e2[e2.KICKED = 2] = "KICKED", e2[e2.OFFLINE = 3] = "OFFLINE";
      }(Mt || (Mt = {}));
      class V2ClientSocket {
        constructor(e2) {
          this.isReconnect = false, this.packetTimeout = 8e3, this.linkSSL = true, this.packetSer = 1, this.backoff = new et({ max: 8e3, min: 1600, jitter: 0.01 }), this.sendingCmdMap = /* @__PURE__ */ new Map(), this.pingTimer = 0, this.hasNetworkListener = false, this.core = e2, this.auth = e2.auth, this.logger = e2.logger, this.reporter = e2.reporter, this.timerManager = e2.timerManager, this.eventBus = e2.eventBus, this.setListener();
        }
        setListener() {
          this.core.eventBus.on("V2NIMLoginService/loginLifeCycleLoginSucc", () => {
            this.isReconnect = true;
          });
        }
        setSessionId(e2) {
          this.socket && (this.socket.sessionId = e2);
        }
        setLinkSSL(e2) {
          this.linkSSL = e2;
        }
        connect(e2, t2 = false) {
          var r2, i2;
          return __awaiter(this, void 0, void 0, function* () {
            this.isReconnect = t2;
            var s2 = this.core.auth.getConnectStatus();
            if (1 === s2) {
              var n2 = `clientSocket::connect status is ${s2}, and would not repeat connect`, a2 = new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_ILLEGAL_STATE, detail: { reason: n2 } });
              return this.logger.warn(n2), Promise.reject(a2);
            }
            this.auth.lifeCycle.processEvent("connect");
            try {
              yield this.auth.doLoginStepsManager.add(this.doConnect(e2)), this.logger.log(`clientSocketV2:: connect success with link url: ${e2}, isReconnect: ${t2}`), this.core.reporter.reportTraceUpdateV2("login", { operation_type: "TCP", target: e2, code: 200, mixlink: true, succeed: true }, { asyncParams: ge.net.getNetworkStatus() }), this.auth.lifeCycle.processEvent("connectSucc");
            } catch (t3) {
              var o2 = t3;
              if (this.core.reporter.reportTraceUpdateV2("login", { operation_type: "TCP", target: e2, code: o2.code || 0, description: `connectFailed:${o2.message}`, mixlink: true, succeed: false }, { asyncParams: ge.net.getNetworkStatus() }), o2.code === ce.V2NIM_ERROR_CODE_CANCELLED || o2.code === ce.V2NIM_ERROR_CODE_TIMEOUT)
                throw null === (r2 = this.socket) || void 0 === r2 || r2.close(), null === (i2 = this.socket) || void 0 === i2 || i2.removeAllListeners(), this.socket = void 0, t3;
              throw this.logger.warn(`clientSocketV2::connect failed with link url: ${e2}`, o2), this.auth.lifeCycle.processEvent("connectFail", o2), t3;
            }
          });
        }
        doConnect(e2) {
          var t2 = false;
          return new Promise((r2, i2) => {
            this.socket = new BaseWebsocket$1(this.core, e2, this.linkSSL), this.socket.on("connect", () => {
              this.logger.log("clientSocketV2::socket on connect", e2), this.core.reporterHookLinkKeep.start(), this.core.reporterHookLinkKeep.update({ code: 0, description: "connection begin", operation_type: 0, target: e2 }), t2 = true, r2();
            }), this.socket.on("message", this.onMessage.bind(this)), this.socket.on("disconnect", (r3) => __awaiter(this, void 0, void 0, function* () {
              t2 = true, this.logger.log("clientSocketV2::socket on disconnect", r3), yield this.core.reporterHookLinkKeep.update({ code: (null == r3 ? void 0 : r3.code) || 0, description: (null == r3 ? void 0 : r3.reason) || "socket on disconnect", operation_type: 1, target: e2 }), this.core.reporterHookLinkKeep.end(false), this.doDisconnect(Mt.OFFLINE, "SocketOnDisconnect");
            })), this.socket.on("handshakeFailed", (e3) => {
              t2 ? this.ping() : (this.logger.error(`clientSocketV2::handshake failed: "${e3 && e3.message}"`), this.cleanSocket()), t2 = true, i2(e3);
            });
          });
        }
        cleanSocket() {
          this.socket && ("function" == typeof this.socket.removeAllListeners && this.socket.removeAllListeners(), "function" == typeof this.socket.close && this.socket.close(), this.socket = void 0);
        }
        resetSocketConfig() {
          this.backoff.reset(), this.initOnlineListener();
        }
        doDisconnect(e2, t2) {
          if (this.logger.log(`clientSocketV2::doDisconnect:type:${e2},reason:`, t2), 0 !== this.core.auth.getConnectStatus()) {
            var r2 = { 1: "close", 2: "kicked", 3: "broken" }[e2] || "";
            this.markAllCmdInvaild(new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_DISCONNECT, detail: { reason: "Packet timeout due to instance disconnect", disconnect_reason: r2 } })), this.timerManager.destroy(), clearTimeout(this.pingTimer), this.cleanSocket(), e2 === Mt.ACTIVE || e2 === Mt.KICKED ? this.destroyOnlineListener() : e2 === Mt.OFFLINE && (this.auth.lifeCycle.processEvent("connectionBroken", new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_DISCONNECT, detail: { reason: "connection broken due to internal reasons" } })), this.logger.log(`clientSocketV2::doDisconnect: pending reconnect ${this.isReconnect}`), this.isReconnect && this.auth.lifeCycle.processEvent("waiting"));
          } else
            this.logger.warn("clientSocketV2::doDisconnect:already disconnected");
        }
        sendCmd(e2, t2, r2) {
          var i2 = this.core.auth.getLoginStatus(), s2 = { cmd: e2 };
          if (1 !== i2 && !["v2Login", "login", "chatroomLogin", "v2ChatroomLogin"].includes(e2))
            return this.logger.warn(`clientSocketV2::NIM login status is ${i2}, so can not sendCmd ${e2}`), Promise.reject(new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_ILLEGAL_STATE, detail: Object.assign({ reason: "Can not sendCmd due to no logined" }, s2) }));
          var n2 = "heartbeat" !== e2, a2 = n2 ? this.packetSer++ : 0, o2 = createCmd(e2, a2, this.logger, t2);
          if (!o2) {
            var c2 = new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INTERNAL, detail: Object.assign(Object.assign({}, s2), { reason: `SendCmd::createCmd error: ${a2} ${e2}` }) });
            return this.logger.error(c2), Promise.reject(c2);
          }
          var { packet: d2, hasPacketResponse: l2, hasPacketTimer: m2 } = o2, p2 = JSON.stringify(d2);
          n2 && (this.logger.getDebugMode() ? this.logger.debug(`clientSocketV2::sendCmd: ${d2.SID}_${d2.CID},${e2},ser:${a2}`, p2) : this.logger.log(`clientSocketV2::sendCmd: ${d2.SID}_${d2.CID},${e2},ser:${a2}`));
          var u2 = (/* @__PURE__ */ new Date()).getTime();
          return new Promise((i3, n3) => {
            l2 && this.sendingCmdMap.set(a2, { cmd: e2, params: t2, callback: [i3, n3], timer: m2 ? setTimeout(() => {
              var t3 = new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_PROTOCOL_TIMEOUT, detail: Object.assign({ ser: a2, reason: `Packet Timeout: ser ${a2} cmd ${e2}`, timetag: (/* @__PURE__ */ new Date()).getTime() }, s2) });
              this.markCmdInvalid(a2, t3, e2);
            }, r2 && r2.timeout ? r2.timeout : this.packetTimeout) : null });
            try {
              this.socket.send(p2), l2 || i3(d2);
            } catch (t3) {
              var o3 = new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_PROTOCOL_SEND_FAILED, detail: Object.assign({ ser: a2, reason: "Unable to send packet" + (t3 && t3.message ? ": " + t3.message : ""), timetag: (/* @__PURE__ */ new Date()).getTime(), rawError: t3 }, s2) });
              this.markCmdInvalid(a2, o3, e2), n3(o3);
            }
          }).catch((e3) => __awaiter(this, void 0, void 0, function* () {
            var t3, r3 = e3;
            if (![ce.V2NIM_ERROR_CODE_DISCONNECT, ce.V2NIM_ERROR_CODE_PROTOCOL_TIMEOUT, ce.V2NIM_ERROR_CODE_PROTOCOL_SEND_FAILED].includes(r3.code))
              return Promise.reject(r3);
            this.reporter.reportTraceStart("exceptions", { user_id: this.core.auth.getLoginUser(), trace_id: null === (t3 = this.socket) || void 0 === t3 ? void 0 : t3.sessionId, start_time: u2, action: 2, exception_service: 6 });
            var i3 = get(r3, "detail.disconnect_reason") || "", s3 = r3.code === ce.V2NIM_ERROR_CODE_DISCONNECT ? JSON.stringify({ disconnect_reason: i3 }) : r3.detail.reason;
            return this.reporter.reportTraceUpdateV2("exceptions", { code: r3.code, description: s3, operation_type: 1, target: `${d2.SID}-${d2.CID}`, context: `${d2.SER}` }, { asyncParams: ge.net.getNetworkStatus() }), this.reporter.reportTraceEnd("exceptions", 1), Promise.reject(r3);
          }));
        }
        onMessage(e2) {
          var t2 = parseCmd(e2, this.logger);
          if (t2 && t2.length > 0) {
            var r2 = t2[0], i2 = r2.raw.ser;
            for (var s2 of (r2.error && this.logger.error("clientSocketV2::onMessage packet error", `${r2.raw.sid}_${r2.raw.cid}, ser:${i2},`, r2.error), "heartbeat" !== r2.cmd && (this.logger.getDebugMode() ? this.logger.debug(`clientSocketV2::recvCmd ${r2.raw.sid}_${r2.raw.cid},${r2.cmd},ser:${i2}`, r2.content) : this.logger.log(`clientSocketV2::recvCmd ${r2.raw.sid}_${r2.raw.cid},${r2.cmd},ser:${i2};code:${r2.raw.code}`)), t2))
              this.packetHandler(s2);
          }
        }
        packetHandler(e2) {
          var t2, r2, i2, s2;
          if (e2) {
            var n2 = e2.raw.ser, a2 = this.sendingCmdMap.get(n2);
            if (a2 && a2.cmd === e2.cmd) {
              var { callback: o2, timer: c2, params: d2 } = a2;
              if (clearTimeout(c2), e2.params = d2, this.sendingCmdMap.delete(n2), "heartbeat" === e2.cmd)
                return void o2[0]();
              var l2 = null === (r2 = null === (t2 = this.core[e2.service]) || void 0 === t2 ? void 0 : t2.process) || void 0 === r2 ? void 0 : r2.call(t2, e2);
              l2 && "function" == typeof l2.then ? l2.then((e3) => {
                o2[0](e3);
              }).catch((e3) => {
                o2[1](e3);
              }) : (this.logger.log("clientSocketV2::handlerFn without promise", e2.service, e2.cmd), o2[0](e2));
            } else {
              var m2 = null === (s2 = null === (i2 = this.core[e2.service]) || void 0 === i2 ? void 0 : i2.process) || void 0 === s2 ? void 0 : s2.call(i2, e2);
              m2 && "function" == typeof m2.then && m2.catch((e3) => {
                this.logger.error("clientSocketV2::no obj cache, no process handler", e3);
              });
            }
          }
        }
        markCmdInvalid(e2, t2, r2) {
          var i2 = this.sendingCmdMap.get(e2);
          if (i2) {
            var { callback: s2, timer: n2 } = i2;
            n2 && clearTimeout(n2), this.sendingCmdMap.delete(e2), this.logger.warn(`clientSocketV2::packet ${e2}, ${r2} is invalid:`, t2), s2[1](t2);
          }
        }
        markAllCmdInvaild(e2) {
          this.logger.log("markAllCmdInvaild", e2), this.sendingCmdMap.forEach((t2) => {
            var { callback: r2, timer: i2, cmd: s2 } = t2;
            this.logger.log(`clientSocketV2::markAllCmdInvaild:cmd ${s2}`), i2 && clearTimeout(i2), r2[1](e2);
          }), this.sendingCmdMap.clear();
        }
        ping() {
          var e2;
          return __awaiter(this, void 0, void 0, function* () {
            clearTimeout(this.pingTimer);
            try {
              yield this.sendCmd("heartbeat");
            } catch (t2) {
              if (t2.code === ce.V2NIM_ERROR_CODE_DISCONNECT)
                return;
              if (yield this.testHeartBeat5Timeout())
                return yield this.core.reporterHookLinkKeep.update({ code: 0, description: "Heartbeat-discovered link failure", operation_type: 1, target: null === (e2 = this.socket) || void 0 === e2 ? void 0 : e2.url }), this.core.reporterHookLinkKeep.end(true), void this.doDisconnect(Mt.OFFLINE, "PingError");
            }
            this.pingTimer = setTimeout(() => {
              this.ping();
            }, 3e4);
          });
        }
        testHeartBeat5Timeout() {
          return __awaiter(this, void 0, void 0, function* () {
            clearTimeout(this.pingTimer);
            for (var e2 = 0; e2 < 5; e2++)
              try {
                return yield this.sendCmd("heartbeat", {}, { timeout: 3e3 }), false;
              } catch (t2) {
                this.logger.log(`clientSocketV2::test heartbeat ${e2} Timeout`);
              }
            return true;
          });
        }
        initOnlineListener() {
          this.hasNetworkListener || (this.logger.log("clientSocketV2::onlineListener:init"), this.hasNetworkListener = true, ge.net.onNetworkStatusChange((e2) => {
            this.logger.log("clientSocketV2::onlineListener:network change", e2);
            var t2 = this.auth.getConnectStatus(), r2 = this.auth.getLoginStatus();
            e2.isConnected && 1 === r2 ? this.ping() : e2.isConnected && 3 === t2 ? (this.logger.log("clientSocketV2::onlineListener:online and connectStatus is waiting, do reLogin"), this.auth.reconnect.clearReconnectTimer(), this.auth.reconnect.doReLogin()) : e2.isConnected || this.doDisconnect(Mt.OFFLINE, "OfflineListener");
          }));
        }
        destroyOnlineListener() {
          this.logger.log("clientSocketV2::onlineListener:destroy"), ge.net.offNetworkStatusChange(), this.hasNetworkListener = false;
        }
      }
      class V2NIMLoginReconnect {
        constructor(e2) {
          var t2, r2;
          this.currenRetryCount = 0, this.backoff = new et({ max: 8e3, min: 1600, jitter: 0.01 }), this.reconnectTimer = 0, this.core = e2, this.auth = e2.V2NIMLoginService, null === (r2 = (t2 = ge.powerMonitor).on) || void 0 === r2 || r2.call(t2, "onPowerMonitorTurnActive", () => {
            this.core.logger.debug("reconnect::powerMonitor turn active"), 3 === this.auth.getLoginStatus() && (this.core.logger.log("reconnect::powerMonitor turn active, try to reconnect"), this.auth.reconnect.clearReconnectTimer(), this.auth.reconnect.doReLogin());
          });
        }
        reset() {
          this.currenRetryCount = 0, this.backoff.reset(), this.reconnectTimer && clearTimeout(this.reconnectTimer);
        }
        destroy() {
          var e2, t2;
          this.currenRetryCount = 0, this.backoff.reset(), this.reconnectTimer && clearTimeout(this.reconnectTimer), ge.powerMonitor.destroy(), null === (t2 = (e2 = ge.powerMonitor).off) || void 0 === t2 || t2.call(e2, "onPowerMonitorTurnActive");
        }
        clearReconnectTimer() {
          this.reconnectTimer && clearTimeout(this.reconnectTimer);
        }
        attempToReLogin() {
          var e2 = this.backoff.duration();
          if ("function" == typeof this.reconnectDelayProvider)
            try {
              var t2 = this.reconnectDelayProvider(e2);
              "number" == typeof t2 && t2 >= 0 && (e2 = t2 >= 1e3 ? t2 : t2 + 200 + Math.ceil(300 * Math.random()));
            } catch (e3) {
              this.core.logger.error("reconnect::connectDelayProvider excute failed,", e3);
            }
          return this.currenRetryCount++, this.core.logger.log(`reconnect::reconnect timer is about to be set, delay ${e2} ms, current retry count is ${this.currenRetryCount}`), this.core.reporter.reportTraceStart("login", { user_id: this.auth.getLoginUser(), action: "auto_login", binary_websocket: this.auth.binaryWebsocket }), this.clearReconnectTimer(), this.reconnectTimer = setTimeout(() => {
            this.core.logger.log("reconnect::reconnect timer is now triggered");
            var e3 = this.auth.getConnectStatus();
            3 === e3 ? this.doReLogin() : this.core.logger.warn(`reconnect::reconnect timer is over because connect status now is ${e3}`);
          }, e2), true;
        }
        doReLogin() {
          if (!ge.powerMonitor.isActive())
            return this.core.logger.log("reconnect::reLogin skip, cause app powerMonitor is not active"), void this.auth.lifeCycle.processEvent("waiting");
          this.auth.loginOption.forceMode = false, this.auth.originLoginPromise = this.auth.doLogin(true);
          var e2 = this.auth.previousLoginManager.add(this.auth.originLoginPromise);
          return e2.then(() => {
            this.core.reporter.reportTraceEnd("login", true);
          }).catch((e3) => {
            var t2 = e3;
            if (this.core.logger.warn("reconnect::try login but failed due to", t2), this.core.reporter.reportTraceEnd("login", false), this.auth.checkLoginTerminalCode(t2 && t2.code))
              return this.auth.clientSocket.doDisconnect(It.ACTIVE, "ReloginTerminated"), void this.auth.lifeCycle.processEvent("exited", t2);
            t2 && 399 === t2.code && this.auth.lbs.reset(), this.auth.lifeCycle.processEvent("waiting");
          }), e2;
        }
        _setReconnectDelayProvider(e2) {
          this.reconnectDelayProvider = e2;
        }
      }
      class V2NIMLoginLbs {
        constructor(e2) {
          this.socketLinkUrls = [], this.timer = 0, this.failedCount = 0, this.core = e2, this.auth = e2.V2NIMLoginService;
        }
        getLbsInfos() {
          return __awaiter(this, void 0, void 0, function* () {
            if (this.socketLinkUrls.length > 0) {
              var e2 = this.socketLinkUrls.shift();
              return this.core.logger.log("V2NIMLoginService::getLbsInfos:use cache link", e2), Promise.resolve(e2);
            }
            this.auth.lifeCycle.processEvent("addressing"), this.core.reporterHookLBS.start(this.core.account);
            var t2 = uniq(this.auth.config.lbsUrls);
            try {
              var r2 = yield this.ladderLoad(t2);
              if (200 !== r2.status || !r2.data)
                throw this.core.logger.error("V1NIMLoginService::getLbsInfos:error status", r2.status, r2), new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INTERNAL, detail: { reason: `V2NIMLoginService::getLbsInfos failed, status ${r2.status}` } });
              this.success(r2);
            } catch (e3) {
              var i2 = e3;
              if (this.core.logger.error(`V2NIMLoginService::lbs getLbsInfos error, use default link: ${this.auth.config.linkUrl}. error:`, e3), this.reportForFail(t2[0], i2.code, i2.message), this.checkTerminator(i2.code))
                throw e3;
              this.socketLinkUrls = [this.auth.config.linkUrl];
            }
            return this.socketLinkUrls.shift();
          });
        }
        checkTerminator(e2) {
          return e2 === ce.V2NIM_ERROR_CODE_CANCELLED || e2 === ce.V2NIM_ERROR_CODE_TIMEOUT;
        }
        generateUrl(e2) {
          var t2 = (e2 = this.processLbsUrl(e2)).indexOf("?") > -1 ? "&" : "?";
          return e2 + t2 + "k=" + this.core.options.appkey + "&id=" + this.core.auth.getLoginUser() + "&sv=180&pv=1&networkType=0&lv=1";
        }
        processLbsUrl(e2) {
          return pendingIsMiniappEnv() ? e2.replace("/webconf", "/wxwebconf") : e2;
        }
        requstLbs(e2) {
          return this.auth.doLoginStepsManager.add(this.core.adapters.request(this.generateUrl(e2), { method: "GET", dataType: "json", timeout: 8e3 }));
        }
        setLadderTimer(e2, t2, r2, i2) {
          this.timer && clearTimeout(this.timer);
          var s2 = e2[t2];
          this.timer = setTimeout(() => {
            s2 && (this.setLadderTimer(e2, t2 + 1, r2, i2), this.core.logger.log(`V2NIMLoginService::getLbsInfos ${t2}:`, this.processLbsUrl(s2)), this.reportForLbsStart(s2, t2), this.requstLbs(s2).then((e3) => {
              this.reset(), r2(Object.assign(Object.assign({}, e3), { url: s2 }));
            }).catch((r3) => {
              var n2;
              if (this.core.logger.warn(`V2NIMLoginService::getLbsInfos ${t2} failed:`, r3), this.failedCount += 1, this.reportForFailOnce(s2, r3.code, (null === (n2 = r3.detail) || void 0 === n2 ? void 0 : n2.reason) || r3.message), this.failedCount >= e2.length || this.checkTerminator(r3.code))
                return this.reset(), void i2(r3);
            }));
          }, 2e3);
        }
        ladderLoad(e2) {
          return new Promise((t2, r2) => {
            e2.length > 1 && this.setLadderTimer(e2, 1, t2, r2);
            var i2 = e2[0];
            this.core.logger.log("V2NIMLoginService::getLbsInfos 0:", i2), this.reportForLbsStart(i2, 0), this.requstLbs(i2).then((e3) => {
              this.reset(), t2(Object.assign(Object.assign({}, e3), { url: i2 }));
            }).catch((t3) => {
              var s2;
              this.failedCount += 1, this.core.logger.warn("V2NIMLoginService::getLbsInfos 0 failed:", t3), this.reportForFailOnce(i2, t3.code, (null === (s2 = t3.detail) || void 0 === s2 ? void 0 : s2.reason) || t3.message), (this.failedCount >= e2.length || this.checkTerminator(t3.code)) && (this.reset(), r2(t3));
            });
          });
        }
        success(e2) {
          var t2, r2, i2 = e2.data.common, s2 = i2["mix.link"] || [], n2 = i2["link.default"] || [];
          this.socketLinkUrls = s2.concat(n2).concat(this.auth.config.linkUrl), e2.data["nos-chunk"] && (null === (t2 = this.core.cloudStorage) || void 0 === t2 ? void 0 : t2.setOptions) && (this.core.logger.log("getLbsInfos success. lbs.nos-chunk", e2.data["nos-chunk"]), this.core.cloudStorage.setOptions({ chunkUploadHost: e2.data["nos-chunk"] })), Array.isArray(e2.data.nosup) && e2.data.nosup.length > 0 && (null === (r2 = this.core.cloudStorage) || void 0 === r2 ? void 0 : r2.setOptions) && (this.core.logger.log("getLbsInfos success. lbs.nosup", e2.data.nosup), this.core.cloudStorage.setOptions({ commonUploadHostBackupList: e2.data.nosup, commonUploadHost: e2.data.nosup[0] })), this.core.logger.log("V2NIMLoginService::getLbsInfos success, socket link:", this.socketLinkUrls.slice(0), "chunkUploadHost: ", e2.data["nos-chunk"]), this.reportForLbsSuccess(e2.url, e2.data);
        }
        reportForLbsStart(e2, t2) {
          this.core.reporterHookLBS.updateBegin({ target: e2, index: t2 });
        }
        reportForLbsSuccess(e2, t2) {
          this.core.reporterHookLBS.updateComplete({ target: e2, code: 200, body: JSON.stringify(t2) }), this.core.reporterHookLBS.end(true), this.core.reporter.reportTraceUpdateV2("login", { operation_type: "HTTP", target: e2, code: 200, succeed: true }, { asyncParams: ge.net.getNetworkStatus() });
        }
        reportForFailOnce(e2, t2, r2) {
          this.core.reporterHookLBS.updateComplete({ target: e2, code: t2, body: r2 });
        }
        reportForFail(e2, t2, r2) {
          this.core.reporterHookLBS.end(false), this.core.reporter.reportTraceUpdateV2("login", { operation_type: "HTTP", target: e2, description: r2, code: t2, succeed: false }, { asyncParams: ge.net.getNetworkStatus() });
        }
        reset() {
          this.socketLinkUrls = [], this.failedCount = 0, clearTimeout(this.timer);
        }
      }
      class V2NIMLoginAuthenticator {
        constructor(e2) {
          this.lastLoginClientKey = "__NIM_LAST_LOGIN_CLIENT__", this.loginClients = [], this.loginClientOfThisConnection = {}, this.core = e2, this.auth = e2.V2NIMLoginService;
        }
        verifyAuthentication(e2) {
          var t2, r2;
          return __awaiter(this, void 0, void 0, function* () {
            var i2 = yield this.auth.doLoginStepsManager.add(this.refreshLoginToken(this.auth.account)), s2 = yield this.auth.doLoginStepsManager.add(this.refreshThirdPartyExt(this.auth.account));
            this.auth.token = i2;
            var n2, a2 = ge.getSystemInfo(), o2 = { appkey: this.core.options.appkey, account: this.auth.account, token: i2, authType: this.auth.loginOption.authType, appLogin: e2 ? 0 : 1, clientType: 16, clientSession: this.auth.clientSession, clientId: this.auth.deviceId, sdkVersion: 100941, userAgent: this.core.options.loginSDKTypeParamCompat ? "Native/10.9.41" : a2.userAgent.replace("{{appkey}}", this.core.options.appkey).slice(0, 299), libEnv: this.core.options.flutterSdkVersion ? "FLUTTER" : this.core.options.loginSDKTypeParamCompat ? void 0 : a2.libEnv, hostEnv: this.core.options.flutterSdkVersion ? 4 : this.core.options.loginSDKTypeParamCompat ? 0 : a2.hostEnvEnum, sdkHumanVersion: this.core.options.flutterSdkVersion || "10.9.41", os: a2.os, browser: a2.browser, protocolVersion: 1, customClientType: this.auth.config.customClientType, customTag: this.auth.config.customTag, thirdPartyExtension: s2, isRoutable: false === (null === (t2 = this.auth.loginOption.routeConfig) || void 0 === t2 ? void 0 : t2.routeEnabled) ? 0 : 1, env: null === (r2 = this.auth.loginOption.routeConfig) || void 0 === r2 ? void 0 : r2.routeEnvironment }, c2 = a2.os.toLowerCase(), d2 = 110 === a2.hostEnvEnum;
            "UNIAPP" === ge.platform && d2 ? (o2.isReactNative = 1, o2.clientType = "ios" === c2 ? 2 : "android" === c2 ? 1 : 65, a2.pushDeviceInfo && a2.pushDeviceInfo.MANUFACTURER && (o2.deviceInfo = JSON.stringify(Object.assign({ IS_SUPPORT_HONOR: true }, a2.pushDeviceInfo)))) : "React Native" === ge.platform && (this.core.logger.log("V2NIMLoginService deviceInfo", this.core.V2NIMLoginService.deviceInfo, "os", c2), o2.isReactNative = 1, o2.clientType = "ios" === c2 ? 2 : 1, o2.deviceInfo = JSON.stringify(Object.assign({ IS_SUPPORT_HONOR: true }, this.core.V2NIMLoginService.deviceInfo))), this.core.logger.log(`V2NIMLoginService::do login,accid:${o2.account};clientSession:${o2.clientSession};appLogin:${o2.appLogin}`);
            try {
              n2 = yield this.auth.doLoginStepsManager.add(this.auth.clientSocket.sendCmd("v2Login", { tag: o2 }));
            } catch (e3) {
              var l2 = e3;
              if (this.core.reporter.reportTraceUpdateV2("login", { operation_type: "protocol", target: "26-3", code: l2.code || 0, succeed: false, description: l2.message }, { asyncParams: ge.net.getNetworkStatus() }), l2.code === ce.V2NIM_ERROR_CODE_CANCELLED || l2.code === ce.V2NIM_ERROR_CODE_TIMEOUT)
                throw l2;
              throw this.processLoginFailed(l2), l2;
            }
            var { data: m2, loginClients: p2 } = n2.content;
            return this.changeLoginClient(1, p2), this.core.reporter.reportTraceUpdateV2("login", { operation_type: "protocol", target: "26-3", code: 200, succeed: true }, { asyncParams: ge.net.getNetworkStatus() }), this.loginClientOfThisConnection = formatLoginInfo(m2), this.core.clientSocket.setSessionId(m2.consid), ge.localStorage.setItem(this.lastLoginClientKey, JSON.stringify(Object.assign({ account: this.auth.account }, this.loginClientOfThisConnection))), this.loginClientOfThisConnection;
          });
        }
        refreshLoginToken(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            if (0 === this.auth.loginOption.authType)
              return this.auth.token;
            if ("function" != typeof this.auth.loginOption.tokenProvider)
              return this.auth.token;
            try {
              var t2 = yield this.auth.loginOption.tokenProvider(e2);
              if ("string" == typeof t2)
                return t2;
              throw this.core.logger.error("V2NIMLoginService::excute tokenProvider complete but got Unexpected value:", t2), new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_CALLBACK_FAILED, detail: { reason: "Excute tokenProvider complete but got Unexpected value", rawData: t2 } });
            } catch (e3) {
              var r2 = e3, i2 = r2;
              throw r2.code !== ce.V2NIM_ERROR_CODE_CALLBACK_FAILED && (this.core.logger.error("V2NIMLoginService::excute tokenProvider error:", r2), i2 = new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_CALLBACK_FAILED, desc: "Excute tokenProvider error", detail: { rawError: e3 } })), this.processLoginFailed(r2), i2;
            }
          });
        }
        refreshThirdPartyExt(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            if ("function" != typeof this.auth.loginOption.loginExtensionProvider)
              return "";
            try {
              var t2 = yield this.auth.loginOption.loginExtensionProvider(e2);
              if ("string" == typeof t2)
                return t2;
              throw this.core.logger.error("V2NIMLoginService::excute loginExtensionProvider complete but got Unexpected value:", t2), new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_CALLBACK_FAILED, detail: { reason: "Excute loginExtensionProvider complete but got Unexpected value", rawData: t2 } });
            } catch (e3) {
              var r2 = e3, i2 = r2;
              if (r2.code !== ce.V2NIM_ERROR_CODE_CALLBACK_FAILED && (this.core.logger.error("V2NIMLoginService::excute loginExtensionProvider error:", r2), i2 = new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_CALLBACK_FAILED, detail: { reason: "Excute loginExtensionProvider error", rawError: e3 } })), 2 === this.auth.loginOption.authType)
                throw this.processLoginFailed(r2), i2;
              return "";
            }
          });
        }
        processLoginFailed(e2) {
          this.auth.clientSocket.doDisconnect(It.ACTIVE, e2), this.checkLoginTerminalCode(e2.code) && (this.auth.authenticator.reset(), this.auth.authenticator.clearLastLoginClient()), this.auth.lifeCycle.processEvent("loginFail", e2);
        }
        changeLoginClient(e2, t2) {
          var r2 = t2.map((e3) => formatLoginInfo(e3));
          if (1 === e2)
            this.loginClients = r2, this.auth.emit("onLoginClientChanged", e2, this.loginClients);
          else if (2 === e2) {
            var i2 = r2.filter((e3) => {
              var t3 = this.loginClients.filter((t4) => t4.clientId === e3.clientId);
              return this.loginClients.push(e3), 0 === t3.length;
            });
            i2.length > 0 && this.auth.emit("onLoginClientChanged", e2, i2);
          } else if (3 === e2) {
            var s2 = r2.filter((e3) => (function remove(e4, t3) {
              t3 = t3 || (() => true);
              for (var r3 = [], i3 = (e4 = e4 || []).length, s3 = 0, n2 = 0; n2 < i3; n2++)
                t3(e4[n2 - s3]) && (r3.push(e4.splice(n2 - s3, 1)[0]), s3 += 1);
              return r3;
            }(this.loginClients, (t3) => t3.clientId === e3.clientId && t3.consid === e3.consid), 0 === this.loginClients.filter((t3) => t3.clientId === e3.clientId).length));
            s2.length > 0 && this.auth.emit("onLoginClientChanged", e2, s2);
          }
        }
        checkAutoLogin(e2) {
          if (e2)
            return false;
          var t2 = ge.localStorage.getItem(this.lastLoginClientKey);
          if (!t2)
            return false;
          var r2 = "", i2 = "";
          try {
            var s2 = JSON.parse(t2);
            r2 = get(s2, "clientId"), i2 = get(s2, "account");
          } catch (e3) {
            return false;
          }
          return r2 === this.auth.deviceId && i2 === this.auth.account;
        }
        checkLoginTerminalCode(e2) {
          return [ce.V2NIM_ERROR_CODE_CANCELLED, ce.V2NIM_ERROR_CODE_TIMEOUT, ce.V2NIM_ERROR_CODE_HANDSHAKE, 302, 317, ce.V2NIM_ERROR_CODE_FORBIDDEN, ce.V2NIM_ERROR_CODE_NOT_FOUND, ce.V2NIM_ERROR_CODE_PARAMETER_ERROR, ce.V2NIM_ERROR_CODE_MULTI_LOGIN_FORBIDDEN, 422, ce.V2NIM_ERROR_CODE_IM_DISABLED, ce.V2NIM_ERROR_CODE_APPKEY_NOT_EXIST, ce.V2NIM_ERROR_CODE_BUNDLEID_CHECK_FAILED, ce.V2NIM_ERROR_CODE_APPKEY_BLOCKED, ce.V2NIM_ERROR_CODE_INVALID_TOKEN, ce.V2NIM_ERROR_CODE_ROBOT_NOT_ALLOWED, ce.V2NIM_ERROR_CODE_ACCOUNT_NOT_EXIST, ce.V2NIM_ERROR_CODE_ACCOUNT_BANNED, ce.V2NIM_ERROR_CODE_USER_PROFILE_NOT_EXIST].includes(e2);
        }
        reset() {
          this.loginClients = [], this.loginClientOfThisConnection = {};
        }
        clearLastLoginClient() {
          ge.localStorage.removeItem(this.lastLoginClientKey);
        }
      }
      class V2NIMLoginLifeCycle {
        constructor(e2) {
          this.name = "V2NIMLoginLifeCycle", this.loginStatus = 0, this.connectStatus = 0, this.core = e2, this.auth = e2.V2NIMLoginService, this.logger = e2.logger;
        }
        processEvent(e2, t2, r2) {
          var i2 = this.getConnectStatus();
          switch (e2) {
            case "addressing":
              this.logger.log(`${this.name}::addressing`), this.setLoginStatus(2), this.setConnectStatus(2);
              break;
            case "connect":
              this.logger.log(`${this.name}::connecting`), this.setLoginStatus(2), this.setConnectStatus(2);
              break;
            case "connectSucc":
              this.logger.log(`${this.name}::connect success`), this.setLoginStatus(2), this.setConnectStatus(1);
              break;
            case "connectFail":
              this.logger.log(`${this.name}::connect fail`, t2), this.setLoginStatus(3), this.setConnectStatus(0, t2);
              break;
            case "connectionBroken":
              this.logger.log(`${this.name}::connectionBroken:`, t2), this.setLoginStatus(3), this.setConnectStatus(0, t2), this.core.eventBus.emit("V2NIMLoginService/loginLifeCycleDisconnected", t2);
              break;
            case "loginSucc":
              this.logger.log(`${this.name}::login success, verify authentication success`), this.setLoginStatus(1), this.core.eventBus.emit("V2NIMLoginService/loginLifeCycleLoginSucc", r2);
              break;
            case "loginFail":
              if (this.logger.log(`${this.name}::login fail due to verify authentication failed:`, t2), !t2)
                return;
              this.setLoginStatus(this.auth.authenticator.checkLoginTerminalCode(t2.code) ? 0 : 3), this.setConnectStatus(0, t2), this.auth.emit("onLoginFailed", t2);
              break;
            case "logout":
              this.logger.log(`${this.name}::logout`), this.setLoginStatus(0), this.setConnectStatus(0), this.core.eventBus.emit("V2NIMLoginService/loginLifeCycleLogout");
              break;
            case "kicked":
              this.logger.log(`${this.name}::kicked`, r2), this.setLoginStatus(0), this.setConnectStatus(0, t2), this.core.eventBus.emit("V2NIMLoginService/loginLifeCycleKicked");
              break;
            case "exited":
              this.logger.log(`${this.name}::exited`, t2), this.setLoginStatus(0), this.setConnectStatus(0, t2);
              break;
            case "waiting":
              this.logger.log(`${this.name}::waiting to reconnect`), this.setLoginStatus(3), this.setConnectStatus(3), 2 !== i2 && this.auth.reconnect.attempToReLogin();
          }
        }
        getConnectStatus() {
          return this.connectStatus;
        }
        getLoginStatus() {
          return this.loginStatus;
        }
        setLoginStatus(e2) {
          e2 !== this.loginStatus && (this.loginStatus = e2, this.auth.emit("onLoginStatus", e2));
        }
        setConnectStatus(e2, t2) {
          if (e2 !== this.connectStatus) {
            var r2 = this.connectStatus;
            this.connectStatus = e2, this.auth.emit("onConnectStatus", e2), this.delegateConnectEvent(r2, e2, t2);
          }
        }
        delegateConnectEvent(e2, t2, r2) {
          1 === e2 && 0 === t2 && r2 && this.auth.emit("onDisconnected", r2), 2 === e2 && 0 === t2 && r2 && this.auth.emit("onConnectFailed", r2);
        }
      }
      class V2NIMLoginDataSync {
        constructor(e2) {
          this.core = e2, this.auth = e2.V2NIMLoginService, this.datas = [];
        }
        switchDataSync(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            var { type: t2, state: r2, error: i2, subType: s2 } = e2, n2 = this.datas.filter((e3) => e3.type === t2 && e3.subType === s2);
            n2.length > 0 ? (n2[0].state = r2, n2[0].error = i2) : this.datas.push({ type: t2, state: r2, subType: s2 });
            var a2 = this.datas.every((e3) => 3 === e3.state);
            1 === t2 && (2 === r2 && "mainSync" === s2 ? (this.core.eventBus.emit("V2NIMLoginService/syncing"), this.auth.emit("onDataSync", t2, r2)) : 3 === r2 && a2 && (this.core.eventBus.emit("V2NIMLoginService/syncDone", i2), this.auth.emit("onDataSync", t2, r2, i2)));
          });
        }
        checkSyncing() {
          return this.datas.some((e2) => "mainSync" === e2.subType && 2 === e2.state);
        }
        reset() {
          this.datas = [];
        }
      }
      function pick(e2, t2) {
        e2 = e2 || {};
        var r2 = {};
        return (t2 = t2 || []).forEach((t3) => {
          void 0 !== e2[t3] && (r2[t3] = e2[t3]);
        }), r2;
      }
      var Tt = { retryCount: { type: "number", min: 0, required: false }, forceMode: { type: "boolean", required: false }, authType: { type: "enum", values: [0, 1, 2], required: false }, syncLevel: { type: "enum", values: [1, 0], required: false }, routeConfig: { type: "object", required: false, rules: { routeEnabled: { type: "boolean", required: false }, routeEnvironment: { type: "string", required: false } } } }, _t = ["https://lbs.netease.im/lbs/webconf.jsp"], Ct = { retryCount: 3, timeout: 6e4, forceMode: false, authType: 0, syncLevel: 0 };
      function invert(e2) {
        e2 = e2 || {};
        var t2 = {};
        for (var r2 in e2)
          t2[e2[r2]] = r2;
        return t2;
      }
      var Et, bt = invert({ none: 0, normal: 1, all: 3 }), Rt = { normal: 0, advanced: 1 }, Nt = invert(Rt), At = invert({ normal: 0, owner: 1, manager: 2 }), Ot = { noVerify: 0, needVerify: 1, rejectAll: 2 }, kt = invert(Ot), wt = { needVerify: 0, noVerify: 1 }, Pt = invert(wt), Vt = { manager: 0, all: 1 }, Lt = invert(Vt), Ut = { manager: 0, all: 1 }, Dt = invert(Ut), qt = { manager: 0, all: 1 }, xt = invert(qt);
      function formatTeam(e2) {
        var t2 = { type: Nt, muteType: bt, joinMode: kt, beInviteMode: Pt, inviteMode: Lt, updateTeamMode: Dt, updateExtMode: xt }, r2 = __rest(e2, ["bits"]);
        return ["teamId"].forEach((e3) => {
          r2[e3] && (r2[e3] = r2[e3].toString());
        }), ["level", "memberNum", "memberUpdateTime", "createTime", "updateTime"].forEach((e3) => {
          void 0 !== r2[e3] && (r2[e3] = parseInt(r2[e3]));
        }), ["valid", "validToCurrentUser", "mute"].forEach((e3) => {
          void 0 !== r2[e3] && (r2[e3] = 1 === parseInt(r2[e3]));
        }), Object.keys(t2).forEach((e3) => {
          void 0 !== r2[e3] && (r2[e3] = t2[e3][r2[e3]] || r2[e3]);
        }), r2;
      }
      function formatTeams(e2) {
        return e2 && e2.length > 0 ? e2.map((e3) => formatTeam(e3)) : [];
      }
      function generateTeam(e2) {
        var t2 = Object.assign({}, e2), r2 = { type: Rt, joinMode: Ot, beInviteMode: wt, inviteMode: Vt, updateTeamMode: Ut, updateExtMode: qt };
        return ["avatar", "name", "intro", "announcement", "ext"].forEach((e3) => {
          void 0 !== t2[e3] && (t2[e3] = t2[e3].toString());
        }), Object.keys(r2).forEach((e3) => {
          void 0 !== t2[e3] && (t2[e3] = r2[e3][t2[e3]]);
        }), t2;
      }
      function generatorTeamMemberForCmd(e2) {
        var t2 = {};
        return void 0 !== e2.bitConfigMask && (t2.bits = parseInt(e2.bitConfigMask)), ["teamId", "ext", "account", "nickInTeam"].forEach((r2) => {
          e2[r2] && (t2[r2] = e2[r2].toString());
        }), Object.prototype.hasOwnProperty.call(e2, "nickInTeam") && (t2.nickInTeam = e2.nickInTeam), t2;
      }
      function formatTeamMember(e2) {
        var t2 = { type: At }, { bits: r2 } = e2, i2 = __rest(e2, ["bits"]);
        return void 0 !== r2 && (i2.muteTeam = 1 === parseInt(r2), i2.bitConfigMask = r2), i2.id = `${i2.teamId}-${i2.account}`, ["teamId"].forEach((e3) => {
          i2[e3] && (i2[e3] = i2[e3].toString());
        }), ["joinTime", "updateTime", "bitConfigMask"].forEach((e3) => {
          void 0 !== i2[e3] && (i2[e3] = parseInt(i2[e3]));
        }), ["active", "valid", "mute"].forEach((e3) => {
          void 0 !== i2[e3] && (i2[e3] = 1 === parseInt(i2[e3]));
        }), Object.keys(t2).forEach((e3) => {
          void 0 !== i2[e3] && (i2[e3] = t2[e3][i2[e3]] || i2[e3]);
        }), i2;
      }
      function formatTeamMembers(e2) {
        return e2 && e2.length > 0 ? e2.map((e3) => formatTeamMember(e3)) : [];
      }
      function generatorMemberByTeam(e2, t2, r2 = "normal") {
        return { id: `${e2.teamId}-${t2}`, teamId: e2.teamId, account: t2, type: r2, nickInTeam: "", muteTeam: false, mute: false, joinTime: e2.memberUpdateTime, updateTime: e2.memberUpdateTime, active: true, valid: true };
      }
      function generatorMembersByTeam(e2, t2, r2 = "normal") {
        return t2 && t2.length > 0 ? t2.map((t3) => generatorMemberByTeam(e2, t3, r2)) : [];
      }
      function formatUser(e2) {
        var t2 = Object.assign({}, e2);
        return t2.createTime && (t2.createTime = +t2.createTime), t2.updateTime && (t2.updateTime = +t2.updateTime), t2.gender && (t2.gender = Et[+t2.gender]), t2;
      }
      !function(e2) {
        e2[e2.unknown = 0] = "unknown", e2[e2.male = 1] = "male", e2[e2.female = 2] = "female";
      }(Et || (Et = {}));
      var Bt = { "8_1": "createTeam", "8_5": "addTeamMembers", "8_6": "removeTeamMembers", "8_7": "updateTeamInfo", "8_8": "leaveTeam", "8_9": "getTeamInfo", "8_10": "getTeams", "8_11": "getTeamMembers", "8_12": "dismissTeam", "8_13": "applyTeam", "8_14": "passTeamApply", "8_15": "rejectTeamApply", "8_16": "addTeamManagers", "8_17": "removeTeamManagers", "8_18": "transferTeam", "8_19": "updateMyMemberInfo", "8_20": "updateNickInTeam", "8_21": "acceptTeamInvite", "8_22": "rejectTeamInvite", "8_25": "muteTeamMember", "8_27": "getMutedTeamMembers", "8_28": "sendTeamMsgReceipt", "8_29": "getTeamMsgReads", "8_30": "getTeamMsgReadAccounts", "8_31": "notifyTeamMsgReceipts", "8_32": "muteTeam", "8_33": "getTeamMemberInvitorAccid", "8_34": "getTeamsById", "8_101": "syncCreateTeam", "8_109": "syncTeams", "8_119": "syncUpdateTeamMember", "8_126": "syncMyTeamMembers" }, Ft = { team: { teamId: 1, name: 3, type: 4, owner: 5, level: 6, selfCustom: 7, valid: 8, memberNum: 9, memberUpdateTime: 10, createTime: 11, updateTime: 12, validToCurrentUser: 13, intro: 14, announcement: 15, joinMode: 16, bits: 17, ext: 18, serverExt: 19, avatar: 20, beInviteMode: 21, inviteMode: 22, updateTeamMode: 23, updateExtMode: 24, mute: 100, muteType: 101 }, teamMsgReceiptTag: { teamId: 0, idServer: 1, read: 100, unread: 101, idClient: 102, account: 103 }, teamMember: { teamId: 1, account: 3, type: 4, nickInTeam: 5, bits: 7, active: 8, valid: 9, joinTime: 10, updateTime: 11, ext: 12, mute: 13, invitorAccid: 14 } }, jt = invertSerializeMap(Ft), $t = { getTeamInfo: { sid: 8, cid: 9, service: "team", params: [{ type: "Long", name: "teamId" }], response: [{ type: "Property", name: "team", reflectMapper: jt.team }] }, getTeams: { sid: 8, cid: 10, service: "team", params: [{ type: "Long", name: "timetag" }], response: [{ type: "PropertyArray", name: "teams", reflectMapper: jt.team }, { type: "Long", name: "timetag" }], ignoreErrCodes: [803] }, createTeam: { sid: 8, cid: 1, service: "team", params: [{ type: "Property", name: "team", reflectMapper: Ft.team }, { type: "StrArray", name: "accounts" }, { type: "String", name: "ps" }], response: [{ type: "Property", name: "team", reflectMapper: jt.team }, { type: "StrArray", name: "abortedAccidList" }] }, sendTeamMsgReceipt: { sid: 8, cid: 28, service: "team", params: [{ type: "PropertyArray", name: "teamMsgReceipts", reflectMapper: Ft.teamMsgReceiptTag }], response: [{ type: "PropertyArray", name: "teamMsgReceipts", reflectMapper: jt.teamMsgReceiptTag }] }, getTeamMsgReads: { sid: 8, cid: 29, service: "team", params: [{ type: "PropertyArray", name: "teamMsgReceipts", reflectMapper: Ft.teamMsgReceiptTag }], response: [{ type: "PropertyArray", name: "teamMsgReceipts", reflectMapper: jt.teamMsgReceiptTag }] }, getTeamMsgReadAccounts: { sid: 8, cid: 30, service: "team", params: [{ type: "Property", name: "teamMsgReceiptTag", reflectMapper: Ft.teamMsgReceiptTag }], response: [{ type: "Property", name: "teamMsgReceipt", reflectMapper: jt.teamMsgReceiptTag }, { type: "StrArray", name: "readAccounts" }, { type: "StrArray", name: "unreadAccounts" }] }, notifyTeamMsgReceipts: { sid: 8, cid: 31, service: "team", response: [{ type: "PropertyArray", name: "teamMsgReceipts", reflectMapper: jt.teamMsgReceiptTag }] }, dismissTeam: { sid: 8, cid: 12, service: "team", params: [{ type: "Long", name: "teamId" }] }, leaveTeam: { sid: 8, cid: 8, service: "team", params: [{ type: "Long", name: "teamId" }] }, transferTeam: { sid: 8, cid: 18, service: "team", params: [{ type: "Long", name: "teamId" }, { type: "String", name: "account" }, { type: "Bool", name: "leave" }] }, updateTeamInfo: { sid: 8, cid: 7, service: "team", params: [{ type: "Property", name: "team", reflectMapper: Ft.team }], response: [{ type: "Long", name: "id" }, { type: "Long", name: "time" }] }, getTeamsById: { sid: 8, cid: 34, service: "team", params: [{ type: "LongArray", name: "teamIds" }], response: [{ type: "PropertyArray", name: "teams", reflectMapper: jt.team }, { type: "LongArray", name: "tids" }], ignoreErrCodes: [816] }, getTeamMembers: { sid: 8, cid: 11, service: "team", params: [{ type: "Long", name: "teamId" }, { type: "Long", name: "timetag" }], response: [{ type: "Long", name: "teamId" }, { type: "PropertyArray", name: "teamMembers", reflectMapper: jt.teamMember }, { type: "Long", name: "timetag" }] }, getMutedTeamMembers: { sid: 8, cid: 27, service: "team", params: [{ type: "Long", name: "teamId" }], response: [{ type: "Long", name: "teamId" }, { type: "PropertyArray", name: "teamMembers", reflectMapper: jt.teamMember }] }, addTeamMembers: { sid: 8, cid: 5, service: "team", params: [{ type: "Long", name: "teamId" }, { type: "StrArray", name: "accounts" }, { type: "String", name: "ps" }, { type: "String", name: "attach" }], response: [{ type: "Long", name: "time" }, { type: "StrArray", name: "abortedAccidList" }] }, removeTeamMembers: { sid: 8, cid: 6, service: "team", params: [{ type: "Long", name: "teamId" }, { type: "StrArray", name: "accounts" }] }, applyTeam: { sid: 8, cid: 13, service: "team", params: [{ type: "Long", name: "teamId" }, { type: "String", name: "ps" }], response: [{ type: "Property", name: "team", reflectMapper: jt.team }] }, addTeamManagers: { sid: 8, cid: 16, service: "team", params: [{ type: "Long", name: "teamId" }, { type: "StrArray", name: "accounts" }] }, removeTeamManagers: { sid: 8, cid: 17, service: "team", params: [{ type: "Long", name: "teamId" }, { type: "StrArray", name: "accounts" }] }, updateMyMemberInfo: { sid: 8, cid: 19, service: "team", params: [{ type: "Property", name: "teamMember", reflectMapper: Ft.teamMember }] }, updateNickInTeam: { sid: 8, cid: 20, service: "team", params: [{ type: "Property", name: "teamMember", reflectMapper: Ft.teamMember }] }, muteTeamMember: { sid: 8, cid: 25, service: "team", params: [{ type: "Long", name: "teamId" }, { type: "String", name: "account" }, { type: "Int", name: "mute" }] }, getTeamMemberInvitorAccid: { sid: 8, cid: 33, service: "team", params: [{ type: "Long", name: "teamId" }, { type: "StrArray", name: "accounts" }], response: [{ type: "StrStrMap", name: "accountsMap" }] }, muteTeam: { sid: 8, cid: 32, service: "team", params: [{ type: "Long", name: "teamId" }, { type: "Int", name: "mute" }] }, passTeamApply: { sid: 8, cid: 14, service: "team", params: [{ type: "Long", name: "teamId" }, { type: "String", name: "from" }] }, rejectTeamApply: { sid: 8, cid: 15, service: "team", params: [{ type: "Long", name: "teamId" }, { type: "String", name: "from" }, { type: "String", name: "ps" }] }, acceptTeamInvite: { sid: 8, cid: 21, service: "team", params: [{ type: "Long", name: "teamId" }, { type: "String", name: "from" }] }, rejectTeamInvite: { sid: 8, cid: 22, service: "team", params: [{ type: "Long", name: "teamId" }, { type: "String", name: "from" }, { type: "String", name: "ps" }] }, syncTeams: { sid: 8, cid: 109, service: "team", response: [{ type: "Long", name: "timetag" }, { type: "PropertyArray", name: "teams", reflectMapper: jt.team }] }, syncCreateTeam: { sid: 8, cid: 101, service: "team", response: [{ type: "Property", name: "team", reflectMapper: jt.team }] }, syncUpdateTeamMember: { sid: 8, cid: 119, service: "team", response: [{ type: "Property", name: "teamMember", reflectMapper: jt.teamMember }] }, syncMyTeamMembers: { sid: 8, cid: 126, ext: "sync", service: "team", response: [{ type: "PropertyArray", name: "teamMembers", entity: "teamMember", reflectMapper: jt.teamMember }, { type: "Long", name: "timetag" }] } }, Gt = { "3_7": "getUsersNameCardFromServer", "3_10": "updateMyNameCard", "3_109": "syncMyNameCard", "3_110": "onUpdateMyNameCard", "3_3": "setBlack", "3_103": "onUpdateBlackList", "3_5": "setMute", "3_105": "onUpdateMuteList", "3_8": "syncRelations" }, Ht = { user: { account: 1, nick: 3, avatar: 4, signature: 5, gender: 6, email: 7, birth: 8, tel: 9, ext: 10, createTime: 12, updateTime: 13 }, relationMember: { account: 0, isMuted: 1, isBlack: 2, createTime: 3, updateTime: 4 } }, zt = invertSerializeMap(Ht), Wt = { syncMyNameCard: { sid: 3, cid: 109, service: "user", response: [{ type: "Property", name: "user", reflectMapper: zt.user }, { type: "Long", name: "timetag" }] }, setBlack: { service: "user", sid: 3, cid: 3, params: [{ type: "String", name: "account" }, { type: "Bool", name: "isAdd" }] }, onUpdateBlackList: { service: "user", sid: 3, cid: 103, response: [{ type: "String", name: "account" }, { type: "Bool", name: "isAdd" }] }, setMute: { service: "user", sid: 3, cid: 5, params: [{ type: "String", name: "account" }, { type: "Bool", name: "isAdd" }] }, onUpdateMuteList: { service: "user", sid: 3, cid: 105, response: [{ type: "String", name: "account" }, { type: "Bool", name: "isAdd" }] }, syncRelations: { service: "user", sid: 3, cid: 8, params: [{ type: "Long", name: "timetag" }], response: [{ type: "PropertyArray", name: "list", reflectMapper: zt.relationMember }, { type: "Long", name: "timetag" }] }, getUsersNameCardFromServer: { service: "user", sid: 3, cid: 7, params: [{ type: "StrArray", name: "accounts" }], response: [{ type: "PropertyArray", name: "users", reflectMapper: zt.user }] }, updateMyNameCard: { service: "user", sid: 3, cid: 10, params: [{ type: "Property", name: "user", reflectMapper: Ht.user }], response: [{ type: "Long", name: "timetag" }] }, onUpdateMyNameCard: { service: "user", sid: 3, cid: 110, response: [{ type: "Property", name: "user", reflectMapper: zt.user }] } }, Kt = { needPush: { type: "boolean", required: false }, needPushBadge: { type: "boolean", required: false }, needPushNick: { type: "boolean", required: false }, pushContent: { type: "string", required: false }, pushPayload: { type: "string", required: false }, needForcePush: { type: "boolean", required: false }, forcePushIDsList: { type: "string", allowEmpty: false, required: false }, forcePushContent: { type: "string", allowEmpty: false, required: false } }, Yt = { function: { type: "string", required: false }, topic: { type: "string", required: false }, customContent: { type: "string", required: false }, account: { type: "string", required: false } }, Jt = { subType: { type: "string" }, setting: { resendFlag: { type: "boolean" }, envConfig: { type: "string" }, needSaveHistory: { type: "boolean" }, needRoaming: { type: "boolean" }, needOffline: { type: "boolean" }, needSelfSync: { type: "boolean" }, needRouted: { type: "boolean" }, needUpdateSession: { type: "boolean" }, isMuted: { type: "boolean" } }, antiSpamInfo: { needAntiSpam: { type: "boolean" }, antiSpamContent: { type: "string" }, antiSpamBIZID: { type: "string" }, clientAntispamHitting: { type: "boolean" }, antiSpamUsingYidun: { type: "boolean" }, yidunCallbackURL: { type: "string" }, yidunAntiCheating: { type: "string" }, yidunAntiSpamExtension: { type: "string" }, yidunAntiSpamResult: { type: "string" } }, pushInfo: Kt, robotInfo: Yt, teamSpecializationInfo: { needACK: { type: "boolean" }, isACKSent: { type: "boolean" }, ackSnapshot: { type: "number" } }, threadMessageInfo: { replyMsgFromAccount: { type: "string" }, replyMsgToAccount: { type: "string" }, replyMsgTime: { type: "number" }, replyMsgIdServer: { type: "string" }, replyMsgIdClient: { type: "string" }, threadMsgFromAccount: { type: "string" }, threadMsgToAccount: { type: "string" }, threadMsgTime: { type: "number" }, threadMsgIdServer: { type: "string" }, threadMsgIdClient: { type: "string" } } }, Qt = { 0: "addTeamMembers", 1: "removeTeamMembers", 2: "leaveTeam", 3: "updateTeam", 4: "dismissTeam", 5: "passTeamApply", 6: "transferTeam", 7: "addTeamManagers", 8: "removeTeamManagers", 9: "acceptTeamInvite", 10: "updateTeamMemberMute", 101: "netcallMiss", 102: "netcallBill", 103: "netcallReject", 401: "addSuperTeamMembers", 402: "removeSuperTeamMembers", 403: "leaveSuperTeam", 404: "updateSuperTeam", 405: "dismissSuperTeam", 406: "transferSuperTeam", 407: "addSuperTeamManagers", 408: "removeSuperTeamManagers", 409: "updateSuperTeamMembersMute", 410: "passSuperTeamApply", 411: "acceptSuperTeamInvite" };
      function getSessionId(e2, t2) {
        return `${je[e2.scene]}-${e2.to === t2 ? e2.from : e2.to}`;
      }
      function msgFlow(e2, t2) {
        return e2.from === t2 ? e2.to === t2 ? "in" : "out" : "in";
      }
      function formatMsg$1(e2, t2) {
        var { account: r2, featureValue: i2, statusValue: s2, sessionAck: n2, msgReceiptTime: a2 } = t2, o2 = je[e2.scene], c2 = e2.to === r2 ? e2.from : e2.to, d2 = He.default, l2 = Ge.unread;
        parseInt(e2.isInBlackList) > 0 ? (l2 = Ge.refused, delete e2.isInBlackList) : l2 = e2.from === r2 ? a2 && a2 >= +e2.time ? Ge.receipt : Ge.sent : n2 && n2 >= +e2.time ? Ge.read : Ge.unread;
        var m2 = Object.assign(Object.assign({}, format(Jt, e2)), { scene: o2, type: Fe[e2.type], fromClientType: $e[e2.fromClientType], flow: msgFlow(e2, r2), target: c2, to: e2.to, from: e2.from, time: e2.time ? +e2.time : void 0, userUpdateTime: e2.userUpdateTime ? +e2.userUpdateTime : void 0, idClient: e2.idClient, sessionId: `${o2}-${c2}`, status: Ge[s2 || l2], feature: He[i2 || d2] });
        if ("string" == typeof m2.attach)
          try {
            m2.attach = JSON.parse(m2.attach);
          } catch (e3) {
          }
        return "notification" === m2.type && (m2.attach = m2.attach ? function formatNotificationAttach(e3) {
          var t3 = {};
          if (t3.type = Qt[e3.id] || e3.id, !e3.data)
            return t3;
          var r3 = { ids: "accounts", id: "account", attach: "custom", channel: "channelId", calltype: "netcallType", mute: "mute", duration: "duration", time: "time", from: "from", ext: "ext" }, i3 = e3.data;
          return Object.keys(r3).forEach((e4) => {
            void 0 !== i3[e4] && (t3[r3[e4]] = i3[e4]);
          }), i3.tinfo && (t3.team = formatTeam(deserialize(i3.tinfo, jt.team))), i3.uinfos && (t3.users = i3.uinfos.map((e4) => formatUser(deserialize(e4, zt.user)))), void 0 !== i3.mute && (t3.mute = 1 === parseInt(i3.mute)), t3;
        }(m2.attach) : {}), m2;
      }
      function formatMsgs$1(e2, t2) {
        return e2 && e2.length > 0 ? removeDupMsgsByIdClient(e2.map((e3) => formatMsg$1(e3, t2))) : [];
      }
      function removeDupMsgsByIdClient(e2) {
        var t2 = {};
        for (var r2 of e2) {
          var i2 = t2[r2.idClient];
          i2 && i2.time > r2.time || (t2[r2.idClient] = r2);
        }
        return Object.keys(t2).map((e3) => t2[e3]);
      }
      function processPushInfoInMsg(e2, t2 = true) {
        var r2 = Object.assign({}, e2);
        if (r2.pushInfo && t2) {
          for (var i2 in r2.pushInfo)
            "boolean" == typeof r2.pushInfo[i2] ? r2[i2] = r2.pushInfo[i2] ? 1 : 0 : r2[i2] = r2.pushInfo[i2];
          delete r2.pushInfo;
        }
        return r2.scene === je.team && r2.needForcePush && (r2.forcePushContent = r2.forcePushContent || r2.pushContent, r2.forcePushIDsList = r2.forcePushIDsList ? r2.forcePushIDsList : "#%@all@%#"), r2;
      }
      function generatorMsgForCmd$1(e2, t2, r2, i2) {
        var { onSendBefore: s2, onUploadStart: n2, onUploadDone: a2, replyMsg: o2 } = e2, c2 = __rest(e2, ["onSendBefore", "onUploadStart", "onUploadDone", "replyMsg"]), d2 = Object.assign(Object.assign({}, formatReverse(Jt, c2)), { scene: je[e2.scene], type: Fe[e2.type], from: t2, fromClientType: 16, fromDeviceId: r2, fromNick: null == i2 ? void 0 : i2.nick, userUpdateTime: null == i2 ? void 0 : i2.updateTime, status: Ge[Ge.sending] });
        if (d2.idClient = d2.resendFlag ? e2.idClient : Ie(), !d2.idClient)
          throw new FormatError("idClient is required to resend a message", "idClient", "required");
        return d2 = processPushInfoInMsg(d2, false), o2 && (d2.replyMsgFromAccount = o2.from, d2.replyMsgToAccount = o2.to, d2.replyMsgTime = +o2.time, d2.replyMsgIdServer = o2.idServer, d2.replyMsgIdClient = o2.idClient, d2.threadMsgFromAccount = o2.from, d2.threadMsgToAccount = o2.to, d2.threadMsgTime = +o2.time, d2.threadMsgIdServer = o2.idServer, d2.threadMsgIdClient = o2.idClient, o2.threadMessageInfo && o2.threadMessageInfo.threadMsgIdServer && (d2.threadMsgFromAccount = o2.threadMessageInfo.threadMsgFromAccount, d2.threadMsgToAccount = o2.threadMessageInfo.threadMsgToAccount, d2.threadMsgTime = o2.threadMessageInfo.threadMsgTime, d2.threadMsgIdServer = o2.threadMessageInfo.threadMsgIdServer, d2.threadMsgIdClient = o2.threadMessageInfo.threadMsgIdClient)), d2;
      }
      function formatDeletedMsgs(e2, t2) {
        return e2.map((e3) => {
          var r2;
          return r2 = t2 || (Number.isNaN(parseInt(e3.scene)) ? e3.scene : 1 === parseInt(e3.scene) ? "p2p" : "team"), { deletedTime: parseInt(e3.time), from: e3.from, idClient: e3.deletedIdClient || e3.idClient, idServer: e3.deletedIdServer || e3.idServer, scene: r2, time: parseInt(e3.deletedMsgCreateTime), to: e3.to, ext: "string" == typeof e3.ext ? e3.ext : null };
        });
      }
      function reverse(e2) {
        for (var t2 = [], r2 = (e2 = e2 || []).length - 1; r2 >= 0; r2--)
          t2.push(e2[r2]);
        return t2;
      }
      class ModuleService$2 {
        constructor(e2) {
          this.core = e2;
        }
        processBroadcastMsg(e2) {
          var t2 = e2.map((e3) => Object.assign(Object.assign({}, e3), { time: parseInt(e3.time) }));
          return this.core.sendCmd("batchMarkRead", { sid: 7, cid: 17, ids: t2.map((e3) => e3.id) }), t2;
        }
      }
      var Xt, Zt, er, tr = { needPush: { type: "boolean", required: false }, needPushBadge: { type: "boolean", required: false }, needPushNick: { type: "boolean", required: false }, pushContent: { type: "string", allowEmpty: false, required: false }, pushPayload: { type: "string", allowEmpty: false, required: false } }, rr = { pushContent: 8, pushPayload: 9, needPush: 107, needPushBadge: 109, needPushNick: 110 }, ir = { "4_4": "syncOfflineMsgs", "4_9": "syncRoamingMsgs", "4_17": "syncRoamingMsgs", "4_21": "syncDeleteSelfMsgs", "7_1": "sendMsg", "8_23": "getHistoryTeamMsgs", "21_14": "getHistorySuperTeamMsgs", "8_2": "sendTeamMsg", "21_2": "sendSuperTeamMsg", "7_11": "sendMsgReceipt", "7_13": "recallMsg", "7_24": "deleteSelfMsgs", "21_17": "recallSuperTeamMsg", "7_2": "onMsg", "8_3": "onMsg", "21_3": "onMsg", "7_101": "onMsg", "8_102": "onMsg", "21_102": "onMsg", "8_4": "nimOnTeamMsgs", "4_16": "syncBroadcastMsg", "7_17": "onBroadcastMsg", "7_123": "onDeleteSelfMsg", "7_124": "onDeleteSelfMsgs" }, sr = Object.assign(Object.assign({ scene: 0, to: 1, from: 2, fromClientType: 4, fromDeviceId: 5, fromNick: 6, time: 7, type: 8, body: 9, attach: 10, idClient: 11, idServer: 12, resendFlag: 13, userUpdateTime: 14, ext: 15, needAntiSpam: 21, antiSpamContent: 22, antiSpamBIZID: 23, clientAntispamHitting: 24, antiSpamUsingYidun: 25, needACK: 26, yidunCallbackURL: 27, needUpdateSession: 28, replyMsgFromAccount: 29, replyMsgToAccount: 30, replyMsgTime: 31, replyMsgIdServer: 32, replyMsgIdClient: 33, threadMsgFromAccount: 34, threadMsgToAccount: 35, threadMsgTime: 36, threadMsgIdServer: 37, threadMsgIdClient: 38, isDeleted: 39, callbackExt: 40, subType: 41, yidunAntiCheating: 42, envConfig: 43, yidunAntiSpamExtension: 44, yidunAntiSpamResult: 45, __clientExt: { id: 46, converter: objectToJSONString, retConverter: stringToJSONObject }, needSaveHistory: 100, needRoaming: 101, needSelfSync: 102, isMuted: 104, needRouted: 105, isInBlackList: 106, needOffline: 108, isReplyMsg: 111, ackSnapshot: 112 }, { pushContent: 17, pushPayload: 16, forcePushIDsList: 18, forcePushContent: 19, needForcePush: 20, needPush: 107, needPushBadge: 109, needPushNick: 110 }), { function: 47, topic: 48, customContent: 49, account: 50 }), nr = { msg: sr, recallMsgTag: Object.assign({ time: 0, type: 1, to: 2, from: 3, ps: 4, attach: 5, deletedIdClient: 10, deletedIdServer: 11, deleteMsgCreatetime: 14, opeAccount: 16, env: 21 }, rr), deleteSelfMsgTag: { scene: 1, from: 2, to: 3, idServer: 4, idClient: 5, deletedMsgCreateTime: 6, time: 7, ext: 8 }, msgReceiptTag: { to: 1, from: 2, time: 7, idClient: 11 }, broadcastMsg: { id: 1, fromAccid: 2, time: 4, body: 5 } }, ar = invertSerializeMap(nr), or = { sendMsg: { sid: 7, cid: 1, service: "msg", params: [{ type: "Property", name: "msg", reflectMapper: nr.msg }], response: [{ type: "Property", name: "msg", reflectMapper: ar.msg }], ignoreErrCodes: [7101] }, sendTeamMsg: { sid: 8, cid: 2, service: "msg", params: [{ type: "Property", name: "msg", reflectMapper: nr.msg }], response: [{ type: "Property", name: "msg", reflectMapper: ar.msg }] }, sendSuperTeamMsg: { sid: 21, cid: 2, service: "msg", params: [{ type: "Property", name: "msg", reflectMapper: nr.msg }], response: [{ type: "Property", name: "msg", reflectMapper: ar.msg }] }, onMsg: { sid: 7, cid: 2, service: "msg", response: [{ type: "Property", name: "msg", reflectMapper: ar.msg }] }, nimOnTeamMsgs: { sid: 8, cid: 4, service: "msg", response: [{ type: "PropertyArray", name: "datas", reflectMapper: ar.msg }] }, getHistoryTeamMsgs: { sid: 8, cid: 23, service: "msg", params: [{ type: "Long", name: "to" }, { type: "Long", name: "beginTime" }, { type: "Long", name: "endTime" }, { type: "Long", name: "lastMsgId" }, { type: "Int", name: "limit" }, { type: "Bool", name: "reverse" }, { type: "LongArray", name: "msgTypes" }], response: [{ type: "PropertyArray", name: "msgs", reflectMapper: ar.msg }] }, getHistorySuperTeamMsgs: { sid: 21, cid: 14, params: [{ type: "Long", name: "to" }, { type: "Long", name: "beginTime" }, { type: "Long", name: "endTime" }, { type: "Long", name: "lastMsgId" }, { type: "Int", name: "limit" }, { type: "Bool", name: "reverse" }, { type: "LongArray", name: "msgTypes" }], response: [{ type: "PropertyArray", name: "msgs", reflectMapper: ar.msg }], service: "msg" }, recallMsg: { sid: 7, cid: 13, service: "msg", params: [{ type: "Property", name: "recallMsgTag", reflectMapper: nr.recallMsgTag }] }, deleteSelfMsgs: { sid: 7, cid: 24, service: "msg", params: [{ type: "PropertyArray", name: "deletedMsgs", reflectMapper: nr.deleteSelfMsgTag }], response: [{ type: "Long", name: "timetag" }] }, recallSuperTeamMsg: { sid: 21, cid: 17, service: "msg", params: [{ type: "Property", name: "recallMsgTag", reflectMapper: nr.recallMsgTag }] }, sendMsgReceipt: { sid: 7, cid: 11, service: "msg", params: [{ type: "Property", name: "msgReceiptTag", reflectMapper: nr.msgReceiptTag }], response: [{ type: "Property", name: "msgReceiptTag", reflectMapper: ar.msgReceiptTag }] }, batchMarkRead: { sid: 4, cid: 5, service: "msg", hasPacketResponse: false, params: [{ type: "Byte", name: "sid" }, { type: "Byte", name: "cid" }, { type: "LongArray", name: "ids" }] }, syncMsgReceipts: { sid: 4, cid: 12, service: "msg", response: [{ type: "PropertyArray", name: "msgReceipts", reflectMapper: ar.msgReceiptTag }, { type: "Long", name: "timetag" }] }, syncOfflineMsgs: { sid: 4, cid: 4, service: "msg", response: [{ type: "PropertyArray", name: "msgs", reflectMapper: ar.msg }] }, syncRoamingMsgs: { sid: 4, cid: 9, service: "msg", response: [{ type: "PropertyArray", name: "msgs", reflectMapper: ar.msg }] }, syncBroadcastMsg: { sid: 4, cid: 16, service: "msg", response: [{ type: "PropertyArray", name: "msgs", reflectMapper: ar.broadcastMsg }] }, onBroadcastMsg: { sid: 7, cid: 17, service: "msg", response: [{ type: "Property", name: "msg", reflectMapper: ar.broadcastMsg }] }, onDeleteSelfMsg: { sid: 7, cid: 123, service: "msg", response: [{ type: "Property", name: "deletedMsg", reflectMapper: ar.deleteSelfMsgTag }] }, onDeleteSelfMsgs: { sid: 7, cid: 124, service: "msg", response: [{ type: "PropertyArray", name: "deletedMsgs", reflectMapper: ar.deleteSelfMsgTag }] }, syncDeleteSelfMsgs: { sid: 4, cid: 21, service: "msg", response: [{ type: "PropertyArray", name: "deletedMsgs", reflectMapper: ar.deleteSelfMsgTag }] } };
      !function(e2) {
        e2[e2.none = 0] = "none", e2[e2.pass = 1] = "pass", e2[e2.decline = 2] = "decline", e2[e2.read = 3] = "read", e2[e2.deleted = 4] = "deleted", e2[e2.invalid = 5] = "invalid";
      }(Xt || (Xt = {})), function(e2) {
        e2[e2.default = 0] = "default", e2[e2.leave = 1] = "leave", e2[e2.roam = 2] = "roam";
      }(Zt || (Zt = {})), function(e2) {
        e2[e2.applyTeam = 0] = "applyTeam", e2[e2.rejectTeamApply = 1] = "rejectTeamApply", e2[e2.teamInvite = 2] = "teamInvite", e2[e2.rejectTeamInvite = 3] = "rejectTeamInvite", e2[e2.friendRequest = 5] = "friendRequest", e2[e2.deleteFriend = 6] = "deleteFriend", e2[e2.recallMsgP2p = 7] = "recallMsgP2p", e2[e2.recallMsgTeam = 8] = "recallMsgTeam", e2[e2.recallMsgSuperTeam = 12] = "recallMsgSuperTeam", e2[e2.deleteMsgP2pOneWay = 13] = "deleteMsgP2pOneWay", e2[e2.deleteMsgTeamOneWay = 14] = "deleteMsgTeamOneWay", e2[e2.applySuperTeam = 15] = "applySuperTeam", e2[e2.rejectSuperTeamApply = 16] = "rejectSuperTeamApply", e2[e2.superTeamInvite = 17] = "superTeamInvite", e2[e2.rejectSuperTeamInvite = 18] = "rejectSuperTeamInvite", e2[e2.customP2p = 100] = "customP2p", e2[e2.customTeam = 101] = "customTeam", e2[e2.customSuperTeam = 103] = "customSuperTeam";
      }(er || (er = {}));
      var cr = { 1: "addFriend", 2: "applyFriend", 3: "passFriendApply", 4: "rejectFriendApply" };
      var dr = { setting: { needSaveOffline: { type: "boolean" }, isRoutable: { type: "boolean" }, envConfig: { type: "string" } }, antiSpamInfo: { needAntiSpam: { type: "boolean" }, antiSpamContent: { type: "boolean" } }, pushInfo: tr, recallMessageInfo: { idClient: { type: "string", rawKey: "deletedIdClient" }, idServer: { type: "string", rawKey: "deletedIdServer" }, createTime: { type: "number", rawKey: "deletedMsgCreateTime" }, fromNick: { type: "string", rawKey: "deletedMsgFromNick" }, opeAccount: { type: "string" } } };
      function formatSystemMessage(e2, t2, r2) {
        var i2 = +e2.type, s2 = getEnumKeyByEnumValue(er, i2);
        r2 = r2 || Zt.default;
        var n2 = Object.assign(Object.assign({}, format(dr, e2)), { type: s2, time: +e2.time, to: e2.to, from: e2.from, idServer: e2.idServer, state: Xt[Xt.none], feature: Zt[r2] });
        if ("0" === n2.idServer && n2.setting && (n2.setting.needSaveOffline = false), "string" == typeof n2.attach)
          try {
            n2.attach = JSON.parse(n2.attach);
          } catch (e3) {
            t2.error(`formatSystemMessage: ${n2.idServer} parse attach error`, e3 && e3.message);
          }
        return 5 === i2 && n2.attach ? (n2.attach.type = cr[+n2.attach.vt], "passFriendApply" === n2.attach.type ? n2.state = Xt[Xt.pass] : "rejectFriendApply" === n2.attach.type && (n2.state = Xt[Xt.decline])) : i2 <= 3 && n2.attach && (n2.attach = function formatTeamAttach(e3) {
          var { attach: t3, tinfo: r3 } = e3, i3 = __rest(e3, ["attach", "tinfo"]);
          return i3.ext = t3, void 0 !== r3 && (i3.team = formatTeam(deserialize(e3.tinfo, jt.team))), i3;
        }(n2.attach)), n2;
      }
      function generatorSysMsgForCmd$1(e2) {
        var t2 = Object.assign({}, e2);
        return Object.assign(Object.assign({}, formatReverse(dr, t2)), { type: er[t2.type], to: t2.to, attach: t2.attach });
      }
      function getSceneFromRecallSysMsg(e2) {
        return e2 === er.recallMsgP2p ? "p2p" : e2 === er.recallMsgTeam ? "team" : e2 === er.recallMsgSuperTeam ? "superTeam" : "";
      }
      var lr = { "5_1": "sync" }, mr = { sync: { sid: 5, cid: 1, service: "sync", hasPacketTimer: false, params: [{ type: "Property", name: "sync", reflectMapper: { myInfo: 1, offlineMsgs: 2, teams: 3, roamingMsgs: 7, relations: 9, friends: 11, friendUsers: 13, msgReceipts: 14, myTeamMembers: 15, donnop: 16, recallMsg: 17, sessionAck: 18, broadcastMsgs: 20, avSignal: 21, superTeams: 22, mySuperTeamMembers: 23, superTeamRoamingMsgs: 24, deleteSuperTeamMsg: 25, superTeamSessionAck: 26, deleteSelfMsgs: 27, stickTopSessions: 28, sessionHistoryMsgsDelete: 29 } }], response: [{ type: "Long", name: "timetag" }] } };
      var pr = { "4_12": "syncMsgReceipts", "4_14": "syncSessionAck", "4_20": "syncSuperTeamSessionAck", "4_22": "nimSyncSessionsWithMoreRoaming", "4_25": "syncSessionReliableInfo", "7_12": "multiSyncMsgReceipt", "7_16": "markSessionAck", "7_25": "markMultSessionsAck", "7_116": "syncMarkSessionAck", "21_25": "markSuperTeamSessionAck", "21_32": "markMultSuperTeamSessionsAck", "21_125": "syncMarkSuperTeamSessionAck", "4_23": "nimSyncStickTopSessions", "23_12": "nimAddStickTopSession", "23_13": "nimDeleteStickTopSession", "23_14": "nimUpdateStickTopSession", "23_112": "nimMultiSyncAddStickTopSession", "23_113": "nimMultiSyncDeleteStickTopSession", "23_114": "nimMultiSyncUpdateStickTopSession" }, ur = { msgReceiptTag: { to: 1, from: 2, time: 7, idClient: 11 }, stickTopSessionTag: { id: 1, ext: 2, createTime: 3, updateTime: 4 }, sessionAckTag: { scene: 1, to: 2, timetag: 3 }, sessionReliableSyncTag: { scene: 1, sessionId: 2, syncStatus: 3, syncEndMsgId: 4, syncEndMsgidClient: 5, syncEndMsgTime: 6, syncStartMsgid: 7, syncStartMsgidClient: 8, syncStartMsgTime: 9, nextMsgid: 10, nextMsgidClient: 11, nextMsgTime: 12, roamMsgSync: 13, offlineMsgSync: 14, netCallOfflineMsgSync: 15 } }, hr = invertSerializeMap(ur), gr = { syncMsgReceipts: { sid: 4, cid: 12, service: "session", response: [{ type: "PropertyArray", name: "msgReceipts", reflectMapper: hr.msgReceiptTag }, { type: "Long", name: "timetag" }] }, syncSessionAck: { sid: 4, cid: 14, service: "session", response: [{ type: "StrLongMap", name: "p2p" }, { type: "LongLongMap", name: "team" }, { type: "Long", name: "timetag" }] }, syncSuperTeamSessionAck: { sid: 4, cid: 20, service: "session", response: [{ type: "LongLongMap", name: "superTeam" }, { type: "Long", name: "timetag" }] }, multiSyncMsgReceipt: { sid: 7, cid: 12, service: "session", response: [{ type: "Property", name: "msgReceiptTag", reflectMapper: hr.msgReceiptTag }] }, markSessionAck: { sid: 7, cid: 16, service: "session", params: [{ type: "Byte", name: "scene" }, { type: "String", name: "to" }, { type: "Long", name: "timetag" }] }, syncMarkSessionAck: { sid: 7, cid: 116, service: "session", response: [{ type: "Byte", name: "scene" }, { type: "String", name: "to" }, { type: "Long", name: "timetag" }] }, syncMarkSuperTeamSessionAck: { sid: 21, cid: 125, service: "session", response: [{ type: "Long", name: "to" }, { type: "Long", name: "timetag" }] }, markMultSessionsAck: { sid: 7, cid: 25, service: "session", ignoreErrCodes: [700], params: [{ type: "PropertyArray", name: "datas", reflectMapper: ur.sessionAckTag }] }, markSuperTeamSessionAck: { sid: 21, cid: 25, service: "session", params: [{ type: "Long", name: "to" }, { type: "Long", name: "timetag" }] }, nimAddStickTopSession: { sid: 23, cid: 12, service: "session", params: [{ type: "Property", name: "tag", reflectMapper: ur.stickTopSessionTag }], response: [{ type: "Property", name: "data", reflectMapper: hr.stickTopSessionTag }] }, nimDeleteStickTopSession: { sid: 23, cid: 13, service: "session", params: [{ type: "Property", name: "tag", reflectMapper: ur.stickTopSessionTag }], response: [{ type: "Long", name: "timetag" }] }, nimUpdateStickTopSession: { sid: 23, cid: 14, service: "session", params: [{ type: "Property", name: "tag", reflectMapper: ur.stickTopSessionTag }], response: [{ type: "Property", name: "data", reflectMapper: hr.stickTopSessionTag }] }, nimMultiSyncAddStickTopSession: { sid: 23, cid: 112, service: "session", response: [{ type: "Property", name: "data", reflectMapper: hr.stickTopSessionTag }] }, nimMultiSyncDeleteStickTopSession: { sid: 23, cid: 113, service: "session", response: [{ type: "Long", name: "timetag" }, { type: "Property", name: "data", reflectMapper: hr.stickTopSessionTag }] }, nimMultiSyncUpdateStickTopSession: { sid: 23, cid: 114, service: "session", response: [{ type: "Property", name: "data", reflectMapper: hr.stickTopSessionTag }] }, nimSyncStickTopSessions: { sid: 4, cid: 23, service: "session", response: [{ type: "Long", name: "timetag" }, { type: "Bool", name: "isThereAnyChange" }, { type: "PropertyArray", name: "datas", reflectMapper: hr.stickTopSessionTag }] }, markMultSuperTeamSessionsAck: { sid: 21, cid: 32, service: "session", ignoreErrCodes: [700], params: [{ type: "PropertyArray", name: "datas", reflectMapper: ur.sessionAckTag }] }, nimSyncSessionsWithMoreRoaming: { sid: 4, cid: 22, service: "session", response: [] }, syncSessionReliableInfo: { sid: 4, cid: 25, service: "session", response: [] } }, vr = { id: { type: "string" }, ext: { type: "string" }, createTime: { type: "number" }, updateTime: { type: "number" } };
      function formatStickTop(e2, t2, r2 = true) {
        var i2 = format(vr, e2);
        i2.isStickOnTop = r2, i2.id = t2.id, r2 || (i2.ext = "");
        var s2 = Object.assign(Object.assign({}, t2), { stickTopInfo: t2.stickTopInfo ? Object.assign({}, t2.stickTopInfo, i2) : i2 });
        return void 0 === s2.lastMsg && (s2.lastMsg = null), s2;
      }
      class StickTopService {
        constructor(e2) {
          this.core = e2;
        }
        getSession(e2) {
          return this.core.session.getSessionWithUncomplete({ id: e2 }) || this.core.session.createSession(e2);
        }
        addStickTopSession(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ id: { type: "string", allowEmpty: false }, ext: { type: "string", required: false } }, e2);
            var { scene: t2, accid: r2 } = getAccountFromSessionId(e2.id), i2 = yield this.core.sendCmd("nimAddStickTopSession", { tag: { id: `${"superTeam" === t2 ? "super_team" : t2}|${r2}`, ext: e2.ext || "" } }), s2 = this.getSession(e2.id);
            return formatStickTop(i2.content.data, s2);
          });
        }
        deleteStickTopSession(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ id: { type: "string", allowEmpty: false } }, e2);
            var { scene: t2, accid: r2 } = getAccountFromSessionId(e2.id), i2 = yield this.core.sendCmd("nimDeleteStickTopSession", { tag: { id: `${"superTeam" === t2 ? "super_team" : t2}|${r2}` } }), s2 = this.getSession(e2.id);
            return formatStickTop({ updateTime: i2.content.timetag, ext: "" }, s2, false);
          });
        }
        updateStickTopSession(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ id: { type: "string", allowEmpty: false }, ext: { type: "string", required: false } }, e2);
            var { scene: t2, accid: r2 } = getAccountFromSessionId(e2.id), i2 = yield this.core.sendCmd("nimUpdateStickTopSession", { tag: { id: `${"superTeam" === t2 ? "super_team" : t2}|${r2}`, ext: e2.ext || "" } }), s2 = this.getSession(e2.id);
            return formatStickTop(i2.content.data, s2);
          });
        }
        stickTopSessionHandler(e2, t2 = true) {
          var { scene: r2, accid: i2 } = getAccountFromSessionId(e2.id, "|"), s2 = `${r2}-${i2}`;
          return formatStickTop(e2, this.getSession(s2), t2);
        }
      }
      class UnreadModuleService {
        constructor(e2) {
          this.core = e2, this.logger = e2.logger;
        }
        canSessionResetUnreadCount(e2) {
          var t2 = e2.id;
          if (void 0 === e2.lastMsg)
            throw new Error(`Session::canSessionResetUnreadCount: session ${t2} is not completly, lastMsg undefined`);
          return null !== e2.lastMsg || e2.unread > 0 ? !(e2.ack && e2.lastMsg && e2.ack >= e2.lastMsg.time) || (this.logger.log(`Session::canSessionResetUnreadCount: session ${t2} reset failed, ack time is greater than last message time`), false) : (this.logger.log(`Session::canSessionResetUnreadCount: session ${t2} doesn't need to be updated, lastMsg null and unread 0`), false);
        }
        filterSessionForResetUnreadCount(e2) {
          var t2 = { cmd: "markMultSuperTeamSessionsAck", params: [] }, r2 = { cmd: "markMultSessionsAck", params: [] };
          return e2.forEach((e3) => {
            var i2;
            try {
              if (!this.canSessionResetUnreadCount(e3))
                return;
              var { accid: s2, scene: n2 } = getAccountFromSessionId(e3.id), a2 = { to: s2, sessionId: e3.id, timetag: (null === (i2 = null == e3 ? void 0 : e3.lastMsg) || void 0 === i2 ? void 0 : i2.time) || e3.updateTime || 0 }, o2 = function generateSceneForCmd(e4) {
                return formatReverse({ scene: { type: "enum", values: je } }, e4);
              }({ scene: n2 });
              "superTeam" === n2 ? t2.params.push(a2) : r2.params.push(Object.assign(Object.assign({}, a2), o2));
            } catch (e4) {
              this.logger.warn(e4);
            }
          }), { superTeam: t2, p2pOrTeam: r2 };
        }
      }
      function chunk(e2, t2) {
        e2 = e2 || [], t2 = t2 || 1, t2 = Math.max(Math.floor(t2), 1);
        for (var r2 = [], i2 = 0; i2 < e2.length; i2 += t2)
          r2.push(e2.slice(i2, i2 + t2));
        return r2;
      }
      class ModuleService$1 {
        constructor(e2) {
          this.core = e2;
        }
        notifyAddTeamMembers(e2, t2) {
          this.core.emit("addTeamMembers", { team: e2, accounts: t2, members: generatorMembersByTeam(e2, t2) });
        }
        notifyUpdateTeamManagers(e2, t2, r2, i2) {
          this.core.emit("updateTeamManagers", { team: { teamId: e2, memberUpdateTime: i2 }, accounts: t2, isManager: r2, members: t2.map((t3) => ({ id: `${e2}-${t3}`, account: t3, type: r2 ? "manager" : "normal", updateTime: i2 })) });
        }
        notifyRemoveTeamMembers(e2, t2) {
          this.core.emit("removeTeamMembers", { team: e2, accounts: t2 });
        }
        notifyTransferTeam(e2, t2, r2) {
          this.core.emit("transferTeam", { team: e2, from: { id: `${e2.teamId}-${t2}`, type: "normal", account: t2, updateTime: e2.memberUpdateTime }, to: { id: `${e2.teamId}-${r2}`, type: "owner", account: r2, updateTime: e2.memberUpdateTime } });
        }
        notifyUpdateTeamMembersMute(e2, t2, r2) {
          this.core.emit("updateTeamMembersMute", { team: e2, accounts: t2, members: t2.map(function(t3) {
            return { id: `${e2.teamId}-${t3}`, account: t3, teamId: e2.teamId, mute: r2, updateTime: e2.memberUpdateTime };
          }), mute: r2 });
        }
      }
      function cloneDeep(e2, t2) {
        if ((t2 = /* @__PURE__ */ new Map()).get(e2))
          return e2;
        if (e2 instanceof RegExp)
          return new RegExp(e2);
        if (e2 instanceof Date)
          return new Date(e2.getTime());
        if (Array.isArray(e2))
          return t2.set(e2, true), e2.map((e3) => cloneDeep(e3, t2));
        if ("object" == typeof e2 && null !== e2) {
          t2.set(e2, true);
          var r2 = {};
          return Object.keys(e2).forEach((i2) => {
            r2[i2] = cloneDeep(e2[i2], t2);
          }), r2;
        }
        return e2;
      }
      var yr = { "4_6": "syncOfflineSysMsgs", "4_18": "syncOfflineSysMsgs", "4_19": "syncRecallMsgOfflineAndRoaming", "7_3": "onSysMsg", "7_7": "sendCustomSysMsg", "7_14": "onRecallMsg", "21_18": "onRecallMsg", "21_117": "onRecallMsg", "7_15": "syncRecallMsgOfflineAndRoaming", "21_19": "onSysMsg", "21_16": "sendSuperTeamCustomSysMsg" }, fr = { sysMsg: Object.assign({ time: 0, type: 1, to: 2, from: 3, content: 4, attach: 5, idServer: 6, needSaveOffline: 7, deletedIdClient: 10, deletedIdServer: 11, needcAntiSpam: 12, antiSpamContent: 13, deletedMsgCreateTime: 14, deletedMsgFromNick: 15, opeAccount: 16, envConfig: 21, callbackExt: 22, isRoutable: 105 }, rr) }, Ir = invertSerializeMap(fr), Mr = { onSysMsg: { service: "systemMessage", sid: 7, cid: 3, response: [{ type: "Property", name: "sysMsg", reflectMapper: Ir.sysMsg }] }, sendCustomSysMsg: { service: "systemMessage", sid: 7, cid: 7, params: [{ type: "Property", name: "sysMsg", reflectMapper: fr.sysMsg }] }, sendSuperTeamCustomSysMsg: { service: "systemMessage", sid: 21, cid: 16, params: [{ type: "Property", name: "sysMsg", reflectMapper: fr.sysMsg }] }, sendFilterCustomSysMsg: { service: "systemMessage", sid: 101, cid: 7, params: [{ type: "Property", name: "sysMsg", reflectMapper: fr.sysMsg }] }, batchMarkRead: { service: "systemMessage", sid: 4, cid: 5, hasPacketResponse: false, params: [{ type: "Byte", name: "sid" }, { type: "Byte", name: "cid" }, { type: "LongArray", name: "ids" }] }, onRecallMsg: { sid: 7, cid: 14, service: "systemMessage", response: [{ type: "Property", name: "sysMsg", reflectMapper: Ir.sysMsg }] }, syncRecallMsgOfflineAndRoaming: { sid: 7, cid: 15, service: "systemMessage", response: [{ type: "PropertyArray", name: "sysMsgs", reflectMapper: Ir.sysMsg }, { type: "Long", name: "timetag" }, { type: "Byte", name: "type" }] }, syncOfflineSysMsgs: { sid: 4, cid: 9, service: "systemMessage", response: [{ type: "PropertyArray", name: "sysMsgs", reflectMapper: Ir.sysMsg }] } };
      function reverseFriend(e2) {
        var t2 = Object.assign({}, e2);
        return ["bitsExtension", "createTime", "updateTime", "passRelationShip", "relationShip", "source"].forEach((e3) => {
          void 0 !== t2[e3] && (t2[e3] = parseInt(t2[e3]));
        }), void 0 !== t2.relationShip && (t2.valid = 1 === t2.relationShip), t2;
      }
      var Sr = { 1: "addFriend", 2: "applyFriend", 3: "passFriendApply", 4: "rejectFriendApply" };
      var Tr = { "12_4": "getFriends", "12_1": "friendReuqest", "12_2": "deleteFriend", "12_3": "updateFriend", "12_5": "syncFriends", "12_6": "syncFriendUsers", "12_101": "syncFriendRequest", "12_102": "syncDeleteFriend", "12_103": "syncUpdateFriend" }, _r = { updateFriendTag: { account: 4, alias: 8, ext: 10 }, delFriendParams: { delAlias: 1 }, friendTag: { account: 4, relationShip: 5, passRelationShip: 6, source: 7, alias: 8, bitsExtension: 9, ext: 10, createTime: 11, updateTime: 12, serverex: 13 }, userTag: { account: 1, nick: 3, avatar: 4, sign: 5, gender: 6, email: 7, birth: 8, tel: 9, ext: 10, createTime: 12, updateTime: 13 } }, Cr = invertSerializeMap(_r), Er = { getFriends: { sid: 12, cid: 4, service: "friend", params: [{ type: "Long", name: "timetag" }], response: [{ type: "PropertyArray", name: "friends", reflectMapper: Cr.friendTag }, { type: "Long", name: "timetag" }] }, friendReuqest: { sid: 12, cid: 1, service: "friend", params: [{ type: "String", name: "account" }, { type: "Byte", name: "type" }, { type: "String", name: "ps" }] }, deleteFriend: { sid: 12, cid: 2, service: "friend", params: [{ type: "String", name: "account" }, { type: "Property", name: "delFriendParams", reflectMapper: _r.delFriendParams }] }, updateFriend: { sid: 12, cid: 3, service: "friend", params: [{ type: "Property", name: "updateFriendTag", reflectMapper: _r.updateFriendTag }] }, syncFriends: { sid: 12, cid: 5, service: "friend", response: [{ type: "PropertyArray", name: "friends", entity: "friendTag", reflectMapper: Cr.friendTag }, { type: "Long", name: "timetag" }] }, syncFriendUsers: { sid: 12, cid: 6, service: "friend", response: [{ type: "PropertyArray", name: "users", entity: "userTag", reflectMapper: Cr.userTag }, { type: "Long", name: "timetag" }] }, syncFriendRequest: { sid: 12, cid: 101, service: "friend", params: [{ type: "String", name: "account" }, { type: "Byte", name: "type" }, { type: "String", name: "ps" }], response: [{ type: "String", name: "account" }, { type: "Byte", name: "type" }, { type: "String", name: "ps" }] }, syncDeleteFriend: { sid: 12, cid: 102, service: "friend", response: [{ type: "String", name: "account" }] }, syncUpdateFriend: { sid: 12, cid: 103, service: "friend", response: [{ type: "Property", name: "friend", reflectMapper: Cr.friendTag }] } };
      function formatSubscribes(e2) {
        return e2 && e2.length > 0 ? e2.map((e3) => function formatSubscribe(e4) {
          var t2 = Object.assign({}, e4);
          return ["subscribeTime", "time"].forEach((e5) => {
            t2[e5] && (t2[e5] = parseInt(t2[e5]));
          }), t2;
        }(e3)) : [];
      }
      function formatEvent(e2) {
        if (!e2)
          return e2;
        var { serverExt: t2 } = e2, r2 = __rest(e2, ["serverExt"]);
        if (["time", "type", "value"].forEach((e3) => {
          r2[e3] && (r2[e3] = parseInt(r2[e3]));
        }), r2.clientType && (r2.clientType = getEnumKeyByEnumValue($e, r2.clientType) || ""), t2)
          try {
            r2.ext = JSON.parse(t2), "string" == typeof r2.ext[0] && (r2.ext = r2.ext[0]);
          } catch (e3) {
          }
        return r2;
      }
      var br = { "14_1": "publishEvent", "14_2": "pushEvent", "14_3": "subscribeEvent", "14_4": "unSubscribeEventsByAccounts", "14_5": "unSubscribeEventsByType", "14_6": "querySubscribeEventsByAccounts", "14_7": "querySubscribeEventsByType", "14_9": "pushEvents" }, Rr = { msgEvent: { type: 1, value: 2, idClient: 3, ext: 4, validTime: 5, broadcastType: 6, sync: 7, validTimeType: 8, durable: 9, time: 10, idServer: 11, clientType: 12, serverConfig: 13, serverExt: 14, appid: 101, account: 103, enableMultiClient: 104, consid: 106 }, msgEventSubscribe: { type: 1, subscribeTime: 2, sync: 3, to: 102, from: 104, time: 105 } }, Nr = invertSerializeMap(Rr), Ar = { publishEvent: { sid: 14, cid: 1, service: "event", params: [{ type: "Property", name: "msgEvent", reflectMapper: Rr.msgEvent }], response: [{ type: "Property", name: "msgEvent", reflectMapper: Nr.msgEvent }] }, pushEvent: { sid: 14, cid: 2, service: "event", response: [{ type: "Property", name: "msgEvent", reflectMapper: Nr.msgEvent }] }, subscribeEvent: { sid: 14, cid: 3, service: "event", params: [{ type: "Property", name: "msgEventSubscribe", reflectMapper: Rr.msgEventSubscribe }, { type: "StrArray", name: "accounts" }], response: [{ type: "StrArray", name: "accounts" }] }, unSubscribeEventsByAccounts: { sid: 14, cid: 4, service: "event", params: [{ type: "Property", name: "msgEventSubscribe", reflectMapper: Rr.msgEventSubscribe }, { type: "StrArray", name: "accounts" }], response: [{ type: "StrArray", name: "accounts" }] }, unSubscribeEventsByType: { sid: 14, cid: 5, service: "event", params: [{ type: "Property", name: "msgEventSubscribe", reflectMapper: Rr.msgEventSubscribe }] }, querySubscribeEventsByAccounts: { sid: 14, cid: 6, service: "event", params: [{ type: "Property", name: "msgEventSubscribe", reflectMapper: Rr.msgEventSubscribe }, { type: "StrArray", name: "accounts" }], response: [{ type: "PropertyArray", name: "msgEventSubscribes", reflectMapper: Nr.msgEventSubscribe }] }, querySubscribeEventsByType: { sid: 14, cid: 7, service: "event", params: [{ type: "Property", name: "msgEventSubscribe", reflectMapper: Rr.msgEventSubscribe }], response: [{ type: "PropertyArray", name: "msgEventSubscribes", reflectMapper: Nr.msgEventSubscribe }] }, pushEvents: { sid: 14, cid: 9, service: "event", response: [{ type: "PropertyArray", name: "msgEvents", reflectMapper: Nr.msgEvent }] } };
      var Or, kr = { "23_1": "getThreadMsgs", "23_2": "getMsgsByIdServer" }, wr = { msg: sr, threadMsgReq: { beginTime: 1, endTime: 2, lastMsgId: 3, limit: 4, reverse: 5 }, threadMsgsMeta: { total: 1, lastMsgTime: 2 } }, Pr = invertSerializeMap(wr), Vr = { getThreadMsgs: { sid: 23, cid: 1, service: "msgExtend", params: [{ type: "Property", name: "msg", reflectMapper: wr.msg }, { type: "Property", name: "threadMsgReq", reflectMapper: wr.threadMsgReq }], response: [{ type: "Property", name: "threadMsg", reflectMapper: Pr.msg }, { type: "Property", name: "threadMsgsMeta", reflectMapper: Pr.threadMsgsMeta }, { type: "PropertyArray", name: "msgs", reflectMapper: Pr.msg }] }, getMsgsByIdServer: { sid: 23, cid: 2, service: "msgExtend", params: [{ type: "PropertyArray", name: "reqMsgs", reflectMapper: wr.msg }], response: [{ type: "PropertyArray", name: "msgs", reflectMapper: Pr.msg }] } };
      !function(e2) {
        e2[e2.ASC = 1] = "ASC", e2[e2.DESC = 2] = "DESC";
      }(Or || (Or = {}));
      var Lr, Ur = { "7_6": "getHistoryMsgs", "7_9": "deleteRoamingMsgs", "4_24": "syncClearServerHistoryMsgs", "7_18": "clearHistoryMsgsFromServer", "7_118": "multiSyncClearServerHistoryMsgs", "7_26": "nimFtsCloudMsgLogsAggWithSession", "7_27": "nimFtsCloudMsgLogs" }, Dr = { msg: sr, clearHistoryMsgsFromServerReqTag: { type: 0, otherAccid: 1, isDeleteRoam: 2, toTid: 3, isSyncSelf: 4, time: 6, ext: 7 }, clearMsgsParamsWithSync: { type: 0, otherAccid: 1, isDeleteRoam: 2, toTid: 3, isSyncSelf: 4, fromAccid: 5, time: 6, ext: 7 }, ftsReqTag: { keyword: 1, fromTime: 2, toTime: 3, sessionLimit: 4, msglogsLimit: 5, orderRule: 6, p2pSessionList: 7, teamSessionList: 8, senderList: 9, msgTypeList: 10, msgSubTypeList: 11 } }, qr = invertSerializeMap(Dr), xr = { deleteRoamingMsgs: { sid: 7, cid: 9, service: "msgLog", params: [{ type: "StrArray", name: "ids" }] }, getHistoryMsgs: { sid: 7, cid: 6, params: [{ type: "String", name: "to" }, { type: "Long", name: "beginTime" }, { type: "Long", name: "endTime" }, { type: "Long", name: "lastMsgId" }, { type: "Int", name: "limit" }, { type: "Bool", name: "reverse" }, { type: "LongArray", name: "msgTypes" }], response: [{ type: "PropertyArray", name: "msgs", reflectMapper: qr.msg }], service: "msgLog" }, clearHistoryMsgsFromServer: { sid: 7, cid: 18, params: [{ type: "Property", name: "clearHistoryMsgsFromServerReqTag", reflectMapper: Dr.clearHistoryMsgsFromServerReqTag }], response: [{ type: "Long", name: "timetag" }], service: "msgLog" }, multiSyncClearServerHistoryMsgs: { sid: 7, cid: 118, response: [{ type: "Property", name: "data", reflectMapper: qr.clearMsgsParamsWithSync }], service: "msgLog" }, syncClearServerHistoryMsgs: { sid: 4, cid: 24, service: "msgLog", response: [{ type: "PropertyArray", name: "datas", reflectMapper: qr.clearMsgsParamsWithSync }] }, nimFtsCloudMsgLogsAggWithSession: { sid: 7, cid: 26, service: "msgLog", params: [{ type: "Property", name: "tag", reflectMapper: Dr.ftsReqTag }], response: [{ type: "PropertyArray", name: "datas", reflectMapper: qr.msg }] }, nimFtsCloudMsgLogs: { sid: 7, cid: 27, service: "msgLog", params: [{ type: "Property", name: "tag", reflectMapper: Dr.ftsReqTag }], response: [{ type: "PropertyArray", name: "datas", reflectMapper: qr.msg }] } };
      !function(e2) {
        e2[e2.p2p = 1] = "p2p", e2[e2.team = 2] = "team";
      }(Lr || (Lr = {}));
      var Br = { type: { type: "enum", values: Lr }, isDeleteRoam: { type: "boolean" }, isSyncSelf: { type: "boolean" }, time: { type: "number" } };
      function formatClearResult(e2) {
        var t2 = format(Br, e2);
        return { sessionId: "p2p" === t2.type ? `p2p-${t2.otherAccid}` : `team-${t2.toTid}`, time: t2.time };
      }
      var Fr = { orderRule: { type: "enum", values: Or } };
      var jr = { "22_1": "requestProxy", "22_2": "onRequestProxy" }, $r = { requestProxyTag: { zone: 1, path: 2, method: 3, header: 4, body: 5 }, requestProxyMsgTag: { from: 1, body: 2, time: 3 } }, Gr = invertSerializeMap($r), Hr = { requestProxy: { sid: 22, cid: 1, service: "passThrough", params: [{ type: "Property", name: "requestProxyTag", reflectMapper: $r.requestProxyTag }], response: [{ type: "Property", name: "requestProxyTag", reflectMapper: Gr.requestProxyTag }] }, onRequestProxy: { sid: 22, cid: 2, service: "passThrough", response: [{ type: "Property", name: "proxyMsg", reflectMapper: Gr.requestProxyMsgTag }] } };
      var zr, Wr, Kr = { file: { md5: "$(Etag)", size: "$(ObjectSize)" }, image: { md5: "$(Etag)", size: "$(ObjectSize)", w: "$(ImageInfo.Width)", h: "$(ImageInfo.Height)", orientation: "$(ImageInfo.Orientation)" }, audio: { md5: "$(Etag)", size: "$(ObjectSize)", dur: "$(AVinfo.Audio.Duration)" }, video: { md5: "$(Etag)", size: "$(ObjectSize)", dur: "$(AVinfo.Video.Duration)", w: "$(AVinfo.Video.Width)", h: "$(AVinfo.Video.Height)" } }, Yr = { accessKeyId: "", secretAccessKey: "", sessionToken: "", region: "", maxRetries: 0, bucket: "", objectName: "", token: "", shortUrl: "" };
      function getUploadResponseFormat(e2 = "file") {
        var t2 = Kr[e2] || {};
        return JSON.stringify(t2).replace(/"/gi, '\\"');
      }
      !function(e2) {
        e2[e2.nos = 1] = "nos", e2[e2.s3 = 2] = "s3";
      }(zr || (zr = {})), function(e2) {
        e2[e2.dontNeed = -1] = "dontNeed", e2[e2.time = 2] = "time", e2[e2.urls = 3] = "urls";
      }(Wr || (Wr = {}));
      var Jr = { chunkUploadHost: "https://wannos-web.127.net", chunkUploadHostBackupList: ["https://fileup.chatnos.com", "https://oss.chatnos.com"], commonUploadHost: "https://fileup.chatnos.com", commonUploadHostBackupList: ["https://oss.chatnos.com"], chunkMaxSize: 4194304e4, commonMaxSize: 104857600, uploadReplaceFormat: "https://{host}/{object}", cdn: { defaultCdnDomain: "nim-nosdn.netease.im", cdnDomain: "", bucket: "", objectNamePrefix: "" }, downloadUrl: "https://{bucket}-nosdn.netease.im/{object}", downloadHostList: ["nos.netease.com"], nosCdnEnable: true, isNeedToGetUploadPolicyFromServer: true };
      function pickBy(e2, t2) {
        e2 = e2 || {}, t2 = t2 || (() => true);
        var r2 = {};
        for (var i2 in e2)
          t2(e2[i2]) && (r2[i2] = e2[i2]);
        return r2;
      }
      class NOS {
        constructor(e2, t2) {
          this.nosCdnHostTimer = 0, this.nosErrorCount = 0, this.core = e2, this.cloudStorage = t2;
        }
        get config() {
          return this.cloudStorage.config;
        }
        reset() {
          this.nosErrorCount = 0;
        }
        getNosAccessToken(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            var t2 = get(yield this.core.sendCmd("getNosAccessToken", { tag: e2 }), "content.nosAccessTokenTag.token"), r2 = e2.url;
            return { token: t2, url: -1 !== r2.indexOf("?") ? r2 + "&token=" + t2 : r2 + "?token=" + t2 };
          });
        }
        deleteNosAccessToken(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            yield this.core.sendCmd("deleteNosAccessToken", { tag: e2 });
          });
        }
        nosUpload(e2, t2) {
          var r2, i2, s2, n2, a2, o2, c2, d2;
          return __awaiter(this, void 0, void 0, function* () {
            var l2 = get(this.core, "config.cdn.bucket"), m2 = { tag: e2.nosScenes || l2 || "nim" };
            e2.nosSurvivalTime && (m2.expireSec = e2.nosSurvivalTime);
            var p2, u2 = this.core.adapters.getFileUploadInformation(e2);
            if (!t2 && !u2)
              try {
                p2 = yield this.core.sendCmd("getNosToken", { responseBody: getUploadResponseFormat(e2.type), nosToken: m2 });
              } catch (e3) {
                if (this.core.logger.error("uploadFile:: getNosToken error", e3), e3 instanceof V2NIMErrorImpl)
                  throw e3;
                throw new UploadError({ code: "v2" === get(this.core, "options.apiVersion") ? ce.V2NIM_ERROR_CODE_FILE_UPLOAD_FAILED : 400, detail: { reason: "getNosToken error", rawError: e3, curProvider: 1 } });
              }
            var h2 = this.config.uploadReplaceFormat.replace("{host}", this.config.cdn.cdnDomain || this.config.cdn.defaultCdnDomain).replace("{object}", u2 ? null === (r2 = u2.uploadInfo) || void 0 === r2 ? void 0 : r2.objectName : t2 ? null == t2 ? void 0 : t2.objectName : p2.content.nosToken.objectName), g2 = "";
            t2 && t2.shortUrl && (g2 = t2.shortUrl), (null === (n2 = null === (s2 = null === (i2 = null == u2 ? void 0 : u2.uploadInfo) || void 0 === i2 ? void 0 : i2.payload) || void 0 === s2 ? void 0 : s2.mixStoreToken) || void 0 === n2 ? void 0 : n2.shortUrl) && (g2 = u2.uploadInfo.payload.mixStoreToken.shortUrl);
            var v2, y2 = g2 || h2;
            try {
              var f2 = u2 ? { token: null === (a2 = null == u2 ? void 0 : u2.uploadInfo) || void 0 === a2 ? void 0 : a2.token, bucket: null === (o2 = null == u2 ? void 0 : u2.uploadInfo) || void 0 === o2 ? void 0 : o2.bucketName, objectName: null === (c2 = null == u2 ? void 0 : u2.uploadInfo) || void 0 === c2 ? void 0 : c2.objectName } : t2 || p2.content.nosToken;
              this.core.logger.log("uploadFile:: uploadFile params", { nosToken: f2, chunkUploadHost: this.config.chunkUploadHost, chunkUploadHostBackupList: this.config.chunkUploadHostBackupList, commonUploadHost: this.config.commonUploadHost, commonUploadHostBackupList: this.config.commonUploadHostBackupList, platform: ge.platform });
              var I2 = "BROWSER" === ge.platform ? this.config.chunkUploadHost : `${this.config.commonUploadHost}/${f2 && f2.bucket}`;
              this.core.reporterHookCloudStorage.update({ remote_addr: I2, operation_type: t2 ? 2 : 0 }), v2 = yield this.core.adapters.uploadFile(Object.assign(Object.assign(Object.assign({}, e2), { nosToken: f2, chunkUploadHost: this.config.chunkUploadHost, chunkUploadHostBackupList: this.config.chunkUploadHostBackupList, commonUploadHost: this.config.commonUploadHost, commonUploadHostBackupList: this.config.commonUploadHostBackupList, maxSize: e2.maxSize || this.config.chunkMaxSize }), t2 ? { payload: { mixStoreToken: t2 } } : {}));
            } catch (r3) {
              this.core.logger.error("uploadFile::nos uploadFile error:", r3);
              var M2 = "v2" === get(this.core, "options.apiVersion");
              if (r3.code === ce.V2NIM_ERROR_CODE_CANCELLED || 10499 === r3.errCode)
                throw new UploadError({ code: M2 ? ce.V2NIM_ERROR_CODE_CANCELLED : 400, detail: { reason: get(r3, "message") || "Request abort", rawError: r3, curProvider: 1 } });
              if (M2 && r3.errCode === ce.V2NIM_ERROR_CODE_FILE_OPEN_FAILED)
                throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_FILE_OPEN_FAILED, detail: { reason: get(r3, "message") || "Read file failed", rawError: r3, curProvider: 1 } });
              var { net_connect: S2 } = yield ge.net.getNetworkStatus();
              if (false === S2)
                throw new UploadError({ code: "v2" === get(this.core, "options.apiVersion") ? ce.V2NIM_ERROR_CODE_FILE_UPLOAD_FAILED : 400, detail: { reason: "No network", rawError: r3, curProvider: 1 } });
              if (t2) {
                if (this.nosErrorCount <= 0) {
                  try {
                    this.cloudStorage.mixStorage._addCircuitTimer();
                  } catch (t3) {
                    throw new UploadError({ code: "v2" === get(this.core, "options.apiVersion") ? ce.V2NIM_ERROR_CODE_FILE_UPLOAD_FAILED : 400, detail: { reason: "All upload attempts failed", rawError: t3, curProvider: this.cloudStorage.mixStorage.curProvider, mixStorePolicy: this.cloudStorage.mixStorage.mixStorePolicy, file: e2.file || e2.filePath } });
                  }
                  return this.nosErrorCount = get(this.cloudStorage, "mixStorePolicy.nosPolicy.uploadConfig.retryPolicy.retry"), this.cloudStorage._uploadFile(e2);
                }
                return this.nosErrorCount--, this.nosUpload(e2, t2);
              }
              throw new UploadError({ code: "v2" === get(this.core, "options.apiVersion") ? ce.V2NIM_ERROR_CODE_FILE_UPLOAD_FAILED : 400, detail: { reason: "NOS attempts failed", rawError: r3, curProvider: 1 } });
            }
            var T2 = null == v2 ? void 0 : v2.type, _2 = T2 && T2.indexOf("/") > -1 ? T2.slice(0, T2.indexOf("/")) : "";
            _2 || (_2 = e2.type || "");
            var C2, E2 = { image: "imageInfo", video: "vinfo", audio: "vinfo" };
            if (!E2[_2])
              return Object.assign({ url: y2 }, v2);
            try {
              C2 = yield this.core.adapters.request(`${h2}?${E2[_2]}`, { method: "GET", dataType: "json", timeout: 5e3 }, { exception_service: 3 });
            } catch (e3) {
              return this.core.logger.error("uploadFile:: fetch file info error", e3), Object.assign({ url: y2 }, v2);
            }
            if (C2) {
              var { data: b2 } = C2, R2 = "imageInfo" === E2[_2] ? b2 : null === (d2 = null == b2 ? void 0 : b2.GetVideoInfo) || void 0 === d2 ? void 0 : d2.VideoInfo;
              return pickBy({ url: y2, name: v2.name, size: v2.size, ext: v2.ext, w: null == R2 ? void 0 : R2.Width, h: null == R2 ? void 0 : R2.Height, orientation: null == R2 ? void 0 : R2.Orientation, dur: null == R2 ? void 0 : R2.Duration, audioCodec: null == R2 ? void 0 : R2.AudioCodec, videoCodec: null == R2 ? void 0 : R2.VideoCodec, container: null == R2 ? void 0 : R2.Container }, function(e3) {
                return void 0 !== e3;
              });
            }
            return Object.assign({ url: y2 }, v2);
          });
        }
        _getNosCdnHost() {
          var e2;
          return __awaiter(this, void 0, void 0, function* () {
            var t2;
            try {
              t2 = yield this.core.sendCmd("getNosCdnHost");
            } catch (e3) {
              return void this.core.logger.error("getNosCdnHost::error", e3);
            }
            if (t2) {
              var r2 = null === (e2 = null == t2 ? void 0 : t2.content) || void 0 === e2 ? void 0 : e2.nosConfigTag, i2 = parseInt(null == r2 ? void 0 : r2.expire);
              0 !== i2 && r2.cdnDomain ? -1 === i2 ? (this.config.cdn.bucket = r2.bucket, this.config.cdn.cdnDomain = r2.cdnDomain, this.config.cdn.objectNamePrefix = r2.objectNamePrefix) : (this.config.cdn.bucket = r2.bucket, this.config.cdn.cdnDomain = r2.cdnDomain, this.config.cdn.objectNamePrefix = r2.objectNamePrefix, this.nosCdnHostTimer = this.core.timerManager.addTimer(() => {
                this._getNosCdnHost();
              }, 1e3 * i2)) : (this.config.cdn.bucket = "", this.config.cdn.cdnDomain = "", this.config.cdn.objectNamePrefix = "");
            }
          });
        }
      }
      var Qr = { "6_2": "getNosToken", "6_22": "getOriginUrl", "6_24": "getNosAccessToken", "6_25": "deleteNosAccessToken", "6_26": "getNosCdnHost", "6_27": "getGrayscaleConfig", "6_28": "getMixStorePolicy", "6_29": "getMixStoreToken", "6_30": "getFileAuthToken" }, Xr = { nosToken: { objectName: 1, token: 2, bucket: 3, expireTime: 4, expireSec: 7, tag: 8, shortUrl: 9 }, mixStoreTokenReqTag: { provider: 0, tokenCount: 1, nosSurvivalTime: 2, tag: 3, returnBody: 4, policyVersion: 5 }, nosConfigTag: { bucket: 1, cdnDomain: 2, expire: 3, objectNamePrefix: 4 }, grayConfigTag: { config: 0, ttl: 1 }, mixStorePolicyTag: { providers: 0, ttl: 1, mixEnable: 2, nosPolicy: 3, s3Policy: 4, policyVersion: 5 }, mixStoreTokenResTag: { provider: 0, accessKeyId: 1, secretAccessKey: 2, sessionToken: 3, token: 4, expireTime: 5, bucket: 6, objectName: 7, fileExpireSec: 8, tag: 9, shortUrl: 10, region: 11 }, nosSafeUrlTag: { safeUrl: 0, originUrl: 1 }, mixStoreAuthTokenReqTag: { type: 1, urls: 2 }, mixStoreAuthTokenResTag: { type: 1, tokens: 2, token: 3, ttl: 4 }, nosAccessTokenTag: { token: 0, url: 1, userAgent: 2, ext: 3 } }, Zr = { getNosToken: { sid: 6, cid: 2, service: "cloudStorage", params: [{ type: "String", name: "responseBody" }, { type: "Property", name: "nosToken", entity: "nosToken", reflectMapper: Xr.nosToken }], response: [{ type: "Property", name: "nosToken", reflectMapper: invertSerializeItem(Xr.nosToken) }] }, getOriginUrl: { sid: 6, cid: 22, service: "cloudStorage", params: [{ type: "Property", name: "nosSafeUrlTag", reflectMapper: Xr.nosSafeUrlTag }], response: [{ type: "Property", name: "nosSafeUrlTag", reflectMapper: invertSerializeItem(Xr.nosSafeUrlTag) }] }, getNosCdnHost: { sid: 6, cid: 26, service: "cloudStorage", response: [{ type: "Property", name: "nosConfigTag", reflectMapper: invertSerializeItem(Xr.nosConfigTag) }] }, getGrayscaleConfig: { sid: 6, cid: 27, service: "cloudStorage", params: [{ type: "Property", name: "config" }], response: [{ type: "Property", name: "grayConfigTag", reflectMapper: invertSerializeItem(Xr.grayConfigTag) }] }, getMixStorePolicy: { sid: 6, cid: 28, service: "cloudStorage", params: [{ type: "LongArray", name: "supportType" }], response: [{ type: "Property", name: "mixStorePolicyTag", reflectMapper: invertSerializeItem(Xr.mixStorePolicyTag) }] }, getMixStoreToken: { sid: 6, cid: 29, service: "cloudStorage", params: [{ type: "Property", name: "mixStoreTokenReqTag", reflectMapper: Xr.mixStoreTokenReqTag }], response: [{ type: "Property", name: "mixStoreTokenResTag", reflectMapper: invertSerializeItem(Xr.mixStoreTokenResTag) }] }, getFileAuthToken: { sid: 6, cid: 30, service: "cloudStorage", params: [{ type: "Property", name: "mixStoreAuthTokenReqTag", reflectMapper: Xr.mixStoreAuthTokenReqTag }], response: [{ type: "Property", name: "mixStoreAuthTokenResTag", reflectMapper: invertSerializeItem(Xr.mixStoreAuthTokenResTag) }] }, getNosAccessToken: { sid: 6, cid: 24, service: "cloudStorage", params: [{ type: "Property", name: "tag", reflectMapper: Xr.nosAccessTokenTag }], response: [{ type: "Property", name: "tag", reflectMapper: invertSerializeItem(Xr.nosAccessTokenTag) }] }, deleteNosAccessToken: { sid: 6, cid: 25, service: "cloudStorage", params: [{ type: "Property", name: "tag", reflectMapper: Xr.nosAccessTokenTag }] } };
      class MixStorage {
        constructor(e2, t2) {
          this.GRAYKEY = "AllGrayscaleConfig", this.MIXSTOREKEY = "AllMixStorePolicy", this.grayConfig = { mixStoreEnable: false, timeStamp: 0, ttl: 0 }, this.mixStorePolicy = { providers: [], timeStamp: 0, ttl: 0, s3Policy: null, nosPolicy: null, policyVersion: void 0 }, this.curProvider = 1, this.mixStoreErrorCount = 10, this.circuitTimer = 0, this.core = e2, this.cloudStorage = t2, this.logger = e2.logger;
        }
        reset() {
          this.grayConfig = null, this.mixStorePolicy = { providers: [], timeStamp: 0, ttl: 0, s3Policy: null, nosPolicy: null, policyVersion: void 0 }, this.curProvider = 1, this.mixStoreErrorCount = 10;
        }
        getGrayscaleConfig(e2, t2) {
          var r2;
          return __awaiter(this, void 0, void 0, function* () {
            if (ge.localStorage)
              try {
                ge.localStorage.getItem && ge.localStorage.getItem(this.GRAYKEY) && (this.grayConfig = JSON.parse(ge.localStorage.getItem(this.GRAYKEY))[e2]);
              } catch (e3) {
                ge.localStorage.getItem(this.GRAYKEY) && this.core.logger.error("uploadFile:: JSON.parse grayscaleConfig error ", e3);
              }
            if (!this.grayConfig || this.grayConfig.timeStamp + 1e3 * this.grayConfig.ttl < t2) {
              var i2 = yield this.core.sendCmd("getGrayscaleConfig", { config: {} });
              if (i2.content && i2.content.grayConfigTag) {
                this.logger.log("uploadFile::getAppGrayConfigRequest success ");
                try {
                  this.grayConfig = JSON.parse(i2.content.grayConfigTag.config), this.grayConfig.ttl = JSON.parse(i2.content.grayConfigTag.ttl);
                } catch (e3) {
                  this.logger.error("getGrayscaleConfig error", e3);
                }
                if (!this.grayConfig)
                  return;
                var s2 = ge.localStorage.getItem(this.GRAYKEY) ? JSON.parse(ge.localStorage.getItem(this.GRAYKEY)) : {};
                this.grayConfig.timeStamp = (/* @__PURE__ */ new Date()).getTime(), s2[e2] = this.grayConfig, ge.localStorage.setItem(this.GRAYKEY, JSON.stringify(s2));
              } else
                this.logger.log("uploadFile:: result grayConfig:", i2.content);
            }
            (null === (r2 = this.grayConfig) || void 0 === r2 ? void 0 : r2.mixStoreEnable) && (yield this._getMixStorePolicy(e2));
          });
        }
        _getMixStorePolicy(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            var t2 = (/* @__PURE__ */ new Date()).getTime();
            if (ge.localStorage)
              try {
                if (this.mixStorePolicy = JSON.parse(ge.localStorage.getItem(this.MIXSTOREKEY))[e2], this.curProvider = parseInt(this.mixStorePolicy.providers[0]), this.mixStorePolicy.timeStamp && this.mixStorePolicy.timeStamp + 1e3 * this.mixStorePolicy.ttl > t2) {
                  var r2 = this.mixStorePolicy.timeStamp + 1e3 * this.mixStorePolicy.ttl - t2;
                  this.core.timerManager.addTimer(this._getMixStorePolicy.bind(this, e2), r2);
                }
              } catch (t3) {
                ge.localStorage.getItem(this.MIXSTOREKEY) && JSON.parse(ge.localStorage.getItem(this.MIXSTOREKEY))[e2] && this.core.logger.error("uploadFile:: JSON.parse mixStorePolicy error ", t3);
              }
            if (!this.mixStorePolicy || this.mixStorePolicy.timeStamp + 1e3 * this.mixStorePolicy.ttl <= t2)
              try {
                var i2 = (yield this.core.sendCmd("getMixStorePolicy", { supportType: this.cloudStorage.aws.s3 ? [1, 2] : [1] })).content.mixStorePolicyTag;
                this.mixStorePolicy = { providers: [], timeStamp: 0, ttl: 0, s3Policy: null, nosPolicy: null, policyVersion: void 0 }, this.mixStorePolicy.policyVersion = i2.policyVersion, this.mixStorePolicy.ttl = Number(i2.ttl), this.mixStorePolicy.providers = i2.providers.split(","), this.circuitTimer && this.core.timerManager.deleteTimer(this.circuitTimer), this.curProvider = parseInt(this.mixStorePolicy.providers[0]), this.mixStorePolicy.nosPolicy = i2.nosPolicy ? JSON.parse(i2.nosPolicy) : null, this.mixStorePolicy.s3Policy = i2.s3Policy ? JSON.parse(i2.s3Policy) : null, null === this.mixStorePolicy.s3Policy ? this.mixStorePolicy.providers = ["1"] : null === this.mixStorePolicy.nosPolicy ? this.mixStorePolicy.providers = ["2"] : this.mixStorePolicy.providers = this.mixStorePolicy.s3Policy.priority < this.mixStorePolicy.nosPolicy.priority ? ["2", "1"] : ["1", "2"], this.core.timerManager.addTimer(this._getMixStorePolicy.bind(this, e2), 1e3 * this.mixStorePolicy.ttl);
                var s2 = ge.localStorage.getItem(this.MIXSTOREKEY) ? JSON.parse(ge.localStorage.getItem(this.MIXSTOREKEY)) : {};
                this.mixStorePolicy.timeStamp = (/* @__PURE__ */ new Date()).getTime(), s2[e2] = this.mixStorePolicy, ge.localStorage.setItem(this.MIXSTOREKEY, JSON.stringify(s2));
              } catch (t3) {
                if (this.logger.error("getMixStorePolicy error", t3), 0 === this.mixStoreErrorCount)
                  throw new Error("getMixStorePolicy all count error");
                this._getMixStorePolicy(e2), this.mixStoreErrorCount--;
              }
            this.mixStorePolicy.nosPolicy && (this.cloudStorage.nos.nosErrorCount = this.mixStorePolicy.nosPolicy.uploadConfig.retryPolicy.retry);
          });
        }
        _addCircuitTimer() {
          var e2 = this.mixStorePolicy.providers, t2 = e2[(e2.indexOf(String(this.curProvider)) + 1) % e2.length];
          if (!t2)
            throw new Error("uploadFile nextProvider error");
          if (t2 === e2[0])
            throw new Error("uploadFile all policy fail");
          if (this.logger.log(`uploadFile:: upload policy will change,now policy:${this.curProvider} nextProvider:${t2}`), this.curProvider = parseInt(t2), this.mixStorePolicy.nosPolicy && this.mixStorePolicy.s3Policy) {
            var r2 = this.mixStorePolicy[1 === this.curProvider ? "nosPolicy" : "s3Policy"].uploadConfig.retryPolicy.circuit;
            if (!r2 || 0 === r2)
              throw new Error("uploadFile circuit error");
            this.circuitTimer = this.core.timerManager.addTimer(() => {
              this.logger.log(`uploadFile:: upload policy will change,now policy:${this.curProvider} nextProvider:${parseInt(this.mixStorePolicy.providers[0])}`), this.curProvider = parseInt(this.mixStorePolicy.providers[0]), this.core.timerManager.deleteTimer(this.circuitTimer);
            }, 1e3 * r2);
          }
          throw new Error("uploadFile will not retry again");
        }
        getFileAuthToken(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return (yield this.core.sendCmd("getFileAuthToken", { mixStoreAuthTokenReqTag: e2 })).content.mixStoreAuthTokenResTag;
          });
        }
      }
      var ei = -1;
      class AWS {
        constructor(e2, t2) {
          this.s3 = null, this.core = e2, this.cloudStorage = t2, this.logger = e2.logger;
        }
        get mixStorePolicy() {
          return this.cloudStorage.mixStorage.mixStorePolicy;
        }
        s3Upload(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            var r2;
            if (ei += 1, e2.file)
              r2 = e2.file;
            else if ("string" == typeof e2.fileInput) {
              this.logger.warn("fileInput will abandon,Please use file or filepath");
              var i2 = document.getElementById(e2.fileInput);
              if (!(i2 && i2.files && i2.files[0]))
                throw new Error("Can not get file from fileInput");
              r2 = i2.files[0];
            } else {
              if (!(e2.fileInput && e2.fileInput.files && e2.fileInput.files[0]))
                throw new Error(`Can not get file from fileInput ${e2.fileInput}`);
              r2 = e2.fileInput.files[0];
            }
            if (!this.mixStorePolicy.s3Policy)
              throw new Error("dont get s3 policy");
            var s2 = { accessKeyId: t2.accessKeyId, secretAccessKey: t2.secretAccessKey, sessionToken: t2.sessionToken, region: t2.region, maxRetries: this.mixStorePolicy.s3Policy.uploadConfig.retryPolicy.retry }, n2 = this.s3, a2 = decodeURIComponent(t2.bucket), o2 = decodeURIComponent(t2.objectName), c2 = r2, d2 = `https://${a2}.s3.amazonaws.com/${o2}`, l2 = {}, m2 = this.mixStorePolicy.s3Policy;
            if (m2 && m2.uploadConfig && Array.isArray(m2.uploadConfig.uploadUrl) && m2.uploadConfig.uploadUrl.length > 0) {
              var p2 = m2.uploadConfig.uploadUrl.length;
              ei %= p2, l2.endpoint = m2.uploadConfig.uploadUrl[ei], l2.s3ForcePathStyle = true, d2 = `${l2.endpoint}/${a2}/${o2}`;
            }
            this.core.reporterHookCloudStorage.update({ remote_addr: d2, operation_type: 1 });
            var u2 = new n2(l2);
            u2.config.update(s2);
            var h2 = { Bucket: a2, Key: o2, Body: c2, Metadata: { token: t2.token }, ContentType: c2.type || "application/octet-stream" };
            this.core.logger.log("uploadFile:: s3 upload params:", h2);
            var g2 = u2.upload(h2);
            return g2.on("httpUploadProgress", (t3) => {
              var r3 = parseFloat((t3.loaded / t3.total).toFixed(2));
              e2.onUploadProgress && e2.onUploadProgress({ total: t3.total, loaded: t3.loaded, percentage: r3, percentageText: Math.round(100 * r3) + "%" });
            }), new Promise((r3, i3) => {
              var s3 = (/* @__PURE__ */ new Date()).getTime();
              g2.send((n3, d3) => __awaiter(this, void 0, void 0, function* () {
                var l3, m3, p3;
                if (n3 && "RequestAbortedError" === n3.code)
                  this.logger.error("uploadFile:", "api::s3:upload file abort.", n3), i3(new UploadError({ code: "v2" === get(this.core, "options.apiVersion") ? ce.V2NIM_ERROR_CODE_CANCELLED : 400, detail: { reason: "S3RequestAbortedError", rawError: n3, curProvider: 2 } }));
                else {
                  if (!n3) {
                    var u3 = this.mixStorePolicy.s3Policy.cdnSchema;
                    u3 = (u3 = u3.replace("{cdnDomain}", this.mixStorePolicy.s3Policy.dlcdn)).replace("{objectName}", d3.Key);
                    var h3 = { size: c2.size, name: c2.name, url: t2.shortUrl ? t2.shortUrl : u3, ext: c2.name.split(".")[1] || "unknown" }, g3 = e2.type || "", v2 = { image: "imageInfo" };
                    return r3(v2[g3] ? yield this.getS3FileInfo({ url: u3, infoSuffix: v2[g3], s3Result: h3 }) : h3);
                  }
                  this.logger.error("uploadFile:", "api::s3:upload file failed.", n3), this.core.reporter.reportTraceStart("exceptions", { user_id: this.core.options.account || (null === (m3 = null === (l3 = this.core) || void 0 === l3 ? void 0 : l3.auth) || void 0 === m3 ? void 0 : m3.account), trace_id: null === (p3 = this.core.clientSocket.socket) || void 0 === p3 ? void 0 : p3.sessionId, start_time: s3, action: 1, exception_service: 4 }), this.core.reporter.reportTraceUpdateV2("exceptions", { code: "number" == typeof n3.status ? n3.status : "number" == typeof n3.code ? n3.code : 0, description: n3.message || `${n3.code}`, operation_type: 1, target: JSON.stringify({ bucket: a2, object: o2 }) }, { asyncParams: ge.net.getNetworkStatus() }), this.core.reporter.reportTraceEnd("exceptions", 1);
                  var { net_connect: y2 } = yield ge.net.getNetworkStatus();
                  if (false === y2)
                    return i3(new UploadError({ code: "v2" === get(this.core, "options.apiVersion") ? ce.V2NIM_ERROR_CODE_FILE_UPLOAD_FAILED : 400, detail: { reason: "No network", rawError: n3, curProvider: this.cloudStorage.mixStorage.curProvider } }));
                  try {
                    this.cloudStorage.mixStorage._addCircuitTimer();
                  } catch (t3) {
                    return i3(new UploadError({ code: "v2" === get(this.core, "options.apiVersion") ? ce.V2NIM_ERROR_CODE_FILE_UPLOAD_FAILED : 400, detail: { reason: "All upload attempts failed", rawError: t3, curProvider: this.cloudStorage.mixStorage.curProvider, mixStorePolicy: this.mixStorePolicy, file: e2.file || e2.filePath } }));
                  }
                  r3(this.cloudStorage._uploadFile(e2));
                }
              })), e2.onUploadStart && e2.onUploadStart(g2);
            });
          });
        }
        getS3FileInfo(e2) {
          var t2;
          return __awaiter(this, void 0, void 0, function* () {
            var r2, { url: i2, infoSuffix: s2, s3Result: n2 } = e2;
            try {
              r2 = yield this.core.adapters.request(`${i2}?${s2}`, { method: "GET", dataType: "text", timeout: 5e3 }, { exception_service: 3 });
            } catch (e3) {
              return this.core.logger.error("uploadFile:: fetch file info error", e3), n2;
            }
            if (r2) {
              var { data: a2 } = r2, o2 = "imageInfo" === s2 ? a2 : null === (t2 = null == a2 ? void 0 : a2.GetVideoInfo) || void 0 === t2 ? void 0 : t2.VideoInfo;
              return pickBy(Object.assign(Object.assign({}, n2), { w: null == o2 ? void 0 : o2.Width, h: null == o2 ? void 0 : o2.Height, orientation: null == o2 ? void 0 : o2.Orientation, dur: null == o2 ? void 0 : o2.Duration, audioCodec: null == o2 ? void 0 : o2.AudioCodec, videoCodec: null == o2 ? void 0 : o2.VideoCodec, container: null == o2 ? void 0 : o2.Container }), function(e3) {
                return void 0 !== e3;
              });
            }
            return this.core.logger.error("uploadFile:: fetch s3 file info no result", `${i2}?${s2}`), n2;
          });
        }
      }
      class CloudStorageService {
        constructor(e2, t2 = {}) {
          this.config = {}, this.uploadTaskMap = {}, this.name = "cloudStorage", this.logger = e2.logger, this.core = e2, this.nos = new NOS(e2, this), this.mixStorage = new MixStorage(e2, this), this.aws = new AWS(e2, this), registerParser({ cmdMap: Qr, cmdConfig: Zr }), this.setOptions(t2), this.setListeners();
        }
        setOptions(e2 = {}) {
          var t2 = e2.storageKeyPrefix || "NIMClient";
          this.mixStorage.GRAYKEY = t2 + "-AllGrayscaleConfig", this.mixStorage.MIXSTOREKEY = t2 + "-AllMixStorePolicy";
          var { s3: r2 } = e2, i2 = __rest(e2, ["s3"]), s2 = Object.assign({}, Jr, this.config);
          if (i2 && Object.prototype.hasOwnProperty.call(i2, "cdn")) {
            var n2 = Object.assign(Object.assign({}, s2.cdn), i2.cdn);
            this.config = Object.assign({}, s2, i2), this.config.cdn = n2;
          } else
            this.config = Object.assign({}, s2, i2);
          r2 && (this.aws.s3 = r2);
        }
        setListeners() {
          this.core.eventBus.on("kicked", this._clearUnCompleteTask.bind(this)), this.core.eventBus.on("disconnect", this._clearUnCompleteTask.bind(this)), this.core.eventBus.on("V2NIMLoginService/loginLifeCycleLogout", this._clearUnCompleteTask.bind(this)), this.core.eventBus.on("V2NIMLoginService/loginLifeCycleKicked", this._clearUnCompleteTask.bind(this));
        }
        _clearUnCompleteTask() {
          Object.keys(this.uploadTaskMap).forEach((e2) => {
            var t2 = this.uploadTaskMap[e2];
            t2 && t2.abort && t2.abort();
          }), this.uploadTaskMap = {};
        }
        init(e2 = Date.now()) {
          return __awaiter(this, void 0, void 0, function* () {
            this.mixStorage.reset(), this.nos.reset(), this.config.isNeedToGetUploadPolicyFromServer && (yield this.mixStorage.getGrayscaleConfig(this.core.options.appkey, e2)), yield this.nos._getNosCdnHost();
          });
        }
        processCallback(e2, t2) {
          var r2 = e2.onUploadProgress, i2 = e2.onUploadDone, s2 = e2.onUploadStart;
          return { onUploadStart: "function" == typeof s2 ? (e3) => {
            this.uploadTaskMap[t2] = e3;
            try {
              s2(e3);
            } catch (e4) {
              this.logger.error("CloudStorage::uploadFile:options.onUploadStart execute error", e4);
            }
          } : (e3) => {
            this.uploadTaskMap[t2] = e3;
          }, onUploadProgress: "function" == typeof r2 ? (e3) => {
            this.core.reporterHookCloudStorage.update({ transferred_size: e3.loaded, full_size: e3.total });
            try {
              r2(e3);
            } catch (e4) {
              this.logger.error("CloudStorage::uploadFile:options.onUploadProgress execute error", e4);
            }
          } : (e3) => {
            this.core.reporterHookCloudStorage.update({ transferred_size: e3.loaded, full_size: e3.total });
          }, onUploadDone: "function" == typeof i2 ? (e3) => {
            this.core.reporterHookCloudStorage.end(0);
            try {
              i2(e3);
            } catch (e4) {
              this.logger.error("CloudStorage::uploadFile:options.onUploadDone execute error", e4);
            }
          } : () => {
            this.core.reporterHookCloudStorage.end(0);
          }, taskKey: t2 };
        }
        uploadFile(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            if (validate({ maxSize: { type: "number", required: false }, type: { type: "enum", values: ["file", "image", "audio", "video"] } }, e2), !e2.fileInput && !e2.file && !e2.filePath)
              throw new Error("uploadFile needs target file object or a filePath");
            if (e2.type && "file" !== e2.type) {
              var t2 = get(e2, "file.type");
              if (t2 && "string" == typeof t2 && -1 === t2.indexOf(e2.type))
                throw new Error(`The meta type "${t2}" does not match "${e2.type}"`);
            }
            if (this.core.reporterHookCloudStorage.start(), e2.file)
              this.core.reporterHookCloudStorage.update({ full_size: e2.file.size });
            else if ("string" == typeof e2.fileInput) {
              var r2 = document.getElementById(e2.fileInput);
              r2 && r2.files && r2.files[0] && this.core.reporterHookCloudStorage.update({ full_size: r2.files[0].size });
            } else
              e2.fileInput && e2.fileInput.files && e2.fileInput.files[0] && this.core.reporterHookCloudStorage.update({ full_size: e2.fileInput.files[0].size });
            var i2 = Ie(), { onUploadStart: s2, onUploadProgress: n2, onUploadDone: a2 } = this.processCallback(e2, i2);
            e2.onUploadStart = s2, e2.onUploadProgress = n2, e2.onUploadDone = a2;
            var o2 = null;
            try {
              o2 = yield this._uploadFile(e2), e2.md5 && (o2.md5 = e2.md5), delete this.uploadTaskMap[i2];
            } catch (e3) {
              throw delete this.uploadTaskMap[i2], this.core.reporterHookCloudStorage.end((e3 && e3.code) === ce.V2NIM_ERROR_CODE_CANCELLED ? 3 : 1), e3;
            }
            return o2 && (o2.size = void 0 === o2.size ? void 0 : Number(o2.size), o2.w = void 0 === o2.w ? void 0 : Number(o2.w), o2.h = void 0 === o2.h ? void 0 : Number(o2.h), o2.dur = void 0 === o2.dur ? void 0 : Number(o2.dur)), o2.url = decodeURIComponent(o2.url), e2.onUploadDone({ size: o2.size, name: o2.name, url: o2.url, ext: o2.name.split(".")[1] || "unknown" }), o2;
          });
        }
        _uploadFile(e2) {
          var t2, r2;
          return __awaiter(this, void 0, void 0, function* () {
            if (!get(this.mixStorage, "grayConfig.mixStoreEnable") || !get(this.mixStorage, "mixStorePolicy.providers.length"))
              return this.logger.log("uploadFile:: uploadFile begin, use old nos"), this.nos.nosUpload(e2);
            this.logger.log(`uploadFile::_uploadFile, grayConfig enable:${get(this.mixStorage, "grayConfig.mixStoreEnable")} curProvider:${get(this.mixStorage, "curProvider")}`);
            var i2 = this.core.adapters.getFileUploadInformation(e2), s2 = true;
            i2 ? false === i2.complete && 2 === this.mixStorage.curProvider && (s2 = false) : s2 = false, this.aws.s3 || (this.mixStorage.curProvider = 1);
            var n2 = Yr;
            if (!s2)
              try {
                n2 = (yield this.core.sendCmd("getMixStoreToken", { mixStoreTokenReqTag: { provider: this.mixStorage.curProvider, tokenCount: 1, tag: "qchat", nosSurvivalTime: e2.nosSurvivalTime, returnBody: getUploadResponseFormat(e2.type), policyVersion: this.mixStorage.mixStorePolicy.policyVersion } })).content.mixStoreTokenResTag;
              } catch (e3) {
                if (this.core.logger.error("uploadFile:: getMixStoreToken error", e3), e3 instanceof V2NIMErrorImpl)
                  throw e3;
                throw new UploadError({ code: "v2" === get(this.core, "options.apiVersion") ? ce.V2NIM_ERROR_CODE_FILE_UPLOAD_FAILED : 400, detail: { reason: "getMixStoreToken error", rawError: e3, curProvider: this.mixStorage.curProvider, mixStorePolicy: this.mixStorage.mixStorePolicy } });
              }
            return s2 ? this.nos.nosUpload(e2, null === (r2 = null === (t2 = null == i2 ? void 0 : i2.uploadInfo) || void 0 === t2 ? void 0 : t2.payload) || void 0 === r2 ? void 0 : r2.mixStoreToken) : 2 === this.mixStorage.curProvider ? this.aws.s3Upload(e2, n2) : this.nos.nosUpload(e2, n2);
          });
        }
        getThumbUrl(e2, t2) {
          var r2, i2, s2, n2, a2;
          if (!new RegExp(/http(s)?:\/\/([\w-]+\.)+[\w-]+(\/[\w- ./?%&=]*)?/).test(e2))
            return this.logger.error("illegal file url:" + e2), e2;
          var [o2, c2, d2, l2, m2, p2, u2, h2] = /^(?:([A-Za-z]+):)?(\/{0,3})([0-9.\-A-Za-z]+)(?::(\d+))?(?:\/([^?#]*))?(?:\?([^#]*))?(?:#(.*))?$/.exec(e2);
          if (null === (r2 = this.grayConfig) || void 0 === r2 ? void 0 : r2.mixStoreEnable) {
            var g2 = this._getUrlType(e2);
            if (2 === g2 && this.mixStorePolicy.s3Policy && get(this.mixStorePolicy, "s3Policy.thumbPolicy.imagethumb"))
              return (null === (s2 = null === (i2 = this.mixStorePolicy.s3Policy) || void 0 === i2 ? void 0 : i2.thumbPolicy) || void 0 === s2 ? void 0 : s2.imagethumb).replace("{cdnDomain}", this.mixStorePolicy.s3Policy.dlcdn).replace("{objectName}", p2).replace("{x}", t2.width.toString()).replace("{y}", t2.height.toString());
            if (1 === g2 && this.mixStorePolicy.nosPolicy && get(this.mixStorePolicy, "nosPolicy.thumbPolicy.imagethumb"))
              return (null === (a2 = null === (n2 = this.mixStorePolicy.nosPolicy) || void 0 === n2 ? void 0 : n2.thumbPolicy) || void 0 === a2 ? void 0 : a2.imagethumb).replace("{cdnDomain}", this.mixStorePolicy.nosPolicy.dlcdn).replace("{objectName}", p2).replace("{x}", t2.width.toString()).replace("{y}", t2.height.toString());
          }
          return e2.includes("?") ? e2 + `&imageView&thumbnail=${t2.width}x${t2.height}` : e2 + `?imageView&thumbnail=${t2.width}x${t2.height}`;
        }
        getVideoCoverUrl(e2, t2) {
          var r2, i2, s2, n2, a2;
          if (!new RegExp(/http(s)?:\/\/([\w-]+\.)+[\w-]+(\/[\w- ./?%&=]*)?/).test(e2))
            return this.logger.error("illegal file url:" + e2), e2;
          var [o2, c2, d2, l2, m2, p2, u2, h2] = /^(?:([A-Za-z]+):)?(\/{0,3})([0-9.\-A-Za-z]+)(?::(\d+))?(?:\/([^?#]*))?(?:\?([^#]*))?(?:#(.*))?$/.exec(e2);
          if (null === (r2 = this.grayConfig) || void 0 === r2 ? void 0 : r2.mixStoreEnable) {
            var g2 = this._getUrlType(e2);
            if (2 === g2 && this.mixStorePolicy.s3Policy && get(this.mixStorePolicy, "s3Policy.thumbPolicy.vframe"))
              return (null === (s2 = null === (i2 = this.mixStorePolicy.s3Policy) || void 0 === i2 ? void 0 : i2.thumbPolicy) || void 0 === s2 ? void 0 : s2.vframe).replace("{cdnDomain}", this.mixStorePolicy.s3Policy.dlcdn).replace("{objectName}", p2).replace("{x}", t2.width.toString()).replace("{y}", t2.height.toString()).replace("{offset}", "0").replace("{type}", "png");
            if (1 === g2 && this.mixStorePolicy.nosPolicy && get(this.mixStorePolicy, "nosPolicy.thumbPolicy.vframe"))
              return (null === (a2 = null === (n2 = this.mixStorePolicy.nosPolicy) || void 0 === n2 ? void 0 : n2.thumbPolicy) || void 0 === a2 ? void 0 : a2.vframe).replace("{cdnDomain}", this.mixStorePolicy.nosPolicy.dlcdn).replace("{objectName}", p2).replace("{x}", t2.width.toString()).replace("{y}", t2.height.toString()).replace("{offset}", "0").replace("{type}", "png");
          }
          return e2.includes("?") ? e2 + `&vframe&offset=0&resize=${t2.width}x${t2.height}&type=png` : e2 + `?vframe&offset=0&resize=${t2.width}x${t2.height}&type=png`;
        }
        getPrivateUrl(e2) {
          var t2;
          if (!new RegExp(/http(s)?:\/\/([\w-]+\.)+[\w-]+(\/[\w- ./?%&=]*)?/).test(e2))
            return this.logger.error("illegal file url:" + e2), "";
          var [r2, i2, s2, n2, a2, o2, c2, d2] = /^(?:([A-Za-z]+):)?(\/{0,3})([0-9.\-A-Za-z]+)(?::(\d+))?(?:\/([^?#]*))?(?:\?([^#]*))?(?:#(.*))?$/.exec(e2);
          if (null === (t2 = this.grayConfig) || void 0 === t2 ? void 0 : t2.mixStoreEnable) {
            var l2 = this._getUrlType(e2);
            return 2 === l2 && this.mixStorePolicy.s3Policy && (e2 = this.mixStorePolicy.s3Policy.cdnSchema.replace("{cdnDomain}", this.mixStorePolicy.s3Policy.dlcdn).replace("{objectName}", o2)), 1 === l2 && this.mixStorePolicy.nosPolicy && (e2 = this.mixStorePolicy.nosPolicy.cdnSchema.replace("{cdnDomain}", this.mixStorePolicy.nosPolicy.dlcdn).replace("{objectName}", o2)), e2;
          }
          var { downloadUrl: m2, downloadHostList: p2, nosCdnEnable: u2 } = this.config, h2 = this.config.cdn.cdnDomain, g2 = this.config.cdn.objectNamePrefix ? decodeURIComponent(this.config.cdn.objectNamePrefix) : "", v2 = decodeURIComponent(o2), y2 = v2.indexOf(g2);
          if (h2 && y2 > -1 && u2)
            return `${i2}${h2}/${v2.slice(y2)}`;
          if (p2.includes(n2) && o2.includes("/")) {
            var f2 = o2.indexOf("/"), I2 = o2.substring(0, f2), M2 = o2.substring(f2 + 1);
            return m2.replace("{bucket}", I2).replace("{object}", M2);
          }
          var S2 = p2.filter((e3) => "string" == typeof n2 && n2.includes(e3))[0], T2 = S2 ? n2.replace(S2, "").replace(/\W/g, "") : null;
          return T2 ? m2.replace("{bucket}", T2).replace("{object}", o2) : e2;
        }
        getOriginUrl(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return "string" == typeof e2 && e2.includes("_im_url=1") ? (yield this.core.sendCmd("getOriginUrl", { nosSafeUrlTag: { safeUrl: e2 } })).content.nosSafeUrlTag.originUrl : e2;
          });
        }
        getFileToken(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ type: { type: "number", min: 2, max: 3 }, urls: { type: "array", required: false, itemType: "string" } }, e2);
            var t2 = this.mixStorePolicy.nosPolicy ? this.mixStorePolicy.nosPolicy.authPolicy.policyType : null, r2 = this.mixStorePolicy.s3Policy ? this.mixStorePolicy.s3Policy.authPolicy.policyType : null;
            if (t2 === String(-1) && r2 === String(-1))
              throw this.logger.error("don't need token"), new Error("don't need token");
            if (2 === e2.type) {
              if (t2 && t2.indexOf(String(2)) >= 0 || r2 && r2.indexOf(String(2)) > 0)
                return this.mixStorage.getFileAuthToken(e2);
              throw this.logger.error("don't support time token "), new Error("don't support type time token ");
            }
            if (!e2.urls || !e2.urls.length)
              throw this.logger.error("urls is required when urls token"), new Error("urls is required when urls token");
            var i2 = [], s2 = [];
            if (e2.urls.forEach((e3) => {
              var t3 = this._getUrlType(e3);
              1 === t3 && s2.push(e3), 2 === t3 && i2.push(e3);
            }), (!r2 || 0 !== i2.length && r2.indexOf(String(3)) < 0) && (this.logger.warn("s3 url don't support url token"), i2 = []), (!t2 || 0 !== s2.length && t2.indexOf(String(3)) < 0) && (this.logger.warn("nos url don't support url token"), s2 = []), 0 === i2.length && 0 === s2.length)
              throw this.logger.error("not support urls"), new Error("not support urls");
            if (0 === i2.length || 0 === s2.length)
              return e2.urls = JSON.stringify(e2.urls), this.mixStorage.getFileAuthToken(e2);
          });
        }
        _getUrlType(e2) {
          return this.mixStorePolicy.nosPolicy && this.mixStorePolicy.nosPolicy.dlcdns.some((t2) => e2.indexOf(t2) >= 0) ? 1 : this.mixStorePolicy.s3Policy && this.mixStorePolicy.s3Policy.dlcdns.some((t2) => e2.indexOf(t2) >= 0) ? 2 : null;
        }
        getNosAccessToken(e2) {
          return validate({ url: { type: "string", allowEmpty: false } }, e2), this.nos.getNosAccessToken(e2);
        }
        deleteNosAccessToken(e2) {
          return validate({ token: { type: "string", allowEmpty: false } }, e2), this.nos.deleteNosAccessToken(e2);
        }
        get grayConfig() {
          return this.mixStorage.grayConfig;
        }
        get mixStorePolicy() {
          return this.mixStorage.mixStorePolicy;
        }
        process(e2) {
          var t2 = get(e2, "error.detail.ignore");
          return e2.error && !t2 ? Promise.reject(e2.error) : Promise.resolve(e2);
        }
      }
      var ti = invert({ none: 0, normal: 1, all: 3 }), ri = invert({ normal: 0, advanced: 1 }), ii = invert({ normal: 0, owner: 1, manager: 2 }), si = { noVerify: 0, needVerify: 1, rejectAll: 2 }, ni = invert(si), ai = { needVerify: 0, noVerify: 1 }, oi = invert(ai), ci = { manager: 0, all: 1 }, di = invert(ci), li = { manager: 0, all: 1 }, mi = invert(li), pi = { manager: 0, all: 1 }, ui = invert(pi);
      function formatSuperTeam(e2) {
        var t2 = { type: ri, muteType: ti, joinMode: ni, beInviteMode: oi, inviteMode: di, updateTeamMode: mi, updateExtMode: ui }, r2 = __rest(e2, ["bits"]);
        return ["teamId"].forEach((e3) => {
          r2[e3] && (r2[e3] = r2[e3].toString());
        }), ["level", "memberNum", "memberUpdateTime", "createTime", "updateTime"].forEach((e3) => {
          void 0 !== r2[e3] && (r2[e3] = parseInt(r2[e3]));
        }), ["valid", "validToCurrentUser", "mute"].forEach((e3) => {
          void 0 !== r2[e3] && (r2[e3] = 1 === parseInt(r2[e3]));
        }), Object.keys(t2).forEach((e3) => {
          void 0 !== r2[e3] && (r2[e3] = t2[e3][r2[e3]] || r2[e3]);
        }), r2;
      }
      function formatSuperTeams(e2) {
        return e2 && e2.length > 0 ? e2.map((e3) => formatSuperTeam(e3)) : [];
      }
      function generatorSuperTeamMemberForCmd(e2) {
        var t2 = {};
        return void 0 !== e2.bitConfigMask && (t2.bits = parseInt(e2.bitConfigMask)), ["teamId", "ext", "account", "nickInTeam"].forEach((r2) => {
          e2[r2] && (t2[r2] = e2[r2].toString());
        }), Object.prototype.hasOwnProperty.call(e2, "nickInTeam") && (t2.nickInTeam = e2.nickInTeam), t2;
      }
      function formatSuperTeamMember(e2) {
        var t2 = { type: ii }, { bits: r2 } = e2, i2 = __rest(e2, ["bits"]);
        return void 0 !== r2 && (i2.muteTeam = 1 === parseInt(r2), i2.bitConfigMask = r2), i2.id = `${i2.teamId}-${i2.account}`, ["teamId"].forEach((e3) => {
          i2[e3] && (i2[e3] = i2[e3].toString());
        }), ["joinTime", "updateTime", "bitConfigMask"].forEach((e3) => {
          void 0 !== i2[e3] && (i2[e3] = parseInt(i2[e3]));
        }), ["active", "valid", "mute"].forEach((e3) => {
          void 0 !== i2[e3] && (i2[e3] = 1 === parseInt(i2[e3]));
        }), Object.keys(t2).forEach((e3) => {
          void 0 !== i2[e3] && (i2[e3] = t2[e3][i2[e3]] || i2[e3]);
        }), i2;
      }
      function formatSuperTeamMembers(e2) {
        return e2 && e2.length > 0 ? e2.map((e3) => formatSuperTeamMember(e3)) : [];
      }
      function generatorMemberBySuperTeam(e2, t2, r2 = "normal") {
        return { id: `${e2.teamId}-${t2}`, teamId: e2.teamId, account: t2, type: r2, nickInTeam: "", muteTeam: false, mute: false, joinTime: e2.memberUpdateTime, updateTime: e2.memberUpdateTime, active: true, valid: true };
      }
      function generatorMembersBySuperTeam(e2, t2, r2 = "normal") {
        return t2 && t2.length > 0 ? t2.map((t3) => generatorMemberBySuperTeam(e2, t3, r2)) : [];
      }
      class ModuleService {
        constructor(e2) {
          this.core = e2;
        }
        notifyAddSuperTeamMembers(e2, t2) {
          this.core.emit("addSuperTeamMembers", { team: e2, accounts: t2, members: generatorMembersBySuperTeam(e2, t2) });
        }
        notifyUpdateSuperTeamManagers(e2, t2, r2, i2) {
          this.core.emit("updateSuperTeamManagers", { team: { teamId: e2, memberUpdateTime: i2 }, accounts: t2, isManager: r2, members: t2.map((t3) => ({ id: `${e2}-${t3}`, type: r2 ? "manager" : "normal", account: t3, updateTime: i2 })) });
        }
        notifyRemoveSuperTeamMembers(e2, t2) {
          this.core.emit("removeSuperTeamMembers", { team: e2, accounts: t2 });
        }
        notifyTransferSuperTeam(e2, t2, r2) {
          this.core.emit("transferSuperTeam", { team: e2, from: { id: `${e2.teamId}-${t2}`, account: t2, type: "normal", updateTime: e2.memberUpdateTime }, to: { id: `${e2.teamId}-${r2}`, account: r2, type: "owner", updateTime: e2.memberUpdateTime } });
        }
        notifyUpdateSuperTeamMembersMute(e2, t2, r2) {
          this.core.emit("updateSuperTeamMembersMute", { team: e2, accounts: t2, members: t2.map(function(t3) {
            return { id: `${e2.teamId}-${t3}`, account: t3, teamId: e2.teamId, mute: r2, updateTime: e2.memberUpdateTime };
          }), mute: r2 });
        }
      }
      var hi = { "21_5": "addSuperTeamMembers", "21_6": "removeSuperTeamMembers", "21_7": "leaveSuperTeam", "21_8": "updateSuperTeamInfo", "21_9": "getSuperTeamInfo", "21_12": "getSuperTeams", "21_15": "getSuperTeamMembers", "21_10": "updateMySuperTeamMemberInfo", "21_20": "applySuperTeam", "21_21": "passSuperTeamApply", "21_22": "rejectSuperTeamApply", "21_23": "acceptSuperTeamInvite", "21_24": "rejectSuperTeamInvite", "21_26": "addSuperTeamManagers", "21_27": "removeSuperTeamManagers", "21_28": "muteSuperTeam", "21_29": "muteSuperTeamMembers", "21_30": "updateSuperTeamMemberNick", "21_31": "transferSuperTeam", "21_33": "getSuperTeamMembersByAccounts", "21_34": "queryMuteSuperTeamMembers", "21_101": "syncCreateSuperTeam", "21_109": "syncSuperTeams", "21_110": "syncUpdateSuperTeamMember", "21_111": "syncMySuperTeamMembers" }, gi = { superTeam: { teamId: 1, name: 3, type: 4, owner: 5, level: 6, selfCustom: 7, valid: 8, memberNum: 9, memberUpdateTime: 10, createTime: 11, updateTime: 12, validToCurrentUser: 13, intro: 14, announcement: 15, joinMode: 16, bits: 17, ext: 18, serverExt: 19, avatar: 20, beInviteMode: 21, inviteMode: 22, updateTeamMode: 23, updateExtMode: 24, mute: 100, muteType: 101 }, superTeamMember: { teamId: 1, account: 3, type: 4, nickInTeam: 5, bits: 7, active: 8, valid: 9, updateTime: 11, ext: 12, mute: 13, invitorAccid: 14, joinTime: 15 } }, vi = invertSerializeMap(gi), yi = { getSuperTeamInfo: { sid: 21, cid: 9, service: "superTeam", params: [{ type: "Long", name: "teamId" }], response: [{ type: "Property", name: "superTeam", reflectMapper: vi.superTeam }] }, getSuperTeams: { sid: 21, cid: 12, service: "superTeam", params: [{ type: "Long", name: "timetag" }], response: [{ type: "PropertyArray", name: "superTeams", reflectMapper: vi.superTeam }, { type: "Bool", name: "isAll" }, { type: "Long", name: "timetag" }] }, updateSuperTeamInfo: { sid: 21, cid: 8, service: "superTeam", params: [{ type: "Property", name: "superTeam", reflectMapper: gi.superTeam }], response: [{ type: "Long", name: "time" }] }, addSuperTeamMembers: { sid: 21, cid: 5, service: "superTeam", params: [{ type: "Long", name: "teamId" }, { type: "StrArray", name: "accounts" }, { type: "String", name: "ps" }], response: [{ type: "StrArray", name: "abortedAccidList" }, { type: "Long", name: "time" }] }, removeSuperTeamMembers: { sid: 21, cid: 6, service: "superTeam", params: [{ type: "Long", name: "teamId" }, { type: "StrArray", name: "accounts" }] }, addSuperTeamManagers: { sid: 21, cid: 26, service: "superTeam", params: [{ type: "Long", name: "teamId" }, { type: "StrArray", name: "accounts" }] }, removeSuperTeamManagers: { sid: 21, cid: 27, service: "superTeam", params: [{ type: "Long", name: "teamId" }, { type: "StrArray", name: "accounts" }] }, applySuperTeam: { sid: 21, cid: 20, service: "superTeam", params: [{ type: "Long", name: "teamId" }, { type: "String", name: "ps" }], response: [{ type: "Property", name: "superTeam", reflectMapper: vi.superTeam }] }, transferSuperTeam: { sid: 21, cid: 31, service: "superTeam", params: [{ type: "Long", name: "teamId" }, { type: "String", name: "account" }, { type: "Bool", name: "leave" }] }, muteSuperTeam: { sid: 21, cid: 28, service: "superTeam", params: [{ type: "Long", name: "teamId" }, { type: "Int", name: "mute" }] }, muteSuperTeamMembers: { sid: 21, cid: 29, service: "superTeam", params: [{ type: "Long", name: "teamId" }, { type: "StrArray", name: "accounts" }, { type: "Int", name: "mute" }] }, updateSuperTeamMemberNick: { sid: 21, cid: 30, service: "superTeam", params: [{ type: "Property", name: "teamMember", reflectMapper: gi.superTeamMember }] }, updateMySuperTeamMemberInfo: { sid: 21, cid: 10, service: "superTeam", params: [{ type: "Property", name: "teamMember", reflectMapper: gi.superTeamMember }] }, getSuperTeamMembersByAccounts: { sid: 21, cid: 33, service: "superTeam", params: [{ type: "StrArray", name: "memberIds" }], response: [{ type: "PropertyArray", name: "superTeamMembers", reflectMapper: vi.superTeamMember }] }, getSuperTeamMembers: { sid: 21, cid: 15, service: "superTeam", params: [{ type: "Long", name: "teamId" }, { type: "Long", name: "joinTime" }, { type: "Int", name: "limit" }, { type: "Bool", name: "reverse" }], response: [{ type: "PropertyArray", name: "superTeamMembers", reflectMapper: vi.superTeamMember }] }, queryMuteSuperTeamMembers: { sid: 21, cid: 34, service: "superTeam", params: [{ type: "Long", name: "teamId" }, { type: "Long", name: "joinTime" }, { type: "Int", name: "limit" }, { type: "Bool", name: "reverse" }], response: [{ type: "PropertyArray", name: "superTeamMembers", reflectMapper: vi.superTeamMember }] }, leaveSuperTeam: { sid: 21, cid: 7, service: "superTeam", params: [{ type: "Long", name: "teamId" }] }, passSuperTeamApply: { sid: 21, cid: 21, service: "superTeam", params: [{ type: "Long", name: "teamId" }, { type: "String", name: "from" }] }, rejectSuperTeamApply: { sid: 21, cid: 22, service: "superTeam", params: [{ type: "Long", name: "teamId" }, { type: "String", name: "from" }, { type: "String", name: "ps" }] }, acceptSuperTeamInvite: { sid: 21, cid: 23, service: "superTeam", params: [{ type: "Long", name: "teamId" }, { type: "String", name: "from" }] }, rejectSuperTeamInvite: { sid: 21, cid: 24, service: "superTeam", params: [{ type: "Long", name: "teamId" }, { type: "String", name: "from" }, { type: "String", name: "ps" }] }, syncSuperTeams: { sid: 21, cid: 109, service: "superTeam", response: [{ type: "PropertyArray", name: "teams", reflectMapper: vi.superTeam }, { type: "Bool", name: "isAll" }, { type: "Long", name: "timetag" }] }, syncCreateSuperTeam: { sid: 21, cid: 101, service: "superTeam", response: [{ type: "Property", name: "superTeam", reflectMapper: vi.superTeam }] }, syncUpdateSuperTeamMember: { sid: 21, cid: 110, service: "superTeam", response: [{ type: "Property", name: "teamMember", reflectMapper: vi.superTeamMember }] }, syncMySuperTeamMembers: { sid: 21, cid: 111, ext: "sync", service: "superTeam", response: [{ type: "PropertyArray", name: "teamMembers", reflectMapper: vi.superTeamMember }, { type: "Long", name: "timetag" }] } };
      var fi = { "13_1": "getChatroomAddress", "24_1": "getQChatAddress" }, Ii = { getChatroomAddress: { sid: 13, cid: 1, service: "plugin", params: [{ type: "Long", name: "chatroomId" }, { type: "Bool", name: "isWeixinApp" }, { type: "Int", name: "ipType" }], response: [{ type: "StrArray", name: "address" }] }, getQChatAddress: { sid: 24, cid: 1, service: "plugin", params: [{ type: "Property", name: "getQChatAddressTag", reflectMapper: { ipType: 1 } }], response: [{ type: "StrArray", name: "address" }] } };
      var Mi = Mi || function(e2) {
        var t2;
        "undefined" != typeof window && window.crypto && (t2 = window.crypto), "undefined" != typeof self && self.crypto && (t2 = self.crypto), "undefined" != typeof globalThis && globalThis.crypto && (t2 = globalThis.crypto), !t2 && "undefined" != typeof window && window.msCrypto && (t2 = window.msCrypto), !t2 && "undefined" != typeof global && global.crypto && (t2 = global.crypto);
        var cryptoSecureRandomInt = function() {
          if (t2) {
            if ("function" == typeof t2.getRandomValues)
              try {
                return t2.getRandomValues(new Uint32Array(1))[0];
              } catch (e3) {
              }
            if ("function" == typeof t2.randomBytes)
              try {
                return t2.randomBytes(4).readInt32LE();
              } catch (e3) {
              }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        }, r2 = Object.create || /* @__PURE__ */ function() {
          function F() {
          }
          return function(e3) {
            var t3;
            return F.prototype = e3, t3 = new F(), F.prototype = null, t3;
          };
        }(), i2 = {}, s2 = i2.lib = {}, n2 = s2.Base = { extend: function(e3) {
          var t3 = r2(this);
          return e3 && t3.mixIn(e3), t3.hasOwnProperty("init") && this.init !== t3.init || (t3.init = function() {
            t3.$super.init.apply(this, arguments);
          }), t3.init.prototype = t3, t3.$super = this, t3;
        }, create: function() {
          var e3 = this.extend();
          return e3.init.apply(e3, arguments), e3;
        }, init: function() {
        }, mixIn: function(e3) {
          for (var t3 in e3)
            e3.hasOwnProperty(t3) && (this[t3] = e3[t3]);
          e3.hasOwnProperty("toString") && (this.toString = e3.toString);
        }, clone: function() {
          return this.init.prototype.extend(this);
        } }, a2 = s2.WordArray = n2.extend({ init: function(e3, t3) {
          e3 = this.words = e3 || [], this.sigBytes = null != t3 ? t3 : 4 * e3.length;
        }, toString: function(e3) {
          return (e3 || c2).stringify(this);
        }, concat: function(e3) {
          var t3 = this.words, r3 = e3.words, i3 = this.sigBytes, s3 = e3.sigBytes;
          if (this.clamp(), i3 % 4)
            for (var n3 = 0; n3 < s3; n3++) {
              var a3 = r3[n3 >>> 2] >>> 24 - n3 % 4 * 8 & 255;
              t3[i3 + n3 >>> 2] |= a3 << 24 - (i3 + n3) % 4 * 8;
            }
          else
            for (var o3 = 0; o3 < s3; o3 += 4)
              t3[i3 + o3 >>> 2] = r3[o3 >>> 2];
          return this.sigBytes += s3, this;
        }, clamp: function() {
          var t3 = this.words, r3 = this.sigBytes;
          t3[r3 >>> 2] &= 4294967295 << 32 - r3 % 4 * 8, t3.length = e2.ceil(r3 / 4);
        }, clone: function() {
          var e3 = n2.clone.call(this);
          return e3.words = this.words.slice(0), e3;
        }, random: function(e3) {
          for (var t3 = [], r3 = 0; r3 < e3; r3 += 4)
            t3.push(cryptoSecureRandomInt());
          return new a2.init(t3, e3);
        } }), o2 = i2.enc = {}, c2 = o2.Hex = { stringify: function(e3) {
          for (var t3 = e3.words, r3 = e3.sigBytes, i3 = [], s3 = 0; s3 < r3; s3++) {
            var n3 = t3[s3 >>> 2] >>> 24 - s3 % 4 * 8 & 255;
            i3.push((n3 >>> 4).toString(16)), i3.push((15 & n3).toString(16));
          }
          return i3.join("");
        }, parse: function(e3) {
          for (var t3 = e3.length, r3 = [], i3 = 0; i3 < t3; i3 += 2)
            r3[i3 >>> 3] |= parseInt(e3.substr(i3, 2), 16) << 24 - i3 % 8 * 4;
          return new a2.init(r3, t3 / 2);
        } }, d2 = o2.Latin1 = { stringify: function(e3) {
          for (var t3 = e3.words, r3 = e3.sigBytes, i3 = [], s3 = 0; s3 < r3; s3++) {
            var n3 = t3[s3 >>> 2] >>> 24 - s3 % 4 * 8 & 255;
            i3.push(String.fromCharCode(n3));
          }
          return i3.join("");
        }, parse: function(e3) {
          for (var t3 = e3.length, r3 = [], i3 = 0; i3 < t3; i3++)
            r3[i3 >>> 2] |= (255 & e3.charCodeAt(i3)) << 24 - i3 % 4 * 8;
          return new a2.init(r3, t3);
        } }, l2 = o2.Utf8 = { stringify: function(e3) {
          try {
            return decodeURIComponent(escape(d2.stringify(e3)));
          } catch (e4) {
            throw new Error("Malformed UTF-8 data");
          }
        }, parse: function(e3) {
          return d2.parse(unescape(encodeURIComponent(e3)));
        } }, m2 = s2.BufferedBlockAlgorithm = n2.extend({ reset: function() {
          this._data = new a2.init(), this._nDataBytes = 0;
        }, _append: function(e3) {
          "string" == typeof e3 && (e3 = l2.parse(e3)), this._data.concat(e3), this._nDataBytes += e3.sigBytes;
        }, _process: function(t3) {
          var r3, i3 = this._data, s3 = i3.words, n3 = i3.sigBytes, o3 = this.blockSize, c3 = n3 / (4 * o3), d3 = (c3 = t3 ? e2.ceil(c3) : e2.max((0 | c3) - this._minBufferSize, 0)) * o3, l3 = e2.min(4 * d3, n3);
          if (d3) {
            for (var m3 = 0; m3 < d3; m3 += o3)
              this._doProcessBlock(s3, m3);
            r3 = s3.splice(0, d3), i3.sigBytes -= l3;
          }
          return new a2.init(r3, l3);
        }, clone: function() {
          var e3 = n2.clone.call(this);
          return e3._data = this._data.clone(), e3;
        }, _minBufferSize: 0 });
        s2.Hasher = m2.extend({ cfg: n2.extend(), init: function(e3) {
          this.cfg = this.cfg.extend(e3), this.reset();
        }, reset: function() {
          m2.reset.call(this), this._doReset();
        }, update: function(e3) {
          return this._append(e3), this._process(), this;
        }, finalize: function(e3) {
          return e3 && this._append(e3), this._doFinalize();
        }, blockSize: 16, _createHelper: function(e3) {
          return function(t3, r3) {
            return new e3.init(r3).finalize(t3);
          };
        }, _createHmacHelper: function(e3) {
          return function(t3, r3) {
            return new p2.HMAC.init(e3, r3).finalize(t3);
          };
        } });
        var p2 = i2.algo = {};
        return i2;
      }(Math), Si = Mi.enc.Utf8, Ti = Mi, _i = Ti.lib, Ci = _i.Base, Ei = _i.WordArray, bi = Ti.algo, Ri = bi.MD5, Ni = bi.EvpKDF = Ci.extend({ cfg: Ci.extend({ keySize: 4, hasher: Ri, iterations: 1 }), init: function(e2) {
        this.cfg = this.cfg.extend(e2);
      }, compute: function(e2, t2) {
        for (var r2, i2 = this.cfg, s2 = i2.hasher.create(), n2 = Ei.create(), a2 = n2.words, o2 = i2.keySize, c2 = i2.iterations; a2.length < o2; ) {
          r2 && s2.update(r2), r2 = s2.update(e2).finalize(t2), s2.reset();
          for (var d2 = 1; d2 < c2; d2++)
            r2 = s2.finalize(r2), s2.reset();
          n2.concat(r2);
        }
        return n2.sigBytes = 4 * o2, n2;
      } });
      Ti.EvpKDF = function(e2, t2, r2) {
        return Ni.create(r2).compute(e2, t2);
      }, Mi.EvpKDF;
      var Ai = Mi, Oi = Ai.lib.WordArray;
      Ai.enc.Base64 = { stringify: function(e2) {
        var t2 = e2.words, r2 = e2.sigBytes, i2 = this._map;
        e2.clamp();
        for (var s2 = [], n2 = 0; n2 < r2; n2 += 3)
          for (var a2 = (t2[n2 >>> 2] >>> 24 - n2 % 4 * 8 & 255) << 16 | (t2[n2 + 1 >>> 2] >>> 24 - (n2 + 1) % 4 * 8 & 255) << 8 | t2[n2 + 2 >>> 2] >>> 24 - (n2 + 2) % 4 * 8 & 255, o2 = 0; o2 < 4 && n2 + 0.75 * o2 < r2; o2++)
            s2.push(i2.charAt(a2 >>> 6 * (3 - o2) & 63));
        var c2 = i2.charAt(64);
        if (c2)
          for (; s2.length % 4; )
            s2.push(c2);
        return s2.join("");
      }, parse: function(e2) {
        var t2 = e2.length, r2 = this._map, i2 = this._reverseMap;
        if (!i2) {
          i2 = this._reverseMap = [];
          for (var s2 = 0; s2 < r2.length; s2++)
            i2[r2.charCodeAt(s2)] = s2;
        }
        var n2 = r2.charAt(64);
        if (n2) {
          var a2 = e2.indexOf(n2);
          -1 !== a2 && (t2 = a2);
        }
        return function parseLoop(e3, t3, r3) {
          for (var i3 = [], s3 = 0, n3 = 0; n3 < t3; n3++)
            if (n3 % 4) {
              var a3 = r3[e3.charCodeAt(n3 - 1)] << n3 % 4 * 2 | r3[e3.charCodeAt(n3)] >>> 6 - n3 % 4 * 2;
              i3[s3 >>> 2] |= a3 << 24 - s3 % 4 * 8, s3++;
            }
          return Oi.create(i3, s3);
        }(e2, t2, i2);
      }, _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=" }, Mi.enc.Base64, function(e2) {
        e2.lib.Cipher || function() {
          var t2 = e2, r2 = t2.lib, i2 = r2.Base, s2 = r2.WordArray, n2 = r2.BufferedBlockAlgorithm, a2 = t2.enc;
          a2.Utf8;
          var o2 = a2.Base64, c2 = t2.algo.EvpKDF, d2 = r2.Cipher = n2.extend({ cfg: i2.extend(), createEncryptor: function(e3, t3) {
            return this.create(this._ENC_XFORM_MODE, e3, t3);
          }, createDecryptor: function(e3, t3) {
            return this.create(this._DEC_XFORM_MODE, e3, t3);
          }, init: function(e3, t3, r3) {
            this.cfg = this.cfg.extend(r3), this._xformMode = e3, this._key = t3, this.reset();
          }, reset: function() {
            n2.reset.call(this), this._doReset();
          }, process: function(e3) {
            return this._append(e3), this._process();
          }, finalize: function(e3) {
            return e3 && this._append(e3), this._doFinalize();
          }, keySize: 4, ivSize: 4, _ENC_XFORM_MODE: 1, _DEC_XFORM_MODE: 2, _createHelper: /* @__PURE__ */ function() {
            function selectCipherStrategy(e3) {
              return "string" == typeof e3 ? f2 : v2;
            }
            return function(e3) {
              return { encrypt: function(t3, r3, i3) {
                return selectCipherStrategy(r3).encrypt(e3, t3, r3, i3);
              }, decrypt: function(t3, r3, i3) {
                return selectCipherStrategy(r3).decrypt(e3, t3, r3, i3);
              } };
            };
          }() });
          r2.StreamCipher = d2.extend({ _doFinalize: function() {
            return this._process(true);
          }, blockSize: 1 });
          var l2 = t2.mode = {}, m2 = r2.BlockCipherMode = i2.extend({ createEncryptor: function(e3, t3) {
            return this.Encryptor.create(e3, t3);
          }, createDecryptor: function(e3, t3) {
            return this.Decryptor.create(e3, t3);
          }, init: function(e3, t3) {
            this._cipher = e3, this._iv = t3;
          } }), p2 = l2.CBC = function() {
            var e3 = m2.extend();
            function xorBlock(e4, t3, r3) {
              var i3, s3 = this._iv;
              s3 ? (i3 = s3, this._iv = void 0) : i3 = this._prevBlock;
              for (var n3 = 0; n3 < r3; n3++)
                e4[t3 + n3] ^= i3[n3];
            }
            return e3.Encryptor = e3.extend({ processBlock: function(e4, t3) {
              var r3 = this._cipher, i3 = r3.blockSize;
              xorBlock.call(this, e4, t3, i3), r3.encryptBlock(e4, t3), this._prevBlock = e4.slice(t3, t3 + i3);
            } }), e3.Decryptor = e3.extend({ processBlock: function(e4, t3) {
              var r3 = this._cipher, i3 = r3.blockSize, s3 = e4.slice(t3, t3 + i3);
              r3.decryptBlock(e4, t3), xorBlock.call(this, e4, t3, i3), this._prevBlock = s3;
            } }), e3;
          }(), u2 = (t2.pad = {}).Pkcs7 = { pad: function(e3, t3) {
            for (var r3 = 4 * t3, i3 = r3 - e3.sigBytes % r3, n3 = i3 << 24 | i3 << 16 | i3 << 8 | i3, a3 = [], o3 = 0; o3 < i3; o3 += 4)
              a3.push(n3);
            var c3 = s2.create(a3, i3);
            e3.concat(c3);
          }, unpad: function(e3) {
            var t3 = 255 & e3.words[e3.sigBytes - 1 >>> 2];
            e3.sigBytes -= t3;
          } };
          r2.BlockCipher = d2.extend({ cfg: d2.cfg.extend({ mode: p2, padding: u2 }), reset: function() {
            var e3;
            d2.reset.call(this);
            var t3 = this.cfg, r3 = t3.iv, i3 = t3.mode;
            this._xformMode == this._ENC_XFORM_MODE ? e3 = i3.createEncryptor : (e3 = i3.createDecryptor, this._minBufferSize = 1), this._mode && this._mode.__creator == e3 ? this._mode.init(this, r3 && r3.words) : (this._mode = e3.call(i3, this, r3 && r3.words), this._mode.__creator = e3);
          }, _doProcessBlock: function(e3, t3) {
            this._mode.processBlock(e3, t3);
          }, _doFinalize: function() {
            var e3, t3 = this.cfg.padding;
            return this._xformMode == this._ENC_XFORM_MODE ? (t3.pad(this._data, this.blockSize), e3 = this._process(true)) : (e3 = this._process(true), t3.unpad(e3)), e3;
          }, blockSize: 4 });
          var h2 = r2.CipherParams = i2.extend({ init: function(e3) {
            this.mixIn(e3);
          }, toString: function(e3) {
            return (e3 || this.formatter).stringify(this);
          } }), g2 = (t2.format = {}).OpenSSL = { stringify: function(e3) {
            var t3 = e3.ciphertext, r3 = e3.salt;
            return (r3 ? s2.create([1398893684, 1701076831]).concat(r3).concat(t3) : t3).toString(o2);
          }, parse: function(e3) {
            var t3, r3 = o2.parse(e3), i3 = r3.words;
            return 1398893684 == i3[0] && 1701076831 == i3[1] && (t3 = s2.create(i3.slice(2, 4)), i3.splice(0, 4), r3.sigBytes -= 16), h2.create({ ciphertext: r3, salt: t3 });
          } }, v2 = r2.SerializableCipher = i2.extend({ cfg: i2.extend({ format: g2 }), encrypt: function(e3, t3, r3, i3) {
            i3 = this.cfg.extend(i3);
            var s3 = e3.createEncryptor(r3, i3), n3 = s3.finalize(t3), a3 = s3.cfg;
            return h2.create({ ciphertext: n3, key: r3, iv: a3.iv, algorithm: e3, mode: a3.mode, padding: a3.padding, blockSize: e3.blockSize, formatter: i3.format });
          }, decrypt: function(e3, t3, r3, i3) {
            return i3 = this.cfg.extend(i3), t3 = this._parse(t3, i3.format), e3.createDecryptor(r3, i3).finalize(t3.ciphertext);
          }, _parse: function(e3, t3) {
            return "string" == typeof e3 ? t3.parse(e3, this) : e3;
          } }), y2 = (t2.kdf = {}).OpenSSL = { execute: function(e3, t3, r3, i3) {
            i3 || (i3 = s2.random(8));
            var n3 = c2.create({ keySize: t3 + r3 }).compute(e3, i3), a3 = s2.create(n3.words.slice(t3), 4 * r3);
            return n3.sigBytes = 4 * t3, h2.create({ key: n3, iv: a3, salt: i3 });
          } }, f2 = r2.PasswordBasedCipher = v2.extend({ cfg: v2.cfg.extend({ kdf: y2 }), encrypt: function(e3, t3, r3, i3) {
            var s3 = (i3 = this.cfg.extend(i3)).kdf.execute(r3, e3.keySize, e3.ivSize);
            i3.iv = s3.iv;
            var n3 = v2.encrypt.call(this, e3, t3, s3.key, i3);
            return n3.mixIn(s3), n3;
          }, decrypt: function(e3, t3, r3, i3) {
            i3 = this.cfg.extend(i3), t3 = this._parse(t3, i3.format);
            var s3 = i3.kdf.execute(r3, e3.keySize, e3.ivSize, t3.salt);
            return i3.iv = s3.iv, v2.decrypt.call(this, e3, t3, s3.key, i3);
          } });
        }();
      }(Mi);
      var ki = Mi, wi = ki.lib.StreamCipher, Pi = ki.algo, Vi = Pi.RC4 = wi.extend({ _doReset: function() {
        for (var e2 = this._key, t2 = e2.words, r2 = e2.sigBytes, i2 = this._S = [], s2 = 0; s2 < 256; s2++)
          i2[s2] = s2;
        s2 = 0;
        for (var n2 = 0; s2 < 256; s2++) {
          var a2 = s2 % r2, o2 = t2[a2 >>> 2] >>> 24 - a2 % 4 * 8 & 255;
          n2 = (n2 + i2[s2] + o2) % 256;
          var c2 = i2[s2];
          i2[s2] = i2[n2], i2[n2] = c2;
        }
        this._i = this._j = 0;
      }, _doProcessBlock: function(e2, t2) {
        e2[t2] ^= generateKeystreamWord.call(this);
      }, keySize: 8, ivSize: 0 });
      function generateKeystreamWord() {
        for (var e2 = this._S, t2 = this._i, r2 = this._j, i2 = 0, s2 = 0; s2 < 4; s2++) {
          r2 = (r2 + e2[t2 = (t2 + 1) % 256]) % 256;
          var n2 = e2[t2];
          e2[t2] = e2[r2], e2[r2] = n2, i2 |= e2[(e2[t2] + e2[r2]) % 256] << 24 - 8 * s2;
        }
        return this._i = t2, this._j = r2, i2;
      }
      ki.RC4 = wi._createHelper(Vi);
      var Li = Pi.RC4Drop = Vi.extend({ cfg: Vi.cfg.extend({ drop: 192 }), _doReset: function() {
        Vi._doReset.call(this);
        for (var e2 = this.cfg.drop; e2 > 0; e2--)
          generateKeystreamWord.call(this);
      } });
      ki.RC4Drop = wi._createHelper(Li);
      var Ui = Mi.RC4, Di = { "3_1": "updatePushToken", "3_2": "updateAppBackground" }, qi = { updatePushToken: { sid: 3, cid: 1, service: "user", params: [{ type: "String", name: "tokenName" }, { type: "String", name: "token" }, { type: "Int", name: "pushkit" }] }, updateAppBackground: { sid: 3, cid: 2, service: "user", params: [{ type: "Bool", name: "isBackground" }, { type: "Int", name: "badge" }] } };
      var xi = { "7_19": "nimQueryCloudSessionList", "7_20": "nimQueryCloudSession", "7_21": "nimUpdateCloudSession", "7_22": "nimDeleteCloudSessionList", "7_121": "nimMultiSyncUpdateCloudSession" }, Bi = { sessionReqTag: { minTimestamp: 1, maxTimestamp: 2, includedLastMsg: 3, limit: 4, hasMore: 5 }, sessionTag: { sessionId: 1, updateTime: 2, ext: 3, lastMsg: 4, lastMsgType: 5 } }, Fi = invertSerializeMap(Bi), ji = { nimQueryCloudSessionList: { sid: 7, cid: 19, service: "cloudSession", params: [{ type: "Property", name: "tag", reflectMapper: Bi.sessionReqTag }], response: [{ type: "Property", name: "tag", reflectMapper: Fi.sessionReqTag }, { type: "PropertyArray", name: "sessions", reflectMapper: Fi.sessionTag }] }, nimQueryCloudSession: { sid: 7, cid: 20, service: "cloudSession", params: [{ type: "Property", name: "tag", reflectMapper: Bi.sessionTag }], response: [{ type: "Property", name: "session", reflectMapper: Fi.sessionTag }] }, nimUpdateCloudSession: { sid: 7, cid: 21, service: "cloudSession", params: [{ type: "Property", name: "tag", reflectMapper: Bi.sessionTag }] }, nimDeleteCloudSessionList: { sid: 7, cid: 22, service: "cloudSession", params: [{ type: "PropertyArray", name: "tags", reflectMapper: Bi.sessionTag }] }, nimMultiSyncUpdateCloudSession: { sid: 7, cid: 121, service: "cloudSession", response: [{ type: "Property", name: "session", reflectMapper: Fi.sessionTag }] } }, $i = { sessionId: { type: "string" }, updateTime: { type: "number" }, ext: { type: "string" }, lastMsg: { type: "object" }, lastMsgType: { type: "number" } };
      function formatCloudSession(e2, t2, r2) {
        var i2 = format($i, e2), { accid: s2, scene: n2 } = getAccountFromSessionId(i2.sessionId, "|");
        if (i2.sessionId = `${n2}-${s2}`, i2.lastMsg) {
          var a2 = 1 === i2.lastMsgType;
          i2.lastMsgInfo = a2 ? { isLastMsgRecalled: a2, revokedMsg: formatSystemMessage(deserialize(i2.lastMsg, Ir.sysMsg), r2) } : { isLastMsgRecalled: a2, lastMsg: formatMsg$1(deserialize(i2.lastMsg, ar.msg), { account: t2 }) };
        }
        return delete i2.lastMsg, delete i2.lastMsgType, i2;
      }
      function formatCloudSessions(e2, t2, r2) {
        return e2 && e2.length > 0 ? e2.map((e3) => formatCloudSession(e3, t2, r2)) : [];
      }
      var Gi = { needPush: { type: "boolean", required: false }, pushTitle: { type: "string", required: false }, pushContent: { type: "string", required: false }, pushPayload: { type: "string", required: false }, needPushBadge: { type: "boolean", required: false } }, Hi = { "15_1": "signalingCreate", "15_2": "signalingDelay", "15_3": "signalingClose", "15_4": "signalingJoin", "15_5": "signalingLeave", "15_6": "signalingInvite", "15_7": "signalingCancelInvite", "15_8": "signalingReject", "15_9": "signalingAccept", "15_10": "signalingSendCustomCommand", "15_11": "signalingRecvNotification", "15_12": "signalingMultiSyncNotification", "15_13": "signalingSyncNotification", "15_14": "singalingSyncChannels", "15_15": "signalingQueryInfo", "15_16": "signalingCallEx", "15_17": "signalingJoinAndAccept" }, zi = { avSignalTag: Object.assign({ type: 1, name: 2, channelId: 3, createTime: 4, expireTime: 5, creatorAccid: 6, ext: 7, invalid: 8, fromAccid: 10, toAccid: 11, requestId: 12, members: 18, attach: 19, attachExt: 20, needOffline: 21, msgId: 22, uid: 23, time: 24, nertcChannelName: 25, nertcTokenTtl: 26, nertcToken: 27, nertcJoinRoomQueryParamMap: 28, nertcJoinRoomResponse: 29, callStatus: 30 }, { needPush: 13, pushTitle: 14, pushContent: 15, pushPayload: 16, needPushBadge: 17 }) }, Wi = invertSerializeMap(zi), Ki = { signalingCreate: { sid: 15, cid: 1, service: "signaling", params: [{ type: "Property", name: "tag", reflectMapper: zi.avSignalTag }], response: [{ type: "Property", name: "data", reflectMapper: Wi.avSignalTag }] }, signalingDelay: { sid: 15, cid: 2, service: "signaling", params: [{ type: "Property", name: "tag", reflectMapper: zi.avSignalTag }], response: [{ type: "Property", name: "data", reflectMapper: Wi.avSignalTag }] }, signalingClose: { sid: 15, cid: 3, service: "signaling", params: [{ type: "Property", name: "tag", reflectMapper: zi.avSignalTag }], response: [{ type: "Property", name: "data", reflectMapper: Wi.avSignalTag }] }, signalingJoin: { sid: 15, cid: 4, service: "signaling", params: [{ type: "Property", name: "tag", reflectMapper: zi.avSignalTag }], response: [{ type: "Property", name: "data", reflectMapper: Wi.avSignalTag }] }, signalingLeave: { sid: 15, cid: 5, service: "signaling", params: [{ type: "Property", name: "tag", reflectMapper: zi.avSignalTag }] }, signalingInvite: { sid: 15, cid: 6, service: "signaling", params: [{ type: "Property", name: "tag", reflectMapper: zi.avSignalTag }] }, signalingCancelInvite: { sid: 15, cid: 7, service: "signaling", params: [{ type: "Property", name: "tag", reflectMapper: zi.avSignalTag }] }, signalingReject: { sid: 15, cid: 8, service: "signaling", params: [{ type: "Property", name: "tag", reflectMapper: zi.avSignalTag }] }, signalingAccept: { sid: 15, cid: 9, service: "signaling", params: [{ type: "Property", name: "tag", reflectMapper: zi.avSignalTag }] }, signalingSendCustomCommand: { sid: 15, cid: 10, service: "signaling", params: [{ type: "Property", name: "tag", reflectMapper: zi.avSignalTag }] }, signalingRecvNotification: { sid: 15, cid: 11, service: "signaling", response: [{ type: "Property", name: "data", reflectMapper: Wi.avSignalTag }] }, signalingMultiSyncNotification: { sid: 15, cid: 12, service: "signaling", response: [{ type: "Property", name: "data", reflectMapper: Wi.avSignalTag }] }, signalingSyncNotification: { sid: 15, cid: 13, service: "signaling", response: [{ type: "PropertyArray", name: "datas", reflectMapper: Wi.avSignalTag }] }, singalingSyncChannels: { sid: 15, cid: 14, service: "signaling", response: [{ type: "PropertyArray", name: "datas", reflectMapper: Wi.avSignalTag }] }, signalingQueryInfo: { sid: 15, cid: 15, service: "signaling", params: [{ type: "Property", name: "tag", reflectMapper: zi.avSignalTag }], response: [{ type: "Property", name: "data", reflectMapper: Wi.avSignalTag }] }, signalingCallEx: { sid: 15, cid: 16, service: "signaling", params: [{ type: "Property", name: "tag", reflectMapper: zi.avSignalTag }], response: [{ type: "Property", name: "data", reflectMapper: Wi.avSignalTag }] }, signalingJoinAndAccept: { sid: 15, cid: 17, service: "signaling", params: [{ type: "Property", name: "tag", reflectMapper: zi.avSignalTag }], response: [{ type: "Property", name: "data", reflectMapper: Wi.avSignalTag }] }, signalingBatchMarkRead: { sid: 4, cid: 5, hasPacketResponse: false, service: "signaling", params: [{ type: "Byte", name: "sid" }, { type: "Byte", name: "cid" }, { type: "LongArray", name: "ids" }] } }, Yi = { type: { type: "number" }, createTime: { type: "number" }, expireTime: { type: "number" }, invalid: { type: "boolean" }, pushInfo: Gi, pluginSetting: { nertcInfo: { nertcChannelName: { type: "string" }, nertcTokenTtl: { type: "number" }, nertcToken: { type: "string" }, nertcJoinRoomQueryParamMap: { type: "string" }, callStatus: { type: "number" } } }, callStatus: { type: "number" }, attach: { type: "object" }, members: { type: "object" }, needOffline: { type: "boolean" }, uid: { type: "number" }, time: { type: "number" } };
      function formatSignalingChannelMember(e2) {
        return format(Yi, deserialize(e2, { 1: "accid", 2: "uid", 3: "createTime", 4: "expireTime" }));
      }
      function formatSignaling(e2) {
        var t2 = format(Yi, e2), r2 = [];
        return t2.members && t2.members.length > 0 && (r2 = t2.members.map((e3) => formatSignalingChannelMember(e3)), delete t2.members), r2.length > 0 ? { channelInfo: t2, memberList: r2 } : { channelInfo: t2 };
      }
      function formatSignalingWithCallStatus(e2) {
        var t2 = format(Yi, e2), r2 = [];
        t2.members && t2.members.length > 0 && (r2 = t2.members.map((e3) => formatSignalingChannelMember(e3)), delete t2.members);
        var i2 = 200;
        return e2.callStatus && (i2 = Number(e2.callStatus)), r2.length > 0 ? { channelInfo: t2, memberList: r2, callStatus: i2 } : { channelInfo: t2, callStatus: i2 };
      }
      function generateSignalingForCmd(e2) {
        return formatReverse(Yi, e2);
      }
      class SignalingService extends se.EventEmitter {
        constructor(e2) {
          super(), this.timer = 0, this.pollingInterval = 12e4, this.name = "signaling", this.logger = e2.logger, this.core = e2, this.channels = {}, registerParser({ cmdMap: Hi, cmdConfig: Ki });
        }
        callEx(e2) {
          var t2;
          return __awaiter(this, void 0, void 0, function* () {
            validate({ type: { type: "number" }, toAccid: { type: "string", allowEmpty: false }, requestId: { type: "string", allowEmpty: false }, needOffline: { type: "boolean", required: false }, pushInfo: { type: "object", required: false, rules: Gi }, pluginSetting: { type: "object", required: false, rules: { nertcInfo: { type: "object", required: false } } } }, e2);
            var r2 = yield this.core.sendCmd("signalingCallEx", { tag: generateSignalingForCmd(e2) }), i2 = formatSignalingWithCallStatus((null === (t2 = r2.content) || void 0 === t2 ? void 0 : t2.data) || {});
            return this.channels[i2.channelInfo.channelId] = cloneDeep(i2.channelInfo), this.timer || (this.timer = this.core.timerManager.addTimer(this.aotoDelay.bind(this), this.pollingInterval, -1)), i2;
          });
        }
        joinAndAccept(e2) {
          var t2;
          return __awaiter(this, void 0, void 0, function* () {
            validate({ channelId: { type: "string", allowEmpty: false }, fromAccid: { type: "string", allowEmpty: false }, requestId: { type: "string", required: false }, needOffline: { type: "boolean", required: false }, uid: { type: "number", required: false }, pluginSetting: { type: "object", required: false, rules: { nertcInfo: { type: "object", required: false } } } }, e2);
            var { fromAccid: r2 } = e2, i2 = __rest(e2, ["fromAccid"]);
            i2.toAccid = r2;
            var s2 = yield this.core.sendCmd("signalingJoinAndAccept", { tag: generateSignalingForCmd(i2) }), n2 = formatSignalingWithCallStatus((null === (t2 = s2.content) || void 0 === t2 ? void 0 : t2.data) || {});
            return this.channels[n2.channelInfo.channelId] = cloneDeep(n2.channelInfo), this.timer || (this.timer = this.core.timerManager.addTimer(this.aotoDelay.bind(this), this.pollingInterval, -1)), n2;
          });
        }
        create(e2) {
          var t2;
          return __awaiter(this, void 0, void 0, function* () {
            validate({ type: { type: "number" }, ext: { type: "string", required: false } }, e2);
            var r2 = yield this.core.sendCmd("signalingCreate", { tag: generateSignalingForCmd(e2) });
            return formatSignaling((null === (t2 = r2.content) || void 0 === t2 ? void 0 : t2.data) || {});
          });
        }
        close(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ channelId: { type: "string", allowEmpty: false }, attachExt: { type: "string", required: false }, needOffline: { type: "boolean", required: false } }, e2), yield this.core.sendCmd("signalingClose", { tag: generateSignalingForCmd(e2) });
          });
        }
        queryInfo(e2) {
          var t2;
          return __awaiter(this, void 0, void 0, function* () {
            validate({ name: { type: "string", allowEmpty: false } }, e2);
            var r2 = yield this.core.sendCmd("signalingQueryInfo", { tag: e2 });
            return formatSignaling((null === (t2 = r2.content) || void 0 === t2 ? void 0 : t2.data) || {});
          });
        }
        join(e2) {
          var t2;
          return __awaiter(this, void 0, void 0, function* () {
            validate({ channelId: { type: "string", allowEmpty: false }, attachExt: { type: "string", required: false }, uid: { type: "number", min: 0, required: false }, needOffline: { type: "boolean", required: false } }, e2);
            var r2 = yield this.core.sendCmd("signalingJoin", { tag: generateSignalingForCmd(e2) }), i2 = formatSignaling((null === (t2 = r2.content) || void 0 === t2 ? void 0 : t2.data) || {});
            return this.channels[i2.channelInfo.channelId] = cloneDeep(i2.channelInfo), this.timer || (this.timer = this.core.timerManager.addTimer(this.aotoDelay.bind(this), this.pollingInterval, -1)), i2;
          });
        }
        aotoDelay() {
          return __awaiter(this, void 0, void 0, function* () {
            var e2 = Object.keys(this.channels);
            if (0 === e2.length)
              return this.timer && this.core.timerManager.deleteTimer(this.timer), void (this.timer = 0);
            this.logger.log("signling:autoDelay", e2);
            for (var t2 = 0; t2 < e2.length; t2++) {
              var r2 = e2[t2];
              try {
                var i2 = formatSignaling((yield this.core.sendCmd("signalingDelay", { tag: { channelId: r2 } })).content.data);
                this.channels[r2] = i2.channelInfo;
              } catch (e3) {
                this.logger.warn(`signling:autoDelay ${r2} failed`, e3), delete this.channels[r2];
              }
            }
          });
        }
        leave(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ channelId: { type: "string", allowEmpty: false }, attachExt: { type: "string", required: false }, needOffline: { type: "boolean", required: false } }, e2), yield this.core.sendCmd("signalingLeave", { tag: generateSignalingForCmd(e2) }), delete this.channels[e2.channelId];
          });
        }
        invite(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ channelId: { type: "string", allowEmpty: false }, toAccid: { type: "string", allowEmpty: false }, requestId: { type: "string", allowEmpty: false }, attachExt: { type: "string", required: false }, needOffline: { type: "boolean", required: false }, pushInfo: { type: "object", required: false, rules: Gi } }, e2), yield this.core.sendCmd("signalingInvite", { tag: generateSignalingForCmd(e2) });
          });
        }
        cancelInvite(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ channelId: { type: "string", allowEmpty: false }, toAccid: { type: "string", allowEmpty: false }, requestId: { type: "string", allowEmpty: false }, attachExt: { type: "string", required: false }, needOffline: { type: "boolean", required: false } }, e2), yield this.core.sendCmd("signalingCancelInvite", { tag: generateSignalingForCmd(e2) });
          });
        }
        reject(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ channelId: { type: "string", allowEmpty: false }, fromAccid: { type: "string", allowEmpty: false }, requestId: { type: "string", allowEmpty: false }, attachExt: { type: "string", required: false }, needOffline: { type: "boolean", required: false } }, e2);
            var { fromAccid: t2 } = e2, r2 = __rest(e2, ["fromAccid"]);
            r2.toAccid = t2, yield this.core.sendCmd("signalingReject", { tag: generateSignalingForCmd(r2) });
          });
        }
        accept(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ channelId: { type: "string", allowEmpty: false }, fromAccid: { type: "string", allowEmpty: false }, requestId: { type: "string", allowEmpty: false }, attachExt: { type: "string", required: false }, needOffline: { type: "boolean", required: false }, autoJoin: { type: "boolean", required: false }, uid: { type: "number", min: 0, required: false }, joinAttachExt: { type: "string", required: false } }, e2);
            var { autoJoin: t2, joinAttachExt: r2, fromAccid: i2 } = e2, s2 = __rest(e2, ["autoJoin", "joinAttachExt", "fromAccid"]);
            if (s2.toAccid = i2, yield this.core.sendCmd("signalingAccept", { tag: generateSignalingForCmd(s2) }), this.logger.log(`Signaling:accept, accept success, autoJoin ${e2.autoJoin}`), t2) {
              var n2 = { channelId: e2.channelId, needOffline: e2.needOffline, attachExt: r2, uid: e2.uid };
              yield this.join(n2);
            }
          });
        }
        sendCustomCommand(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ channelId: { type: "string", allowEmpty: false }, fromAccid: { type: "string", allowEmpty: false, required: false }, attachExt: { type: "string", required: false } }, e2), yield this.core.sendCmd("signalingSendCustomCommand", { tag: generateSignalingForCmd(e2) });
          });
        }
        signalingRecvNotificationHandler(e2) {
          var t2 = fillIdServer(e2, e2.content.data, "msgId", "0"), r2 = t2.msgId;
          this.doNotify(t2), r2 && parseInt(r2) && this.core.sendCmd("signalingBatchMarkRead", { sid: 15, cid: 11, ids: [r2] });
        }
        signalingMultiSyncNotificationHandler(e2) {
          this.doNotify(e2.content.data, 3);
        }
        doNotify(e2, t2 = 0) {
          var { metaData: r2, rawData: i2 } = function formatSignalingNotification(e3, t3 = 0) {
            var r3 = format(Yi, e3), { attach: i3, attachExt: s3, time: n3, msgId: a3, fromAccid: o3, toAccid: c3, members: d3, requestId: l2, pushInfo: m2 } = r3, p2 = __rest(r3, ["attach", "attachExt", "time", "msgId", "fromAccid", "toAccid", "members", "requestId", "pushInfo"]);
            if (2 === i3.type)
              try {
                r3.member = { accid: r3.attach.member[1], uid: Number(r3.attach.member[2]), createTime: Number(r3.attach.member[3]), expireTime: Number(r3.attach.member[4]) };
              } catch (e4) {
                delete r3.member;
              }
            var u2 = i3.type;
            return delete r3.attach, { metaData: { eventType: u2, channelInfo: p2, feature: t3, ext: s3 || "", time: n3, msgId: a3 }, rawData: r3 };
          }(e2, t2), { fromAccid: s2, toAccid: n2, requestId: a2, pushInfo: o2, msgId: c2, member: d2 } = i2;
          switch (r2.eventType) {
            case 1:
              this.emit("signalingClose", { fromAccid: s2, metaData: r2 });
              break;
            case 2:
              this.emit("signalingJoin", { fromAccid: s2, metaData: r2, member: d2 });
              break;
            case 3:
              this.emit("signalingInvite", { fromAccid: s2, toAccid: n2, requestId: a2, pushInfo: o2, metaData: r2 });
              break;
            case 4:
              this.emit("signalingCancelInvite", { fromAccid: s2, toAccid: n2, requestId: a2, metaData: r2 });
              break;
            case 5:
              this.emit("signalingReject", { fromAccid: s2, toAccid: n2, requestId: a2, metaData: r2 });
              break;
            case 6:
              this.emit("signalingAccept", { fromAccid: s2, toAccid: n2, requestId: a2, metaData: r2 });
              break;
            case 7:
              this.emit("signalingLeave", { fromAccid: s2, metaData: r2 });
              break;
            case 8:
              this.emit("signalingCustomCommand", { fromAccid: s2, metaData: r2 });
              break;
            default:
              this.logger.warn(`signaling:notification, no such a type ${r2.eventType}`, i2);
          }
          return c2;
        }
        signalingSyncNotificationHandler(e2) {
          if (e2.content.datas && e2.content.datas.length > 0) {
            var t2 = e2.content.datas.map((e3) => this.doNotify(e3, 1)).filter((e3) => e3);
            t2.length > 0 && this.core.sendCmd("signalingBatchMarkRead", { sid: 15, cid: 11, ids: t2 });
          }
        }
        singalingSyncChannelsHandler(e2) {
          if (this.timer = 0, this.channels = {}, e2.content.datas && e2.content.datas.length > 0) {
            var t2 = e2.content.datas.map((e3) => formatSignaling(e3));
            t2.forEach((e3) => {
              var t3 = e3.channelInfo.channelId;
              this.channels[t3] = cloneDeep(e3.channelInfo);
            }), this.emit("singalingSyncChannels", t2);
          }
        }
        process(e2) {
          var t2 = this[e2.cmd + "Handler"];
          if ("function" == typeof t2)
            return t2.call(this, e2), Promise.resolve(e2);
          var r2 = get(e2, "error.detail.ignore");
          return e2.error && !r2 ? Promise.reject(e2.error) : Promise.resolve(e2);
        }
      }
      class Service extends se {
        constructor(e2, t2) {
          super(), this.name = e2, this.core = t2, this.name = e2, this.logger = t2.logger, this.core = t2;
        }
        emit(e2, ...t2) {
          try {
            return super.emit(e2, ...t2);
          } catch (t3) {
            return setTimeout(() => {
              throw this.logger.error(`${this.name}::emit throw error in setTimeout. event: ${e2.toString()}. Error`, t3), t3;
            }, 0), false;
          }
        }
        process(e2) {
          var t2 = this[e2.cmd + "Handler"];
          if ("function" == typeof t2)
            return t2.call(this, e2);
          var r2 = get(e2, "error.detail.ignore");
          return e2.error && !r2 ? Promise.reject(e2.error) : Promise.resolve(e2);
        }
      }
      var Ji, Qi, Xi, Zi, es, ts, rs, is = { "24_15": "qchatSubscribe", "24_27": "qchatGetUnreadInfo", "24_48": "qchatCreateChannel", "24_49": "qchatDeleteChannel", "24_50": "qchatUpdateChannel", "24_51": "qchatGetChannels", "24_52": "qchatGetChannelsByPage", "24_53": "qchatGetMembersByPage", "24_54": "qchatUpdateWhiteBlackRole", "24_55": "qchatGetWhiteBlackRolesPage", "24_56": "qchatUpdateWhiteBlackMembers", "24_57": "qchatGetWhiteBlackMembersPage", "24_58": "qchatGetExistingWhiteBlackRoles", "24_59": "qchatGetExistingWhiteBlackMembers", "24_60": "qchatUpdateCategoryInfoOfChannel", "24_109": "qchatCreateChannelCategory", "24_110": "qchatRemoveChannelCategory", "24_111": "qchatUpdateChannelCategory", "24_112": "qchatGetChannelCategoriesByID", "24_113": "qchatUpdateChannelCategoryWhiteBlackRole", "24_114": "qchatGetChannelCategoryWhiteBlackRolesPage", "24_115": "qchatUpdateChannelCategoryWhiteBlackMembers", "24_116": "qchatGetChannelCategoryWhiteBlackMembersPage", "24_117": "qchatGetChannelCategoryWhiteBlackRoles", "24_118": "qchatGetChannelCategoryWhiteBlackMembers", "24_119": "qchatGetChannelCategoriesPage", "24_120": "qchatGetChannelCategoryChannelsPage", "24_93": "qchatGetChannelSearchByPage", "24_95": "qchatChannelMemberSearch", "25_8": "qchatGetRoleIdsByServerId", "25_9": "qchatSubscribeAsVisitor", "25_12": "qchatAutoSubscribe", "25_13": "qchatAutoSubscribeNotification" }, ss = { serverId: 1, channelId: 2, ackTimestamp: 3, unreadCount: 4, mentionedCount: 5, maxCount: 6, lastMsgTime: 7 }, ns = { channelInfo: { channelId: 1, serverId: 2, name: 4, topic: 5, ext: 6, type: 7, validFlag: 8, createTime: 9, updateTime: 10, owner: 11, viewMode: 12, categoryId: 13, syncMode: 14, reorderWeight: 15, visitorMode: 16 }, antispamTag: { antiSpamBusinessId: 1 }, memberInfo: { serverId: 1, accid: 3, nick: 4, avatar: 5, ext: 6, type: 7, joinTime: 8, inviter: 9, validFlag: 10, createTime: 11, updateTime: 12 }, serverRole: { serverId: 1, roleId: 2, name: 3, icon: 4, ext: 5, auths: 6, type: 7, memberCount: 8, priority: 9, createTime: 10, updateTime: 11 }, qchatSubReqTag: { type: 1, opeType: 2 }, qchatChannelIdInfoTag: { serverId: 1, channelId: 2 }, unreadInfo: ss, qchatGetChannelListPageTag: { serverId: 1, timetag: 2, limit: 3 }, qchatGetMembersByPageTag: { serverId: 1, channelId: 2, timetag: 3, limit: 4 }, qchatUpdateWhiteBlackRoleTag: { serverId: 1, channelId: 2, type: 3, opeType: 4, roleId: 5 }, qchatGetWhiteBlackRolesPageTag: { serverId: 1, channelId: 2, type: 3, timetag: 4, limit: 5 }, qchatUpdateWhiteBlackMembersTag: { serverId: 1, channelId: 2, type: 3, opeType: 4, toAccids: 5 }, qchatGetWhiteBlackMembersPageTag: { serverId: 1, channelId: 2, type: 3, timetag: 4, limit: 5 }, qchatGetExistingWhiteBlackRolesTag: { serverId: 1, channelId: 2, type: 3, roleIds: 4 }, qchatGetExistingWhiteBlackMembersTag: { serverId: 1, channelId: 2, type: 3, accids: 4 }, QChatChannelCategoryInfo: { categoryId: 1, serverId: 2, name: 4, ext: 5, owner: 6, viewMode: 7, validFlag: 8, createTime: 9, updateTime: 10, channelNumber: 11 }, qchatUpdateChannelCategoryWhiteBlackRoleTag: { serverId: 1, categoryId: 2, type: 3, opeType: 4, roleId: 5 }, qchatGetChannelCategoryWhiteBlackRolesPageTag: { serverId: 1, categoryId: 2, type: 3, timetag: 4, limit: 5 }, qchatUpdateChannelCategoryWhiteBlackMembersTag: { serverId: 1, categoryId: 2, type: 3, opeType: 4, toAccids: 5 }, qchatGetChannelCategoryWhiteBlackMembersPageTag: { serverId: 1, categoryId: 2, type: 3, timetag: 4, limit: 5 }, qchatGetChannelCategoryWhiteBlackRolesTag: { serverId: 1, categoryId: 2, type: 3, roleIds: 4 }, qchatGetChannelCategoryWhiteBlackMembersTag: { serverId: 1, categoryId: 2, type: 3, accids: 4 }, qchatGetChannelCategoriesPageTag: { serverId: 1, timetag: 2, limit: 3 }, qchatGetChannelCategoryChannelsPageTag: { serverId: 1, categoryId: 2, timetag: 3, limit: 4 }, qchatGetChannelSearchByPageTag: { keyword: 1, startTime: 2, endTime: 3, order: 4, limit: 5, serverId: 6, sort: 7, cursor: 8 }, qchatUpdateChannelTag: { channelId: 1, name: 4, topic: 5, ext: 6, viewMode: 12, visitorMode: 16 }, serverRoles: { serverId: 1, roleIds: 2, timeTag: 3 }, qchatChannelMemberSearchTag: { serverId: 1, channelId: 2, keyword: 3, limit: 4 }, qchatChannelMemberInfo: { serverId: 1, channelId: 2, avatar: 3, accid: 4, nick: 5, createTime: 6, updateTime: 7 } }, getDeserializeTag$4 = () => invertSerializeMap(ns), getCmdConfig$4 = () => {
        var e2 = getDeserializeTag$4();
        return { qchatCreateChannel: { sid: 24, cid: 48, service: "qchatChannel", params: [{ type: "Property", name: "channelInfo", reflectMapper: ns.channelInfo }, { type: "Property", name: "antispamTag", reflectMapper: ns.antispamTag }], response: [{ type: "Property", name: "channelInfo", reflectMapper: e2.channelInfo }] }, qchatDeleteChannel: { sid: 24, cid: 49, service: "qchatChannel", params: [{ type: "Long", name: "channelId" }] }, qchatUpdateChannel: { sid: 24, cid: 50, service: "qchatChannel", params: [{ type: "Property", name: "channelInfo", reflectMapper: ns.qchatUpdateChannelTag }, { type: "Property", name: "antispamTag", reflectMapper: ns.antispamTag }], response: [{ type: "Property", name: "channelInfo", reflectMapper: e2.channelInfo }] }, qchatGetChannels: { sid: 24, cid: 51, service: "qchatChannel", params: [{ type: "LongArray", name: "channelIds" }], response: [{ type: "PropertyArray", name: "channelList", reflectMapper: e2.channelInfo }] }, qchatGetChannelsByPage: { sid: 24, cid: 52, service: "qchatChannel", params: [{ type: "Property", name: "qchatGetChannelListPageTag", reflectMapper: ns.qchatGetChannelListPageTag }], response: [{ type: "Property", name: "listQueryTag", reflectMapper: { 1: "hasMore", 2: "nextTimetag" } }, { type: "PropertyArray", name: "datas", reflectMapper: e2.channelInfo }] }, qchatGetMembersByPage: { sid: 24, cid: 53, service: "qchatChannel", params: [{ type: "Property", name: "qchatGetMembersByPageTag", reflectMapper: ns.qchatGetMembersByPageTag }], response: [{ type: "Property", name: "listQueryTag", reflectMapper: { 1: "hasMore", 2: "nextTimetag" } }, { type: "PropertyArray", name: "datas", reflectMapper: e2.memberInfo }] }, qchatUpdateWhiteBlackRole: { sid: 24, cid: 54, service: "qchatChannel", params: [{ type: "Property", name: "qchatUpdateWhiteBlackRoleTag", reflectMapper: ns.qchatUpdateWhiteBlackRoleTag }] }, qchatGetWhiteBlackRolesPage: { sid: 24, cid: 55, service: "qchatChannel", params: [{ type: "Property", name: "qchatGetWhiteBlackRolesPageTag", reflectMapper: ns.qchatGetWhiteBlackRolesPageTag }], response: [{ type: "Property", name: "listQueryTag", reflectMapper: { 1: "hasMore", 2: "nextTimetag" } }, { type: "PropertyArray", name: "datas", reflectMapper: e2.serverRole }] }, qchatUpdateWhiteBlackMembers: { sid: 24, cid: 56, service: "qchatChannel", params: [{ type: "Property", name: "qchatUpdateWhiteBlackMembersTag", reflectMapper: ns.qchatUpdateWhiteBlackMembersTag }] }, qchatGetWhiteBlackMembersPage: { sid: 24, cid: 57, service: "qchatChannel", params: [{ type: "Property", name: "qchatGetWhiteBlackMembersPageTag", reflectMapper: ns.qchatGetWhiteBlackMembersPageTag }], response: [{ type: "Property", name: "listQueryTag", reflectMapper: { 1: "hasMore", 2: "nextTimetag" } }, { type: "PropertyArray", name: "datas", reflectMapper: e2.memberInfo }] }, qchatGetExistingWhiteBlackRoles: { sid: 24, cid: 58, service: "qchatChannel", params: [{ type: "Property", name: "qchatGetExistingWhiteBlackRolesTag", reflectMapper: ns.qchatGetExistingWhiteBlackRolesTag }], response: [{ type: "PropertyArray", name: "datas", reflectMapper: e2.serverRole }] }, qchatGetExistingWhiteBlackMembers: { sid: 24, cid: 59, service: "qchatChannel", params: [{ type: "Property", name: "qchatGetExistingWhiteBlackMembersTag", reflectMapper: ns.qchatGetExistingWhiteBlackMembersTag }], response: [{ type: "PropertyArray", name: "datas", reflectMapper: e2.memberInfo }] }, qchatUpdateCategoryInfoOfChannel: { sid: 24, cid: 60, service: "qchatChannel", params: [{ type: "Property", name: "qchatUpdateCategoryInfoOfChannelTag", reflectMapper: ns.channelInfo }], response: [{ type: "Property", name: "channelInfo", reflectMapper: e2.channelInfo }] }, qchatCreateChannelCategory: { sid: 24, cid: 109, service: "qchatChannel", params: [{ type: "Property", name: "qchatCreateChannelCategoryTag", reflectMapper: ns.QChatChannelCategoryInfo }], response: [{ type: "Property", name: "QChatChannelCategoryInfo", reflectMapper: e2.QChatChannelCategoryInfo }] }, qchatRemoveChannelCategory: { sid: 24, cid: 110, service: "qchatChannel", params: [{ type: "Long", name: "categoryId" }] }, qchatUpdateChannelCategory: { sid: 24, cid: 111, service: "qchatChannel", params: [{ type: "Property", name: "qchatUpdateChannelCategoryTag", reflectMapper: ns.QChatChannelCategoryInfo }], response: [{ type: "Property", name: "QChatChannelCategoryInfo", reflectMapper: e2.QChatChannelCategoryInfo }] }, qchatGetChannelCategoriesByID: { sid: 24, cid: 112, service: "qchatChannel", params: [{ type: "LongArray", name: "categoryIds" }], response: [{ type: "PropertyArray", name: "channelCategoryList", reflectMapper: e2.QChatChannelCategoryInfo }] }, qchatUpdateChannelCategoryWhiteBlackRole: { sid: 24, cid: 113, service: "qchatChannel", params: [{ type: "Property", name: "qchatUpdateChannelCategoryWhiteBlackRoleTag", reflectMapper: ns.qchatUpdateChannelCategoryWhiteBlackRoleTag }] }, qchatGetChannelCategoryWhiteBlackRolesPage: { sid: 24, cid: 114, service: "qchatChannel", params: [{ type: "Property", name: "qchatGetChannelCategoryWhiteBlackRolesPageTag", reflectMapper: ns.qchatGetChannelCategoryWhiteBlackRolesPageTag }], response: [{ type: "Property", name: "listQueryTag", reflectMapper: { 1: "hasMore", 2: "nextTimetag" } }, { type: "PropertyArray", name: "datas", reflectMapper: e2.serverRole }] }, qchatUpdateChannelCategoryWhiteBlackMembers: { sid: 24, cid: 115, service: "qchatChannel", params: [{ type: "Property", name: "qchatUpdateChannelCategoryWhiteBlackMembersTag", reflectMapper: ns.qchatUpdateChannelCategoryWhiteBlackMembersTag }] }, qchatGetChannelCategoryWhiteBlackMembersPage: { sid: 24, cid: 116, service: "qchatChannel", params: [{ type: "Property", name: "qchatGetChannelCategoryWhiteBlackMembersPageTag", reflectMapper: ns.qchatGetChannelCategoryWhiteBlackMembersPageTag }], response: [{ type: "Property", name: "listQueryTag", reflectMapper: { 1: "hasMore", 2: "nextTimetag" } }, { type: "PropertyArray", name: "datas", reflectMapper: e2.memberInfo }] }, qchatGetChannelCategoryWhiteBlackRoles: { sid: 24, cid: 117, service: "qchatChannel", params: [{ type: "Property", name: "qchatGetChannelCategoryWhiteBlackRolesTag", reflectMapper: ns.qchatGetChannelCategoryWhiteBlackRolesTag }], response: [{ type: "PropertyArray", name: "datas", reflectMapper: e2.serverRole }] }, qchatGetChannelCategoryWhiteBlackMembers: { sid: 24, cid: 118, service: "qchatChannel", params: [{ type: "Property", name: "qchatGetChannelCategoryWhiteBlackMembersTag", reflectMapper: ns.qchatGetChannelCategoryWhiteBlackMembersTag }], response: [{ type: "PropertyArray", name: "datas", reflectMapper: e2.memberInfo }] }, qchatGetChannelCategoriesPage: { sid: 24, cid: 119, service: "qchatChannel", params: [{ type: "Property", name: "qchatGetChannelCategoriesPageTag", reflectMapper: ns.qchatGetChannelCategoriesPageTag }], response: [{ type: "Property", name: "listQueryTag", reflectMapper: { 1: "hasMore", 2: "nextTimetag" } }, { type: "PropertyArray", name: "datas", reflectMapper: e2.QChatChannelCategoryInfo }] }, qchatGetChannelCategoryChannelsPage: { sid: 24, cid: 120, service: "qchatChannel", params: [{ type: "Property", name: "qchatGetChannelCategoryChannelsPageTag", reflectMapper: ns.qchatGetChannelCategoryChannelsPageTag }], response: [{ type: "Property", name: "listQueryTag", reflectMapper: { 1: "hasMore", 2: "nextTimetag" } }, { type: "PropertyArray", name: "datas", reflectMapper: e2.channelInfo }] }, qchatSubscribe: { sid: 24, cid: 15, service: "qchatChannel", params: [{ type: "Property", name: "qchatSubReqTag", reflectMapper: ns.qchatSubReqTag }, { type: "PropertyArray", name: "channels", reflectMapper: ns.qchatChannelIdInfoTag }], response: [{ type: "PropertyArray", name: "unreadInfos", reflectMapper: e2.unreadInfo }, { type: "PropertyArray", name: "failedChannels", reflectMapper: e2.qchatChannelIdInfoTag }] }, qchatAutoSubscribe: { sid: 25, cid: 12, service: "qchatChannel", hasPacketTimer: false, params: [{ type: "Property", name: "qchatAutoSubReqTag" }], response: [{ type: "Property", name: "qchatAutoSubInfo", reflectMapper: { 1: "time" } }] }, qchatAutoSubscribeNotification: { service: "qchatChannel", sid: 25, cid: 13, response: [{ type: "PropertyArray", name: "serverIds", reflectMapper: e2.unreadInfo }, { type: "PropertyArray", name: "unreadInfos", reflectMapper: e2.unreadInfo }] }, qchatGetUnreadInfo: { sid: 24, cid: 27, service: "qchatChannel", params: [{ type: "PropertyArray", name: "channels", reflectMapper: ns.qchatChannelIdInfoTag }], response: [{ type: "PropertyArray", name: "unreadInfos", reflectMapper: e2.unreadInfo }] }, qchatGetChannelSearchByPage: { sid: 24, cid: 93, service: "qchatChannel", params: [{ type: "Property", name: "qchatGetChannelSearchByPageTag", reflectMapper: ns.qchatGetChannelSearchByPageTag }], response: [{ type: "Property", name: "listQueryTag", reflectMapper: { 1: "hasMore", 2: "nextTimetag", 3: "cursor" } }, { type: "PropertyArray", name: "datas", reflectMapper: e2.channelInfo }] }, qchatGetRoleIdsByServerId: { sid: 25, cid: 8, service: "qchatChannel", params: [{ type: "Property", name: "qchatGetRoleIdsByServerIdTag", reflectMapper: { serverIdTimeTags: 1 } }], response: [{ type: "PropertyArray", name: "serverRoles", reflectMapper: e2.serverRoles }, { type: "String", name: "failServerIds" }] }, qchatChannelMemberSearch: { sid: 24, cid: 95, service: "qchatChannel", params: [{ type: "Property", name: "qchatChannelMemberSearchTag", reflectMapper: ns.qchatChannelMemberSearchTag }], response: [{ type: "PropertyArray", name: "datas", reflectMapper: e2.qchatChannelMemberInfo }] }, qchatSubscribeAsVisitor: { sid: 25, cid: 9, service: "qchatChannel", params: [{ type: "Property", name: "tag", reflectMapper: ns.qchatSubReqTag }, { type: "PropertyArray", name: "datas", reflectMapper: ns.qchatChannelIdInfoTag }], response: [{ type: "PropertyArray", name: "failedArr", reflectMapper: e2.qchatChannelIdInfoTag }] } };
      };
      !function(e2) {
        e2[e2.reorderWeight = 0] = "reorderWeight", e2[e2.createTime = 1] = "createTime";
      }(Ji || (Ji = {})), function(e2) {
        e2[e2.white = 1] = "white", e2[e2.black = 2] = "black";
      }(Qi || (Qi = {})), function(e2) {
        e2[e2.add = 1] = "add", e2[e2.remove = 2] = "remove";
      }(Xi || (Xi = {})), function(e2) {
        e2[e2.message = 0] = "message", e2[e2.media = 1] = "media", e2[e2.ext = 100] = "ext";
      }(Zi || (Zi = {})), function(e2) {
        e2[e2.ASC = 1] = "ASC", e2[e2.DESC = 2] = "DESC";
      }(es || (es = {})), function(e2) {
        e2[e2.reorderWeight = 0] = "reorderWeight", e2[e2.createTime = 1] = "createTime", e2[e2.totalMember = 2] = "totalMember";
      }(ts || (ts = {})), function(e2) {
        e2[e2.square = 1] = "square", e2[e2.person = 2] = "person";
      }(rs || (rs = {}));
      var as = { channelId: { type: "string" }, serverId: { type: "string" }, name: { type: "string" }, topic: { type: "string" }, ext: { type: "string" }, type: { type: "enum", values: Zi }, validFlag: { type: "boolean" }, createTime: { type: "number" }, updateTime: { type: "number" }, viewMode: { type: "number" }, categoryId: { type: "string" }, syncMode: { type: "number" }, visitorMode: { type: "number" }, reorderWeight: { type: "string" } }, os = { serverId: { type: "string" }, channelId: { type: "string" }, ackTimestamp: { type: "number" }, unreadCount: { type: "number" }, mentionedCount: { type: "number" }, maxCount: { type: "number" }, lastMsgTime: { type: "number" } }, cs = { serverId: { type: "string" }, channelId: { type: "string" }, type: { type: "enum", values: Qi }, opeType: { type: "enum", values: Xi }, toAccids: { type: "object" } }, ds = { serverId: { type: "string" }, channelId: { type: "string" }, type: { type: "enum", values: Qi }, opeType: { type: "enum", values: Xi }, roleId: { type: "string" } }, ls = { categoryId: { type: "string" }, serverId: { type: "string" }, name: { type: "string" }, ext: { type: "string" }, owner: { type: "string" }, viewMode: { type: "number" }, validFlag: { type: "boolean" }, createTime: { type: "number" }, updateTime: { type: "number" }, channelNumber: { type: "number" } }, ms = { serverId: { type: "string" }, channelId: { type: "string" }, accid: { type: "string" }, avatar: { type: "string" }, nick: { type: "string" }, createTime: { type: "number" }, updateTime: { type: "number" } };
      function formatUpdateWhiteBlackRole(e2) {
        return format(ds, e2);
      }
      function formatChannel(e2) {
        return format(as, e2);
      }
      function formatChannels(e2) {
        return Array.isArray(e2) && e2.length > 0 ? e2.map((e3) => formatChannel(e3)) : [];
      }
      function formatUnreadInfo(e2) {
        return format(os, e2);
      }
      function formatUnreadInfos(e2) {
        return Array.isArray(e2) && e2.length > 0 ? e2.map((e3) => formatUnreadInfo(e3)) : [];
      }
      function formatChannelCategory(e2) {
        return format(ls, e2);
      }
      function formatChannelCategorys(e2) {
        return Array.isArray(e2) && e2.length > 0 ? e2.map((e3) => formatChannelCategory(e3)) : [];
      }
      function formatChannelMembers(e2) {
        return Array.isArray(e2) && e2.length > 0 ? e2.map((e3) => function formatChannelMember(e4) {
          return format(ms, e4);
        }(e3)) : [];
      }
      function formatFailServerIds(e2) {
        try {
          return JSON.parse(e2);
        } catch (e3) {
          return [];
        }
      }
      var ps = { serverId: { type: "string" }, name: { type: "string" }, icon: { type: "string" }, ext: { type: "string" }, owner: { type: "string" }, memberNumber: { type: "number" }, inviteMode: { type: "number" }, applyMode: { type: "number" }, validFlag: { type: "boolean" }, createTime: { type: "number" }, updateTime: { type: "number" }, channelNumber: { type: "number" }, categoryNumber: { type: "number" }, searchType: { type: "number" }, searchEnable: { type: "boolean" }, reorderWeight: { type: "string" } }, us = { serverId: { type: "string" }, uid: { type: "string" }, accid: { type: "string" }, nick: { type: "string" }, avatar: { type: "string" }, ext: { type: "string" }, type: { type: "number" }, joinTime: { type: "number" }, inviter: { type: "string" }, validFlag: { type: "boolean" }, createTime: { type: "number" }, updateTime: { type: "number" } }, hs = { serverId: { type: "string" }, appid: { type: "string" }, accid: { type: "string" }, ext: { type: "string" }, banTime: { type: "number" }, validFlag: { type: "boolean" }, createTime: { type: "number" }, updateTime: { type: "number" } };
      function formatServer(e2) {
        return format(ps, e2);
      }
      function formatServers(e2) {
        return Array.isArray(e2) && e2.length > 0 ? e2.map((e3) => formatServer(e3)) : [];
      }
      function formatMember$1(e2) {
        return format(us, e2);
      }
      function formatMembers$1(e2) {
        return Array.isArray(e2) && e2.length > 0 ? e2.map((e3) => formatMember$1(e3)) : [];
      }
      function formatServerMemberBanInfos(e2) {
        return Array.isArray(e2) && e2.length > 0 ? e2.map((e3) => function formatServerMemberBanInfo(e4) {
          return format(hs, e4);
        }(e3)) : [];
      }
      function generateAntispamTag(e2) {
        var t2, r2, i2;
        if (!e2.antispamTag)
          return {};
        var s2 = Object.assign({}, e2.antispamTag);
        return (null === (t2 = e2.antispamTag) || void 0 === t2 ? void 0 : t2.antiSpamBusinessId) && "string" != typeof (null === (r2 = e2.antispamTag) || void 0 === r2 ? void 0 : r2.antiSpamBusinessId) && (s2.antiSpamBusinessId = JSON.stringify(null === (i2 = e2.antispamTag) || void 0 === i2 ? void 0 : i2.antiSpamBusinessId)), s2;
      }
      var gs = { accid: { type: "string" }, type: { type: "number" }, serverId: { type: "string" }, status: { type: "number" }, requestId: { type: "string" }, createTime: { type: "number" }, updateTime: { type: "number" }, expireTime: { type: "number" }, data: { type: "object" } };
      function formatInviteApplyRecord(e2) {
        return format(gs, e2);
      }
      function formatInviteApplyRecords(e2) {
        return Array.isArray(e2) && e2.length > 0 ? e2.map((e3) => formatInviteApplyRecord(e3)) : [];
      }
      var vs, ys, fs, Is, Ms = { successServerIds: { type: "object" }, failServerIds: { type: "object" }, ackTimestamp: { type: "number" } };
      function formatClearServersUnread(e2) {
        return format(Ms, e2);
      }
      !function(e2) {
        e2[e2.everyone = 1] = "everyone", e2[e2.custom = 2] = "custom";
      }(vs || (vs = {})), function(e2) {
        e2[e2.normal = 0] = "normal", e2[e2.owner = 1] = "owner";
      }(ys || (ys = {})), function(e2) {
        e2[e2.ignore = 0] = "ignore", e2[e2.deny = -1] = "deny", e2[e2.allow = 1] = "allow";
      }(fs || (fs = {})), function(e2) {
        e2[e2.manageServer = 1] = "manageServer", e2[e2.manageChannel = 2] = "manageChannel", e2[e2.manageRole = 3] = "manageRole", e2[e2.sendMsg = 4] = "sendMsg", e2[e2.accountInfoSelf = 5] = "accountInfoSelf", e2[e2.inviteServer = 6] = "inviteServer", e2[e2.kickServer = 7] = "kickServer", e2[e2.accountInfoOther = 8] = "accountInfoOther", e2[e2.recallMsg = 9] = "recallMsg", e2[e2.deleteMsg = 10] = "deleteMsg", e2[e2.remindOther = 11] = "remindOther", e2[e2.remindEveryone = 12] = "remindEveryone", e2[e2.manageBlackWhiteList = 13] = "manageBlackWhiteList", e2[e2.banServerMember = 14] = "banServerMember", e2[e2.RTCChannelConnect = 15] = "RTCChannelConnect", e2[e2.RTCChannelDisconnectOther = 16] = "RTCChannelDisconnectOther", e2[e2.RTCChannelOpenMicrophone = 17] = "RTCChannelOpenMicrophone", e2[e2.RTCChannelOpenCamera = 18] = "RTCChannelOpenCamera", e2[e2.RTCChannelOpenCloseOtherMicrophone = 19] = "RTCChannelOpenCloseOtherMicrophone", e2[e2.RTCChannelOpenCloseOtherCamera = 20] = "RTCChannelOpenCloseOtherCamera", e2[e2.RTCChannelOpenCloseEveryoneMicrophone = 21] = "RTCChannelOpenCloseEveryoneMicrophone", e2[e2.RTCChannelOpenCloseEveryoneCamera = 22] = "RTCChannelOpenCloseEveryoneCamera", e2[e2.RTCChannelOpenShareScreen = 23] = "RTCChannelOpenShareScreen", e2[e2.RTCChannelCloseOtherShareScreen = 24] = "RTCChannelCloseOtherShareScreen", e2[e2.manageInviteApply = 25] = "manageInviteApply", e2[e2.manageInviteApplyHistory = 26] = "manageInviteApplyHistory", e2[e2.mentionedRole = 27] = "mentionedRole";
      }(Is || (Is = {}));
      var Ss, Ts, _s, Cs, Es, bs, Rs, Ns, As = { type: { type: "enum", values: vs }, memberType: { type: "enum", values: ys }, createTime: { type: "number" }, updateTime: { type: "number" }, priority: { type: "number" }, memberCount: { type: "number" }, joinTime: { type: "number" } }, Os = { roleId: { type: "string" }, categoryId: { type: "string" }, serverId: { type: "string" }, type: { type: "enum", values: vs }, validFlag: { type: "boolean" }, createTime: { type: "number" }, updateTime: { type: "number" }, name: { type: "string" }, icon: { type: "string" }, ext: { type: "string" } }, ks = { id: { type: "string" }, accid: { type: "string" }, categoryId: { type: "string" }, serverId: { type: "string" }, validFlag: { type: "boolean" }, createTime: { type: "number" }, updateTime: { type: "number" }, nick: { type: "string" }, avatar: { type: "string" }, ext: { type: "string" }, memberType: { type: "enum", values: ys }, joinTime: { type: "number" }, inviter: { type: "string" } };
      function generatorRoleForCmd(e2) {
        var t2 = Object.assign({}, e2), r2 = formatReverse(As, t2);
        return r2.auths && (r2.auths = function generateRoleAuthsForCmd(e3) {
          var t3 = Object.keys(e3).reduce((t4, r3) => {
            var i2 = Is[r3];
            return i2 ? t4[i2] = fs[e3[r3]] : t4[r3] = fs[e3[r3]], t4;
          }, {});
          return JSON.stringify(t3);
        }(r2.auths)), r2;
      }
      function formatRoleAuths(e2) {
        return Object.keys(e2).reduce((t2, r2) => {
          var i2 = getEnumKeyByEnumValue(Is, r2);
          i2 ? t2[i2] = fs[e2[r2]] : t2[parseInt(r2)] = fs[e2[r2]];
          return t2;
        }, {});
      }
      function formatRole(e2) {
        var t2 = format(As, e2);
        return e2.auths && (t2.auths = formatRoleAuths(JSON.parse(t2.auths))), t2.isMember && delete t2.isMember, t2;
      }
      function formatRoles(e2) {
        return Array.isArray(e2) && e2.length > 0 ? e2.map((e3) => formatRole(e3)) : [];
      }
      function formatChannelCategoryRole(e2) {
        return e2.auths && (e2.auths = formatRoleAuths(JSON.parse(e2.auths))), format(Os, e2);
      }
      function formatChannelCategoryMemberRole(e2) {
        return e2.auths && (e2.auths = formatRoleAuths(JSON.parse(e2.auths))), format(ks, e2);
      }
      function isObject(e2) {
        var t2 = typeof e2;
        return null != e2 && ("object" == t2 || "function" == t2);
      }
      !function(e2) {
        e2[e2.default = 1] = "default", e2[e2.sync = 2] = "sync";
      }(Ss || (Ss = {})), function(e2) {
        e2[e2.sendTime = 1] = "sendTime";
      }(Ts || (Ts = {})), function(e2) {
        e2[e2.text = 0] = "text", e2[e2.image = 1] = "image", e2[e2.audio = 2] = "audio", e2[e2.video = 3] = "video", e2[e2.geo = 4] = "geo", e2[e2.notification = 5] = "notification", e2[e2.file = 6] = "file", e2[e2.tip = 10] = "tip", e2[e2.robot = 11] = "robot", e2[e2.g2 = 12] = "g2", e2[e2.custom = 100] = "custom";
      }(_s || (_s = {})), function(e2) {
        e2[e2.sending = 1] = "sending", e2[e2.success = 2] = "success", e2[e2.failed = 3] = "failed";
      }(Cs || (Cs = {})), function(e2) {
        e2[e2.notifyAll = 1] = "notifyAll", e2[e2.notifySubscribe = 2] = "notifySubscribe";
      }(Es || (Es = {})), function(e2) {
        e2[e2.unknown = 0] = "unknown", e2[e2.server = 1] = "server", e2[e2.channel = 2] = "channel", e2[e2.serverAccids = 3] = "serverAccids", e2[e2.channelAccids = 4] = "channelAccids", e2[e2.accids = 5] = "accids";
      }(bs || (bs = {})), function(e2) {
        e2[e2.serverMemberInvite = 1] = "serverMemberInvite", e2[e2.serverMemberInviteReject = 2] = "serverMemberInviteReject", e2[e2.serverMemberApply = 3] = "serverMemberApply", e2[e2.serverMemberApplyReject = 4] = "serverMemberApplyReject", e2[e2.serverCreate = 5] = "serverCreate", e2[e2.serverRemove = 6] = "serverRemove", e2[e2.serverUpdate = 7] = "serverUpdate", e2[e2.serverMemberInviteDone = 8] = "serverMemberInviteDone", e2[e2.serverMemberInviteAccept = 9] = "serverMemberInviteAccept", e2[e2.serverMemberApplyDone = 10] = "serverMemberApplyDone", e2[e2.serverMemberApplyAccept = 11] = "serverMemberApplyAccept", e2[e2.serverMemberKick = 12] = "serverMemberKick", e2[e2.serverMemberLeave = 13] = "serverMemberLeave", e2[e2.serverMemberUpdate = 14] = "serverMemberUpdate", e2[e2.channelCreate = 15] = "channelCreate", e2[e2.channelRemove = 16] = "channelRemove", e2[e2.channelUpdate = 17] = "channelUpdate", e2[e2.channelUpdateWhiteBlackIdentify = 18] = "channelUpdateWhiteBlackIdentify", e2[e2.channelUpdateWhiteBlackIdentifyUser = 19] = "channelUpdateWhiteBlackIdentifyUser", e2[e2.updateQuickComment = 20] = "updateQuickComment", e2[e2.channelCategoryCreate = 21] = "channelCategoryCreate", e2[e2.channelCategoryRemove = 22] = "channelCategoryRemove", e2[e2.channelCategoryUpdate = 23] = "channelCategoryUpdate", e2[e2.channelCategoryUpdateWhiteBlackIdentify = 24] = "channelCategoryUpdateWhiteBlackIdentify", e2[e2.channelCategoryUpdateWhiteBlackIdentifyUser = 25] = "channelCategoryUpdateWhiteBlackIdentifyUser", e2[e2.serverIdentifyAdd = 26] = "serverIdentifyAdd", e2[e2.serverIdentifyRemove = 27] = "serverIdentifyRemove", e2[e2.serverIdentifyUpdate = 28] = "serverIdentifyUpdate", e2[e2.channelIdentifyUpdate = 29] = "channelIdentifyUpdate", e2[e2.userIdentifyUpdate = 30] = "userIdentifyUpdate", e2[e2.channelVisibilityUpdate = 31] = "channelVisibilityUpdate", e2[e2.serverEnterLeave = 32] = "serverEnterLeave", e2[e2.serverMemberJoinByInviteCode = 33] = "serverMemberJoinByInviteCode", e2[e2.channelVisibilityToVisitorUpdate = 34] = "channelVisibilityToVisitorUpdate", e2[e2.myMemberInfoUpdated = 35] = "myMemberInfoUpdated", e2[e2.custom = 100] = "custom", e2[e2.msgTyping = 101] = "msgTyping";
      }(Rs || (Rs = {})), function(e2) {
        e2[e2.reply = 1] = "reply", e2[e2.thread = 2] = "thread", e2[e2.all = 3] = "all";
      }(Ns || (Ns = {}));
      var ws = Math.max, Ps = Math.min;
      function debounce(e2, t2, r2) {
        var i2, s2, n2, a2, o2, c2, d2 = 0, l2 = false, m2 = false, p2 = true;
        if ("function" != typeof e2)
          throw new TypeError("Expected a function");
        function invokeFunc(t3) {
          var r3 = i2, n3 = s2;
          return i2 = s2 = void 0, d2 = t3, a2 = e2.apply(n3, r3);
        }
        function leadingEdge(e3) {
          return d2 = e3, o2 = setTimeout(timerExpired, t2), l2 ? invokeFunc(e3) : a2;
        }
        function shouldInvoke(e3) {
          var r3 = e3 - c2;
          return void 0 === c2 || r3 >= t2 || r3 < 0 || m2 && e3 - d2 >= n2;
        }
        function timerExpired() {
          var e3 = Date.now();
          if (shouldInvoke(e3))
            return trailingEdge(e3);
          o2 = setTimeout(timerExpired, function remainingWait(e4) {
            var r3 = t2 - (e4 - c2);
            return m2 ? Ps(r3, n2 - (e4 - d2)) : r3;
          }(e3));
        }
        function trailingEdge(e3) {
          return o2 = void 0, p2 && i2 ? invokeFunc(e3) : (i2 = s2 = void 0, a2);
        }
        function debounced() {
          var e3 = Date.now(), r3 = shouldInvoke(e3);
          if (i2 = arguments, s2 = this, c2 = e3, r3) {
            if (void 0 === o2)
              return leadingEdge(c2);
            if (m2)
              return clearTimeout(o2), o2 = setTimeout(timerExpired, t2), invokeFunc(c2);
          }
          return void 0 === o2 && (o2 = setTimeout(timerExpired, t2)), a2;
        }
        return t2 = Number(t2) || 0, isObject(r2) && (l2 = !!r2.leading, n2 = (m2 = "maxWait" in r2) ? ws(Number(r2.maxWait) || 0, t2) : n2, p2 = "trailing" in r2 ? !!r2.trailing : p2), debounced.cancel = function cancel() {
          void 0 !== o2 && clearTimeout(o2), d2 = 0, i2 = c2 = s2 = o2 = void 0;
        }, debounced.flush = function flush() {
          return void 0 === o2 ? a2 : trailingEdge(Date.now());
        }, debounced;
      }
      var Vs;
      function throttle(e2, t2, r2) {
        var i2 = true, s2 = true;
        if ("function" != typeof e2)
          throw new TypeError("Expected a function");
        return isObject(r2) && (i2 = "leading" in r2 ? !!r2.leading : i2, s2 = "trailing" in r2 ? !!r2.trailing : s2), debounce(e2, t2, { leading: i2, maxWait: t2, trailing: s2 });
      }
      !function(e2) {
        e2[e2.sub = 1] = "sub", e2[e2.unSub = 2] = "unSub";
      }(Vs || (Vs = {}));
      class UnreadInfoModuleService {
        constructor(e2) {
          this.unreadCount = {}, this.manualSubscribeUnreadMap = {}, this.manualSubscribeServerMap = {}, this.manualSubscribeTypingMap = {}, this.unreadServerCount = {}, this.serverRoleIdsMap = {}, this.autoSubscribeUnreadMap = {}, this.autoSubscribeServerMap = {}, this._serverUnreadInfo = throttle((e3) => {
            this.core.emit("serverUnreadInfo", this.getServerUnreadInfo(e3)), get(this.core, "qchatServer.emit") && this.core.qchatServer.emit("serverUnreadInfo", this.getServerUnreadInfo(e3));
          }, 100), this.core = e2;
        }
        changeCacheServerRoleIds(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            var { serverId: t2, roleId: r2 } = e2.attach.serverIdentifyInfo;
            this.serverRoleIdsMap[t2] || (yield this.getRoleIdsByServerId([t2]));
            var i2 = this.serverRoleIdsMap[t2];
            if (!(e2.time < i2.timeTag)) {
              e2.type === Rs[Rs.serverIdentifyAdd] ? i2.roleIds.add(r2) : i2.roleIds.delete(r2), this.core.logger.debug(`QChatChannel::qchatChannel/serverIdentifyChange::now ${t2} roleIds is`, [...i2.roleIds]);
              var s2 = this.unreadServerCount[t2];
              if (s2)
                chunk(Object.keys(s2), 100).forEach((e3) => {
                  this.core.qchatChannel.getChannelUnreadInfos({ channels: e3.map((e4) => ({ serverId: t2, channelId: e4 })) });
                });
            }
          });
        }
        getRoleIdsByServerId(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            var t2 = e2.filter((e3) => !this.serverRoleIdsMap[e3]);
            if (t2.length) {
              var r2 = { serverIdTimeTags: t2 }, i2 = yield this.core.sendCmd("qchatGetRoleIdsByServerId", { qchatGetRoleIdsByServerIdTag: r2 });
              this.core.logger.debug("QChatChannel:: getRoleIdsByServerId, params is ", r2, "result is", i2), i2.content.serverRoles.forEach((e3) => {
                try {
                  e3.roleIds = JSON.parse(e3.roleIds);
                } catch (e4) {
                  this.core.logger.error("QChatChannel:: getRoleIdsByServerId JSON parse roleIds error", e4);
                }
                this.serverRoleIdsMap[e3.serverId] = { roleIds: new Set(e3.roleIds), timeTag: e3.timeTag };
              });
            }
          });
        }
        _unSubscribeChannel(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            var r2 = `${e2}_${t2}`, i2 = [];
            if (this.manualSubscribeUnreadMap[r2] ? i2.push(this.manualSubscribeUnreadMap[r2]) : this.autoSubscribeUnreadMap[r2] && i2.push(this.autoSubscribeUnreadMap[r2]), this.manualSubscribeTypingMap[r2] && i2.push(this.manualSubscribeTypingMap[r2]), 0 !== i2.length) {
              for (var s2 of i2)
                this.subscribe({ opeType: Vs.unSub, type: s2, channels: [{ serverId: e2, channelId: t2 }] });
              this.manualSubscribeUnreadMap[r2] ? this.manualSubscribeUnreadMap[r2] = void 0 : this.autoSubscribeUnreadMap[r2] && (this.autoSubscribeUnreadMap[r2] = void 0), this.manualSubscribeTypingMap[r2] && (this.manualSubscribeTypingMap[r2] = void 0);
            }
          });
        }
        _unSubscribeServer(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            var t2 = e2, r2 = this.manualSubscribeServerMap[t2] || this.autoSubscribeServerMap[t2];
            r2 && (this.subscribe({ opeType: Vs.unSub, type: r2, channels: [{ serverId: e2, channelId: "" }] }), this.manualSubscribeServerMap[t2] ? this.manualSubscribeServerMap[t2] = void 0 : this.autoSubscribeServerMap[t2] && (this.autoSubscribeServerMap[t2] = void 0));
          });
        }
        subscribe(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ type: { type: "number", min: 1, max: 5 }, opeType: { type: "number", min: 1, max: 2 } }, e2);
            var t2 = yield this.core.sendCmd("qchatSubscribe", { qchatSubReqTag: { type: e2.type, opeType: e2.opeType }, channels: e2.channels }), r2 = /* @__PURE__ */ new Set();
            return e2.channels.forEach((e3) => __awaiter(this, void 0, void 0, function* () {
              this.serverRoleIdsMap[e3.serverId] || r2.add(e3.serverId);
            })), chunk(Array.from(r2), 10).forEach((e3) => {
              this.getRoleIdsByServerId(e3);
            }), t2.content;
          });
        }
        autoSubscribe() {
          return __awaiter(this, void 0, void 0, function* () {
            yield this.core.sendCmd("qchatAutoSubscribe", { qchatAutoSubReqTag: {} });
          });
        }
        resumeSubscribe(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.serverRoleIdsMap = {};
            if (!e2)
              return this.unreadServerCount = {}, void (this.unreadCount = {});
            var t2 = {};
            Object.keys(this.manualSubscribeUnreadMap).forEach((e3) => {
              var r3 = this.manualSubscribeUnreadMap[e3];
              if (r3) {
                var [i2, s2] = e3.split("_"), n2 = { serverId: i2, channelId: s2 };
                t2[r3] = t2[r3] || [], t2[r3].push(n2);
              }
            }), t2[5] = [], Object.keys(this.manualSubscribeTypingMap).forEach((e3) => __awaiter(this, void 0, void 0, function* () {
              if (this.manualSubscribeTypingMap[e3]) {
                var [r3, i2] = e3.split("_"), s2 = { serverId: r3, channelId: i2 };
                t2[5].push(s2);
              }
            })), t2[4] = [], Object.keys(this.manualSubscribeServerMap).forEach((e3) => __awaiter(this, void 0, void 0, function* () {
              if (this.manualSubscribeServerMap[e3]) {
                var r3 = { serverId: e3 };
                t2[4].push(r3);
              }
            }));
            var r2 = [];
            Object.keys(t2).forEach((e3) => {
              var i2 = t2[e3];
              return i2 && 0 === i2.length ? Promise.resolve() : i2.length > 100 ? chunk(i2, 100).forEach((t3) => {
                r2.push(this.createSubscribePromise(t3, e3));
              }) : void r2.push(this.createSubscribePromise(i2, e3));
            }), yield Promise.all(r2);
          });
        }
        createSubscribePromise(e2, t2) {
          var r2 = { type: parseInt(t2), opeType: 1, channels: e2 };
          return this.core.logger.debug("qchatChannel:: autoSubscribeUnread params", r2), this.subscribe(r2).then(({ unreadInfos: e3 }) => {
            e3 && e3.length > 0 && (e3 = formatUnreadInfos(e3), this.updateUnreads(e3));
          }).catch((e3) => {
            this.core.logger.error("qchatChannel:: autoSubscribeUnread error ", e3);
          });
        }
        cacheSubscribe(e2) {
          e2.channels.forEach((t2) => {
            var r2 = t2.channelId ? `${t2.serverId}_${t2.channelId}` : `${t2.serverId}`, i2 = 5 === e2.type ? this.manualSubscribeTypingMap : 4 === e2.type ? this.manualSubscribeServerMap : this.manualSubscribeUnreadMap;
            e2.opeType === Vs.sub ? i2[r2] = e2.type : e2.opeType === Vs.unSub && (i2[r2] = void 0);
          });
        }
        cacheAutoSubscribe(e2) {
          e2.channels.forEach((t2) => {
            var r2 = t2.channelId ? `${t2.serverId}_${t2.channelId}` : `${t2.serverId}`, i2 = 4 === e2.type ? this.autoSubscribeServerMap : this.autoSubscribeUnreadMap;
            e2.opeType === Vs.sub ? i2[r2] = e2.type : e2.opeType === Vs.unSub && (i2[r2] = void 0);
          });
        }
        cacheUnreadCount(e2) {
          e2.forEach((e3) => {
            var t2 = `${e3.serverId}_${e3.channelId}`;
            this.unreadCount[t2] = Object.assign({}, e3), this.unreadServerCount[e3.serverId] || (this.unreadServerCount[e3.serverId] = {}), this.unreadServerCount[e3.serverId][e3.channelId] = true;
          });
        }
        getServerUnreadInfo(e2) {
          var t2 = { serverId: e2, unreadCount: 0, mentionedCount: 0, maxCount: 0 }, r2 = this.unreadServerCount[e2];
          return r2 && (Object.keys(r2).forEach((r3) => {
            var i2 = `${e2}_${r3}`, s2 = this.unreadCount[i2];
            t2.unreadCount += s2.unreadCount, t2.mentionedCount += s2.mentionedCount, void 0 !== s2.maxCount && (t2.maxCount = s2.maxCount);
          }), t2.unreadCount = t2.unreadCount > t2.maxCount ? t2.maxCount : t2.unreadCount, t2.mentionedCount = t2.mentionedCount > t2.maxCount ? t2.maxCount : t2.mentionedCount), t2;
        }
        getUnreadInfo(e2) {
          validate({ serverId: { type: "string" }, channelId: { type: "string" } }, e2);
          var t2 = `${e2.serverId}_${e2.channelId}`;
          return this.unreadCount[t2] ? this.unreadCount[t2] : null;
        }
        shouldChangeUnread(e2, t2) {
          if (!e2.serverId || !e2.channelId)
            return false;
          if (this.core.qchatChannel.subscribeForVisitorService.isInSubscribeChannels(e2.serverId, e2.channelId))
            return false;
          if (false === e2.historyEnable)
            return false;
          if (false === e2.needBadge)
            return false;
          if (e2.fromAccount === this.core.account)
            return false;
          if (t2 && 2 !== (null == e2 ? void 0 : e2.status))
            return false;
          if (e2.notifyReason && e2.notifyReason === getEnumKeyByEnumValue(Es, Es.notifySubscribe)) {
            if (!e2.serverId || !e2.channelId)
              return false;
            var r2 = this.getUnreadInfo({ serverId: e2.serverId, channelId: e2.channelId }), i2 = t2 ? "ackTimestamp" : "lastMsgTime";
            if (!r2)
              return false;
            if (e2.time && r2[i2] && r2[i2] > e2.time)
              return false;
          }
          return true;
        }
        shouldChangeMentionedUnread(e2, t2 = false) {
          return __awaiter(this, void 0, void 0, function* () {
            if (e2.accidsOfMentionedRoles && e2.accidsOfMentionedRoles.includes(this.core.account))
              return true;
            if (e2.mentionRoleIds && e2.serverId) {
              if (!this.serverRoleIdsMap[e2.serverId]) {
                if (!t2)
                  return this.handledRoleMsg(e2), false;
                yield this.getRoleIdsByServerId([e2.serverId]);
              }
              for (var r2 = 0; r2 < e2.mentionRoleIds.length; r2++)
                if (this.serverRoleIdsMap[e2.serverId].roleIds.has(e2.mentionRoleIds[r2]))
                  return true;
            }
            return false;
          });
        }
        handledRoleMsg(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            if (e2.mentionRoleIds)
              if (this.serverRoleIdsMap[e2.serverId] || (yield this.getRoleIdsByServerId([e2.serverId])), this.serverRoleIdsMap[e2.serverId]) {
                var t2 = false;
                if (e2.mentionRoleIds.forEach((r3) => {
                  this.serverRoleIdsMap[e2.serverId].roleIds.has(r3) && (t2 = true, this.core.logger.debug("QChatChannel::handledRoleMsg::will update message mentionedCountmessage is ", e2));
                }), t2) {
                  var r2 = this.unreadCount[`${e2.serverId}_${e2.channelId}`], i2 = 2 === (null == e2 ? void 0 : e2.status);
                  if (r2.mentionedCount = i2 ? r2.mentionedCount ? r2.mentionedCount - 1 : 0 : r2.mentionedCount ? r2.mentionedCount + 1 : 1, "number" == typeof r2.maxCount) {
                    var s2 = r2.mentionedCount;
                    if ((s2 = s2 > r2.maxCount ? r2.maxCount : s2) > r2.maxCount)
                      return void this.core.logger.debug("QChatChannel::handledRoleMsg::tempUnreadCount more than maxCount");
                    this.core.emit("unreadInfo", Object.assign(Object.assign({}, r2), { mentionedCount: s2 })), this.core.emit("unreadInfos", [Object.assign(Object.assign({}, r2), { mentionedCount: s2 })]), this.core.qchatChannel.emit("unreadInfos", [Object.assign(Object.assign({}, r2), { mentionedCount: s2 })]), this._serverUnreadInfo(e2.serverId);
                  }
                }
              } else
                this.core.logger.warn("QChatChannel::handledRoleMsg::can not get serverRoleIds,server id", e2.serverId);
          });
        }
        getMentionedFlag(e2, t2 = false) {
          return __awaiter(this, void 0, void 0, function* () {
            return !!e2.mentionAll || (e2.mentionRoleIds || e2.accidsOfMentionedRoles ? yield this.shouldChangeMentionedUnread(e2, t2) : !(!e2.mentionAccids || !e2.mentionAccids.includes(this.core.account)));
          });
        }
        changeUnread(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            var r2 = e2.serverId, i2 = e2.channelId, s2 = `${r2}_${i2}`;
            if (this.shouldChangeUnread(e2, t2)) {
              if (!this.unreadCount[s2])
                return yield this.core.qchatChannel.getChannelUnreadInfos({ channels: [{ serverId: r2, channelId: i2 }] }), void (!this.serverRoleIdsMap[r2] && e2.mentionRoleIds && this.getRoleIdsByServerId([r2]));
              var n2 = this.unreadCount[s2], a2 = 2 === (null == e2 ? void 0 : e2.status), o2 = yield this.getMentionedFlag(e2);
              a2 ? (n2.unreadCount = n2.unreadCount ? n2.unreadCount - 1 : 0, o2 && (n2.mentionedCount = n2.mentionedCount ? n2.mentionedCount - 1 : 0), delete n2.lastMsgTime, this.core.logger.debug(`changeUnread: ${s2} unread reduce `, n2)) : (n2.unreadCount = n2.unreadCount ? n2.unreadCount + 1 : 1, o2 && (n2.mentionedCount = n2.mentionedCount ? n2.mentionedCount + 1 : 1), e2.time && (n2.lastMsgTime = e2.time), this.core.logger.debug(`changeUnread: ${s2} unread add `, n2));
              var c2 = "number" == typeof n2.maxCount ? n2.maxCount : 100;
              n2.unreadCount > c2 ? this.core.logger.debug("QChatChannel::subscribe::tempUnreadCount more than maxCount") : (this.core.logger.warn("unreadInfo event will abandon,please use unreadInfos"), this.core.emit("unreadInfo", Object.assign(Object.assign({}, n2), { mentionedCount: n2.mentionedCount > c2 ? c2 : n2.mentionedCount, unreadCount: n2.unreadCount > c2 ? c2 : n2.unreadCount })), this.core.emit("unreadInfos", [Object.assign(Object.assign({}, n2), { mentionedCount: n2.mentionedCount > c2 ? c2 : n2.mentionedCount, unreadCount: n2.unreadCount > c2 ? c2 : n2.unreadCount })]), this.core.qchatChannel.emit("unreadInfos", [Object.assign(Object.assign({}, n2), { mentionedCount: n2.mentionedCount > c2 ? c2 : n2.mentionedCount, unreadCount: n2.unreadCount > c2 ? c2 : n2.unreadCount })]), this._serverUnreadInfo(r2));
            } else
              this.core.logger.debug(`changeUnread: ${s2} does not need to update unreadInfo`);
          });
        }
        updateUnreads(e2) {
          if (e2 && e2.length > 0) {
            var t2 = [], r2 = [], i2 = e2.filter((e3) => {
              var t3 = `${e3.serverId}_${e3.channelId}`, r3 = this.unreadCount[t3], i3 = get(r3, "ackTimestamp"), s3 = get(e3, "ackTimestamp");
              return !(i3 && s3 && s3 < i3) && (get(r3, "unreadCount") !== get(e3, "unreadCount") || get(r3, "mentionedCount") !== get(e3, "mentionedCount"));
            }).map((e3) => {
              t2.push(this.getServerUnreadInfo(e3.serverId)), r2.push(this.unreadServerCount[e3.serverId]);
              var i3 = e3.serverId, s3 = e3.channelId, n2 = `${i3}_${s3}`;
              return this.core.logger.debug("qchat channel updateUnread: ", e3), this.unreadCount[n2] = Object.assign({}, e3), this.unreadServerCount[i3] || (this.unreadServerCount[i3] = {}), this.unreadServerCount[i3][s3] = true, e3;
            });
            if (0 !== i2.length) {
              this.core.emit("unreadInfos", i2), this.core.qchatChannel.emit("unreadInfos", i2);
              var s2 = {};
              i2.forEach((e3, i3) => {
                this.core.emit("unreadInfo", e3);
                var n2 = t2[i3], a2 = r2[i3], o2 = this.getServerUnreadInfo(e3.serverId), c2 = this.unreadServerCount[e3.serverId], d2 = n2.unreadCount !== o2.unreadCount, l2 = !a2 || 0 === Object.keys(a2).length, m2 = c2 && Object.keys(c2).length > 0, p2 = n2.mentionedCount !== o2.mentionedCount;
                (d2 || p2 || l2 && m2) && (s2[e3.serverId] = true);
              }), Object.keys(s2).forEach((e3) => {
                this.core.emit("serverUnreadInfo", this.getServerUnreadInfo(e3)), get(this.core, "qchatServer.emit") && this.core.qchatServer.emit("serverUnreadInfo", this.getServerUnreadInfo(e3));
              });
            }
          }
        }
        clearUnreadCountByServers(e2, t2) {
          var r2 = [];
          e2.forEach((e3) => {
            this.unreadServerCount[e3] && Object.keys(this.unreadServerCount[e3]).forEach((t3) => {
              r2.push(`${e3}_${t3}`);
            });
          });
          var i2 = [];
          r2.forEach((e3) => {
            i2.push(Object.assign(Object.assign({}, this.unreadCount[e3]), { unreadCount: 0, mentionedCount: 0, ackTimestamp: t2 }));
          }), this.updateUnreads(i2);
        }
      }
      class SubscribeForVisitorService {
        constructor(e2) {
          this.limitForBatchEnter = 10, this.limitForBatchSubscribe = 100, this.autoServers = /* @__PURE__ */ new Set(), this.autoVisitorSubscribeServer = /* @__PURE__ */ new Set(), this.autoVisitorSubscribeChannel = /* @__PURE__ */ new Set(), this.core = e2;
        }
        subscribeChannelAsVisitor(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            var t2 = (yield this.core.sendCmd("qchatSubscribeAsVisitor", { tag: { type: e2.type || 6, opeType: e2.opeType }, datas: e2.channels })).content.failedArr;
            return e2.channels.filter((e3) => !t2.some((t3) => t3.channelId === e3.channelId && t3.serverId === e3.serverId)).forEach((t3) => {
              1 === e2.opeType ? this.autoVisitorSubscribeChannel.add(`${t3.serverId}&${t3.channelId}`) : this.autoVisitorSubscribeChannel.delete(`${t3.serverId}&${t3.channelId}`);
            }), { failedChannels: t2 };
          });
        }
        subscribeServerAsVisitor(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            var t2 = yield this.core.sendCmd("qchatSubscribeAsVisitor", { tag: { type: e2.type || 7, opeType: e2.opeType }, datas: e2.serverIds.map((e3) => ({ serverId: e3 })) }), r2 = t2.content.failedArr;
            return e2.serverIds.filter((e3) => !r2.some((t3) => t3.serverId === e3)).forEach((t3) => {
              1 === e2.opeType ? this.autoVisitorSubscribeServer.add(t3) : this.autoVisitorSubscribeServer.delete(t3);
            }), { failedServers: t2.content.failedArr.map((e3) => e3.serverId) };
          });
        }
        deleteServer(e2) {
          this.autoServers.delete(e2), this.autoVisitorSubscribeServer.has(e2) && this.subscribeServerAsVisitor({ opeType: 2, serverIds: [e2] });
          var t2 = [];
          this.autoVisitorSubscribeChannel.forEach((r2) => {
            if (0 === r2.indexOf(e2)) {
              var i2 = r2.replace(`${e2}&`, "");
              t2.push({ serverId: e2, channelId: i2 });
            }
          }), t2.length > 0 && this.subscribeChannelAsVisitor({ opeType: 2, channels: t2 });
        }
        deleteAutoSetInServerId(e2) {
          this.autoServers.delete(e2), this.autoVisitorSubscribeServer.delete(e2), this.autoVisitorSubscribeChannel.forEach((t2) => {
            0 === t2.indexOf(e2) && this.autoVisitorSubscribeChannel.delete(t2);
          });
        }
        deleteAutoSetInChannel(e2, t2) {
          this.autoVisitorSubscribeChannel.delete(`${e2}&${t2}`);
        }
        unSubscribeChannel(e2, t2) {
          this.subscribeChannelAsVisitor({ opeType: 2, channels: [{ serverId: e2, channelId: t2 }] });
        }
        isInSubscribeChannels(e2, t2) {
          return this.autoVisitorSubscribeChannel.has(`${e2}&${t2}`);
        }
        isInAutoServers(e2) {
          return this.autoServers.has(e2);
        }
        doAutoSubscribe() {
          var e2 = [];
          return chunk(Array.from(this.autoVisitorSubscribeServer), this.limitForBatchSubscribe).forEach((t2) => {
            e2.push(this.subscribeServerAsVisitor({ opeType: 1, serverIds: t2 }));
          }), chunk(Array.from(this.autoVisitorSubscribeChannel), this.limitForBatchSubscribe).forEach((t2) => {
            e2.push(this.subscribeChannelAsVisitor({ opeType: 1, channels: t2.map((e3) => {
              var t3 = e3.indexOf("&");
              return { serverId: e3.slice(0, t3), channelId: e3.slice(t3 + 1) };
            }) }));
          }), Promise.all(e2);
        }
        doAutoEnterServer() {
          return __awaiter(this, void 0, void 0, function* () {
            var e2 = chunk(Array.from(this.autoServers), this.limitForBatchEnter), t2 = [];
            e2.forEach((e3) => {
              t2.push(this.core.qchatServer.enterAsVisitor({ serverIds: e3 }));
            }), (yield Promise.all(t2)).forEach((e3) => {
              e3.failedServers.forEach((e4) => {
                this.deleteAutoSetInServerId(e4);
              });
            });
          });
        }
        resumeSubscribe(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            e2 ? (yield this.doAutoEnterServer(), yield this.doAutoSubscribe()) : (this.autoServers.clear(), this.autoVisitorSubscribeChannel.clear(), this.autoVisitorSubscribeServer.clear());
          });
        }
        cacheServer(e2) {
          e2.forEach((e3) => this.autoServers.add(e3));
        }
      }
      var Ls = { serverId: { type: "string" }, uid: { type: "string" }, accid: { type: "string" }, nick: { type: "string" }, avatar: { type: "string" }, ext: { type: "string" }, type: { type: "number" }, joinTime: { type: "number" }, inviter: { type: "string" }, validFlag: { type: "boolean" }, createTime: { type: "number" }, updateTime: { type: "number" } }, Us = { limit: { type: "number" } };
      function formatMembers(e2) {
        return Array.isArray(e2) && e2.length > 0 ? e2.map((e3) => function formatMember(e4) {
          return format(Ls, e4);
        }(e3)) : [];
      }
      var Ds = { "25_1": "qchatGetNeroomToken", "25_2": "qchatUpdateRTCChannelConfig", "25_3": "qchatGetRTCChannelConfig", "25_4": "qchatGetRTCChannelMembers" }, qs = { QChatRTCChannelConfigTag: { serverId: 1, channelId: 2, limit: 3, audio: 4, video: 5 }, QChatRTCChannelConfigResultTag: { limit: 1, audio: 2, video: 3 }, QChatGetRTCParams: { serverId: 1, channelId: 2 }, qchatGetRTCChannelMembersTag: { serverId: 1, channelId: 2 }, memberInfo: { serverId: 1, accid: 3, nick: 4, avatar: 5, ext: 6, type: 7, joinTime: 8, inviter: 9, validFlag: 10, createTime: 11, updateTime: 12 }, QChatGetNeroomTokenResultTag: { token: 1, expire: 2 }, QChatGetNeroomTokenParams: { neroomDeviceId: 1 } }, getCmdConfig$3 = () => {
        var e2 = invertSerializeMap(qs);
        return { qchatGetNeroomToken: { sid: 25, cid: 1, service: "qchatMedia", params: [{ type: "Property", name: "qchatGetNeroomTokenTag", reflectMapper: qs.QChatGetNeroomTokenParams }], response: [{ type: "Property", name: "neroomToken", reflectMapper: e2.QChatGetNeroomTokenResultTag }] }, qchatUpdateRTCChannelConfig: { sid: 25, cid: 2, service: "qchatMedia", params: [{ type: "Property", name: "RTCChannelConfig", reflectMapper: qs.QChatRTCChannelConfigTag }] }, qchatGetRTCChannelConfig: { sid: 25, cid: 3, service: "qchatMedia", params: [{ type: "Property", name: "qchatGetRTCChannelConfigTag", reflectMapper: qs.QChatGetRTCParams }], response: [{ type: "Property", name: "RTCChannelConfig", reflectMapper: e2.QChatRTCChannelConfigResultTag }] }, qchatGetRTCChannelMembers: { sid: 25, cid: 4, service: "qchatMedia", params: [{ type: "Property", name: "qchatGetRTCChannelMembersTag", reflectMapper: qs.QChatGetRTCParams }], response: [{ type: "PropertyArray", name: "memberList", reflectMapper: e2.memberInfo }] } };
      };
      var xs, Bs = { "24_10": "qchatSendMsg", "24_11": "qchatOnMsg", "24_12": "qchatOnRecvUnreadInfo", "24_13": "qchatSendCustomSysMsg", "24_14": "qchatOnSysMsg", "24_16": "qchatGetHistoryMsg", "24_17": "qchatMarkMessageRead", "24_18": "qchatMultiSyncMessageRead", "24_22": "qchatUpdateSystemNotification", "24_23": "qchatMultiSyncSystemNotificationUpdate", "24_24": "qchatSyncSystemNotification", "24_25": "qchatUpdateMessage", "24_26": "qchatRecvMessageUpdate", "24_28": "qchatMarkSysMsgRead", "24_94": "qchatMessageSearchByPage", "24_100": "qchatGetMessageHistoryByIds", "24_101": "qchatGetThreadMessages", "24_102": "qchatUpdateQuickComment", "24_103": "qchatGetQuickComments", "24_108": "qchatGetThreadRootMessagesMeta", "24_121": "qchatGetLastMessageOfChannels", "24_127": "qchatGetMentionedMeMessages", "25_6": "qchatMultiSyncServersMessageRead" }, Fs = { getHistoryMsgTag: { serverId: 1, channelId: 2, beginTime: 3, endTime: 4, excludeMsgId: 5, limit: 6, reverse: 7 }, getThreadHistoryMsgTag: { beginTime: 1, endTime: 2, excludeMsgId: 3, limit: 4, reverse: 5 }, qchatMsgTag: { serverId: 1, channelId: 2, fromAccount: 3, fromClientType: 4, fromDeviceId: 5, fromNick: 6, time: 7, updateTime: 8, type: 9, body: 10, attach: 11, ext: 12, msgIdClient: 13, msgIdServer: 14, resendFlag: 15, status: 16, pushPayload: 17, pushContent: 18, mentionAccids: 19, mentionAll: 20, env: 21, callbackExt: 22, replyMsgFromAccount: 23, replyMsgTime: 24, replyMsgIdServer: 25, replyMsgIdClient: 26, threadMsgFromAccount: 27, threadMsgTime: 28, threadMsgIdServer: 29, threadMsgIdClient: 30, useCustomContent: 31, antiSpamContent: 32, antiSpamBusinessId: 33, antiSpamUsingYidun: 34, yidunCallback: 35, yidunAntiCheating: 36, yidunAntiSpamExt: 37, yidunAntiSpamRes: 38, mentionRoleIds: 41, accidsOfMentionedRoles: 42, updateContent: 39, updateOperatorInfo: 40, subType: 61, historyEnable: 100, pushEnable: 101, needBadge: 102, needPushNick: 103, notifyReason: 104, routeEnable: 105, isAntispam: 106 }, sysMsg: { toType: 1, serverId: 2, channelId: 3, toAccids: 4, fromAccount: 5, fromClientType: 6, fromDeviceId: 7, fromNick: 8, time: 9, updateTime: 10, type: 11, msgIdClient: 12, msgIdServer: 13, body: 14, attach: 15, ext: 16, resendFlag: 17, status: 18, pushPayload: 19, pushContent: 20, env: 21, callbackExt: 22, persistEnable: 100, pushEnable: 101, needBadge: 102, needPushNick: 103, routeEnable: 104 }, qchatMsgUpdateTag: { operatorAccount: 1, operatorClientType: 2, ps: 3, ext: 4, pushContent: 5, pushPayload: 6, env: 7, routeEnable: 100 }, markMsgReadTag: { serverId: 1, channelId: 2, time: 3 }, qchatQuickCommentRequestTag: { serverId: 1, channelId: 2, fromAccount: 3, msgIdServer: 4, time: 5, type: 6, opeType: 7, opeAccid: 8 }, qchatQuickCommentQueryTag: { serverId: 1, channelId: 2, msgIdServerList: 3 }, qchatGetLastMessageOfChannelsTag: { serverId: 1, channelIdList: 2 }, qchatMultiSyncServersMessageReadTag: { successServerIds: 1, failServerIds: 2, ackTimestamp: 3 }, qchatMessageSearchByPageTag: { keyword: 1, serverId: 2, channelId: 3, fromAccid: 4, fromTime: 5, toTime: 6, msgTypes: 7, subTypes: 8, includeSelf: 9, order: 10, limit: 11, sort: 12, cursor: 13 }, qchatPageQueryTag: { hasMore: 1, nextTimetag: 2, cursor: 3 }, unreadInfo: ss }, getDeserializeTag$2 = () => invertSerializeMap(Fs), getCmdConfig$2 = () => {
        var e2 = getDeserializeTag$2();
        return { qchatSendMsg: { service: "qchatMsg", sid: 24, cid: 10, params: [{ type: "Property", name: "qchatMsg", reflectMapper: Fs.qchatMsgTag }], response: [{ type: "Property", name: "qchatMsg", reflectMapper: e2.qchatMsgTag }] }, qchatOnMsg: { service: "qchatMsg", sid: 24, cid: 11, response: [{ type: "Property", name: "qchatMsg", reflectMapper: e2.qchatMsgTag }] }, qchatOnRecvUnreadInfo: { service: "qchatMsg", sid: 24, cid: 12, response: [{ type: "Property", name: "qchatMsg", reflectMapper: e2.qchatMsgTag }] }, qchatSendCustomSysMsg: { service: "qchatMsg", sid: 24, cid: 13, params: [{ type: "Property", name: "sysMsg", reflectMapper: Fs.sysMsg }], response: [{ type: "Property", name: "sysMsg", reflectMapper: e2.sysMsg }] }, qchatOnSysMsg: { service: "qchatMsg", sid: 24, cid: 14, response: [{ type: "Property", name: "sysMsg", reflectMapper: e2.sysMsg }] }, qchatGetHistoryMsg: { service: "qchatMsg", sid: 24, cid: 16, params: [{ type: "Property", name: "getHistoryMsgTag", reflectMapper: Fs.getHistoryMsgTag }], response: [{ type: "PropertyArray", name: "qchatMsgs", reflectMapper: e2.qchatMsgTag }] }, qchatUpdateMessage: { service: "qchatMsg", sid: 24, cid: 25, params: [{ type: "Property", name: "qchatMsgUpdateTag", reflectMapper: Fs.qchatMsgUpdateTag }, { type: "Property", name: "qchatMsg", reflectMapper: Fs.qchatMsgTag }], response: [{ type: "Property", name: "qchatMsg", reflectMapper: e2.qchatMsgTag }] }, qchatRecvMessageUpdate: { service: "qchatMsg", sid: 24, cid: 26, response: [{ type: "Property", name: "qchatMsgUpdateInfo", reflectMapper: e2.qchatMsgUpdateTag }, { type: "Property", name: "qchatMsg", reflectMapper: e2.qchatMsgTag }] }, qchatMarkMessageRead: { sid: 24, cid: 17, service: "qchatMsg", params: [{ type: "Property", name: "markMsgReadTag", reflectMapper: Fs.markMsgReadTag }], response: [{ type: "Property", name: "unreadInfo", reflectMapper: e2.unreadInfo }] }, qchatMultiSyncMessageRead: { sid: 24, cid: 18, service: "qchatMsg", response: [{ type: "Property", name: "unreadInfo", reflectMapper: e2.unreadInfo }] }, qchatUpdateSystemNotification: { service: "qchatMsg", sid: 24, cid: 22, params: [{ type: "Property", name: "qchatMsgUpdateTag", reflectMapper: Fs.qchatMsgUpdateTag }, { type: "Property", name: "sysMsg", reflectMapper: Fs.sysMsg }], response: [{ type: "Property", name: "sysMsg", reflectMapper: e2.sysMsg }] }, qchatMultiSyncSystemNotificationUpdate: { service: "qchatMsg", sid: 24, cid: 23, response: [{ type: "Property", name: "qchatMsgUpdateTag", reflectMapper: e2.qchatMsgUpdateTag }, { type: "Property", name: "sysMsg", reflectMapper: e2.sysMsg }] }, qchatSyncSystemNotification: { service: "qchatMsg", sid: 24, cid: 24, response: [{ type: "PropertyArray", name: "systemNotifications", reflectMapper: e2.sysMsg }] }, qchatMarkSysMsgRead: { service: "qchatMsg", sid: 24, cid: 28, params: [{ type: "PropertyArray", name: "sysMsgs", reflectMapper: Fs.sysMsg }] }, qchatMessageSearchByPage: { service: "qchatMsg", sid: 24, cid: 94, params: [{ type: "Property", name: "qchatMessageSearchByPageTag", reflectMapper: Fs.qchatMessageSearchByPageTag }], response: [{ type: "Property", name: "listQueryTag", reflectMapper: e2.qchatPageQueryTag }, { type: "PropertyArray", name: "datas", reflectMapper: e2.qchatMsgTag }] }, qchatGetMessageHistoryByIds: { service: "qchatMsg", sid: 24, cid: 100, params: [{ type: "Property", name: "channelInfo", reflectMapper: { serverId: 1, channelId: 2 } }, { type: "PropertyArray", name: "messageReferList", reflectMapper: { msgIdServer: 1, time: 2 } }], response: [{ type: "PropertyArray", name: "qchatMsgs", reflectMapper: e2.qchatMsgTag }] }, qchatGetThreadMessages: { service: "qchatMsg", sid: 24, cid: 101, params: [{ type: "Property", name: "qchatMsg", reflectMapper: Fs.qchatMsgTag }, { type: "Property", name: "getThreadHistoryMsgTag", reflectMapper: Fs.getThreadHistoryMsgTag }], response: [{ type: "Property", name: "thread", reflectMapper: e2.qchatMsgTag }, { type: "Property", name: "threadInfo", reflectMapper: { 1: "messageCount", 2: "lastMessageTimestamp" } }, { type: "PropertyArray", name: "qchatMsgs", reflectMapper: e2.qchatMsgTag }] }, qchatUpdateQuickComment: { service: "qchatMsg", sid: 24, cid: 102, params: [{ type: "Property", name: "tag", reflectMapper: Fs.qchatQuickCommentRequestTag }] }, qchatGetQuickComments: { service: "qchatMsg", sid: 24, cid: 103, params: [{ type: "Property", name: "tag", reflectMapper: Fs.qchatQuickCommentQueryTag }], response: [{ type: "PropertyArray", name: "quickCommentResponse", reflectMapper: { 1: "serverId", 2: "channelId", 3: "msgIdServer", 4: "totalCount", 5: "lastUpdateTime", 6: "details" } }] }, qchatGetThreadRootMessagesMeta: { service: "qchatMsg", sid: 24, cid: 108, params: [{ type: "Property", name: "tag", reflectMapper: { serverId: 1, channelId: 2 } }, { type: "PropertyArray", name: "qchatMsgs", reflectMapper: { time: 7, msgIdServer: 14 } }], response: [{ type: "PropertyArray", name: "metas", reflectMapper: { 1: "total", 2: "timestamp", 3: "msgIdServer", 4: "msgTime" } }] }, qchatGetLastMessageOfChannels: { service: "qchatMsg", sid: 24, cid: 121, params: [{ type: "Property", name: "tag", reflectMapper: Fs.qchatGetLastMessageOfChannelsTag }], response: [{ type: "PropertyArray", name: "msgs", reflectMapper: e2.qchatMsgTag }] }, qchatMultiSyncServersMessageRead: { service: "qchatMsg", sid: 25, cid: 6, response: [{ type: "Property", name: "qchatMultiSyncServersMessageReadTag", reflectMapper: e2.qchatMultiSyncServersMessageReadTag }] }, qchatGetMentionedMeMessages: { service: "qchatMsg", sid: 24, cid: 127, params: [{ type: "Property", name: "tag", reflectMapper: { serverId: 1, channelId: 2, timestamp: 3, limit: 4 } }], response: [{ type: "Property", name: "page", reflectMapper: e2.qchatPageQueryTag }, { type: "PropertyArray", name: "datas", reflectMapper: e2.qchatMsgTag }] } };
      };
      !function(e2) {
        e2[e2.Android = 1] = "Android", e2[e2.iOS = 2] = "iOS", e2[e2.PC = 4] = "PC", e2[e2.WindowsPhone = 8] = "WindowsPhone", e2[e2.Web = 16] = "Web", e2[e2.Server = 32] = "Server", e2[e2.Mac = 64] = "Mac", e2[e2.HarmonyOS = 65] = "HarmonyOS";
      }(xs || (xs = {}));
      var js = { "24_31": "qchatCreateServer", "24_32": "qchatDeleteServer", "24_33": "qchatUpdateServer", "24_34": "qchatGetServers", "24_35": "qchatGetServersByPage", "24_36": "qchatInviteServerMembers", "24_37": "qchatAcceptServerInvite", "24_38": "qchatRejectInviteServer", "24_39": "qchatApplyServerJoin", "24_40": "qchatAcceptServerApply", "24_41": "qchatRejectServerApply", "24_42": "qchatKickServerMembers", "24_43": "qchatLeaveServer", "24_44": "qchatUpdateMyMemberInfo", "24_45": "qchatUpdateServerMemberInfo", "24_46": "qchatGetServerMembers", "24_47": "qchatGetServerMembersByPage", "24_104": "qchatUpdateServerMemberBan", "24_105": "qchatGetBannedMembersByPage", "24_91": "qchatServerSearchByPage", "24_92": "qchatServerMemberSearchByPage", "24_122": "qchatGenerateInviteCode", "24_123": "qchatJoinByInviteCode", "24_124": "qchatGetInviteApplyRecordOfServer", "24_125": "qchatGetInviteApplyRecordOfSelf", "25_5": "qchatClearServersUnread", "25_7": "qchatSubscribeChannelsByServers", "25_10": "qchatEnterAsVisitor", "25_11": "qchatLeaveAsVisitor" }, $s = { serverInfo: { serverId: 1, name: 3, icon: 4, ext: 5, owner: 6, memberNumber: 7, inviteMode: 8, applyMode: 9, validFlag: 10, createTime: 11, updateTime: 12, channelNumber: 13, categoryNumber: 14, searchType: 15, searchEnable: 16, reorderWeight: 17 }, antispamTag: { antiSpamBusinessId: 1 }, memberInfo: { serverId: 1, accid: 3, nick: 4, avatar: 5, ext: 6, type: 7, joinTime: 8, inviter: 9, validFlag: 10, createTime: 11, updateTime: 12 }, otherMemberInfo: { serverId: 1, accid: 3, nick: 4, avatar: 5, type: 7, joinTime: 8, inviter: 9, validFlag: 10, createTime: 11, updateTime: 12 }, getServerListPageTag: { timestamp: 1, limit: 2 }, getServerMemberListPageTag: { serverId: 1, timetag: 2, limit: 3 }, updateServerMemberBanTag: { serverId: 1, opeType: 2, accid: 3, ext: 4 }, getBannedMembersByPageTag: { serverId: 1, timetag: 2, limit: 3 }, serverMemberBanInfo: { serverId: 1, appid: 2, accid: 3, ext: 4, banTime: 5, validFlag: 6, createTime: 7, updateTime: 8 }, serverSearchByPageTag: { keyword: 1, startTime: 2, endTime: 3, order: 4, limit: 5, serverType: 6, searchType: 7, sort: 8, cursor: 9 }, serverMemberSearchByPageTag: { serverId: 1, keyword: 3, limit: 4 }, inviteRespParamTag: { requestId: 1 }, applyRespParamTag: { requestId: 1, expireTime: 2 }, inviteApplyRecord: { accid: 1, type: 2, serverId: 3, status: 4, requestId: 5, createTime: 6, updateTime: 7, expireTime: 8, data: 9, recordId: 10 }, clearServersUnreadTag: { successServerIds: 1, failServerIds: 2, ackTimestamp: 3 }, unreadInfo: ss }, getDeserializeTag$1 = () => invertSerializeMap($s), getCmdConfig$1 = () => {
        var e2 = getDeserializeTag$1();
        return { qchatCreateServer: { sid: 24, cid: 31, service: "qchatServer", params: [{ type: "Property", name: "serverInfo", reflectMapper: $s.serverInfo }, { type: "Property", name: "antispamTag", reflectMapper: $s.antispamTag }], response: [{ type: "Property", name: "serverInfo", reflectMapper: e2.serverInfo }] }, qchatDeleteServer: { sid: 24, cid: 32, service: "qchatServer", params: [{ type: "Long", name: "serverId" }] }, qchatUpdateServer: { sid: 24, cid: 33, service: "qchatServer", params: [{ type: "Property", name: "serverInfo", reflectMapper: $s.serverInfo }, { type: "Property", name: "antispamTag", reflectMapper: $s.antispamTag }], response: [{ type: "Property", name: "serverInfo", reflectMapper: e2.serverInfo }] }, qchatGetServers: { sid: 24, cid: 34, service: "qchatServer", params: [{ type: "LongArray", name: "serverIds" }], response: [{ type: "PropertyArray", name: "serverList", reflectMapper: e2.serverInfo }] }, qchatGetServersByPage: { sid: 24, cid: 35, service: "qchatServer", params: [{ type: "Property", name: "tag", reflectMapper: $s.getServerListPageTag }], response: [{ type: "Property", name: "listQueryTag", reflectMapper: { 1: "hasMore", 2: "nextTimetag" } }, { type: "PropertyArray", name: "datas", reflectMapper: e2.serverInfo }] }, qchatInviteServerMembers: { sid: 24, cid: 36, service: "qchatServer", params: [{ type: "Long", name: "serverId" }, { type: "StrArray", name: "accids" }, { type: "String", name: "ps" }, { type: "Property", name: "params", reflectMapper: { ttl: 1 } }], response: [{ type: "StrArray", name: "failByOverAccids" }, { type: "StrArray", name: "failByBanAccids" }, { type: "Property", name: "record", reflectMapper: e2.applyRespParamTag }] }, qchatAcceptServerInvite: { sid: 24, cid: 37, service: "qchatServer", params: [{ type: "Long", name: "serverId" }, { type: "String", name: "accid" }, { type: "Property", name: "recordInfo", reflectMapper: $s.inviteRespParamTag }] }, qchatRejectInviteServer: { sid: 24, cid: 38, service: "qchatServer", params: [{ type: "Long", name: "serverId" }, { type: "String", name: "accid" }, { type: "String", name: "ps" }, { type: "Property", name: "recordInfo", reflectMapper: $s.inviteRespParamTag }] }, qchatApplyServerJoin: { sid: 24, cid: 39, service: "qchatServer", params: [{ type: "Long", name: "serverId" }, { type: "String", name: "ps" }, { type: "Property", name: "params", reflectMapper: { ttl: 1 } }], response: [{ type: "Property", name: "data", reflectMapper: e2.applyRespParamTag }] }, qchatAcceptServerApply: { sid: 24, cid: 40, service: "qchatServer", params: [{ type: "Long", name: "serverId" }, { type: "String", name: "accid" }, { type: "Property", name: "recordInfo", reflectMapper: $s.applyRespParamTag }] }, qchatRejectServerApply: { sid: 24, cid: 41, service: "qchatServer", params: [{ type: "Long", name: "serverId" }, { type: "String", name: "accid" }, { type: "String", name: "ps" }, { type: "Property", name: "recordInfo", reflectMapper: $s.applyRespParamTag }] }, qchatKickServerMembers: { sid: 24, cid: 42, service: "qchatServer", params: [{ type: "Long", name: "serverId" }, { type: "StrArray", name: "accids" }] }, qchatLeaveServer: { sid: 24, cid: 43, service: "qchatServer", params: [{ type: "Long", name: "serverId" }] }, qchatUpdateMyMemberInfo: { sid: 24, cid: 44, service: "qchatServer", params: [{ type: "Property", name: "memberInfo", reflectMapper: $s.memberInfo }, { type: "Property", name: "antispamTag", reflectMapper: $s.antispamTag }], response: [{ type: "Property", name: "memberInfo", reflectMapper: e2.memberInfo }] }, qchatUpdateServerMemberInfo: { sid: 24, cid: 45, service: "qchatServer", params: [{ type: "Property", name: "memberInfo", reflectMapper: $s.otherMemberInfo }, { type: "Property", name: "antispamTag", reflectMapper: $s.antispamTag }], response: [{ type: "Property", name: "memberInfo", reflectMapper: e2.memberInfo }] }, qchatGetServerMembers: { sid: 24, cid: 46, service: "qchatServer", params: [{ type: "StrArray", name: "accids" }], response: [{ type: "PropertyArray", name: "accidList", reflectMapper: e2.memberInfo }] }, qchatGetServerMembersByPage: { sid: 24, cid: 47, service: "qchatServer", params: [{ type: "Property", name: "tag", reflectMapper: $s.getServerMemberListPageTag }], response: [{ type: "Property", name: "listQueryTag", reflectMapper: { 1: "hasMore", 2: "nextTimetag" } }, { type: "PropertyArray", name: "datas", reflectMapper: e2.memberInfo }] }, qchatUpdateServerMemberBan: { sid: 24, cid: 104, service: "qchatServer", params: [{ type: "Property", name: "tag", reflectMapper: $s.updateServerMemberBanTag }] }, qchatGetBannedMembersByPage: { sid: 24, cid: 105, service: "qchatServer", params: [{ type: "Property", name: "tag", reflectMapper: $s.getBannedMembersByPageTag }], response: [{ type: "Property", name: "listQueryTag", reflectMapper: { 1: "hasMore", 2: "nextTimetag" } }, { type: "PropertyArray", name: "datas", reflectMapper: e2.serverMemberBanInfo }] }, qchatServerSearchByPage: { sid: 24, cid: 91, service: "qchatServer", params: [{ type: "Property", name: "tag", reflectMapper: $s.serverSearchByPageTag }], response: [{ type: "Property", name: "listQueryTag", reflectMapper: { 1: "hasMore", 2: "nextTimetag", 3: "cursor" } }, { type: "PropertyArray", name: "datas", reflectMapper: e2.serverInfo }] }, qchatServerMemberSearchByPage: { sid: 24, cid: 92, service: "qchatServer", params: [{ type: "Property", name: "tag", reflectMapper: $s.serverMemberSearchByPageTag }], response: [{ type: "PropertyArray", name: "members", reflectMapper: e2.memberInfo }] }, qchatGenerateInviteCode: { sid: 24, cid: 122, service: "qchatServer", params: [{ type: "Property", name: "tag", reflectMapper: { serverId: 1, ttl: 2 } }], response: [{ type: "Property", name: "data", reflectMapper: { 1: "serverId", 2: "requestId", 3: "inviteCode", 4: "expireTime" } }] }, qchatJoinByInviteCode: { sid: 24, cid: 123, service: "qchatServer", params: [{ type: "Property", name: "tag", reflectMapper: { serverId: 1, inviteCode: 2, ps: 3 } }] }, qchatGetInviteApplyRecordOfServer: { sid: 24, cid: 124, service: "qchatServer", params: [{ type: "Property", name: "tag", reflectMapper: { serverId: 1, fromTime: 2, toTime: 3, reverse: 4, limit: 5, cursor: 6 } }], response: [{ type: "PropertyArray", name: "data", reflectMapper: e2.inviteApplyRecord }] }, qchatGetInviteApplyRecordOfSelf: { sid: 24, cid: 125, service: "qchatServer", params: [{ type: "Property", name: "tag", reflectMapper: { fromTime: 1, toTime: 2, reverse: 3, limit: 4, cursor: 5 } }], response: [{ type: "PropertyArray", name: "data", reflectMapper: e2.inviteApplyRecord }] }, qchatClearServersUnread: { sid: 25, cid: 5, service: "qchatServer", params: [{ type: "LongArray", name: "serverIds" }], response: [{ type: "Property", name: "clearServersUnreadTag", reflectMapper: e2.clearServersUnreadTag }] }, qchatSubscribeChannelsByServers: { sid: 25, cid: 7, service: "qchatServer", params: [{ type: "Int", name: "type" }, { type: "LongArray", name: "serverIds" }], response: [{ type: "PropertyArray", name: "unreadInfos", reflectMapper: e2.unreadInfo }, { type: "String", name: "failServerIds" }] }, qchatEnterAsVisitor: { sid: 25, cid: 10, service: "qchatServer", params: [{ type: "Property", name: "tag", reflectMapper: { serverIds: 1 } }], response: [{ type: "String", name: "failServerIds" }] }, qchatLeaveAsVisitor: { sid: 25, cid: 11, service: "qchatServer", params: [{ type: "Property", name: "tag", reflectMapper: { serverIds: 1 } }], response: [{ type: "String", name: "failServerIds" }] } };
      }, Gs = { "24_61": "qchatCreateServerRole", "24_62": "qchatDeleteServerRole", "24_63": "qchatUpdateServerRole", "24_64": "qchatGetServerRoles", "24_65": "qchatAddChannelRole", "24_66": "qchatRemoveChannelRole", "24_67": "qchatUpdateChannelRole", "24_68": "qchatGetChannelRoles", "24_69": "qchatAddMemberRole", "24_70": "qchatRemoveMemberRole", "24_71": "qchatUpdateMemberRole", "24_72": "qchatGetMemberRoles", "24_73": "qchatAddMembersToServerRole", "24_74": "qchatRemoveMembersFromServerRole", "24_75": "qchatGetMembersFromServerRole", "24_76": "qchatGetServerRolesByAccid", "24_77": "qchatGetExistingServerRolesByAccids", "24_78": "qchatGetExistingChannelRolesByServerRoleIds", "24_79": "qchatGetExistingAccidsOfMemberRoles", "24_80": "qchatUpdateServerRolePriorities", "24_81": "qchatGetExistingAccidsInServerRole", "24_82": "qchatCheckPermission", "24_83": "qchatAddChannelCategoryRole", "24_84": "qchatRemoveChannelCategoryRole", "24_85": "qchatUpdateChannelCategoryRole", "24_86": "qchatGetChannelCategoryRole", "24_87": "qchatAddChannelCategoryMemberRole", "24_88": "qchatRemoveChannelCategoryMemberRole", "24_89": "qchatUpdateChannelCategoryMemberRole", "24_90": "qchatGetChannelCategoryMemberRole", "24_126": "qchatCheckPermissions" }, Hs = { channelRole: { serverId: 1, roleId: 2, parentRoleId: 3, channelId: 4, name: 5, icon: 6, ext: 7, auths: 8, type: 9, createTime: 10, updateTime: 11 }, memberRole: { serverId: 1, id: 2, accid: 3, channelId: 4, auths: 5, createTime: 6, updateTime: 7, nick: 8, avatar: 9, ext: 10, memberType: 11, joinTime: 12, inviter: 13 }, antispamTag: { antiSpamBusinessId: 1 }, serverRole: { serverId: 1, roleId: 2, name: 3, icon: 4, ext: 5, auths: 6, type: 7, memberCount: 8, priority: 9, createTime: 10, updateTime: 11, isMember: 12 }, getRoleByPagesTag: { serverId: 1, channelId: 2, time: 3, limit: 4 }, checkPermissionTag: { serverId: 1, channelId: 2, auth: 3 }, member: { serverId: 1, roleId: 2, accid: 3, createTime: 4, updateTime: 5, nick: 6, avatar: 7, ext: 8, type: 9, joinTime: 10, inviter: 11 }, qchatAddChannelCategoryRoleTag: { categoryId: 3, serverId: 4, parentRoleId: 5 }, channelCategoryRole: { roleId: 1, categoryId: 3, serverId: 4, parentRoleId: 5, type: 6, validFlag: 7, createTime: 8, updateTime: 9, auths: 10, name: 11, icon: 12, ext: 13 }, qchatGetChannelCategoryRoleTag: { serverId: 1, categoryId: 2, timetag: 3, limit: 4 }, channelCategoryMemberRole: { id: 1, accid: 3, categoryId: 4, serverId: 5, validFlag: 6, createTime: 7, updateTime: 8, auths: 9, nick: 10, avatar: 11, ext: 12, memberType: 13, joinTime: 14, inviter: 15 }, qchatGetChannelCategoryMemberRoleTag: { serverId: 1, categoryId: 2, timetag: 3, limit: 4 }, checkPermissionsTag: { serverId: 1, channelId: 2, auths: 3 } }, getDeserializeTag = () => invertSerializeMap(Hs), getCmdConfig = () => {
        var e2 = getDeserializeTag();
        return { qchatCreateServerRole: { service: "qchatRole", sid: 24, cid: 61, params: [{ type: "Property", name: "serverRole", reflectMapper: Hs.serverRole }, { type: "Property", name: "antispamTag", reflectMapper: Hs.antispamTag }], response: [{ type: "Property", name: "serverRole", reflectMapper: e2.serverRole }] }, qchatDeleteServerRole: { service: "qchatRole", sid: 24, cid: 62, params: [{ type: "Long", name: "serverId" }, { type: "Long", name: "roleId" }] }, qchatUpdateServerRole: { service: "qchatRole", sid: 24, cid: 63, params: [{ type: "Property", name: "updateServerRoleTag", reflectMapper: { serverId: 1, roleId: 2, name: 3, icon: 4, ext: 5, auths: 6, priority: 7 } }, { type: "Property", name: "antispamTag", reflectMapper: Hs.antispamTag }], response: [{ type: "Property", name: "serverRole", reflectMapper: e2.serverRole }] }, qchatGetServerRoles: { service: "qchatRole", sid: 24, cid: 64, params: [{ type: "Property", name: "getServerRolesTag", reflectMapper: { serverId: 1, timetag: 2, limit: 3, priority: 4, channelId: 5, categoryId: 6 } }], response: [{ type: "PropertyArray", name: "serverRoles", reflectMapper: e2.serverRole }] }, qchatAddChannelRole: { service: "qchatRole", sid: 24, cid: 65, params: [{ type: "Property", name: "channelRole", reflectMapper: Hs.channelRole }], response: [{ type: "Property", name: "channelRole", reflectMapper: e2.channelRole }] }, qchatRemoveChannelRole: { service: "qchatRole", sid: 24, cid: 66, params: [{ type: "Long", name: "serverId" }, { type: "Long", name: "channelId" }, { type: "Long", name: "roleId" }] }, qchatUpdateChannelRole: { service: "qchatRole", sid: 24, cid: 67, params: [{ type: "Property", name: "updateChannelRoleTag", reflectMapper: { serverId: 1, roleId: 2, channelId: 3, auths: 4 } }], response: [{ type: "Property", name: "channelRole", reflectMapper: e2.channelRole }] }, qchatGetChannelRoles: { service: "qchatRole", sid: 24, cid: 68, params: [{ type: "Property", name: "getChannelRolesTag", reflectMapper: { serverId: 1, channelId: 2, timetag: 3, limit: 4 } }], response: [{ type: "PropertyArray", name: "channelRoles", reflectMapper: e2.channelRole }] }, qchatAddMemberRole: { service: "qchatRole", sid: 24, cid: 69, params: [{ type: "Property", name: "memberRole", reflectMapper: Hs.memberRole }], response: [{ type: "Property", name: "memberRole", reflectMapper: e2.memberRole }] }, qchatRemoveMemberRole: { service: "qchatRole", sid: 24, cid: 70, params: [{ type: "Property", name: "memberRole", reflectMapper: Hs.memberRole }] }, qchatUpdateMemberRole: { service: "qchatRole", sid: 24, cid: 71, params: [{ type: "Property", name: "updateMemberRoleTag", reflectMapper: { serverId: 1, accid: 2, channelId: 3, auths: 4 } }], response: [{ type: "Property", name: "memberRole", reflectMapper: e2.memberRole }] }, qchatGetMemberRoles: { service: "qchatRole", sid: 24, cid: 72, params: [{ type: "Property", name: "getMemberRolesTag", reflectMapper: { serverId: 1, channelId: 2, timetag: 3, limit: 4 } }], response: [{ type: "PropertyArray", name: "memberRoles", reflectMapper: e2.memberRole }] }, qchatAddMembersToServerRole: { service: "qchatRole", sid: 24, cid: 73, params: [{ type: "Long", name: "serverId" }, { type: "Long", name: "roleId" }, { type: "String", name: "accids" }], response: [{ type: "Property", name: "accids", reflectMapper: { 1: "successAccids", 2: "failedAccids" } }] }, qchatRemoveMembersFromServerRole: { service: "qchatRole", sid: 24, cid: 74, params: [{ type: "Long", name: "serverId" }, { type: "Long", name: "roleId" }, { type: "String", name: "accids" }], response: [{ type: "Property", name: "accids", reflectMapper: { 1: "successAccids", 2: "failedAccids" } }] }, qchatGetMembersFromServerRole: { service: "qchatRole", sid: 24, cid: 75, params: [{ type: "Property", name: "getMembersFromServerRoleTag", reflectMapper: { serverId: 1, roleId: 2, timetag: 3, accid: 4, limit: 5 } }], response: [{ type: "PropertyArray", name: "members", reflectMapper: e2.member }] }, qchatGetServerRolesByAccid: { service: "qchatRole", sid: 24, cid: 76, params: [{ type: "Property", name: "getServerRolesByAccidTag", reflectMapper: { serverId: 1, accid: 2, timetag: 3, limit: 4 } }], response: [{ type: "PropertyArray", name: "serverRoles", reflectMapper: e2.serverRole }] }, qchatGetExistingServerRolesByAccids: { service: "qchatRole", sid: 24, cid: 77, params: [{ type: "Long", name: "serverId" }, { type: "String", name: "accids" }], response: [{ type: "String", name: "serverRoles" }] }, qchatGetExistingChannelRolesByServerRoleIds: { service: "qchatRole", sid: 24, cid: 78, params: [{ type: "Long", name: "serverId" }, { type: "Long", name: "channelId" }, { type: "String", name: "roleIds" }], response: [{ type: "PropertyArray", name: "channelRoles", reflectMapper: e2.channelRole }] }, qchatGetExistingAccidsOfMemberRoles: { service: "qchatRole", sid: 24, cid: 79, params: [{ type: "Long", name: "serverId" }, { type: "Long", name: "channelId" }, { type: "String", name: "accids" }], response: [{ type: "PropertyArray", name: "memberRoles", reflectMapper: e2.memberRole }] }, qchatUpdateServerRolePriorities: { service: "qchatRole", sid: 24, cid: 80, params: [{ type: "Long", name: "serverId" }, { type: "PropertyArray", name: "serverRoles", reflectMapper: { serverId: 1, roleId: 2, priority: 7 } }], response: [{ type: "PropertyArray", name: "serverRoles", reflectMapper: e2.serverRole }] }, qchatGetExistingAccidsInServerRole: { service: "qchatRole", sid: 24, cid: 81, params: [{ type: "Long", name: "serverId" }, { type: "Long", name: "roleId" }, { type: "String", name: "accids" }], response: [{ type: "PropertyArray", name: "members", reflectMapper: e2.member }] }, qchatCheckPermission: { service: "qchatRole", sid: 24, cid: 82, params: [{ type: "Property", name: "checkPermissionTag", reflectMapper: Hs.checkPermissionTag }], response: [{ type: "Bool", name: "checked" }] }, qchatAddChannelCategoryRole: { service: "qchatRole", sid: 24, cid: 83, params: [{ type: "Property", name: "qchatAddChannelCategoryRoleTag", reflectMapper: Hs.channelCategoryRole }], response: [{ type: "Property", name: "channelCategoryRole", reflectMapper: e2.channelCategoryRole }] }, qchatRemoveChannelCategoryRole: { service: "qchatRole", sid: 24, cid: 84, params: [{ type: "Long", name: "serverId" }, { type: "Long", name: "categoryId" }, { type: "Long", name: "roleId" }] }, qchatUpdateChannelCategoryRole: { service: "qchatRole", sid: 24, cid: 85, params: [{ type: "Property", name: "qchatUpdateChannelCategoryRoleTag", reflectMapper: Hs.channelCategoryRole }], response: [{ type: "Property", name: "channelCategoryRole", reflectMapper: e2.channelCategoryRole }] }, qchatGetChannelCategoryRole: { service: "qchatRole", sid: 24, cid: 86, params: [{ type: "Property", name: "qchatGetChannelCategoryRoleTag", reflectMapper: Hs.qchatGetChannelCategoryRoleTag }], response: [{ type: "PropertyArray", name: "list", reflectMapper: e2.channelCategoryRole }] }, qchatAddChannelCategoryMemberRole: { service: "qchatRole", sid: 24, cid: 87, params: [{ type: "Property", name: "qchatAddChannelCategoryMemberRoleTag", reflectMapper: Hs.channelCategoryMemberRole }], response: [{ type: "Property", name: "channelCategoryMemberRole", reflectMapper: e2.channelCategoryMemberRole }] }, qchatRemoveChannelCategoryMemberRole: { service: "qchatRole", sid: 24, cid: 88, params: [{ type: "Long", name: "serverId" }, { type: "Long", name: "categoryId" }, { type: "String", name: "accid" }] }, qchatUpdateChannelCategoryMemberRole: { service: "qchatRole", sid: 24, cid: 89, params: [{ type: "Property", name: "qchatUpdateChannelCategoryMemberRoleTag", reflectMapper: Hs.channelCategoryMemberRole }], response: [{ type: "Property", name: "channelCategoryMemberRole", reflectMapper: e2.channelCategoryMemberRole }] }, qchatGetChannelCategoryMemberRole: { service: "qchatRole", sid: 24, cid: 90, params: [{ type: "Property", name: "qchatGetChannelCategoryMemberRoleTag", reflectMapper: Hs.qchatGetChannelCategoryMemberRoleTag }], response: [{ type: "PropertyArray", name: "list", reflectMapper: e2.channelCategoryMemberRole }] }, qchatCheckPermissions: { service: "qchatRole", sid: 24, cid: 126, params: [{ type: "Property", name: "checkPermissionsTag", reflectMapper: Hs.checkPermissionsTag }], response: [{ type: "PropertyArray", name: "checkPermissionsResult", reflectMapper: { 1: "auth", 2: "isAllow" } }] } };
      }, zs = ["image", "audio", "video", "file"], Ws = { time: { type: "number" }, updateTime: { type: "number" }, resendFlag: { type: "boolean" }, persistEnable: { type: "boolean" }, routeEnable: { type: "boolean" }, pushEnable: { type: "boolean" }, needBadge: { type: "boolean" }, needPushNick: { type: "boolean" }, type: { type: "enum", values: Rs }, fromClientType: { type: "enum", values: xs }, status: { type: "number" }, toAccids: { type: "object" }, toType: { type: "number" }, attach: { type: "object" }, pushPayload: { type: "object" } };
      function generatorSysMsgForCmd(e2, t2) {
        var r2 = Object.assign({}, e2), i2 = Object.assign({ type: t2 || Rs.custom }, formatReverse(Ws, r2));
        return i2.serverId && i2.channelId && i2.toAccids ? i2.toType = 4 : i2.serverId && i2.toAccids ? i2.toType = 3 : i2.serverId && i2.channelId ? i2.toType = 2 : i2.serverId ? i2.toType = 1 : i2.toAccids ? i2.toType = 5 : i2.toType = 0, i2;
      }
      var Ks = { [Rs.channelUpdateWhiteBlackIdentify]: function(e2) {
        var t2 = getDeserializeTag$4();
        return e2.notify = formatUpdateWhiteBlackRole(deserialize(e2.notify, t2.qchatUpdateWhiteBlackRoleTag)), e2;
      }, [Rs.channelUpdateWhiteBlackIdentifyUser]: function(e2) {
        var t2 = getDeserializeTag$4();
        return e2.notify = function formatUpdateWhiteBlackMembers(e3) {
          return format(cs, e3);
        }(deserialize(e2.notify, t2.qchatUpdateWhiteBlackMembersTag)), e2;
      }, [Rs.updateQuickComment]: function(e2) {
        var t2 = getDeserializeTag$2();
        return e2.notify = function formatQuickCommentRequest(e3) {
          return format(Qs, e3);
        }(deserialize(e2.notify, t2.qchatQuickCommentRequestTag)), e2;
      }, [Rs.channelCategoryCreate]: function(e2) {
        var t2 = getDeserializeTag$4();
        return e2.categoryInfo = formatChannelCategory(deserialize(e2.categoryInfo, t2.QChatChannelCategoryInfo)), e2;
      }, [Rs.channelCategoryUpdate]: function(e2) {
        var t2 = getDeserializeTag$4();
        return e2.categoryInfo = formatChannelCategory(deserialize(e2.categoryInfo, t2.QChatChannelCategoryInfo)), e2;
      }, [Rs.channelCategoryUpdateWhiteBlackIdentify]: function(e2) {
        var t2 = getDeserializeTag$4();
        return e2.notify = formatUpdateWhiteBlackRole(deserialize(e2.notify, t2.qchatUpdateChannelCategoryWhiteBlackRoleTag)), e2;
      }, [Rs.channelCategoryUpdateWhiteBlackIdentifyUser]: function(e2) {
        var t2 = getDeserializeTag$4();
        return e2.notify = formatUpdateWhiteBlackRole(deserialize(e2.notify, t2.qchatUpdateChannelCategoryWhiteBlackMembersTag)), e2;
      }, [Rs.serverIdentifyAdd]: function(e2) {
        var t2 = getDeserializeTag();
        return e2.serverIdentifyInfo = formatRole(deserialize(e2.serverIdentifyInfo, t2.serverRole)), e2;
      }, [Rs.serverIdentifyRemove]: function(e2) {
        var t2 = getDeserializeTag();
        return e2.serverIdentifyInfo = formatRole(deserialize(e2.serverIdentifyInfo, t2.serverRole)), e2;
      }, [Rs.serverIdentifyUpdate]: function(e2) {
        var t2 = getDeserializeTag();
        return e2.serverIdentifyInfo = formatRole(deserialize(e2.serverIdentifyInfo, t2.serverRole)), e2;
      }, [Rs.channelIdentifyUpdate]: function(e2) {
        var t2 = getDeserializeTag();
        return e2.channelIdentifyInfo = formatRole(deserialize(e2.channelIdentifyInfo, t2.channelRole)), e2;
      }, [Rs.userIdentifyUpdate]: function(e2) {
        var t2 = getDeserializeTag();
        return e2.userIdentifyInfo = formatRole(deserialize(e2.userIdentifyInfo, t2.memberRole)), e2;
      }, [Rs.myMemberInfoUpdated]: function(e2) {
        var t2 = get(e2, "userInfo.name"), r2 = get(e2, "userInfo.icon");
        return e2.updatedInfos = e2.reuseServers.map((e3) => {
          var i2 = { serverId: e3.serverId };
          return 1 == (1 & e3.bits) && "string" == typeof t2 && Object.assign(i2, { nickChanged: true, nick: t2 }), 2 == (2 & e3.bits) && "string" == typeof r2 && Object.assign(i2, { avatarChanged: true, avatar: r2 }), i2;
        }), delete e2.userInfo, delete e2.reuseServers, e2;
      } };
      function formatSystemNotification(e2, t2) {
        var r2 = format(Ws, e2);
        if (!r2.attach)
          return r2;
        var i2 = getDeserializeTag$1(), s2 = getDeserializeTag$4();
        if (r2.attach.serverInfo && (r2.attach.serverInfo = formatServer(deserialize(r2.attach.serverInfo, i2.serverInfo))), r2.attach.channelInfo && (r2.attach.channelInfo = formatChannel(deserialize(r2.attach.channelInfo, s2.channelInfo))), r2.attach.serverMember && (r2.attach.serverMember = formatMember$1(deserialize(r2.attach.serverMember, i2.memberInfo))), Ks[r2.attach.type] && (r2.attach = Ks[r2.attach.type](r2.attach)), r2.attach.updateAuths)
          try {
            r2.attach.updateAuths = formatRoleAuths(JSON.parse(r2.attach.updateAuths));
          } catch (e3) {
            t2.error("formatSystemNotification:JSON parse updateAuths error: ", e3);
          }
        return r2.attach.type && (r2.attach.rawType = r2.attach.type, r2.attach.type = Rs[r2.attach.type]), r2;
      }
      var Ys = { type: { type: "enum", values: _s }, fromClientType: { type: "enum", values: xs }, status: { type: "number" }, resendFlag: { type: "boolean" }, mentionAll: { type: "boolean" }, notifyReason: { type: "enum", values: Es }, pushEnable: { type: "boolean" }, historyEnable: { type: "boolean" }, needBadge: { type: "boolean" }, needPushNick: { type: "boolean" }, routeEnable: { type: "boolean" }, time: { type: "number" }, updateTime: { type: "number" }, mentionAccids: { type: "object" }, mentionRoleIds: { type: "object" }, accidsOfMentionedRoles: { type: "object" }, attach: { type: "object" }, pushPayload: { type: "object" }, isAntispam: { type: "boolean" }, antiSpamInfo: { useCustomContent: { type: "boolean" }, antiSpamContent: { type: "string" }, antiSpamBusinessId: { type: "string" }, antiSpamUsingYidun: { type: "boolean" }, yidunCallback: { type: "string" }, yidunAntiCheating: { type: "object" }, yidunAntiSpamExt: { type: "object" }, yidunAntiSpamRes: { type: "string" } }, replyRefer: { fromAccount: { type: "string", rawKey: "replyMsgFromAccount" }, time: { type: "number", rawKey: "replyMsgTime" }, msgIdServer: { type: "string", rawKey: "replyMsgIdServer" }, msgIdClient: { type: "string", rawKey: "replyMsgIdClient" } }, threadRefer: { fromAccount: { type: "string", rawKey: "threadMsgFromAccount" }, time: { type: "number", rawKey: "threadMsgTime" }, msgIdServer: { type: "string", rawKey: "threadMsgIdServer" }, msgIdClient: { type: "string", rawKey: "threadMsgIdClient" } } };
      function generatorMsgForCmd(e2) {
        var t2 = __rest(e2, ["onSendBefore", "onUploadStart", "onUploadDone", "onUploadProgress"]), r2 = formatReverse(Ys, t2);
        if (r2.msgIdClient = e2.resendFlag ? e2.msgIdClient : Ie(), !r2.msgIdClient)
          throw new FormatError("msgIdClient is required for resend a message", "msgIdClient", "required");
        return e2.replyMessage && e2.replyMessage.msgIdServer && (r2.replyMsgFromAccount = e2.replyMessage.fromAccount, r2.replyMsgTime = +e2.replyMessage.time, r2.replyMsgIdServer = e2.replyMessage.msgIdServer, r2.replyMsgIdClient = e2.replyMessage.msgIdClient, e2.replyMessage.threadRefer && e2.replyMessage.threadRefer.msgIdServer ? (r2.threadMsgFromAccount = e2.replyMessage.threadRefer.fromAccount, r2.threadMsgTime = +e2.replyMessage.threadRefer.time, r2.threadMsgIdServer = e2.replyMessage.threadRefer.msgIdServer, r2.threadMsgIdClient = e2.replyMessage.threadRefer.msgIdClient) : (r2.threadMsgFromAccount = e2.replyMessage.fromAccount, r2.threadMsgTime = +e2.replyMessage.time, r2.threadMsgIdServer = e2.replyMessage.msgIdServer, r2.threadMsgIdClient = e2.replyMessage.msgIdClient), delete r2.replyMessage), r2;
      }
      function formatMsgOperatorInfo(e2) {
        return format({ operatorClientType: { type: "enum", values: xs }, pushPayload: { type: "object" } }, e2);
      }
      function formatMsg(e2, t2 = {}, r2) {
        var i2, s2;
        return __awaiter(this, void 0, void 0, function* () {
          var n2 = format(Ys, e2);
          n2.deliveryStatus = t2.deliveryStatus ? Cs[t2.deliveryStatus] : Cs[Cs.success], t2.time && (n2.time = t2.time);
          var a2 = getDeserializeTag$2();
          if (n2.updateContent) {
            var o2 = JSON.parse(n2.updateContent);
            o2 = format({ status: { type: "number" } }, o2 = deserialize(o2, a2.qchatMsgTag)), n2.updateContent = o2;
          }
          if (n2.updateOperatorInfo) {
            var c2 = JSON.parse(n2.updateOperatorInfo);
            c2 = formatMsgOperatorInfo(deserialize(c2, a2.qchatMsgUpdateTag)), n2.updateOperatorInfo = c2;
          }
          return "" === (null === (i2 = null == n2 ? void 0 : n2.threadRefer) || void 0 === i2 ? void 0 : i2.fromAccount) && delete n2.threadRefer, "" === (null === (s2 = null == n2 ? void 0 : n2.replyRefer) || void 0 === s2 ? void 0 : s2.fromAccount) && delete n2.replyRefer, n2.attach && t2.attachUrl && (n2.attach.url = t2.attachUrl), yield function formatMsgAttach(e3, t3) {
            return __awaiter(this, void 0, void 0, function* () {
              if (!(zs.includes(e3.type) && e3.attach && e3.attach.url))
                return e3;
              if (!t3 || !t3.cloudStorage || "function" != typeof t3.cloudStorage.getPrivateUrl || "function" != typeof t3.cloudStorage.getOriginUrl)
                return e3;
              if (e3.attach.url.indexOf("_im_url=1") < 0)
                return e3.attach.url = t3.cloudStorage.getPrivateUrl(e3.attach.url), e3;
              try {
                e3.attach.url = yield t3.cloudStorage.getOriginUrl(e3.attach.url);
              } catch (t4) {
                throw new FormatError(`url "${e3.attach.url}" parse error`, "message.attach.url", "parse error");
              }
              return e3;
            });
          }(n2, r2);
        });
      }
      function formatMsgs(e2, t2 = {}, r2) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!(Array.isArray(e2) && e2.length > 0))
            return [];
          var i2 = e2.map((e3) => formatMsg(e3, t2, r2));
          return yield Promise.all(i2);
        });
      }
      var Js = { totalCount: { type: "number" }, lastUpdateTime: { type: "number" }, details: { type: "object" } };
      var Qs = { type: { type: "number" }, time: { type: "number" }, opeType: { type: "number" } };
      var Xs = { includeSelf: { type: "number" }, order: { type: "enum", values: es }, sort: { type: "enum", values: Ts }, msgTypes: { type: "object" }, subTypes: { type: "object" } };
      var Zs = { hasMore: { type: "boolean" }, nextTimetag: { type: "number" }, cursor: { type: "string" } };
      var en = { 6: function(e2) {
        return this.core.qchatChannel.subscribeForVisitorService.deleteAutoSetInServerId(e2.serverId), true;
      }, 16: function(e2) {
        return this.core.qchatChannel.subscribeForVisitorService.deleteAutoSetInChannel(e2.serverId, e2.channelId), true;
      }, 26: function(e2) {
        var t2 = get(e2, "attach.addAccids");
        return t2 && t2.includes(this.core.account) && this.core.eventBus.emit("qchatChannel/serverIdentifyChange", e2), true;
      }, 27: function(e2) {
        var t2 = get(e2, "attach.deleteAccids");
        return t2 && t2.includes(this.core.account) && this.core.eventBus.emit("qchatChannel/serverIdentifyChange", e2), true;
      }, 31: function(e2) {
        var t2, r2;
        return 1 === e2.attach.event ? (null === (r2 = null === (t2 = this.core.qchatChannel) || void 0 === t2 ? void 0 : t2.config) || void 0 === r2 ? void 0 : r2.autoSubscribe) && this.core.qchatChannel.subscribeChannel({ type: 1, opeType: 1, channels: [{ serverId: e2.serverId, channelId: e2.channelId }], isInternalTrigger: true }) : 2 === e2.attach.event && (this.core.eventBus.emit("qchatChannel/autoUnSubscribe", e2), this.core.eventBus.emit("qchatMedia/serverOrChannelLeave", e2)), true;
      }, 32: function(e2) {
        var t2, r2;
        return 2 === e2.attach.event ? (this.core.eventBus.emit("qchatChannel/autoUnSubscribe", e2), this.core.eventBus.emit("qchatMedia/serverOrChannelLeave", e2)) : 1 === e2.attach.event && (this.core.qchatChannel.subscribeForVisitorService.deleteServer(e2.serverId), (null === (r2 = null === (t2 = this.core.qchatChannel) || void 0 === t2 ? void 0 : t2.config) || void 0 === r2 ? void 0 : r2.autoSubscribe) && this.core.qchatServer.subscribeServer({ type: 4, opeType: 1, servers: [{ serverId: e2.serverId }], isInternalTrigger: true })), true;
      }, 34: function(e2) {
        return 2 === e2.attach.event && this.core.qchatChannel.subscribeForVisitorService.unSubscribeChannel(e2.serverId, e2.channelId), true;
      }, 101: function(e2) {
        var t2 = pick(e2, ["serverId", "channelId", "ext", "fromAccount", "fromNick", "time"]);
        return this.logger.log("qchat on recvTypingEvent: ", t2), this.core.emit("recvTypingEvent", t2), this.core.qchatMsg.emit("recvTypingEvent", t2), false;
      } };
      class NotificationModuleService {
        constructor(e2) {
          this.core = e2, this.logger = e2.logger;
        }
        sendSystemNotification(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            var t2 = formatSystemNotification((yield this.core.sendCmd("qchatSendCustomSysMsg", { sysMsg: generatorSysMsgForCmd(e2) })).content.sysMsg, this.logger);
            return this.logger.getDebugMode() ? this.logger.debug("sendCustomSysMsg success", t2) : this.logger.log("sendCustomSysMsg success", t2.serverId, t2.channelId, t2.msgIdServer), t2;
          });
        }
        updateSystemNotification(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            var { systemNotification: t2 } = e2, r2 = __rest(e2, ["systemNotification"]), i2 = generatorSysMsgForCmd(pick(t2, ["msgIdServer", "type", "body", "ext", "status"]));
            return formatSystemNotification((yield this.core.sendCmd("qchatUpdateSystemNotification", { sysMsg: i2, qchatMsgUpdateTag: Object.assign(Object.assign({}, r2), { operatorAccount: this.core.account, operatorClientType: xs.Web, pushPayload: JSON.stringify(e2.pushPayload), routeEnable: Xe.boolean(e2, "routeEnable") }) })).content.sysMsg, this.logger);
          });
        }
        markSystemNotificationsRead(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            yield this.core.sendCmd("qchatMarkSysMsgRead", { sysMsgs: e2.systemNotifications.map((e3) => function generatorSysMsgMarkersForCmd(e4) {
              var t2 = pick(e4, ["msgIdServer", "type"]);
              return formatReverse(Ws, t2);
            }(e3)) });
          });
        }
        onSysMsg(e2) {
          var t2 = e2.content.sysMsg;
          if (t2) {
            var r2 = formatSystemNotification(t2, this.core.logger), i2 = en[Rs[r2.type]];
            if (i2) {
              if (false === i2.call(this, r2))
                return;
            }
            var s2 = { feature: "default", systemNotifications: [r2] };
            this.logger.log("qchat on systemNotification: ", s2), this.core.emit("systemNotification", s2), this.core.qchatMsg.emit("systemNotification", s2);
          } else
            this.core.logger.warn("No sysMsg in onSysMsg packet");
        }
        onMultiSysMsg(e2) {
          var t2 = e2.content.sysMsg;
          if (t2) {
            var r2 = formatSystemNotification(t2, this.logger);
            this.core.emit("systemNotificationUpdate", r2), this.core.qchatMsg.emit("systemNotificationUpdate", r2);
          }
        }
        onSyncSysMsg(e2) {
          var t2 = e2.content.systemNotifications;
          if (t2 && t2.length > 0) {
            var r2 = t2.map((e3) => formatSystemNotification(e3, this.logger));
            this.core.emit("systemNotification", { feature: "sync", systemNotifications: r2 }), this.core.qchatMsg.emit("systemNotification", { feature: "sync", systemNotifications: r2 });
          } else
            this.logger.warn("sync system notification not exist");
        }
      }
      var tn = ["image", "audio", "video", "file"];
      class MessageModuleService {
        constructor(e2) {
          this.markMessageRead = throttle((e3) => __awaiter(this, void 0, void 0, function* () {
            var t2 = formatUnreadInfo((yield this.core.sendCmd("qchatMarkMessageRead", { markMsgReadTag: e3 })).content.unreadInfo);
            this.core.eventBus.emit("qchatChannel/updateUnreads", [t2]);
          }), 200), this.core = e2, this.logger = e2.logger;
        }
        sendMessage(e2) {
          var t2, r2, i2, s2;
          return __awaiter(this, void 0, void 0, function* () {
            tn.indexOf(e2.type) > -1 && (e2.attach = yield this.doSendFile(e2));
            var n2, a2 = generatorMsgForCmd(Object.assign({ fromAccount: this.core.account }, e2)), o2 = yield formatMsg(a2, { time: (/* @__PURE__ */ new Date()).getTime(), deliveryStatus: Cs.sending }, this.core);
            try {
              e2.onSendBefore && e2.onSendBefore(o2);
            } catch (e3) {
              this.logger.error("sendMsg: options.onSendBefore error", e3);
            }
            try {
              n2 = yield this.core.sendCmd("qchatSendMsg", { qchatMsg: a2 });
            } catch (e3) {
              var c2 = yield formatMsg(a2, { time: (/* @__PURE__ */ new Date()).getTime(), deliveryStatus: Cs.failed, attachUrl: null === (t2 = o2.attach) || void 0 === t2 ? void 0 : t2.url }, this.core);
              throw e3.msg = c2, e3;
            }
            var { content: d2 } = n2, l2 = yield formatMsg(Object.assign({}, d2.qchatMsg), { deliveryStatus: Cs.success, attachUrl: null === (r2 = o2.attach) || void 0 === r2 ? void 0 : r2.url }, this.core);
            if (l2.isAntispam)
              throw { code: 10403, msg: l2, message: (null === (i2 = null == l2 ? void 0 : l2.antiSpamInfo) || void 0 === i2 ? void 0 : i2.yidunAntiSpamRes) || "message has be antispam", isAntispam: true, yidunAntiSpamRes: (null === (s2 = null == l2 ? void 0 : l2.antiSpamInfo) || void 0 === s2 ? void 0 : s2.yidunAntiSpamRes) || "" };
            return l2;
          });
        }
        doSendFile(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ type: { type: "enum", values: ["image", "audio", "video", "file"] }, attach: { type: "object", rules: { url: { type: "string", allowEmpty: false } }, required: false }, maxSize: { type: "number", min: 1, required: false } }, e2);
            var t2 = e2.attach;
            if (!t2) {
              if (!this.core.cloudStorage || !this.core.cloudStorage.uploadFile)
                throw new Error('Service "cloudStorage" does not exist');
              try {
                t2 = yield this.core.cloudStorage.uploadFile(e2);
              } catch (e3) {
                throw this.logger.error("sendFile:: upload File error or abort.", e3), e3;
              }
            }
            return t2;
          });
        }
        resendMessage(e2) {
          var t2, r2;
          return __awaiter(this, void 0, void 0, function* () {
            var i2, s2 = generatorMsgForCmd(Object.assign(Object.assign({}, e2), { resendFlag: true }));
            s2.deliveryStatus = Cs.sending;
            try {
              i2 = yield this.core.sendCmd("qchatSendMsg", { qchatMsg: s2 });
            } catch (e3) {
              var n2 = yield formatMsg(s2, { time: (/* @__PURE__ */ new Date()).getTime(), deliveryStatus: Cs.failed }, this.core);
              throw e3.msg = n2, e3;
            }
            var { content: a2 } = i2, o2 = yield formatMsg(Object.assign({}, a2.qchatMsg), { deliveryStatus: Cs.success }, this.core);
            if (o2.isAntispam)
              throw { code: 10403, msg: o2, message: (null === (t2 = null == o2 ? void 0 : o2.antiSpamInfo) || void 0 === t2 ? void 0 : t2.yidunAntiSpamRes) || "message has be antispam", isAntispam: true, yidunAntiSpamRes: (null === (r2 = null == o2 ? void 0 : o2.antiSpamInfo) || void 0 === r2 ? void 0 : r2.yidunAntiSpamRes) || "" };
            return o2;
          });
        }
        doUpdateMessage(e2) {
          var t2, r2;
          return __awaiter(this, void 0, void 0, function* () {
            var { message: i2 } = e2, s2 = __rest(e2, ["message"]), n2 = generatorMsgForCmd(i2);
            n2.msgIdClient = void 0, n2.time = i2.time;
            var a2 = yield this.core.sendCmd("qchatUpdateMessage", { qchatMsg: n2, qchatMsgUpdateTag: Object.assign(Object.assign({}, s2), { operatorAccount: this.core.account, operatorClientType: xs.Web, pushPayload: JSON.stringify(e2.pushPayload), routeEnable: Xe.boolean(e2, "routeEnable") }) }), o2 = yield formatMsg(a2.content.qchatMsg, {}, this.core);
            if (this.core.eventBus.emit("qchatChannel/changeUnread", o2, true), a2.content.qchatMsg.isAntispam)
              throw { code: 10403, msg: n2, message: (null === (t2 = a2.content.qchatMsg) || void 0 === t2 ? void 0 : t2.yidunAntiSpamRes) || "message has be antispam", isAntispam: true, yidunAntiSpamRes: (null === (r2 = a2.content.qchatMsg) || void 0 === r2 ? void 0 : r2.yidunAntiSpamRes) || "" };
            return o2;
          });
        }
        getHistoryMessage(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            var t2 = yield this.core.sendCmd("qchatGetHistoryMsg", { getHistoryMsgTag: Object.assign(Object.assign({}, e2), { reverse: e2.reverse ? 1 : 0 }) }), { content: r2 } = t2;
            return yield Promise.all(r2.qchatMsgs.map((e3) => formatMsg(e3, {}, this.core)));
          });
        }
        getMentionedMeMessages(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            var t2 = yield this.core.sendCmd("qchatGetMentionedMeMessages", { tag: e2 }), { content: r2 } = t2;
            return { pageInfo: function formatPageInfo(e3) {
              return format(Zs, e3);
            }(r2.page), messages: yield Promise.all(r2.datas.map((e3) => formatMsg(e3, {}, this.core))) };
          });
        }
        areMentionedMeMessages(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            for (var t2 = {}, r2 = 0; r2 < e2.length; r2++) {
              var i2 = e2[r2];
              i2.fromAccount !== this.core.account ? t2[i2.msgIdClient] = yield this.core.qchatChannel.subscribeModuleService.getMentionedFlag(i2, true) : t2[i2.msgIdClient] = false;
            }
            return t2;
          });
        }
        getLastMessageOfChannels(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            var t2 = (yield this.core.sendCmd("qchatGetLastMessageOfChannels", { tag: e2 })).content.msgs;
            return (yield formatMsgs(t2, {}, this.core)).reduce((e3, t3) => (e3[t3.channelId] = t3, e3), {});
          });
        }
        messageSearchByPage(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            var t2, r2 = yield this.core.sendCmd("qchatMessageSearchByPage", { qchatMessageSearchByPageTag: Object.assign(Object.assign({}, (t2 = e2, formatReverse(Xs, t2))), { includeSelf: e2.includeSelf ? 1 : "" }) }), { datas: i2, listQueryTag: s2 } = r2.content, n2 = yield formatMsgs(i2, {}, this.core);
            return { listQueryTag: { hasMore: 1 == +s2.hasMore, nextTimetag: s2.nextTimetag ? parseInt(s2.nextTimetag) : 0, cursor: s2.cursor }, datas: n2 };
          });
        }
        onMsg(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            var t2 = e2.content.qchatMsg;
            if (t2) {
              var r2 = yield formatMsg(t2, {}, this.core);
              this.core.eventBus.emit("qchatChannel/changeUnread", r2, false), this.core.emit("message", r2), this.core.qchatMsg.emit("message", r2);
            } else
              this.logger.warn("No qchatMsg in qchatMsg packet");
          });
        }
        onRecvUnreadInfo(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            var t2 = e2.content.qchatMsg;
            if (t2) {
              var r2 = yield formatMsg(t2);
              this.core.eventBus.emit("qchatChannel/changeUnread", r2, false);
            }
          });
        }
        onMultiSyncRead(e2) {
          var t2 = e2.content.unreadInfo;
          if (t2) {
            var r2 = formatUnreadInfo(t2);
            this.core.eventBus.emit("qchatChannel/updateUnreads", [r2]);
          }
        }
        onMultiSyncServersRead(e2) {
          var t2 = e2.content.qchatMultiSyncServersMessageReadTag;
          if (t2) {
            var { successServerIds: r2, ackTimestamp: i2 } = formatClearServersUnread(t2);
            this.core.eventBus.emit("qchatChannel/clearUnreadCountByServers", r2, i2);
          }
        }
        onRecvMsgUpdate(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            var t2 = e2.content.qchatMsg, r2 = e2.content.qchatMsgUpdateInfo;
            if (t2) {
              var i2 = yield formatMsg(t2, {}, this.core), s2 = formatMsgOperatorInfo(r2);
              this.core.eventBus.emit("qchatChannel/changeUnread", i2, true), this.core.emit("messageUpdate", i2, s2), this.core.qchatMsg.emit("messageUpdate", i2, s2);
            }
          });
        }
      }
      class ExtendModuleService {
        constructor(e2) {
          this._sendTypingEvent = throttle((e3) => __awaiter(this, void 0, void 0, function* () {
            yield this.core.sendCmd("qchatSendCustomSysMsg", { sysMsg: generatorSysMsgForCmd(Object.assign(Object.assign({}, e3), { resendFlag: false, persistEnable: false, routeEnable: false, pushEnable: false, needBadge: false, needPushNick: false }), Rs.msgTyping) });
          }), 3e3), this.core = e2, this.logger = e2.logger, this.lastChannelIdInTyping = "";
        }
        getMessageHistoryByIds(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            var t2 = yield this.core.sendCmd("qchatGetMessageHistoryByIds", { channelInfo: { serverId: e2.serverId, channelId: e2.channelId }, messageReferList: e2.messageReferList });
            return Promise.all(t2.content.qchatMsgs.map((e3) => formatMsg(e3)));
          });
        }
        getReferMessages(e2) {
          var t2, r2;
          return __awaiter(this, void 0, void 0, function* () {
            if (!(null === (t2 = e2.message.replyRefer) || void 0 === t2 ? void 0 : t2.msgIdServer) || !(null === (r2 = e2.message.threadRefer) || void 0 === r2 ? void 0 : r2.msgIdServer))
              throw new Error("Message has no reply");
            var i2 = yield this.getMessageHistoryByIds({ serverId: e2.message.serverId, channelId: e2.message.channelId, messageReferList: [e2.message.replyRefer, e2.message.threadRefer] });
            return e2.referType === Ns[Ns.all] ? { replyMessage: i2[0], threadMessage: i2[1] } : e2.referType === Ns[Ns.reply] ? { replyMessage: i2[0] } : e2.referType === Ns[Ns.thread] ? { threadMessage: i2[1] } : { replyMessage: i2[0], threadMessage: i2[1] };
          });
        }
        getThreadMessages(e2) {
          var t2;
          return __awaiter(this, void 0, void 0, function* () {
            var r2;
            r2 = (null === (t2 = e2.message.threadRefer) || void 0 === t2 ? void 0 : t2.msgIdServer) ? Object.assign({ serverId: e2.message.serverId, channelId: e2.message.channelId }, e2.message.threadRefer) : e2.message;
            var i2 = yield this.core.sendCmd("qchatGetThreadMessages", { qchatMsg: r2, getThreadHistoryMsgTag: Object.assign(Object.assign({}, e2.messageQueryOption), { reverse: Xe.boolean(e2.messageQueryOption, "reverse") }) }), s2 = yield formatMsg(i2.content.thread), n2 = yield Promise.all(i2.content.qchatMsgs.map((e3) => formatMsg(e3)));
            return { thread: s2, threadInfo: { messageCount: +i2.content.threadInfo.messageCount, lastMessageTimestamp: +i2.content.threadInfo.lastMessageTimestamp }, messages: n2 };
          });
        }
        getThreadRootMessagesMeta(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            var { threadRootMessages: t2 } = e2, r2 = __rest(e2, ["threadRootMessages"]), i2 = (yield this.core.sendCmd("qchatGetThreadRootMessagesMeta", { qchatMsgs: t2, tag: r2 })).content.metas;
            return i2 && i2.length > 0 ? i2.map((e3) => Object.assign(Object.assign({}, e3), { total: parseInt(e3.total), timestamp: parseInt(e3.timestamp), msgTime: parseInt(e3.msgTime) })) : [];
          });
        }
        getQuickComments(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            var t2 = yield this.core.sendCmd("qchatGetQuickComments", { tag: { serverId: e2.serverId, channelId: e2.channelId, msgIdServerList: JSON.stringify(e2.msgList.map((e3) => e3.msgIdServer)) } }), { quickCommentResponse: r2 } = t2.content;
            return function formatQuickComments(e3) {
              var t3 = e3.map((e4) => {
                var t4 = format(Js, e4);
                return t4.details = t4.details.map((e5) => {
                  var t5 = e5.createTime ? parseInt(e5.createTime) : 0;
                  return t5 = isNaN(t5) ? 0 : t5, { count: e5.count, hasSelf: e5.self, severalAccids: e5.topN, type: e5.type, createTime: t5 };
                }), t4;
              }), r3 = {};
              return t3.forEach((e4) => r3[e4.msgIdServer] = e4), r3;
            }(r2);
          });
        }
        updateQuickComment(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ type: { type: "number" }, commentMessage: { type: "object", rules: { msgIdServer: { type: "string", allowEmpty: false } } } }, e2);
            var { serverId: r2, channelId: i2, fromAccount: s2, msgIdServer: n2, time: a2 } = e2.commentMessage;
            yield this.core.sendCmd("qchatUpdateQuickComment", { tag: { serverId: r2, channelId: i2, fromAccount: s2, msgIdServer: n2, time: a2, type: e2.type, opeType: t2, opeAccid: this.core.account } });
          });
        }
        sendTypingEvent(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            if (e2.channelId === this.lastChannelIdInTyping)
              return this.logger.log("qchatMsg sendTypingEvent throttle"), void this._sendTypingEvent(e2);
            this.lastChannelIdInTyping = e2.channelId, this._sendTypingEvent.flush(), this._sendTypingEvent(e2);
          });
        }
      }
      class CategoryModuleService {
        constructor(e2) {
          this.core = e2;
        }
        addChannelCategoryRole(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ serverId: { type: "string", allowEmpty: false }, categoryId: { type: "string", allowEmpty: false }, parentRoleId: { type: "string", allowEmpty: false } }, e2), formatChannelCategoryRole((yield this.core.sendCmd("qchatAddChannelCategoryRole", { qchatAddChannelCategoryRoleTag: e2 })).content.channelCategoryRole);
          });
        }
        removeChannelCategoryRole(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ serverId: { type: "string", allowEmpty: false }, categoryId: { type: "string", allowEmpty: false }, roleId: { type: "string", allowEmpty: false } }, e2), yield this.core.sendCmd("qchatRemoveChannelCategoryRole", e2);
          });
        }
        updateChannelCategoryRole(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ serverId: { type: "string", allowEmpty: false }, categoryId: { type: "string", allowEmpty: false }, roleId: { type: "string", allowEmpty: false }, auths: { type: "object" } }, e2);
            var t2 = yield this.core.sendCmd("qchatUpdateChannelCategoryRole", { qchatUpdateChannelCategoryRoleTag: generatorRoleForCmd(e2) });
            if (406 === t2.raw.code)
              throw new CustomError("No update required", {}, 406);
            return formatChannelCategoryRole(t2.content.channelCategoryRole);
          });
        }
        getChannelCategoryRole(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ serverId: { type: "string", allowEmpty: false }, categoryId: { type: "string", allowEmpty: false }, timetag: { type: "number", min: 0, required: false }, limit: { type: "number", min: 1, required: false } }, e2), function formatChannelCategoryRoles(e3) {
              return Array.isArray(e3) && e3.length > 0 ? e3.map((e4) => formatChannelCategoryRole(e4)) : [];
            }((yield this.core.sendCmd("qchatGetChannelCategoryRole", { qchatGetChannelCategoryRoleTag: e2 })).content.list);
          });
        }
        addChannelCategoryMemberRole(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ serverId: { type: "string", allowEmpty: false }, categoryId: { type: "string", allowEmpty: false }, accid: { type: "string", allowEmpty: false } }, e2), formatChannelCategoryMemberRole((yield this.core.sendCmd("qchatAddChannelCategoryMemberRole", { qchatAddChannelCategoryMemberRoleTag: e2 })).content.channelCategoryMemberRole);
          });
        }
        removeChannelCategoryMemberRole(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ serverId: { type: "string", allowEmpty: false }, categoryId: { type: "string", allowEmpty: false }, accid: { type: "string", allowEmpty: false } }, e2), yield this.core.sendCmd("qchatRemoveChannelCategoryMemberRole", e2);
          });
        }
        updateChannelCategoryMemberRole(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ serverId: { type: "string", allowEmpty: false }, categoryId: { type: "string", allowEmpty: false }, accid: { type: "string", allowEmpty: false }, auths: { type: "object" } }, e2);
            var t2 = yield this.core.sendCmd("qchatUpdateChannelCategoryMemberRole", { qchatUpdateChannelCategoryMemberRoleTag: generatorRoleForCmd(e2) });
            if (406 === t2.raw.code)
              throw new CustomError("No update required", {}, 406);
            return formatChannelCategoryMemberRole(t2.content.channelCategoryMemberRole);
          });
        }
        getChannelCategoryMemberRole(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ serverId: { type: "string", allowEmpty: false }, categoryId: { type: "string", allowEmpty: false }, timetag: { type: "number", min: 0, required: false }, limit: { type: "number", min: 1, required: false } }, e2), function formatChannelCategoryMemberRoles(e3) {
              return Array.isArray(e3) && e3.length > 0 ? e3.map((e4) => formatChannelCategoryMemberRole(e4)) : [];
            }((yield this.core.sendCmd("qchatGetChannelCategoryMemberRole", { qchatGetChannelCategoryMemberRoleTag: e2 })).content.list);
          });
        }
      }
      class V2NIMConversationIdUtilImpl {
        constructor(e2) {
          this.name = "V2NIMConversationIdUtil", this.core = e2;
        }
        conversationId(e2, t2) {
          return `${this.core.account}|${e2}|${t2}`;
        }
        p2pConversationId(e2) {
          return `${this.core.account}|1|${e2}`;
        }
        teamConversationId(e2) {
          return `${this.core.account}|2|${e2}`;
        }
        superTeamConversationId(e2) {
          return `${this.core.account}|3|${e2}`;
        }
        messageConversationId(e2) {
          return 1 === e2.conversationType ? e2.senderId === this.core.account ? this.p2pConversationId(e2.receiverId) : this.p2pConversationId(e2.senderId) : 2 === e2.conversationType ? this.teamConversationId(e2.receiverId) : this.superTeamConversationId(e2.receiverId);
        }
        parseConversationType(e2) {
          try {
            if (e2 && e2.startsWith(`${this.core.account}|`)) {
              var t2 = e2.replace(`${this.core.account}|`, "");
              return Number(t2[0]);
            }
            return this.core.logger.warn(`conversationId is not start with ${this.core.account}`), 0;
          } catch (e3) {
            return 0;
          }
        }
        parseConversationTargetId(e2) {
          try {
            return e2 && e2.startsWith(`${this.core.account}|`) ? e2.replace(`${this.core.account}|`, "").slice(2) : (this.core.logger.warn(`conversationId is not start with ${this.core.account}`), "");
          } catch (e3) {
            return "";
          }
        }
        convertToV1ConversationId(e2) {
          var t2 = this.parseConversationType(e2);
          return `${1 === t2 ? "p2p" : 2 === t2 ? "team" : "superTeam"}|${this.parseConversationTargetId(e2)}`;
        }
      }
      class V2NIMMessageModelImpl {
        constructor() {
          this.messages = /* @__PURE__ */ new Map(), this.capacity = 1e4;
        }
        reset() {
          this.messages.clear();
        }
        getMessageById(e2) {
          if (e2)
            return this.messages.get(e2);
        }
        getMessagesByConversationId(e2) {
          var t2 = [];
          return this.messages.forEach((r2) => {
            r2.conversationId === e2 && t2.push(r2);
          }), t2;
        }
        getLastMessageOfConversation(e2) {
          var t2 = this.getMessagesByConversationId(e2);
          if (0 !== t2.length)
            return t2.reduce((e3, t3) => t3.createTime > e3.createTime ? t3 : e3, t2[0]);
        }
        upsertMessages(e2) {
          e2.forEach((e3) => {
            this.setLRU(e3.messageClientId, e3);
          });
        }
        setLRU(e2, t2) {
          if (this.messages.has(e2))
            this.messages.delete(e2);
          else if (this.messages.size >= this.capacity) {
            var r2 = this.messages.keys().next().value;
            r2 && this.messages.delete(r2);
          }
          this.messages.set(e2, t2);
        }
        deleteMessage(e2) {
          this.messages.delete(e2);
        }
        deleteMessages(e2, t2) {
          this.messages.forEach((r2) => {
            e2 === r2.conversationId && (!t2 || t2 && r2.createTime < t2) && this.messages.delete(r2.messageClientId);
          });
        }
      }
      var rn = { accountId: { type: "string", allowEmpty: false }, content: { type: "object", required: false, rules: { msg: { type: "string", allowEmpty: false }, type: { type: "number", allowEmpty: false } } }, messages: { type: "array", required: false, rules: { msg: { type: "string", allowEmpty: false }, type: { type: "number" }, role: { type: "enum", values: ["assistant", "user", "system"] } } }, promptVariables: { type: "jsonstr", required: false }, modelConfigParams: { type: "object", required: false, rules: { prompt: { type: "string", required: false }, maxTokens: { type: "number", required: false }, topP: { type: "number", required: false }, temperature: { type: "number", required: false } } }, aiStream: { type: "boolean", required: false } }, sn = Object.assign({ requestId: { type: "string", allowEmpty: false } }, rn), nn = { requestId: { type: "string", allowEmpty: false }, accountId: { type: "string", allowEmpty: false } }, an = [1, 3, 2, 0], cn = [2, 7, 12, 100, 6, 1, -1, 4, 5, 11, 0, 10, 3], dn = { routeEnabled: { type: "boolean", required: false }, routeEnvironment: { type: "string", required: false } }, ln = { pushEnabled: { type: "boolean", required: false }, pushNickEnabled: { type: "boolean", required: false }, pushContent: { type: "string", required: false }, pushPayload: { type: "string", required: false }, forcePush: { type: "boolean", required: false }, forceContent: { type: "string", required: false }, forcePushAccountIds: { type: "array", required: false, itemType: "string" } }, mn = { antispamEnabled: { type: "boolean", required: false }, antispamBusinessId: { type: "string", required: false }, antispamCustomMessage: { type: "string", required: false }, antispamCheating: { type: "string", required: false }, antispamExtension: { type: "string", required: false } }, pn = { messageConfig: { type: "object", required: false, rules: { readReceiptEnabled: { type: "boolean", required: false }, lastMessageUpdateEnabled: { type: "boolean", required: false }, historyEnabled: { type: "boolean", required: false }, roamingEnabled: { type: "boolean", required: false }, onlineSyncEnabled: { type: "boolean", required: false }, offlineEnabled: { type: "boolean", required: false }, unreadEnabled: { type: "boolean", required: false } } }, routeConfig: { type: "object", required: false, rules: dn }, pushConfig: { type: "object", required: false, rules: ln }, antiSpamConfig: { type: "object", required: false, rules: mn }, robotConfig: { type: "object", required: false, rules: { accountId: { type: "string", required: false }, topic: { type: "string", required: false }, function: { type: "string", required: false }, customContent: { type: "string", required: false } } }, aiConfig: { type: "object", required: false, rules: rn }, targetConfig: { type: "object", required: false, rules: { receiverIds: { type: "array", itemType: "string" }, inclusive: { type: "boolean" }, newMemberVisible: { type: "boolean", required: false } } }, clientAntispamEnabled: { type: "boolean", required: false }, clientAntispamReplace: { type: "string", required: false } }, un = { message: { type: "object", rules: { text: { type: "string", required: false }, messageType: { type: "enum", values: cn }, messageClientId: { type: "string", allowEmpty: false } } }, params: { type: "object", rules: pn, required: false }, replyMessage: { type: "object", rules: { conversationType: { type: "enum", values: [1, 3, 2, 0] }, receiverId: { type: "string", allowEmpty: false }, senderId: { type: "string", allowEmpty: false }, messageClientId: { type: "string", allowEmpty: false }, messageServerId: { type: "string", allowEmpty: false }, createTime: { type: "number" } } } }, hn = { conversationId: { type: "string", allowEmpty: false }, message: { type: "object", rules: { text: { type: "string", required: false }, messageType: { type: "enum", values: cn }, messageClientId: { type: "string", allowEmpty: false }, attachment: { type: "object", required: false, rules: { file: { type: "file", required: false } } } } }, params: { type: "object", required: false, rules: pn } }, gn = { message: { type: "object", rules: { messageClientId: { type: "string", allowEmpty: false }, messageServerId: { type: "string", allowEmpty: false }, conversationType: { type: "enum", values: an }, createTime: { type: "number" } } }, params: { type: "object", rules: { postscript: { type: "string", required: false }, serverExtension: { type: "string", required: false }, pushContent: { type: "string", required: false }, pushPayload: { type: "string", required: false }, env: { type: "string", required: false } }, required: false } }, vn = { conversationId: { type: "string", allowEmpty: false }, messageTypes: { type: "array", required: false, itemType: "enum", values: cn }, beginTime: { type: "number", required: false }, endTime: { type: "number", required: false }, limit: { type: "number", min: 1, required: false }, direction: { type: "enum", values: [1, 0], required: false }, anchorMessage: { type: "object", required: false, rules: { messageServerId: { type: "string", allowEmpty: false }, createTime: { type: "number" } } } }, yn = { conversationType: { type: "enum", values: an }, receiverId: { type: "string", allowEmpty: false }, senderId: { type: "string", allowEmpty: false }, messageServerId: { type: "string", allowEmpty: false }, messageClientId: { type: "string", allowEmpty: false } }, fn = { messageRefers: { type: "array", required: true, rules: yn } }, In = { conversationId: { type: "string", allowEmpty: false }, conversationType: { type: "enum", values: an }, receiverId: { type: "string", allowEmpty: false }, senderId: { type: "string", allowEmpty: false }, messageClientId: { type: "string", allowEmpty: false }, createTime: { type: "number" } }, Mn = { messages: { type: "array", rules: In } }, Sn = { conversationId: { type: "string", allowEmpty: false }, serverExtension: { type: "string", required: false }, onlineSync: { type: "boolean", required: false }, deleteRoam: { type: "boolean", required: false }, clearMode: { type: "enum", values: [0, 1, 2], required: false } }, Tn = { serverExtension: { type: "string", required: false } }, _n = { messageClientId: { type: "string", allowEmpty: false }, conversationType: { type: "enum", values: [1] }, receiverId: { type: "string", allowEmpty: false }, createTime: { type: "number" } }, Cn = { messages: { type: "array", rules: { messageClientId: { type: "string", allowEmpty: false }, conversationType: { type: "enum", values: [2] }, receiverId: { type: "string", allowEmpty: false }, createTime: { type: "number" } }, min: 1 } }, En = { voiceUrl: { type: "string", required: false, allowEmpty: false }, file: { type: "file", required: false }, voicePath: { type: "string", required: false, allowEmpty: false }, mimeType: { type: "string", required: false, allowEmpty: false }, sampleRate: { type: "string", required: false, allowEmpty: false }, duration: { type: "number", required: true, min: 0 }, sceneName: { type: "string", required: false } }, bn = { message: { type: "object", rules: { conversationType: { type: "enum", values: an }, receiverId: { type: "string", allowEmpty: false }, senderId: { type: "string", allowEmpty: false }, messageServerId: { type: "string", allowEmpty: false }, messageClientId: { type: "string", allowEmpty: false }, createTime: { type: "number" } } }, index: { type: "number", min: 1 }, serverExtension: { type: "string", required: false }, pushConfig: { type: "object", required: false, rules: { pushEnabled: { type: "boolean", required: false }, needBadge: { type: "boolean", required: false }, title: { type: "string", required: false, allowEmpty: false }, content: { type: "string", required: false, allowEmpty: false }, pushPayload: { type: "string", required: false, allowEmpty: false } } } }, Rn = { messages: { type: "array", rules: { conversationType: { type: "enum", values: [1, 3, 2, 0] }, receiverId: { type: "string", allowEmpty: false }, senderId: { type: "string", allowEmpty: false }, messageServerId: { type: "string", allowEmpty: false }, messageClientId: { type: "string", allowEmpty: false }, createTime: { type: "number" } } } }, Nn = { params: { type: "object", rules: { collectionType: { type: "number", min: 1 }, collectionData: { type: "string", allowEmpty: false }, serverExtension: { type: "string", required: false }, uniqueId: { type: "string", required: false } } } }, An = { collections: { type: "array", min: 1, rules: { collectionId: { type: "string", allowEmpty: false }, createTime: { type: "number" } } } }, On = { serverExtension: { type: "string", required: false }, collection: { type: "object", rules: { collectionId: { type: "string", allowEmpty: false }, collectionType: { type: "number" }, createTime: { type: "number" } } } }, kn = { beginTime: { type: "number", required: false }, endTime: { type: "number", required: false }, limit: { type: "number", min: 1, required: false }, direction: { type: "enum", required: false, values: [1, 0] }, collectionType: { type: "number", required: false }, anchorCollection: { type: "object", required: false, rules: { collectionId: { type: "string", allowEmpty: false, required: false }, createTime: { type: "number", required: false } } } }, wn = { keyword: { type: "string", allowEmpty: false }, beginTime: { type: "number", required: false }, endTime: { type: "number", required: false }, sortOrder: { type: "enum", values: [1, 0], required: false }, conversationLimit: { type: "number", min: 0, required: false }, messageLimit: { type: "number", min: 1, required: false }, p2pAccountIds: { type: "array", required: false, itemType: "string" }, teamIds: { type: "array", required: false, itemType: "string" }, senderAccountIds: { type: "array", required: false, itemType: "string" }, messageTypes: { type: "array", required: false, itemType: "enum", values: cn }, messageSubtypes: { type: "array", required: false, itemType: "number" } }, Pn = { conversationId: { type: "string", required: false, allowEmpty: false }, keywordList: { type: "array", required: false, itemType: "string" }, keywordMatchType: { type: "enum", values: [1, 0], required: false }, senderAccountIds: { type: "array", required: false, itemType: "string" }, messageTypes: { type: "array", required: false, itemType: "enum", values: cn }, messageSubtypes: { type: "array", required: false, itemType: "number" }, searchStartTime: { type: "number", required: false }, searchTimePeriod: { type: "number", required: false }, limit: { type: "number", min: 1, required: false }, direction: { type: "enum", values: [0, 1], required: false }, pageToken: { type: "string", required: false } }, Vn = { message: { type: "object", rules: { receiverId: { type: "string", allowEmpty: false }, messageServerId: { type: "string", allowEmpty: false }, conversationType: { type: "enum", values: [2] } } } }, Ln = { messages: { type: "array", rules: { receiverId: { type: "string", allowEmpty: false }, messageServerId: { type: "string", allowEmpty: false }, conversationType: { type: "enum", values: [2] } }, min: 1 } }, Un = { sceneName: { type: "string", required: false }, name: { type: "string", required: false } }, Dn = Object.assign(Object.assign({}, Un), { duration: { type: "number", required: false } }), qn = Object.assign(Object.assign({}, Dn), { width: { type: "number", required: false }, height: { type: "number", required: false } }), xn = Object.assign(Object.assign({}, Un), { width: { type: "number", required: false }, height: { type: "number", required: false } }), Bn = { messageRefer: { type: "object", required: true, rules: yn }, beginTime: { type: "number", required: false }, endTime: { type: "number", required: false }, limit: { type: "number", min: 1, required: false }, direction: { type: "enum", values: [1, 0], required: false }, excludeMessageServerId: { type: "string", required: false, allowEmpty: false } }, Fn = { senderId: { type: "string", allowEmpty: false }, receiverId: { type: "string", allowEmpty: false }, createTime: { type: "number" }, messageClientId: { type: "string", allowEmpty: false }, messageServerId: { type: "string", allowEmpty: false } }, jn = { subType: { type: "number", min: 0, required: false }, text: { type: "string", required: false }, attachment: { type: "object", required: false }, serverExtension: { type: "string", required: false }, routeConfig: { type: "object", required: false, rules: dn }, pushConfig: { type: "object", required: false, rules: ln }, antiSpamConfig: { type: "object", required: false, rules: mn }, clientAntispamEnabled: { type: "boolean", required: false }, clientAntispamReplace: { type: "string", required: false } }, $n = { messageClientId: { type: "string", allowEmpty: false }, messageServerId: { type: "string", allowEmpty: false }, createTime: { type: "number" }, aiConfig: { type: "object", rules: rn } }, Gn = { operationType: { type: "enum", values: [0, 1, 2] }, updateContent: { type: "string", allowEmpty: true, required: false } }, Hn = { operationType: { type: "enum", values: [2, 1], required: true } };
      class ReceiptUtil {
        constructor(e2, t2) {
          this.p2pMessageReceipts = {}, this.core = e2, this.service = t2;
        }
        reset() {
          this.p2pMessageReceipts = {};
        }
        sendP2PMessageReceipt(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            if (validate(_n, e2, "", true), e2.senderId === this.core.account)
              throw new ValidateErrorV2({ detail: { reason: `sendP2PMessageReceipt. sender: ${e2.senderId} is not allowed to send msg receipt` } });
            yield this.core.sendCmd("v2SendP2PMessageReceipt", { tag: { receiverId: e2.senderId, messageClientId: e2.messageClientId, createTime: e2.createTime } });
          });
        }
        isPeerRead(e2) {
          if (1 !== e2.conversationType)
            return false;
          if (e2.senderId !== this.core.account)
            return false;
          if (e2.senderId === this.core.account && e2.receiverId === this.core.account)
            return true;
          var t2 = this.core.V2NIMConversationIdUtil.messageConversationId(e2), r2 = this.p2pMessageReceipts[t2] || 0;
          return e2.createTime <= r2;
        }
        getP2PMessageReceipt(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            if (validateConversationId(this.core.account, e2), 1 !== this.core.V2NIMConversationIdUtil.parseConversationType(e2))
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "getP2PMessageReceipt: conversationId is not p2p conversationId" } });
            return { conversationId: e2, timestamp: this.p2pMessageReceipts[e2] || 0 };
          });
        }
        getTeamMessageReceipts(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            if (validate(Ln, { messages: e2 }, "", true), e2.some((e3) => e3.senderId !== this.core.account))
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "getTeamMessageReceipts: exist messages senderId is not current user" } });
            if (e2.some((t2) => t2.receiverId !== e2[0].receiverId))
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_MISUSE, detail: { reason: "getTeamMessageReceipts: exist messages receiverId is not same" } });
            return (yield this.core.sendCmd("v2GetTeamMessageReceipts", { tag: e2 })).content.data.map((e3) => Object.assign(Object.assign({}, e3), { conversationId: this.core.V2NIMConversationIdUtil.teamConversationId(e3.receiverId) }));
          });
        }
        getTeamMessageReceiptDetail(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            if (validate(Vn, { message: e2 }, "", true), e2.senderId !== this.core.account)
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: `getTeamMessageReceiptDetail::senderId ${e2.senderId} incorrect` } });
            var t2 = yield this.core.sendCmd("v2GetTeamMessageReceiptDetail", { tag: e2 });
            return { readReceipt: { conversationId: this.core.V2NIMConversationIdUtil.teamConversationId(e2.receiverId), messageClientId: e2.messageClientId, messageServerId: e2.messageServerId, readCount: t2.content.readAccountList.length, unreadCount: t2.content.unreadAccountList.length }, readAccountList: t2.content.readAccountList, unreadAccountList: t2.content.unreadAccountList };
          });
        }
        sendTeamMessageReceipts(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            if (e2.some((t2) => t2.conversationId !== e2[0].conversationId))
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_MISUSE, detail: { reason: "getTeamMessageReceipts: conversationId not same" } });
            if (validate(Cn, { messages: e2 }, "", true), e2.some((e3) => e3.senderId === this.core.account))
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "getTeamMessageReceipts: exist messages senderId is not current user" } });
            yield this.core.sendCmd("v2SendTeamMessageReceipts", { tag: e2 });
          });
        }
        syncP2PMessagReceiptsHandler(e2) {
          var t2 = e2.content.data.map((e3) => {
            var t3 = this.core.V2NIMConversationIdUtil.p2pConversationId(e3.senderId), r2 = e3.createTime;
            return this.p2pMessageReceipts[t3] = r2, { conversationId: t3, timestamp: r2 };
          });
          this.service.emit("onReceiveP2PMessageReadReceipts", t2);
        }
        onP2PMessageReceiptsHandler(e2) {
          var t2 = this.core.V2NIMConversationIdUtil.p2pConversationId(e2.content.data.senderId), r2 = e2.content.data.createTime;
          this.p2pMessageReceipts[t2] = r2, this.service.emit("onReceiveP2PMessageReadReceipts", [{ conversationId: t2, timestamp: r2 }]);
        }
        onTeamMessageReceiptsHandler(e2) {
          var t2 = e2.content.data.map((e3) => ({ conversationId: this.core.V2NIMConversationIdUtil.teamConversationId(e3.receiverId), messageServerId: e3.messageServerId, messageClientId: e3.messageClientId, readCount: e3.readCount, unreadCount: e3.unreadCount, latestReadAccount: e3.latestReadAccount }));
          this.service.emit("onReceiveTeamMessageReadReceipts", t2);
        }
      }
      var zn = { "31_1": "v2TeamCreate", "32_1": "v2SuperTeamCreate", "31_5": "v2TeamInviteMembers", "32_5": "v2SuperTeamInviteMembers", "31_6": "v2TeamKickMembers", "32_6": "v2SuperTeamKickMembers", "31_8": "v2TeamLeave", "32_7": "v2SuperTeamLeave", "31_7": "v2TeamUpdateInfo", "32_8": "v2SuperTeamUpdateInfo", "31_9": "v2TeamGetInfo", "32_9": "v2SuperTeamGetInfo", "31_12": "v2TeamDismiss", "32_4": "v2SuperTeamDismiss", "31_13": "v2TeamApplyToJoin", "32_20": "v2SuperTeamApplyToJoin", "31_14": "v2TeamAcceptJoinApplication", "32_21": "v2SuperTeamAcceptJoinApplication", "31_15": "v2TeamRejectJoinApplication", "32_22": "v2SuperTeamRejectJoinApplication", "31_16": "v2TeamAddManagers", "32_26": "v2SuperTeamAddManagers", "31_17": "v2TeamRemoveManagers", "32_27": "v2SuperTeamRemoveManagers", "31_18": "v2TeamTransferOwner", "32_31": "v2SuperTeamTransferOwner", "31_19": "v2TeamUpdateSelfMemberInfo", "32_10": "v2SuperTeamUpdateSelfMemberInfo", "31_20": "v2TeamUpdateMember", "32_30": "v2SuperTeamUpdateMember", "31_21": "v2TeamAcceptInvitation", "32_23": "v2SuperTeamAcceptInvitation", "31_22": "v2TeamRejectInvite", "32_24": "v2SuperTeamRejectInvite", "31_33": "v2TeamGetMemberInvitor", "32_35": "v2SuperTeamGetMemberInvitor", "31_25": "v2TeamMemberSetChatBannedStatus", "32_29": "v2SuperTeamMemberSetChatBannedStatus", "31_32": "v2TeamSetChatBannedMode", "32_28": "v2SuperTeamSetChatBannedMode", "31_34": "v2TeamGetByIds", "32_36": "v2SuperTeamGetByIds", "31_35": "v2TeamMemberGetListByIds", "32_37": "v2SuperTeamMemberGetListByIds", "31_36": "v2TeamMemberGetList", "8_101": "v2TeamCreateMultiSync", "8_109": "v2TeamSync", "8_119": "v2TeamMemberUpdateMultiSync", "8_126": "v2TeamMembersOfSelfInSync", "21_101": "v2SuperTeamCreateMultiSync", "21_109": "v2SuperTeamSync", "21_110": "v2SuperTeamMemberUpdateMultiSync", "21_111": "v2SuperTeamMembersOfSelfInSync" }, Wn = { antispamBusinessId: 1 }, Kn = "V2NIMTeamService", Yn = { teamId: 1, name: 3, teamType: { id: 4, retConverter: (e2) => 0 == +e2 ? 1 : +e2 }, ownerAccountId: 5, memberLimit: { id: 6, retType: "number" }, isValidTeam: { id: 8, retConverter: (e2, t2) => 1 == +e2 && (void 0 === t2[13] || 1 == +t2[13]) }, memberCount: { id: 9, retType: "number" }, memberUpdateTime: { id: 10, retType: "number" }, createTime: { id: 11, retType: "number" }, updateTime: { id: 12, retType: "number" }, intro: 14, announcement: 15, joinMode: { id: 16, retType: "number" }, serverExtension: 18, customerExtension: 19, avatar: 20, agreeMode: { id: 21, retType: "number" }, inviteMode: { id: 22, retType: "number" }, updateInfoMode: { id: 23, retType: "number" }, updateExtensionMode: { id: 24, retType: "number" }, chatBannedMode: { id: 101, retType: "number" } }, Jn = { teamId: 1, accountId: 3, memberRole: { id: 4, retType: "number" }, teamNick: 5, bits: { id: 7, retType: "number" }, inTeam: { id: 9, retType: "boolean" }, joinTime: { id: 10, retType: "number" }, updateTime: { id: 11, retType: "number" }, serverExtension: 12, chatBanned: { id: 13, retType: "boolean" }, invitorAccountId: 14, followAccountIds: { id: 16, retConverter: (e2) => {
        try {
          return JSON.parse(e2);
        } catch (e3) {
          return [];
        }
      } } }, Qn = { teamId: 1, accountId: 3, memberRole: { id: 4, retType: "number" }, teamNick: 5, bits: { id: 7, retType: "number" }, inTeam: { id: 9, retType: "boolean" }, updateTime: { id: 11, retType: "number" }, serverExtension: 12, chatBanned: { id: 13, retType: "boolean" }, invitorAccountId: 14, joinTime: { id: 15, retType: "number" }, followAccountIds: { id: 17, retConverter: (e2) => {
        try {
          return JSON.parse(e2);
        } catch (e3) {
          return [];
        }
      } } }, Xn = { accountIds: { id: 1, converter: (e2) => JSON.stringify(e2) }, operation: 2 }, Zn = { teamId: 1, teamType: 2, roleQueryType: 3, onlyChatBanned: { id: 4, converter: (e2) => +e2 }, nextToken: 5, limit: 6, direction: 7 }, ea = { v2TeamCreate: { sid: 31, cid: 1, service: Kn, params: [{ type: "Property", name: "team", reflectMapper: Yn }, { type: "StrArray", name: "inviteeAccountIds" }, { type: "String", name: "postscript" }, { type: "Property", name: "antispamConfig", reflectMapper: Wn }], response: [{ type: "Property", name: "team", reflectMapper: invertSerializeItem(Yn) }, { type: "StrArray", name: "failedList" }] }, v2SuperTeamCreate: { sid: 32, cid: 1, service: Kn, params: [{ type: "Property", name: "team", reflectMapper: Yn }, { type: "StrArray", name: "inviteeAccountIds" }, { type: "String", name: "postscript" }, { type: "Property", name: "antispamConfig", reflectMapper: Wn }], response: [{ type: "Property", name: "team", reflectMapper: invertSerializeItem(Yn) }, { type: "StrArray", name: "failedList" }] }, v2TeamInviteMembers: { sid: 31, cid: 5, service: Kn, params: [{ type: "Long", name: "teamId" }, { type: "StrArray", name: "accounts" }, { type: "String", name: "ps" }, { type: "String", name: "attach" }], response: [{ type: "Long", name: "time" }, { type: "StrArray", name: "abortedAccidList" }] }, v2SuperTeamInviteMembers: { sid: 32, cid: 5, service: Kn, params: [{ type: "Long", name: "teamId" }, { type: "StrArray", name: "accounts" }, { type: "String", name: "ps" }, { type: "String", name: "attach" }], response: [{ type: "StrArray", name: "abortedAccidList" }, { type: "Long", name: "time" }] }, v2TeamUpdateInfo: { sid: 31, cid: 7, service: Kn, params: [{ type: "Property", name: "team", reflectMapper: Yn }, { type: "Property", name: "antispamConfig", reflectMapper: Wn }], response: [{ type: "Long", name: "teamId" }, { type: "Long", name: "timestamp" }] }, v2SuperTeamUpdateInfo: { sid: 32, cid: 8, service: Kn, params: [{ type: "Property", name: "team", reflectMapper: Yn }, { type: "Property", name: "antispamConfig", reflectMapper: Wn }], response: [{ type: "Long", name: "timestamp" }] }, v2TeamLeave: { sid: 31, cid: 8, service: Kn, params: [{ type: "Long", name: "teamId" }] }, v2SuperTeamLeave: { sid: 32, cid: 7, service: Kn, params: [{ type: "Long", name: "teamId" }] }, v2TeamGetInfo: { sid: 31, cid: 9, service: Kn, params: [{ type: "Long", name: "teamId" }], response: [{ type: "Property", name: "team", reflectMapper: invertSerializeItem(Yn) }] }, v2SuperTeamGetInfo: { sid: 32, cid: 9, service: Kn, params: [{ type: "Long", name: "teamId" }], response: [{ type: "Property", name: "team", reflectMapper: invertSerializeItem(Yn) }] }, v2TeamGetByIds: { sid: 31, cid: 34, service: Kn, params: [{ type: "LongArray", name: "teamIds" }], response: [{ type: "PropertyArray", name: "teams", reflectMapper: invertSerializeItem(Yn) }, { type: "LongArray", name: "tids" }] }, v2SuperTeamGetByIds: { sid: 32, cid: 36, service: Kn, params: [{ type: "LongArray", name: "teamIds" }], response: [{ type: "PropertyArray", name: "teams", reflectMapper: invertSerializeItem(Yn) }, { type: "LongArray", name: "tids" }] }, v2TeamDismiss: { sid: 31, cid: 12, service: Kn, params: [{ type: "Long", name: "teamId" }] }, v2SuperTeamDismiss: { sid: 32, cid: 4, service: Kn, params: [{ type: "Long", name: "teamId" }] }, v2TeamAcceptInvitation: { sid: 31, cid: 21, service: Kn, params: [{ type: "Long", name: "teamId" }, { type: "String", name: "from" }], response: [{ type: "Property", name: "team", reflectMapper: invertSerializeItem(Yn) }] }, v2SuperTeamAcceptInvitation: { sid: 32, cid: 23, service: Kn, params: [{ type: "Long", name: "teamId" }, { type: "String", name: "from" }], response: [{ type: "Property", name: "team", reflectMapper: invertSerializeItem(Yn) }] }, v2TeamRejectInvite: { sid: 31, cid: 22, service: Kn, params: [{ type: "Long", name: "teamId" }, { type: "String", name: "from" }, { type: "String", name: "ps" }] }, v2SuperTeamRejectInvite: { sid: 32, cid: 24, service: Kn, params: [{ type: "Long", name: "teamId" }, { type: "String", name: "from" }, { type: "String", name: "ps" }] }, v2TeamKickMembers: { sid: 31, cid: 6, service: Kn, params: [{ type: "Long", name: "teamId" }, { type: "StrArray", name: "accounts" }] }, v2SuperTeamKickMembers: { sid: 32, cid: 6, service: Kn, params: [{ type: "Long", name: "teamId" }, { type: "StrArray", name: "accounts" }] }, v2TeamApplyToJoin: { sid: 31, cid: 13, service: Kn, params: [{ type: "Long", name: "teamId" }, { type: "String", name: "ps" }], response: [{ type: "Property", name: "team", reflectMapper: invertSerializeItem(Yn) }, { type: "Int", name: "isInTeam" }] }, v2SuperTeamApplyToJoin: { sid: 32, cid: 20, service: Kn, params: [{ type: "Long", name: "teamId" }, { type: "String", name: "ps" }], response: [{ type: "Property", name: "team", reflectMapper: invertSerializeItem(Yn) }, { type: "Int", name: "isInTeam" }] }, v2TeamAcceptJoinApplication: { sid: 31, cid: 14, service: Kn, params: [{ type: "Long", name: "teamId" }, { type: "String", name: "from" }] }, v2SuperTeamAcceptJoinApplication: { sid: 32, cid: 21, service: Kn, params: [{ type: "Long", name: "teamId" }, { type: "String", name: "from" }] }, v2TeamRejectJoinApplication: { sid: 31, cid: 15, service: Kn, params: [{ type: "Long", name: "teamId" }, { type: "String", name: "from" }, { type: "String", name: "ps" }] }, v2SuperTeamRejectJoinApplication: { sid: 32, cid: 22, service: Kn, params: [{ type: "Long", name: "teamId" }, { type: "String", name: "from" }, { type: "String", name: "ps" }] }, v2TeamAddManagers: { sid: 31, cid: 16, service: Kn, params: [{ type: "Long", name: "teamId" }, { type: "StrArray", name: "accounts" }] }, v2SuperTeamAddManagers: { sid: 32, cid: 26, service: Kn, params: [{ type: "Long", name: "teamId" }, { type: "StrArray", name: "accounts" }] }, v2TeamRemoveManagers: { sid: 31, cid: 17, service: Kn, params: [{ type: "Long", name: "teamId" }, { type: "StrArray", name: "accounts" }] }, v2SuperTeamRemoveManagers: { sid: 32, cid: 27, service: Kn, params: [{ type: "Long", name: "teamId" }, { type: "StrArray", name: "accounts" }] }, v2TeamTransferOwner: { sid: 31, cid: 18, service: Kn, params: [{ type: "Long", name: "teamId" }, { type: "String", name: "account" }, { type: "Bool", name: "leave" }] }, v2SuperTeamTransferOwner: { sid: 32, cid: 31, service: Kn, params: [{ type: "Long", name: "teamId" }, { type: "String", name: "account" }, { type: "Bool", name: "leave" }] }, v2TeamUpdateSelfMemberInfo: { sid: 31, cid: 19, service: Kn, params: [{ type: "Property", name: "teamMember", reflectMapper: Jn }, { type: "Property", name: "specialFollowUpdate", reflectMapper: Xn }, { type: "Property", name: "antispam", reflectMapper: Wn }], response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(Jn) }] }, v2SuperTeamUpdateSelfMemberInfo: { sid: 32, cid: 10, service: Kn, params: [{ type: "Property", name: "teamMember", reflectMapper: Qn }, { type: "Property", name: "specialFollowUpdate", reflectMapper: Xn }, { type: "Property", name: "antispam", reflectMapper: Wn }], response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(Qn) }] }, v2TeamUpdateMember: { sid: 31, cid: 20, service: Kn, params: [{ type: "Property", name: "teamMember", reflectMapper: Jn }, { type: "Property", name: "antispam", reflectMapper: Wn }] }, v2SuperTeamUpdateMember: { sid: 32, cid: 30, service: Kn, params: [{ type: "Property", name: "teamMember", reflectMapper: Qn }, { type: "Property", name: "antispam", reflectMapper: Wn }] }, v2TeamGetMemberInvitor: { sid: 31, cid: 33, service: Kn, params: [{ type: "Long", name: "teamId" }, { type: "StrArray", name: "accounts" }], response: [{ type: "StrStrMap", name: "accountsMap" }] }, v2SuperTeamGetMemberInvitor: { sid: 32, cid: 35, service: Kn, params: [{ type: "Long", name: "teamId" }, { type: "StrArray", name: "accounts" }], response: [{ type: "StrStrMap", name: "accountsMap" }] }, v2TeamMemberSetChatBannedStatus: { sid: 31, cid: 25, service: Kn, params: [{ type: "Long", name: "teamId" }, { type: "String", name: "accountId" }, { type: "Int", name: "chatBanned" }] }, v2SuperTeamMemberSetChatBannedStatus: { sid: 32, cid: 29, service: Kn, params: [{ type: "Long", name: "teamId" }, { type: "StrArray", name: "accountId" }, { type: "Int", name: "chatBanned" }] }, v2TeamSetChatBannedMode: { sid: 31, cid: 32, service: Kn, params: [{ type: "Long", name: "teamId" }, { type: "Int", name: "chatBannedMode" }] }, v2SuperTeamSetChatBannedMode: { sid: 32, cid: 28, service: Kn, params: [{ type: "Long", name: "teamId" }, { type: "Int", name: "chatBannedMode" }] }, v2TeamMemberGetListByIds: { sid: 31, cid: 35, service: Kn, params: [{ type: "StrArray", name: "tag" }], response: [{ type: "PropertyArray", name: "datas", reflectMapper: invertSerializeItem(Jn) }] }, v2SuperTeamMemberGetListByIds: { sid: 32, cid: 37, service: Kn, params: [{ type: "StrArray", name: "tag" }], response: [{ type: "PropertyArray", name: "datas", reflectMapper: invertSerializeItem(Qn) }] }, v2TeamMemberGetList: { sid: 31, cid: 36, service: Kn, params: [{ type: "Property", name: "tag", reflectMapper: Zn }], response: [{ type: "PropertyArray", name: "datas", reflectMapper: invertSerializeItem(Jn) }, { type: "Property", name: "pageInfo", reflectMapper: { 1: "hasMore", 2: "nextToken" } }] }, v2TeamSync: { sid: 8, cid: 109, service: Kn, response: [{ type: "Long", name: "timetag" }, { type: "PropertyArray", name: "datas", reflectMapper: invertSerializeItem(Yn) }] }, v2TeamCreateMultiSync: { sid: 8, cid: 101, service: Kn, response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(Yn) }] }, v2TeamMemberUpdateMultiSync: { sid: 8, cid: 119, service: Kn, response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(Jn) }] }, v2TeamMembersOfSelfInSync: { sid: 8, cid: 126, service: Kn, response: [{ type: "PropertyArray", name: "datas", reflectMapper: invertSerializeItem(Jn) }, { type: "Long", name: "timetag" }] }, v2SuperTeamSync: { sid: 21, cid: 109, service: Kn, response: [{ type: "PropertyArray", name: "datas", reflectMapper: invertSerializeItem(Yn) }, { type: "Bool", name: "isAll" }, { type: "Long", name: "timetag" }] }, v2SuperTeamCreateMultiSync: { sid: 21, cid: 101, service: Kn, response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(Yn) }] }, v2SuperTeamMemberUpdateMultiSync: { sid: 21, cid: 110, service: Kn, response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(Qn) }] }, v2SuperTeamMembersOfSelfInSync: { sid: 21, cid: 111, service: Kn, response: [{ type: "PropertyArray", name: "datas", reflectMapper: invertSerializeItem(Qn) }, { type: "Long", name: "timetag" }] } };
      function formatTeamNotificationAttachData(e2, t2) {
        if (!e2)
          return {};
        var r2 = e2;
        return r2.tinfo && (r2.tinfo = function formatTeamFromTinfo(e3) {
          return deserialize(e3, invertSerializeItem(Yn));
        }(r2.tinfo), r2.tinfo.teamType = t2), r2.uinfos, void 0 !== r2.mute && (r2.mute = parseInt(r2.mute)), r2;
      }
      function generateTeamByTeamId(e2, t2, r2 = {}) {
        return Object.assign({ teamId: e2, teamType: t2, name: "", ownerAccountId: "", memberLimit: 0, memberCount: 0, createTime: 0, updateTime: 0, intro: "", announcement: "", avatar: "", joinMode: 0, agreeMode: 0, inviteMode: 0, updateInfoMode: 0, updateExtensionMode: 0, chatBannedMode: 0, isValidTeam: true }, r2);
      }
      function generateMemberByTeamId(e2, t2, r2, i2 = {}) {
        return Object.assign({ teamId: e2, teamType: t2, accountId: r2, joinTime: 0, inTeam: true, memberRole: 0, chatBanned: false }, i2);
      }
      function processTeamMembers(e2, t2 = 1) {
        return e2.map((e3) => function processTeamMember(e4, t3 = 1) {
          return e4.teamType = t3, e4.chatBanned = void 0 !== e4.chatBanned && e4.chatBanned, e4;
        }(e3, t2));
      }
      function completeMessage(e2, t2, r2) {
        var i2, s2 = Object.assign(Object.assign({}, t2), { conversationId: e2.V2NIMConversationIdUtil.messageConversationId(t2), isSelf: t2.senderId === e2.account, sendingState: 1, messageStatus: { errorCode: (null === (i2 = null == t2 ? void 0 : t2.messageStatus) || void 0 === i2 ? void 0 : i2.errorCode) || 200 }, messageSource: r2 || 0 });
        if (s2.threadReply && (s2.threadReply = Object.assign(Object.assign({}, s2.threadReply), { conversationType: s2.conversationType, conversationId: s2.conversationId })), s2.threadRoot && (s2.threadRoot = Object.assign(Object.assign({}, s2.threadRoot), { conversationType: s2.conversationType, conversationId: s2.conversationId })), s2.isInBlackList && (s2.sendingState = 2, s2.messageStatus.errorCode = ce.V2NIM_ERROR_CODE_ACCOUNT_IN_BLOCK_LIST, delete s2.isInBlackList), s2.streamConfig) {
          var n2 = get(s2.streamConfig, "isStream");
          if (false === n2)
            delete s2.streamConfig;
          else if (true === n2 && void 0 === s2.streamConfig.status)
            delete s2.streamConfig, t2.aiConfig && (t2.aiConfig.aiStream = true, t2.aiConfig.aiStreamStatus = 0);
          else if ("number" == typeof s2.streamConfig.status)
            return s2.streamConfig = { status: s2.streamConfig.status }, function completeMessageStreamConfig(e3) {
              e3.streamConfig && e3.aiConfig && (e3.aiConfig.aiStream = true, e3.aiConfig.aiStreamStatus = e3.streamConfig.status);
              if (e3.attachment && e3.streamConfig) {
                var t3 = e3.attachment;
                e3.streamConfig.lastChunk = { content: t3.msg, messageTime: e3.createTime, chunkTime: t3.timestamp, type: t3.type, index: t3.index }, e3.aiConfig && (e3.aiConfig.aiStreamLastChunk = e3.streamConfig.lastChunk), delete e3.attachment;
              }
              return e3;
            }(s2);
        }
        return formatMessageAttachment(s2, e2);
      }
      function formatMessageAttachment(e2, t2) {
        return 5 === e2.messageType ? function formatNotificationMessage(e3, t3) {
          var r2, i2, s2, n2, a2, o2 = t3.attachment || {};
          if (t3.attachment && "type" in t3.attachment)
            return t3;
          var c2 = void 0;
          if (null === (r2 = o2.data) || void 0 === r2 ? void 0 : r2.tinfo) {
            var { id: d2, data: l2 } = o2, m2 = d2 > 400 ? 2 : 1, { tinfo: p2 } = formatTeamNotificationAttachData(Object.assign({}, l2), m2);
            c2 = {}, c2 = __rest(p2, ["teamId"]);
          }
          var u2 = Object.assign(Object.assign(Object.assign(Object.assign({ raw: o2.raw, type: convertNotificationType(e3, o2.id) }, c2 ? { updatedTeamInfo: c2 } : {}), { targetIds: (null === (i2 = o2.data) || void 0 === i2 ? void 0 : i2.ids) || ((null === (s2 = o2.data) || void 0 === s2 ? void 0 : s2.id) ? [o2.data.id] : []) }), "string" == typeof (null === (n2 = o2.data) || void 0 === n2 ? void 0 : n2.attach) ? { serverExtension: o2.data.attach } : {}), "number" == typeof (null === (a2 = o2.data) || void 0 === a2 ? void 0 : a2.mute) ? { chatBanned: 0 !== o2.data.mute } : {});
          return Object.assign(Object.assign({}, t3), { attachment: u2 });
        }(t2, e2) : 100 === e2.messageType ? function formatCustomMessage(e3, t3) {
          var r2, i2, s2;
          if ("string" == typeof (null === (r2 = t3.attachment) || void 0 === r2 ? void 0 : r2.raw) && (null === (s2 = null === (i2 = e3.V2NIMMessageService) || void 0 === i2 ? void 0 : i2.customAttachmentParsers) || void 0 === s2 ? void 0 : s2.length) > 0) {
            var n2 = t3.subType || 0, a2 = e3.V2NIMMessageService.customAttachmentParsers, o2 = t3.attachment.raw;
            a2.some((r3) => {
              try {
                var i3 = r3(n2, o2);
                if (isPlainObject(i3))
                  return i3.raw = o2, t3.attachment = i3, true;
              } catch (t4) {
                return e3.logger.warn(`customAttachmentParser: subType ${n2}, raw: ${o2}. parse error with ${t4}`), false;
              }
              return false;
            });
          }
          return t3;
        }(t2, e2) : e2;
      }
      function completeMessageRefer(e2, t2) {
        return Object.assign(Object.assign({}, t2), { conversationId: e2.V2NIMConversationIdUtil.messageConversationId(t2) });
      }
      function formatMessageRefer(e2, t2) {
        var { createTime: r2, senderId: i2, receiverId: s2, conversationType: n2 } = t2;
        return { conversationType: n2, conversationId: e2.V2NIMConversationIdUtil.messageConversationId({ conversationType: n2, senderId: i2, receiverId: s2 }), senderId: t2.senderId, receiverId: t2.receiverId, messageServerId: t2.messageServerId, createTime: r2, messageClientId: t2.messageClientId };
      }
      function formatRevokeMessage(e2, t2) {
        var r2 = { 7: 1, 8: 2, 12: 3, 13: 1, 14: 2 }[t2.sysMsgType];
        return { postscript: t2.postscript, revokeType: { 7: 1, 8: 2, 12: 3, 13: 4, 14: 5 }[t2.sysMsgType] || 0, revokeAccountId: t2.opeAccount || t2.senderId, callbackExtension: t2.callbackExtension, serverExtension: t2.attach || "", messageRefer: { conversationType: r2, conversationId: e2.V2NIMConversationIdUtil.messageConversationId(Object.assign(Object.assign({}, t2), { conversationType: r2, senderId: t2.senderId, receiverId: t2.receiverId })), senderId: t2.senderId, receiverId: t2.receiverId, messageServerId: t2.messageServerId, createTime: t2.deleteMsgCreatetime, messageClientId: t2.messageClientId } };
      }
      function formatClearHistoryNotification(e2, t2) {
        return { conversationId: 1 === t2.conversationType ? e2.V2NIMConversationIdUtil.p2pConversationId(t2.receiverId) : 2 === t2.conversationType ? e2.V2NIMConversationIdUtil.teamConversationId(t2.teamId) : e2.V2NIMConversationIdUtil.superTeamConversationId(t2.teamId), deleteTime: t2.deleteTime, serverExtension: t2.serverExtension };
      }
      function convertNotificationType(e2, t2) {
        var r2 = { 0: 0, 401: 401, 1: 1, 402: 402, 2: 2, 403: 403, 3: 3, 404: 404, 4: 4, 405: 405, 5: 5, 410: 410, 6: 6, 406: 406, 7: 7, 407: 407, 8: 8, 408: 408, 9: 9, 411: 411, 10: 10, 409: 409 };
        return void 0 === r2[t2] && e2.logger.warn(`[V2NIMMessageService] undefined notification type: ${t2}`), "number" == typeof r2[t2] ? r2[t2] : -1;
      }
      function formatSearchCloudMessageListEx(e2, t2) {
        var r2 = [], i2 = {};
        for (var s2 in t2.forEach((e3) => {
          var t3 = e3.conversationId;
          i2[t3] || (i2[t3] = { conversationId: t3, messages: [], count: 0 }), i2[t3].messages.push(e3), i2[t3].count++;
        }), i2) {
          var n2 = i2[s2];
          r2.push(n2);
        }
        return r2;
      }
      function attachmentToRaw(e2, t2) {
        if (!t2)
          return "";
        switch (e2) {
          case 100:
            return t2.raw || "";
          case 1:
          case 3:
          case 2:
          case 6:
            return function mediaAttachmentToRaw(e3) {
              var t3 = e3, { width: r2, height: i2, duration: s2, path: n2, file: a2, raw: o2, ctx: c2, payload: d2, bucketName: l2, objectName: m2, token: p2, ext: u2 } = t3, h2 = __rest(t3, ["width", "height", "duration", "path", "file", "raw", "ctx", "payload", "bucketName", "objectName", "token", "ext"]), g2 = "string" == typeof u2 && "." === u2[0] ? u2.slice(1) : u2;
              return JSON.stringify(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, h2), void 0 === u2 ? {} : { ext: g2 }), void 0 === r2 ? {} : { w: r2 }), void 0 === i2 ? {} : { h: i2 }), void 0 === s2 ? {} : { dur: s2 }));
            }(t2);
          case 4:
            return function locationAttachmentToRaw(e3) {
              return JSON.stringify({ lat: e3.latitude, lng: e3.longitude, title: e3.address });
            }(t2);
          case 12:
            return function callAttachmentToRaw(e3) {
              var t3 = __rest(e3, ["raw"]);
              try {
                return JSON.stringify(Object.assign(Object.assign({}, t3), { durations: e3.durations.map((e4) => ({ accid: e4.accountId, duration: e4.duration })) }));
              } catch (t4) {
                return JSON.stringify(e3);
              }
            }(t2);
          default:
            return t2.raw || JSON.stringify(t2);
        }
      }
      function rawToAttachment(e2, t2) {
        var r2;
        try {
          switch (r2 = JSON.parse(e2), t2) {
            case 100:
              return { raw: e2 };
            case 4:
              return function locationRawToAttachment(e3, t3) {
                return { latitude: t3.lat, longitude: t3.lng, address: t3.title, raw: e3 };
              }(e2, r2);
            case 2:
            case 3:
            case 1:
            case 6:
              return function mediaRawToAttachment(e3, t3) {
                var { w: r3, h: i2, dur: s2, ext: n2 } = t3, a2 = __rest(t3, ["w", "h", "dur", "ext"]), o2 = "string" == typeof n2 && "." !== n2[0] ? `.${n2}` : n2;
                return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, a2), void 0 === n2 ? {} : { ext: o2 }), void 0 === r3 ? {} : { width: r3 }), void 0 === i2 ? {} : { height: i2 }), void 0 === s2 ? {} : { duration: s2 }), { raw: e3 });
              }(e2, r2);
            case 12:
              return function callRawToAttachment(e3, t3) {
                return Object.assign(Object.assign({}, t3), { durations: t3.durations.map((e4) => ({ accountId: e4.accid, duration: e4.duration })), raw: e3 });
              }(e2, r2);
            default:
              return "object" == typeof r2 && r2 ? Object.assign(Object.assign({}, r2), { raw: e2 }) : { raw: e2 };
          }
        } catch (t3) {
          return "object" == typeof r2 && r2 ? Object.assign(Object.assign({}, r2), { raw: e2 }) : { raw: e2 };
        }
      }
      class FileUtil {
        constructor(e2) {
          this.core = e2;
        }
        doSendFile(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            var r2 = e2.attachment;
            try {
              var [i2, s2] = yield this.core.V2NIMStorageService._uploadFile({ taskId: e2.messageClientId, uploadParams: { fileObj: (null == r2 ? void 0 : r2.file) || (null == r2 ? void 0 : r2.path), sceneName: null == r2 ? void 0 : r2.sceneName } }, t2, { fileType: e2.messageType }), n2 = Object.assign(Object.assign({}, r2), { uploadState: 1 });
              void 0 !== s2.w && (n2.width = n2.width || s2.w), void 0 !== s2.h && (n2.height = n2.height || s2.h), void 0 !== s2.dur && (n2.duration = n2.duration || s2.dur), n2.ext = n2.ext && -1 === n2.ext.indexOf(".") ? `.${n2.ext}` : n2.ext;
              var a2 = ["w", "h", "dur", "ext", "name"];
              for (var o2 in s2)
                a2.includes(o2) || (n2[o2] = s2[o2]);
              var { raw: c2, file: d2, path: l2 } = n2, m2 = __rest(n2, ["raw", "file", "path"]);
              e2.attachment = JSON.parse(JSON.stringify(m2)), e2.attachment && (e2.attachment.raw = attachmentToRaw(e2.messageType, e2.attachment));
            } catch (t3) {
              throw e2.attachment && (e2.attachment.uploadState = 2), t3;
            }
          });
        }
        cancelMessageAttachmentUpload(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            if (validate({ messageClientId: { type: "string", allowEmpty: false } }, e2, "", true), ![2, 6, 1, 3].includes(e2.messageType))
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_MISUSE, detail: { reason: `cancelMessageAttachmentUpload: messageType ${e2.messageType} incorrect` } });
            if (2 === e2.sendingState || 1 === e2.sendingState)
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_RESOURCE_NOT_EXIST, detail: { reason: "cancelMessageAttachmentUpload: message is already failed or succeeded" } });
            yield this.core.V2NIMStorageService._cancelUploadFile(e2.messageClientId);
          });
        }
      }
      var ta = "V2NIMMessageService", ra = { "30_1": "v2SendP2pMessage", "31_2": "v2SendTeamMessage", "30_31": "v2MessageP2pModify", "31_37": "v2MessageTeamModify", "32_38": "v2MessageSuperTeamModify", "7_33": "v2MessageOnModified", "4_27": "v2MessageSyncModified", "4_28": "v2MessageSuperTeamSyncModified", "4_5": "v2BatchMarkRead", "4_12": "syncP2PMessagReceipts", "30_11": "v2SendP2PMessageReceipt", "31_28": "v2SendTeamMessageReceipts", "32_2": "v2SendSuperTeamMessage", "7_12": "onP2PMessageReceipts", "8_31": "onTeamMessageReceipts", "31_29": "v2GetTeamMessageReceipts", "31_30": "v2GetTeamMessageReceiptDetail", "7_2": "onMsg", "8_3": "onMsg", "7_101": "onMsg", "8_102": "onMsg", "21_3": "onMsg", "21_102": "onMsg", "4_4": "syncOfflineMsgs", "4_9": "syncRoamingMsgs", "4_17": "syncRoamingMsgs", "30_13": "v2RevokeMessage", "32_17": "v2RevokeSuperTeamMessage", "7_14": "onRevokeMessage", "7_15": "syncRevokeMessage", "21_18": "onRevokeMessage", "21_117": "onRevokeMessage", "30_23": "v2DeleteMessage", "30_24": "v2DeleteMessages", "4_21": "syncOnDeleteMessages", "7_123": "onDeleteMessage", "7_124": "onDeleteMessages", "29_17": "v2DownloadLocalAntiSpamVocabs" };
      var ia = { conversationType: { id: 0, converter: conversationTypeV2ToV1, retConverter: conversationTypeV1ToV2 }, receiverId: 1, senderId: 2, fromClientType: 4, fromDeviceId: 5, fromNick: 6, createTime: { id: 7, retType: "number" }, messageType: { id: 8, retType: "number" }, text: 9, attachment: { id: 10, converter: (e2, t2) => attachmentToRaw(t2.messageType, e2), retConverter: (e2, t2) => rawToAttachment(e2, Number(t2[8])) }, messageClientId: 11, messageServerId: 12, resend: { id: 13, converter: boolToInt, retType: "boolean" }, userUpdateTime: { id: 14, retType: "number" }, serverExtension: 15, pushPayload: { id: 16, access: "pushConfig.pushPayload" }, pushContent: { id: 17, access: "pushConfig.pushContent" }, forcePushAccountIds: { id: 18, access: "pushConfig.forcePushAccountIds", def: (e2) => {
        if (e2["pushConfig.forcePush"])
          return "#%@all@%#";
      }, converter: (e2, t2) => {
        if (t2["pushConfig.forcePush"])
          return e2 ? JSON.stringify(e2) : "#%@all@%#";
      }, retConverter(e2) {
        if ("#%@all@%#" !== e2 && e2)
          try {
            return JSON.parse(e2);
          } catch (e3) {
            return [];
          }
      } }, forcePushContent: { id: 19, access: "pushConfig.forcePushContent" }, forcePush: { id: 20, access: "pushConfig.forcePush", converter: boolToInt, retType: "boolean" }, antispamCustomMessageEnabled: { id: 21, def: (e2) => get(e2, "antispamConfig.antispamCustomMessage") ? 1 : void 0, retConverter: () => {
      } }, antispamCustomMessage: { id: 22, access: "antispamConfig.antispamCustomMessage" }, antispamBusinessId: { id: 23, access: "antispamConfig.antispamBusinessId" }, clientAntispamHit: { id: 24, access: "clientAntispamHit", converter: boolToInt, retType: "boolean" }, antispamEnabled: { id: 25, access: "antispamConfig.antispamEnabled", converter: boolToInt, retType: "boolean" }, needAck: { id: 26, access: "messageConfig.readReceiptEnabled", converter: boolToInt, retType: "boolean" }, lastMessageUpdateEnabled: { id: 28, access: "messageConfig.lastMessageUpdateEnabled", converter: boolToInt, retType: "boolean" }, threadReplySenderId: { id: 29, access: "threadReply.senderId" }, threadReplyReceiverId: { id: 30, access: "threadReply.receiverId" }, threadReplyTime: { id: 31, access: "threadReply.createTime", retType: "number" }, threadReplyServerId: { id: 32, access: "threadReply.messageServerId" }, threadReplyClientId: { id: 33, access: "threadReply.messageClientId" }, threadRootSenderId: { id: 34, access: "threadRoot.senderId" }, threadRootReceiverId: { id: 35, access: "threadRoot.receiverId" }, threadRootTime: { id: 36, access: "threadRoot.createTime", retType: "number" }, threadRootServerId: { id: 37, access: "threadRoot.messageServerId" }, threadRootClientId: { id: 38, access: "threadRoot.messageClientId" }, isDeleted: { id: 39, converter: boolToInt, retType: "boolean" }, callbackExtension: 40, subType: { id: 41, retType: "number" }, antispamCheating: { id: 42, access: "antispamConfig.antispamCheating" }, routeEnvironment: { id: 43, access: "routeConfig.routeEnvironment" }, antispamExtension: { id: 44, access: "antispamConfig.antispamExtension" }, antispamResult: 45, __clientExt: { id: 46, converter: objectToJSONString, retConverter: stringToJSONObject }, robotFunction: { id: 47, access: "robotConfig.function" }, robotTopic: { id: 48, access: "robotConfig.topic" }, robotCustomContent: { id: 49, access: "robotConfig.customContent" }, robotAccount: { id: 50, access: "robotConfig.accountId" }, _conversationOnlineSyncNotify: { id: 51 }, _conversationOnlineSyncData: { id: 52 }, aiAgentMsgDirection: { id: 55, access: "aiConfig.aiStatus", retAccess: "aiConfig.aiStatus", retType: "number" }, aiAgentAccount: { id: 56, access: "aiConfig.accountId", retAccess: "aiConfig.accountId" }, aiAgentContent: { id: 57, access: "aiConfig.content", converter: objectToJSONString, retConverter: emptyFunc }, aiAgentMessages: { id: 58, access: "aiConfig.messages", converter: objectToJSONString, retConverter: emptyFunc }, aiAgentPromptVariables: { id: 59, access: "aiConfig.promptVariables", retConverter: emptyFunc }, aiAgentModelConfigParams: { id: 60, access: "aiConfig.modelConfigParams", converter: objectToJSONString, retConverter: emptyFunc }, errorCode: { id: 61, access: "messageStatus.errorCode", converter: emptyFunc, retType: "number" }, modifyTime: { id: 62, retType: "number" }, modifyAccountId: 63, aiStream: { id: 65, access: "aiConfig.aiStream", retAccess: "streamConfig.isStream", converter: boolToInt, retConverter: intToBool }, aiRAGs: { id: 66, access: "aiConfig.aiRAGs", retConverter: function aiAgentStreamAIRAGsRetConverter$1(e2) {
        try {
          var t2 = JSON.parse(e2);
          return t2 && t2.length > 0 ? t2.map((e3) => (e3.description = e3.desc, delete e3.desc, e3)) : [];
        } catch (e3) {
          return [];
        }
      } }, aiStreamStatus: { id: 67, access: "streamConfig.status", retType: "number" }, historyEnabled: { id: 100, access: "messageConfig.historyEnabled", converter: boolToInt, retType: "boolean" }, roamingEnabled: { id: 101, access: "messageConfig.roamingEnabled", converter: boolToInt, retType: "boolean" }, onlineSyncEnabled: { id: 102, access: "messageConfig.onlineSyncEnabled", converter: boolToInt, retType: "boolean" }, routeEnabled: { id: 105, access: "routeConfig.routeEnabled", converter: boolToInt, retType: "boolean" }, isInBlackList: { id: 106, access: "isInBlackList", converter: boolToInt, retType: "boolean" }, pushEnable: { id: 107, access: "pushConfig.pushEnabled", converter: boolToInt, retType: "boolean" }, offlineEnabled: { id: 108, access: "messageConfig.offlineEnabled", converter: boolToInt, retType: "boolean" }, unreadEnabled: { id: 109, access: "messageConfig.unreadEnabled", converter: boolToInt, retType: "boolean" }, pushNickEnabled: { id: 110, access: "pushConfig.pushNickEnabled", converter: boolToInt, retType: "boolean" }, msgAckSnapshot: { id: 112, retType: "number" }, receiverIds: { id: 154, access: "targetConfig.receiverIds", converter: objectToJSONString, retConverter: () => {
      } }, inclusive: { id: 155, access: "targetConfig.inclusive", converter: (e2) => e2 ? 1 : 2, retConverter: () => {
      } }, newMemberVisible: { id: 156, access: "targetConfig.newMemberVisible", converter: (e2) => e2 ? 1 : 2, retConverter: () => {
      } } }, sa = invertSerializeItem(ia), na = { conversationType: { id: 1, access: "messageRefer.conversationType", retType: "number" }, senderId: { id: 2, access: "messageRefer.senderId" }, receiverId: { id: 3, access: "messageRefer.receiverId" }, messageServerId: { id: 4, access: "messageRefer.messageServerId" }, messageClientId: { id: 5, access: "messageRefer.messageClientId" }, createTime: { id: 6, access: "messageRefer.createTime", retType: "number" }, deleteTime: { id: 7, retType: "number" }, serverExtension: 8 };
      invertSerializeItem(na);
      var aa = { version: 1, md5: 2, nosurl: 3, thesaurus: 4 }, oa = { createTime: { id: 0, retType: "number" }, sysMsgType: 1, receiverId: 2, senderId: 3, postscript: 4, attach: 5, pushContent: 8, pushPayload: 9, messageClientId: 10, messageServerId: 11, deleteMsgCreatetime: { id: 14, retType: "number" }, opeAccount: 16, env: 21, callbackExtension: 22 }, ca = { receiverId: 0, messageServerId: 1, readCount: { id: 100, retType: "number" }, unreadCount: { id: 101, retType: "number" }, messageClientId: 102, latestReadAccount: 103 }, da = { v2BatchMarkRead: { sid: 4, cid: 5, service: ta, hasPacketResponse: false, params: [{ type: "Byte", name: "sid" }, { type: "Byte", name: "cid" }, { type: "LongArray", name: "ids" }] }, v2SendP2pMessage: { sid: 30, cid: 1, service: ta, params: [{ type: "Property", name: "tag", reflectMapper: ia }], response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(ia) }] }, onMsg: { sid: 7, cid: 2, service: ta, response: [{ type: "Property", name: "msg", reflectMapper: invertSerializeItem(ia) }] }, syncOfflineMsgs: { sid: 4, cid: 4, service: ta, response: [{ type: "PropertyArray", name: "datas", reflectMapper: invertSerializeItem(ia) }] }, syncRoamingMsgs: { sid: 4, cid: 9, service: ta, response: [{ type: "PropertyArray", name: "datas", reflectMapper: invertSerializeItem(ia) }] }, v2SendP2PMessageReceipt: { sid: 30, cid: 11, service: ta, params: [{ type: "Property", name: "tag", reflectMapper: ia }], response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(ia) }] }, v2RevokeMessage: { sid: 30, cid: 13, service: ta, params: [{ type: "Property", name: "tag", reflectMapper: oa }] }, v2DeleteMessage: { sid: 30, cid: 23, service: ta, params: [{ type: "Property", name: "tag", reflectMapper: na }], response: [{ type: "Long", name: "timetag" }] }, v2DeleteMessages: { sid: 30, cid: 24, service: ta, params: [{ type: "PropertyArray", name: "tag", reflectMapper: na }], response: [{ type: "Long", name: "timetag" }] }, v2SendTeamMessage: { sid: 31, cid: 2, service: ta, params: [{ type: "Property", name: "tag", reflectMapper: ia }], response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(ia) }] }, v2SendTeamMessageReceipts: { sid: 31, cid: 28, service: ta, params: [{ type: "PropertyArray", name: "tag", reflectMapper: ca }], response: [{ type: "PropertyArray", name: "tag", reflectMapper: invertSerializeItem(ca) }] }, v2SendSuperTeamMessage: { sid: 32, cid: 2, service: ta, params: [{ type: "Property", name: "tag", reflectMapper: ia }], response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(ia) }] }, v2RevokeSuperTeamMessage: { sid: 32, cid: 17, service: ta, params: [{ type: "Property", name: "tag", reflectMapper: oa }] }, syncP2PMessagReceipts: { sid: 4, cid: 12, service: ta, response: [{ type: "PropertyArray", name: "data", reflectMapper: invertSerializeItem(ia) }] }, onP2PMessageReceipts: { sid: 7, cid: 12, service: ta, response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(ia) }] }, v2GetTeamMessageReceipts: { sid: 31, cid: 29, service: ta, params: [{ type: "PropertyArray", name: "tag", reflectMapper: ca }], response: [{ type: "PropertyArray", name: "data", reflectMapper: invertSerializeItem(ca) }] }, v2GetTeamMessageReceiptDetail: { sid: 31, cid: 30, service: ta, params: [{ type: "Property", name: "tag", reflectMapper: ca, select: ["receiverId", "messageServerId"] }], response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(ca) }, { type: "StrArray", name: "readAccountList" }, { type: "StrArray", name: "unreadAccountList" }] }, onTeamMessageReceipts: { sid: 8, cid: 31, service: ta, response: [{ type: "PropertyArray", name: "data", reflectMapper: invertSerializeItem(ca) }] }, onRevokeMessage: { sid: 7, cid: 14, service: ta, response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(oa) }] }, syncRevokeMessage: { sid: 7, cid: 15, service: ta, response: [{ type: "PropertyArray", name: "datas", reflectMapper: invertSerializeItem(oa) }] }, syncOnDeleteMessages: { sid: 4, cid: 21, service: ta, response: [{ type: "PropertyArray", name: "datas", reflectMapper: invertSerializeItem(na) }] }, onDeleteMessage: { sid: 7, cid: 123, service: ta, response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(na) }] }, onDeleteMessages: { sid: 7, cid: 124, service: ta, response: [{ type: "PropertyArray", name: "data", reflectMapper: invertSerializeItem(na) }] }, v2DownloadLocalAntiSpamVocabs: { sid: 29, cid: 17, service: ta, params: [{ type: "Property", name: "tag", reflectMapper: aa }], response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(aa) }] }, v2MessageP2pModify: { sid: 30, cid: 31, service: ta, params: [{ type: "Property", name: "tag", reflectMapper: ia }], response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(ia) }] }, v2MessageTeamModify: { sid: 31, cid: 37, service: ta, params: [{ type: "Property", name: "tag", reflectMapper: ia }], response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(ia) }] }, v2MessageSuperTeamModify: { sid: 32, cid: 38, service: ta, params: [{ type: "Property", name: "tag", reflectMapper: ia }], response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(ia) }] }, v2MessageOnModified: { sid: 7, cid: 33, service: ta, response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(ia) }] }, v2MessageSyncModified: { sid: 4, cid: 27, service: ta, response: [{ type: "PropertyArray", name: "datas", reflectMapper: invertSerializeItem(ia) }, { type: "Long", name: "time" }] }, v2MessageSuperTeamSyncModified: { sid: 4, cid: 28, service: ta, response: [{ type: "PropertyArray", name: "datas", reflectMapper: invertSerializeItem(ia) }, { type: "Long", name: "time" }] } };
      function conversationTypeV2ToV1(e2) {
        return 1 === e2 ? 0 : 2 === e2 ? 1 : 3 === e2 ? 5 : void 0;
      }
      function conversationTypeV1ToV2(e2) {
        var t2 = parseInt(e2);
        return 0 === t2 ? 1 : 1 === t2 ? 2 : 5 === t2 ? 3 : 0;
      }
      var la = "V2NIMNotificationService", ma = { "30_7": "v2SendCustomNotification", "32_16": "v2SendCustomNotificationWithSuperTeam", "7_3": "onSysNotification", "21_19": "onSysNotification", "4_6": "v2SyncOfflineSysNotifications", "4_18": "v2SyncOfflineSysNotifications", "7_14": "v2NotificationRevoke", "21_18": "v2NotificationRevoke", "21_117": "v2NotificationRevoke", "4_19": "v2NotificationSyncRevoke", "7_15": "v2NotificationSyncRevoke", "4_16": "syncBroadcastMsg", "7_17": "onBroadcastMsg" }, pa = { timestamp: { id: 0, retType: "number" }, type: { id: 1, retType: "number" }, receiverId: 2, senderId: 3, postscript: 4, content: 5, idServer: 6, offlineEnabled: { id: 7, converter: boolToInt, retConverter: function(e2, t2) {
        return "0" !== t2[6] && !!parseInt(e2);
      }, access: "notificationConfig.offlineEnabled" }, pushContent: { id: 8, access: "pushConfig.pushContent" }, pushPayload: { id: 9, access: "pushConfig.pushPayload" }, deletedIdClient: 10, deletedIdServer: 11, antispamEnabled: { id: 12, converter: boolToInt, retType: "boolean", access: "antispamConfig.antispamEnabled" }, antispamCustomNotification: { id: 13, access: "antispamConfig.antispamCustomNotification" }, deletedMsgCreateTime: 14, deletedMsgFromNick: 15, opeAccount: 16, forcePushAccountIds: { id: 18, access: "pushConfig.forcePushAccountIds", def: (e2) => {
        if (101 === e2.type && e2["pushConfig.forcePush"])
          return "#%@all@%#";
      }, converter: (e2, t2) => {
        if (t2["pushConfig.forcePush"])
          return e2 ? JSON.stringify(e2) : "#%@all@%#";
      }, retConverter(e2) {
        if ("#%@all@%#" !== e2 && e2)
          try {
            return JSON.parse(e2);
          } catch (e3) {
            return [];
          }
      } }, forcePushContent: { id: 19, access: "pushConfig.forcePushContent" }, forcePush: { id: 20, converter: boolToInt, retType: "boolean", access: "pushConfig.forcePush" }, routeEnvironment: { id: 21, access: "routeConfig.routeEnvironment" }, callbackExt: 22, clientNotificationId: { id: 23, access: "notificationConfig.clientNotificationId" }, conversationOnlineSyncNotify: 24, conversationOnlineSyncData: 25, routeEnabled: { id: 105, converter: boolToInt, retType: "boolean", access: "routeConfig.routeEnabled" }, pushEnabled: { id: 107, converter: boolToInt, retType: "boolean", access: "pushConfig.pushEnabled" }, unreadEnabled: { id: 109, converter: boolToInt, retType: "boolean", access: "notificationConfig.unreadEnabled" }, pushNickEnabled: { id: 110, converter: boolToInt, retType: "boolean", access: "pushConfig.pushNickEnabled" } }, ua = { id: 1, senderId: 2, timestamp: { id: 4, retType: "number" }, content: 5 }, ha = { v2SendCustomNotification: { sid: 30, cid: 7, service: la, params: [{ type: "Property", name: "tag", reflectMapper: pa }] }, v2SendCustomNotificationWithSuperTeam: { sid: 32, cid: 16, service: la, params: [{ type: "Property", name: "tag", reflectMapper: pa }] }, onSysNotification: { sid: 7, cid: 3, service: la, response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(pa) }] }, syncBroadcastMsg: { sid: 4, cid: 16, service: la, response: [{ type: "PropertyArray", name: "datas", reflectMapper: invertSerializeItem(ua) }] }, onBroadcastMsg: { sid: 7, cid: 17, service: la, response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(ua) }] }, v2SyncOfflineSysNotifications: { sid: 4, cid: 9, service: la, response: [{ type: "PropertyArray", name: "datas", reflectMapper: invertSerializeItem(pa) }] }, v2NotificationRevoke: { sid: 7, cid: 14, service: la, response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(pa) }] }, v2NotificationSyncRevoke: { sid: 7, cid: 15, service: la, response: [{ type: "PropertyArray", name: "datas", reflectMapper: invertSerializeItem(pa) }, { type: "Long", name: "timetag" }, { type: "Byte", name: "type" }] } }, ga = "YSFService", va = { "4_5": "ysfBatchMarkRead", "101_1": "ysfSendMessage", "101_2": "ysfOnMsg", "4_100": "ysfSyncOfflineMsgs", "101_3": "ysfOnSysNotification", "101_7": "ysfSendCustomNotification", "4_101": "ysfSyncSysNotification" }, ya = { ysfBatchMarkRead: { sid: 4, cid: 5, service: ga, hasPacketResponse: false, params: [{ type: "Byte", name: "sid" }, { type: "Byte", name: "cid" }, { type: "LongArray", name: "ids" }] }, ysfSendMessage: { sid: 101, cid: 1, service: ga, params: [{ type: "Property", name: "tag", reflectMapper: ia }], response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(ia) }] }, ysfOnMsg: { sid: 101, cid: 2, service: ga, response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(ia) }] }, ysfSyncOfflineMsgs: { sid: 4, cid: 100, service: ga, response: [{ type: "PropertyArray", name: "datas", reflectMapper: invertSerializeItem(ia) }] }, ysfOnSysNotification: { sid: 101, cid: 3, service: ga, response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(pa) }] }, ysfSendCustomNotification: { sid: 101, cid: 7, service: ga, params: [{ type: "Property", name: "tag", reflectMapper: pa }] }, ysfSyncSysNotification: { sid: 4, cid: 101, service: ga, response: [{ type: "PropertyArray", name: "datas", reflectMapper: invertSerializeItem(pa) }] } }, fa = { content: { type: "string", allowEmpty: false }, params: { type: "object", required: false, rules: { notificationConfig: { type: "object", required: false, rules: { offlineEnabled: { type: "boolean", required: false }, unreadEnabled: { type: "boolean", required: false } } }, pushConfig: { type: "object", required: false, rules: { pushEnabled: { type: "boolean", required: false }, pushNickEnabled: { type: "boolean", required: false }, pushContent: { type: "string", required: false }, pushPayload: { type: "string", required: false }, forcePush: { type: "boolean", required: false }, forcePushContent: { type: "string", required: false }, forcePushAccountIds: { type: "array", required: false, itemType: "string" } } }, antispamConfig: { type: "object", required: false, rules: { antispamEnabled: { type: "boolean", required: false }, antispamCustomNotification: { type: "string", required: false } } }, routeConfig: { type: "object", required: false, rules: { routeEnabled: { type: "boolean", required: false }, routeEnvironment: { type: "string", required: false } } } } } };
      class NotificationUtil {
        constructor(e2) {
          this.core = e2;
        }
        generateNotificationTag(e2, t2, r2 = {}) {
          var i2 = this.core.V2NIMConversationIdUtil.parseConversationType(e2), s2 = this.core.V2NIMConversationIdUtil.parseConversationTargetId(e2), n2 = Date.now(), a2 = { 1: 100, 2: 101, 3: 103 };
          return Object.assign(Object.assign({}, r2), { notificationConfig: Object.assign({ unreadEnabled: true, offlineEnabled: true }, null == r2 ? void 0 : r2.notificationConfig), pushConfig: Object.assign({ pushEnabled: true, pushNickEnabled: true }, null == r2 ? void 0 : r2.pushConfig), antispamConfig: Object.assign({ antispamEnabled: true }, null == r2 ? void 0 : r2.antispamConfig), routeConfig: Object.assign({ routeEnabled: true }, null == r2 ? void 0 : r2.routeConfig), timestamp: n2, type: a2[i2], receiverId: s2, content: t2 });
        }
      }
      function getFileOrPath(e2) {
        var t2 = "object" == typeof e2 ? e2 : void 0, r2 = "string" == typeof e2 ? e2 : void 0;
        if (!t2 && !r2)
          throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_MISUSE, detail: { reason: "getFileOrPath::incorrect file and path" } });
        if ("string" == typeof r2) {
          if (0 === r2.indexOf("nim-external")) {
            var i2 = document.getElementById(r2);
            if (!(i2 && i2.files && i2.files[0]))
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_FILE_NOT_FOUND, detail: { reason: `getFileOrPath::file not exist: ${r2}` } });
            t2 = i2.files[0];
          } else if ("BROWSER" === ge.platform)
            throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_MISUSE, detail: { reason: `getFileOrPath::incorrect path: ${r2}` } });
        }
        if ("object" == typeof t2 && void 0 === t2.size)
          throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_MISUSE, detail: { reason: "getFileOrPath::file no size" } });
        return { file: t2, path: r2 };
      }
      var Ia = { attachment: { type: "object", rules: { url: { type: "string", allowEmpty: false } } }, thumbSize: { type: "object", rules: { width: { type: "number", required: false, min: 0 }, height: { type: "number", required: false, min: 0 } } } };
      class V2NIMStorageUtil extends V2Service {
        constructor(e2) {
          super("V2NIMStorageUtil", e2), this.core = e2;
        }
        imageThumbUrl(e2, t2) {
          return e2 + `?imageView&thumbnail=${t2}z${t2}`;
        }
        videoCoverUrl(e2, t2) {
          return e2 + `?vframe&offset=${t2}`;
        }
        getImageThumbUrl(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2();
            var r2 = e2;
            validate(Ia, { attachment: r2, thumbSize: t2 }, "", true), t2.width = t2.width || 0, t2.height = t2.height || 0, 0 === t2.width && 0 === t2.height && (t2.width = 150);
            var i2 = r2.url;
            try {
              i2 = yield this.core.V2NIMStorageService.shortUrlToLong(r2.url);
            } catch (e3) {
              this.core.logger.warn("shortUrlToLong error:", e3);
            }
            return { url: this.core.cloudStorage.getThumbUrl(i2, t2) };
          });
        }
        getVideoCoverUrl(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2();
            var r2 = e2;
            validate(Ia, { attachment: r2, thumbSize: t2 }, "", true), t2.width = t2.width || 0, t2.height = t2.height || 0, 0 === t2.width && 0 === t2.height && (t2.width = 150);
            var i2 = r2.url;
            try {
              i2 = yield this.core.V2NIMStorageService.shortUrlToLong(r2.url);
            } catch (e3) {
              this.core.logger.warn("shortUrlToLong error:", e3);
            }
            return { url: this.core.cloudStorage.getVideoCoverUrl(i2, t2) };
          });
        }
      }
      class V2NIMStorageServiceImpl extends V2Service {
        constructor(e2) {
          super("V2NIMStorageService", e2), this.sceneMap = { nim_default_profile_icon: { sceneName: "nim_default_profile_icon", expireTime: 0 }, nim_default_im: { sceneName: "nim_default_im", expireTime: 0 }, nim_system_nos_scene: { sceneName: "nim_system_nos_scene", expireTime: 0 }, nim_security: { sceneName: "nim_security", expireTime: 0 } }, this.uploadingMessageInfo = {}, this.core = e2, this.core._registerDep(CloudStorageService, "cloudStorage"), this.core._registerDep(V2NIMStorageUtil, "V2NIMStorageUtil");
        }
        addCustomStorageScene(e2, t2) {
          return this.checkV2(), validate({ sceneName: { type: "string", allowEmpty: false }, expireTime: { type: "number", min: 0 } }, { sceneName: e2, expireTime: t2 }, "", true), this.sceneMap[e2] = { sceneName: e2, expireTime: t2 }, { sceneName: e2, expireTime: t2 };
        }
        getStorageSceneList() {
          return this.checkV2(), Object.values(this.sceneMap);
        }
        getStorageScene(e2) {
          return e2 && this.sceneMap[e2] || this.sceneMap.nim_default_im;
        }
        hasStorageScene(e2) {
          return void 0 !== this.sceneMap[e2];
        }
        createUploadFileTask(e2) {
          if (this.checkV2(), "string" == typeof e2.fileObj && 0 === e2.fileObj.indexOf("nim-external")) {
            var t2 = document.getElementById(e2.fileObj);
            t2 && t2.files && t2.files[0] && (e2.fileObj = t2.files[0]);
          }
          return { taskId: Ie(), uploadParams: e2 };
        }
        uploadFile(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.checkV2(), validate({ taskId: { type: "string", allowEmpty: false } }, e2, "fileTask", true), (yield this._uploadFile(e2, t2))[0];
          });
        }
        uploadFileWithMetaInfo(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.checkV2(), validate({ taskId: { type: "string", allowEmpty: false } }, e2, "fileTask", true), function formatV2NIMFileMetaInfo(e3) {
              var { url: t3, name: r2, size: i2, ext: s2, md5: n2, h: a2, w: o2, orientation: c2, dur: d2, audioCodec: l2, videoCodec: m2, container: p2 } = e3;
              return JSON.parse(JSON.stringify({ url: t3, name: r2, size: i2, ext: s2, md5: n2, height: a2, width: o2, orientation: c2, duration: d2, audioCodec: l2, videoCodec: m2, container: p2 }));
            }((yield this._uploadFile(e2, t2))[1]);
          });
        }
        _uploadFile(e2, t2, r2) {
          var i2;
          return __awaiter(this, void 0, void 0, function* () {
            if (!this.core.cloudStorage || !this.core.cloudStorage.uploadFile)
              throw new Error('Service "cloudStorage" does not exist');
            var { uploadParams: s2, taskId: n2 } = e2, { file: a2, path: o2 } = getFileOrPath(s2.fileObj), { fileType: c2 } = r2 || {};
            if (this.uploadingMessageInfo[n2])
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_RESOURCE_ALREADY_EXIST, detail: { reason: "V2NIMStorageService.uploadFile: repeat upload" } });
            try {
              var d2 = {};
              a2 ? d2.file = a2 : o2 && (0 === (null == o2 ? void 0 : o2.indexOf("nim-external")) ? d2.fileInput = o2 : d2.filePath = o2);
              var l2 = this.getStorageScene(s2.sceneName);
              if (d2.nosScenes = l2.sceneName, d2.nosSurvivalTime = l2.expireTime, d2.type = 1 === c2 ? "image" : 2 === c2 ? "audio" : 3 === c2 ? "video" : "file", d2.file && this.core.pluginMap["browser-md5-file"]) {
                var m2 = yield this.getFileMd5(this.core.pluginMap["browser-md5-file"], n2, d2.file);
                d2.md5 = m2;
              }
              d2.onUploadProgress = (e3) => {
                "function" == typeof t2 && t2(Math.round(100 * e3.percentage));
              }, d2.onUploadStart = (e3) => {
                var t3;
                if (null === (t3 = this.uploadingMessageInfo[n2]) || void 0 === t3 ? void 0 : t3.abort)
                  return e3.abort(), void delete this.uploadingMessageInfo[n2];
                this.uploadingMessageInfo[n2] = { abort: false, task: e3 };
              }, this.uploadingMessageInfo[n2] = { abort: false };
              var p2 = yield this.core.cloudStorage.uploadFile(d2);
              if (null === (i2 = this.uploadingMessageInfo[n2]) || void 0 === i2 ? void 0 : i2.abort)
                throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_CANCELLED, detail: { reason: "upload file aborted" } });
              return delete this.uploadingMessageInfo[n2], [p2.url, p2];
            } catch (e3) {
              throw delete this.uploadingMessageInfo[n2], this.core.logger.error("sendFile:: upload File error or abort.", e3), e3;
            }
          });
        }
        cancelUploadFile(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), yield this._cancelUploadFile(e2.taskId);
          });
        }
        _cancelUploadFile(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2();
            var t2 = this.uploadingMessageInfo[e2];
            if (null == t2 ? void 0 : t2.task)
              try {
                this.logger.log("V2NIMStorageService.cancelUploadFile: uploadInfo task exist"), yield t2.task.abort(), delete this.uploadingMessageInfo[e2];
              } catch (t3) {
                delete this.uploadingMessageInfo[e2], this.core.logger.error("cancelMessageAttachmentUpload::abort error.", t3);
              }
            else {
              if (!t2)
                throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_RESOURCE_NOT_EXIST, detail: { reason: "V2NIMStorageService.cancelUploadFile: uploadInfo not exist" } });
              this.logger.log("V2NIMStorageService.cancelUploadFile: uploadInfo task not exist"), t2.abort = true;
            }
          });
        }
        getFileMd5(e2, t2, r2) {
          return __awaiter(this, void 0, void 0, function* () {
            return new Promise((i2, s2) => {
              var n2, a2 = new e2();
              (null === (n2 = this.uploadingMessageInfo[t2]) || void 0 === n2 ? void 0 : n2.abort) ? s2(new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_CANCELLED, detail: { reason: "upload file aborted" } })) : this.uploadingMessageInfo[t2] = { abort: false, task: a2 };
              try {
                a2.md5(r2, (e3, t3) => {
                  "aborted" === e3 ? s2(new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_CANCELLED, detail: { reason: e3 } })) : e3 ? s2(new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INTERNAL, detail: { reason: "md5 calculate error in callback", rawError: e3 } })) : i2(t3);
                });
              } catch (e3) {
                s2(new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INTERNAL, detail: { reason: "md5 calculate error", rawError: e3 } }));
              }
            });
          });
        }
        shortUrlToLong(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.checkV2(), this.core.cloudStorage.getOriginUrl(e2);
          });
        }
        getImageThumbUrl(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.core.V2NIMStorageUtil.getImageThumbUrl(e2, t2);
          });
        }
        getVideoCoverUrl(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.core.V2NIMStorageUtil.getVideoCoverUrl(e2, t2);
          });
        }
      }
      class V2NIMMessageCreatorImpl extends V2Service {
        constructor(e2) {
          super("V2NIMMessageCreator", e2), this.name = "V2NIMMessageCreator", this.defaultNosSceneName = "nim_default_im", this.core = e2;
        }
        createMessage(e2, t2) {
          return Object.assign(Object.assign(Object.assign({ messageClientId: Ie(), messageType: e2, createTime: this.core.timeOrigin.getNTPTime(), sendingState: 0, messageStatus: { errorCode: 200 }, messageSource: 0, isSelf: true }, t2), t2.attachment ? { attachment: Object.assign(Object.assign({}, t2.attachment), { raw: attachmentToRaw(e2, t2.attachment) }) } : {}), { senderId: "", receiverId: "", conversationType: 0, conversationId: "", messageServerId: "", messageConfig: Object.assign({ unreadEnabled: true, roamingEnabled: true, readReceiptEnabled: false, lastMessageUpdateEnabled: true, historyEnabled: true, onlineSyncEnabled: true, offlineEnabled: true }, t2.messageConfig), pushConfig: Object.assign({ pushEnabled: true, pushNickEnabled: true, forcePush: false }, t2.pushConfig), routeConfig: Object.assign({ routeEnabled: true }, t2.routeConfig), antispamConfig: Object.assign({ antispamEnabled: true }, t2.antispamConfig) });
        }
        createTextMessage(e2) {
          return this.checkV2(), validate({ text: { type: "string", allowEmpty: false } }, { text: e2 }, "", true), this.createMessage(0, { text: e2 });
        }
        createImageMessage(e2, t2, r2, i2, s2) {
          this.checkV2(), validate(xn, { name: t2, sceneName: r2, width: i2, height: s2 }, "", true);
          var n2 = this.createGenericFileMessageAttachment(e2, t2, r2, void 0, i2, s2, "jpeg");
          return this.createMessage(1, { attachment: n2, attachmentUploadState: 0 });
        }
        createAudioMessage(e2, t2, r2, i2) {
          this.checkV2(), validate(Dn, { name: t2, sceneName: r2, duration: i2 }, "", true);
          var s2 = this.createGenericFileMessageAttachment(e2, t2, r2, i2, void 0, void 0, "aac");
          return this.createMessage(2, { attachment: s2, attachmentUploadState: 0 });
        }
        createVideoMessage(e2, t2, r2, i2, s2, n2) {
          this.checkV2(), validate(qn, { name: t2, sceneName: r2, duration: i2, width: s2, height: n2 }, "", true);
          var a2 = this.createGenericFileMessageAttachment(e2, t2, r2, i2, s2, n2, "mp4");
          return this.createMessage(3, { attachment: a2, attachmentUploadState: 0 });
        }
        createFileMessage(e2, t2, r2) {
          this.checkV2(), validate(Un, { name: t2, sceneName: r2 }, "", true);
          var i2 = this.createGenericFileMessageAttachment(e2, t2, r2, void 0, void 0, void 0, "txt");
          return this.createMessage(6, { attachment: i2, attachmentUploadState: 0 });
        }
        createGenericFileMessageAttachment(e2, t2, r2, i2, s2, n2, a2) {
          if (r2 = r2 || this.defaultNosSceneName, !this.core.V2NIMStorageService.hasStorageScene)
            throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_MISUSE, detail: { reason: "V2NIMStorageService not exist" } });
          if (!this.core.V2NIMStorageService.hasStorageScene(r2))
            throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "sceneName: " + r2 + " has not been added" } });
          var { file: o2, path: c2 } = getFileOrPath(e2), d2 = Object.assign(Object.assign(Object.assign({ name: t2, uploadState: 0, sceneName: r2 || this.defaultNosSceneName }, i2 ? { duration: i2 } : {}), s2 ? { width: s2 } : {}), n2 ? { height: n2 } : {});
          if (o2) {
            var l2 = o2.name.lastIndexOf("."), m2 = -1 === l2 ? o2.name : o2.name.substring(0, l2);
            d2.name = d2.name || m2, d2.size = o2.size, d2.ext = `.${getFileExtension(o2.name) || getFileExtension(t2 || "") || a2}`;
          } else if (c2) {
            var p2 = c2.lastIndexOf("/"), u2 = c2.lastIndexOf("."), h2 = -1 === u2 ? c2.substring(p2 + 1) : c2.substring(p2 + 1, u2);
            d2.name = d2.name || h2, d2.ext = `.${getFileExtension(c2) || getFileExtension(t2 || "") || a2}`;
          }
          return d2 = JSON.parse(JSON.stringify(d2)), c2 ? d2.path = c2 : o2 && (d2.file = o2), d2;
        }
        createLocationMessage(e2, t2, r2) {
          return this.checkV2(), validate({ latitude: { type: "number", allowEmpty: false }, longitude: { type: "number", allowEmpty: false }, address: { type: "string", allowEmpty: false } }, { latitude: e2, longitude: t2, address: r2 }, "", true), this.createMessage(4, { attachment: { latitude: e2, longitude: t2, address: r2 } });
        }
        createCustomMessage(e2, t2) {
          return this.checkV2(), validate({ text: { type: "string" } }, { text: e2 }, "", true), validate({ rawAttachment: { type: "string" } }, { rawAttachment: t2 }, "", true), this.createMessage(100, { text: e2, attachment: { raw: t2 } });
        }
        createCustomMessageWithAttachment(e2, t2) {
          return this.checkV2(), validate({ raw: { type: "string" } }, e2, "attachment", true), validate({ subType: { type: "number", min: 0, required: false } }, { subType: t2 }, "", true), this.createMessage(100, t2 ? { attachment: e2, subType: t2 } : { attachment: e2 });
        }
        createCallMessage(e2, t2, r2, i2, s2) {
          return this.checkV2(), validate({ type: { type: "number", allowEmpty: false } }, { type: e2 }, "", true), validate({ channelId: { type: "string", allowEmpty: false } }, { channelId: t2 }, "", true), validate({ status: { type: "number", allowEmpty: false } }, { status: r2 }, "", true), validate({ durations: { type: "array", allowEmpty: false } }, { durations: i2 }, "", true), this.createMessage(12, { text: s2 || "", attachment: { type: e2, channelId: t2, durations: i2, status: r2 } });
        }
        createForwardMessage(e2) {
          this.checkV2();
          if (!e2 || [11, 5, 7, 10].includes(e2.messageType))
            return null;
          var t2 = { messageClientId: Ie(), messageType: e2.messageType };
          return e2.text && (t2.text = e2.text), e2.attachment && (t2.attachment = e2.attachment), e2.attachment && "uploadState" in e2.attachment && (t2.attachmentUploadState = e2.attachment.uploadState), this.createMessage(e2.messageType, t2);
        }
        createTipsMessage(e2) {
          return this.checkV2(), validate({ text: { type: "string", allowEmpty: false } }, { text: e2 }, "", true), this.createMessage(10, { text: e2 });
        }
      }
      class V2NIMMessageAttachmentCreatorImpl {
        constructor() {
          this.name = "V2NIMMessageAttachmentCreator";
        }
        createLocationMessageAttachment(e2, t2, r2) {
          return { latitude: "number" == typeof e2 ? e2 : 0, longitude: "number" == typeof t2 ? t2 : 0, address: "string" == typeof r2 ? r2 : "" };
        }
        createCustomMessageAttachment(e2) {
          return { raw: "string" == typeof e2 ? e2 : "" };
        }
      }
      class V2NIMClientAntispamUtilImpl {
        constructor(e2) {
          this.config = { enable: false }, this.name = "V2NIMClientAntispamUtil", this.core = e2;
        }
        setOptions(e2) {
          this.config = Object.assign(this.config, e2);
        }
        reset(e2) {
          "destroy" === e2 && (this.vocabInfo = void 0);
        }
        downloadLocalAntiSpamVocabs() {
          return __awaiter(this, void 0, void 0, function* () {
            if (this.config.enable && !this.vocabInfo)
              try {
                var e2 = yield this.core.sendCmd("v2DownloadLocalAntiSpamVocabs", { tag: { version: 0, md5: "" } });
                this.vocabInfo = Object.assign(Object.assign({}, e2.content.data), { thesaurus: JSON.parse(e2.content.data.thesaurus).thesaurus });
              } catch (e3) {
                this.core.logger.warn("V2NIMLocalAntispamUtil::downloadLocalAntiSpamVocabs error", e3);
              }
          });
        }
        checkTextAntispam(e2, t2 = "**") {
          if (!this.config.enable)
            return { operateType: 0, replacedText: e2 };
          if (validate({ text: { type: "string", required: true, allowEmpty: false }, replace: { type: "string" } }, { text: e2, replace: t2 }, "", true), !this.vocabInfo)
            return { operateType: 0, replacedText: e2 };
          for (var r2 = e2, i2 = 0; i2 < this.vocabInfo.thesaurus.length; i2++) {
            var s2 = this.filterContent(r2, this.vocabInfo.thesaurus[i2], t2);
            if (r2 = s2.replacedText, 2 === s2.operateType || 3 === s2.operateType)
              return s2;
          }
          return { operateType: r2 === e2 ? 0 : 1, replacedText: r2 };
        }
        filterContent(e2, t2, r2) {
          for (var i2 = 0; i2 < t2.keys.length; i2++) {
            var s2 = t2.keys[i2], n2 = s2.match || t2.match, a2 = s2.operate || t2.operate, o2 = void 0;
            try {
              o2 = this.matchContent(e2, s2.key, n2, a2, r2);
            } catch (e3) {
            }
            if (o2 && (e2 = o2.replacedText, 2 === o2.operateType || 3 === o2.operateType))
              return o2;
          }
          return { operateType: 1, replacedText: e2 };
        }
        matchContent(e2, t2, r2, i2, s2) {
          var n2 = false, a2 = null;
          if (1 === r2) {
            if (e2.indexOf(t2) >= 0) {
              n2 = true;
              var o2 = t2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
              a2 = new RegExp(o2, "g");
            }
          } else
            2 === r2 && (a2 = new RegExp(t2, "g")).test(e2) && (n2 = true);
          if (n2 && a2)
            switch (i2) {
              case 1:
                return { operateType: 1, replacedText: e2.replace(a2, s2) };
              case 2:
                return { operateType: 2, replacedText: e2 };
              case 3:
                return { operateType: 3, replacedText: e2 };
            }
          return { operateType: 0, replacedText: e2 };
        }
      }
      class YSFServiceImpl extends V2Service {
        constructor(e2) {
          super("YSFService", e2), this.core._registerDep(V2NIMConversationIdUtilImpl, "V2NIMConversationIdUtil"), this.core._registerDep(V2NIMMessageCreatorImpl, "V2NIMMessageCreator"), this.core._registerDep(V2NIMMessageAttachmentCreatorImpl, "V2NIMMessageAttachmentCreator"), this.core._registerDep(V2NIMClientAntispamUtilImpl, "V2NIMClientAntispamUtil"), this.core._registerDep(V2NIMStorageServiceImpl, "V2NIMStorageService"), this.sendUtil = new SendUtil(this.core, this), this.fileUtil = new FileUtil(this.core), this.model = new V2NIMMessageModelImpl(), this.notificationUtil = new NotificationUtil(this.core), registerParser({ cmdMap: va, cmdConfig: ya });
        }
        emit(e2, ...t2) {
          var r2, i2 = `${this.name}::emit ${e2.toString()}`;
          if ("onSendMessage" === e2) {
            var s2 = t2[0];
            this.logger.log(`${i2}`, `${s2.messageClientId}/${s2.messageServerId};createTime:${s2.createTime};`, `sendingState:${s2.sendingState};attachmentUploadState:${s2.attachmentUploadState || 0};messageStatus:${null === (r2 = s2.messageStatus) || void 0 === r2 ? void 0 : r2.errorCode}`);
          } else if ("onReceiveMessages" === e2) {
            var n2 = t2[0];
            this.logger.log(`${i2}`, n2.map((e3) => `${e3.messageClientId}/${e3.messageServerId};createTime:${e3.createTime}`));
          } else if ("onReceiveCustomNotifications" === e2) {
            var a2 = t2[0];
            this.logger.log(`${i2}`, a2.map((e3) => `sender:${e3.senderId};receiver:${e3.receiverId};ctype:${e3.conversationType};time:${e3.timestamp}`));
          } else
            this.logger.log(`${i2}`, ...t2);
          return super.emit(e2, ...t2);
        }
        sendMessage(e2, t2, r2 = {}, i2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ message: { type: "object" } }, { message: e2 }, "", true), e2.messageClientId = e2.messageClientId || Ie(), validate(hn, { conversationId: t2, message: e2, params: r2 }, "", true), validateConversationId(this.core.account, t2);
            var s2 = this.core.timeOrigin.getTimeNode(), { messageBeforeSend: n2, clientAntispamResult: a2, hiddenParams: o2 } = this.sendUtil.prepareMessage(e2, t2, r2), c2 = yield this.sendUtil.doSendMessage({ apiCallingTimeNode: s2, messageBeforeSend: n2, clientAntispamResult: a2, hiddenParams: o2, progress: i2 });
            return c2.message.senderId === c2.message.receiverId && this.markMsgsAck([c2.message]), c2;
          });
        }
        sendCustomNotification(e2, t2, r2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validateConversationId(this.core.account, e2), validate(fa, { content: t2, params: r2 }, "", true);
            var i2 = this.notificationUtil.generateNotificationTag(e2, t2, r2);
            i2.type = 100, yield this.core.sendCmd("ysfSendCustomNotification", { tag: i2 });
          });
        }
        sendMessageFn(e2) {
        }
        cancelMessageAttachmentUpload(e2) {
          return this.fileUtil.cancelMessageAttachmentUpload(e2);
        }
        markMsgsAck(e2) {
          if (e2 && e2.length > 0) {
            var t2 = e2.map((e3) => e3.messageServerId).filter((e3) => e3 && "0" !== e3);
            0 !== t2.length && this.core.sendCmd("ysfBatchMarkRead", { sid: 101, cid: 2, ids: t2 });
          }
        }
        markNotificationAck(e2) {
          if (e2 && e2.length > 0) {
            var t2 = e2.map((e3) => e3.idServer).filter((e3) => e3 && "0" !== e3);
            0 !== t2.length && this.core.sendCmd("ysfBatchMarkRead", { sid: 101, cid: 3, ids: t2 });
          }
        }
        ysfOnMsgHandler(e2) {
          var t2 = fillIdServer(e2, e2.content.data, "messageServerId"), r2 = completeMessage(this.core, t2);
          delete r2.__clientExt, this.emit("onReceiveMessages", [r2]), this.model.upsertMessages([r2]), this.markMsgsAck([r2]);
        }
        ysfSyncOfflineMsgsHandler(e2) {
          var t2 = e2.content.datas;
          t2 = t2.map((e3) => completeMessage(this.core, e3)), this.markMsgsAck(t2), this.emit("onReceiveMessages", t2), this.model.upsertMessages(t2);
        }
        ysfOnSysNotificationHandler(e2) {
          var t2 = fillIdServer(e2, e2.content.data, "idServer");
          this.markNotificationAck([t2]);
          var r2 = this.processSystemNotification(t2);
          r2 && this.emit("onReceiveCustomNotifications", [r2]);
        }
        processSystemNotification(e2) {
          var t2 = Object.assign(Object.assign({}, e2), { conversationType: 1 });
          return delete t2.type, t2;
        }
        ysfSyncSysNotificationHandler(e2) {
          this.markNotificationAck(e2.content.datas);
          var t2 = e2.content.datas.sort((e3, t3) => e3.timestamp - t3.timestamp).map((e3) => this.processSystemNotification(e3)).filter((e3) => e3);
          t2 && this.emit("onReceiveCustomNotifications", t2);
        }
      }
      class SendUtil {
        constructor(e2, t2) {
          this.uploadingMessageInfo = {}, this.core = e2, this.service = t2;
        }
        prepareMessage(e2, t2, r2, i2) {
          var s2 = this.checkIfResend(e2), n2 = this.generateSendMessage({ message: e2, params: r2, resend: s2, conversationId: t2, replyMessage: i2 }), a2 = Object.assign({}, r2.targetConfig ? { targetConfig: r2.targetConfig } : {}), { clientAntispamResult: o2, text: c2 } = this.checkIfAntispam(r2, n2);
          return n2.text = c2, n2.clientAntispamHit = !!o2 && 3 === o2.operateType, { messageBeforeSend: n2, clientAntispamResult: o2, hiddenParams: a2 };
        }
        checkIfAntispam(e2, t2) {
          var r2, i2 = t2.text;
          if (e2.clientAntispamEnabled && (0 === t2.messageType || 10 === t2.messageType)) {
            if (1 === (r2 = this.core.V2NIMClientAntispamUtil.checkTextAntispam ? this.core.V2NIMClientAntispamUtil.checkTextAntispam(t2.text || "", e2.clientAntispamReplace) : { operateType: 0, replacedText: "" }).operateType)
              i2 = r2.replacedText;
            else if (2 === r2.operateType)
              throw this.service.emit("onSendMessage", Object.assign(Object.assign({}, t2), { sendingState: 2, messageStatus: { errorCode: ce.V2NIM_ERROR_CODE_CLIENT_ANTISPAM } })), new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_CLIENT_ANTISPAM, detail: { reason: "sendMessage: text intercepted by client antispam" } });
          }
          return { clientAntispamResult: r2, text: i2 };
        }
        doMsgReceiveReport(e2, t2) {
          if (e2.senderId !== this.core.account) {
            var r2 = get(e2, "__clientExt.statistics.apiCallingTime") || 0, i2 = get(e2, "__clientExt.statistics.sendTime") || 0, s2 = get(e2, "__clientExt.statistics.attachUploadDuration") || 0, n2 = this.core.timeOrigin.getNTPTime(), a2 = e2.createTime, o2 = this.core.timeOrigin.checkNodeReliable(t2.__receiveTimeNode) ? this.core.timeOrigin.getNTPTime(t2.__receiveTimeNode) : n2;
            this.core.reporter.report("msgReceive", { msgId: e2.messageServerId, clientId: e2.messageClientId, serverTime: e2.createTime, receiveTime: o2, fromAccid: 1 === e2.conversationType ? e2.senderId : "", toAccid: e2.receiverId, type: conversationTypeV2ToV1(e2.conversationType), tid: 1 === e2.conversationType ? "" : e2.receiverId, apiCallingTime: r2, sendTime: i2, attachUploadDuration: s2, callbackTime: n2, preHandleTime: n2, result: 200, failReason: "", rt: n2 - a2 });
          }
        }
        checkIfResend(e2) {
          var t2 = this.service.model.getMessageById(e2.messageClientId), r2 = false;
          if ("messageServerId" in e2 && "0" !== e2.messageServerId && "" !== e2.messageServerId)
            throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "sendMessage: message has already been sent" } });
          if (t2 && "messageServerId" in t2 && "0" !== t2.messageServerId && "" !== t2.messageServerId)
            throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "sendMessage: message has already been sent" } });
          return t2 && (r2 = true), r2;
        }
        doSendMessage(e2) {
          var t2;
          return __awaiter(this, void 0, void 0, function* () {
            var r2, i2, { apiCallingTimeNode: s2, messageBeforeSend: n2, clientAntispamResult: a2, hiddenParams: o2, progress: c2 } = e2, d2 = {}, l2 = this.service instanceof YSFServiceImpl;
            if (l2)
              r2 = "ysfSendMessage";
            else if (1 === n2.conversationType)
              r2 = "v2SendP2pMessage";
            else if (2 === n2.conversationType)
              r2 = "v2SendTeamMessage";
            else {
              if (3 !== n2.conversationType)
                throw new ValidateErrorV2({ detail: { reason: `conversationType: ${n2.conversationType} is not supported` } });
              r2 = "v2SendSuperTeamMessage";
            }
            if (this.service.sendMessageFn(n2), !l2 && this.core.eventBus.emit("forwardSend/V2NIMMessageService/sendMsg", n2), !n2.attachment || !("uploadState" in n2.attachment) || n2.attachment.url || 0 !== n2.attachment.uploadState && 2 !== n2.attachment.uploadState)
              this.service.emit("onSendMessage", n2);
            else {
              var m2 = Date.now();
              try {
                n2.attachmentUploadState = 3, n2.attachment.uploadState = 3, this.service.emit("onSendMessage", n2), yield this.service.fileUtil.doSendFile(n2, c2), n2.attachmentUploadState = 1, n2.attachment.uploadState = 1, this.service.emit("onSendMessage", n2);
              } catch (e3) {
                throw n2.attachmentUploadState = 2, n2.attachment.uploadState = 2, n2.sendingState = 2, n2.messageStatus = { errorCode: e3.code || ce.V2NIM_ERROR_CODE_UNKNOWN }, this.service.emit("onSendMessage", n2), d2.attachUploadDuration = Date.now() - m2, this.doSendMessageFailed(s2, d2, n2, e3), e3;
              }
              d2.attachUploadDuration = Date.now() - m2;
            }
            this.core.timeOrigin.checkNodeReliable(s2) && (d2.apiCallingTime = this.core.timeOrigin.getNTPTime(s2), d2.sendTime = this.core.timeOrigin.getNTPTime(), n2.__clientExt = { statistics: d2 });
            try {
              i2 = yield this.core.sendCmd(r2, { tag: Object.assign({}, n2, o2) });
            } catch (e3) {
              throw this.doSendMessageFailed(s2, d2, n2, e3), n2.sendingState = 2, n2.messageStatus = { errorCode: e3.code || ce.V2NIM_ERROR_CODE_UNKNOWN }, this.service.emit("onSendMessage", n2), e3;
            }
            var p2 = get(i2, "content.data.errorCode"), u2 = Object.assign(Object.assign(Object.assign(Object.assign({}, n2), i2.content.data), n2.aiConfig ? { aiConfig: Object.assign(Object.assign({}, n2.aiConfig), (null === (t2 = i2.content.data) || void 0 === t2 ? void 0 : t2.aiConfig) || {}) } : {}), { sendingState: 1, messageStatus: { errorCode: p2 && 200 !== p2 ? p2 : 200 } });
            this.service.sendMessageFn(u2), !l2 && this.core.eventBus.emit("forwardSend/V2NIMMessageService/sendMsg", u2), this.doMsgSendReport(s2, d2, n2);
            var h2 = u2.antispamResult;
            return h2 && (u2.messageStatus.errorCode = ce.V2NIM_ERROR_CODE_SERVER_ANTISPAM), delete u2.antispamResult, this.service.emit("onSendMessage", u2), Object.assign(Object.assign({ message: u2 }, h2 ? { antispamResult: h2 } : {}), a2 ? { clientAntispamResult: a2 } : {});
          });
        }
        doSendMessageFailed(e2, t2, r2, i2) {
          var s2 = Object.assign(Object.assign({}, r2), { sendingState: 2 });
          this.core.eventBus.emit("forwardSend/V2NIMMessageService/sendMsg", s2), this.service.sendMessageFn(s2), this.doMsgSendReport(e2, t2, r2, i2);
        }
        doMsgSendReport(e2, t2, r2, i2) {
          t2.apiCallingTime = this.core.timeOrigin.getNTPTime(e2), t2.sendTime = this.core.timeOrigin.getNTPTime();
          var s2 = this.core.timeOrigin.getNTPTime(), n2 = get(i2, "detail.reason");
          this.core.reporter.report("msgSend", { msgId: r2.messageServerId, clientId: r2.messageClientId, msgTime: r2.createTime, fromAccid: 1 === r2.conversationType ? r2.senderId : "", toAccid: r2.receiverId, type: conversationTypeV2ToV1(r2.conversationType), tid: 1 === r2.conversationType ? "" : r2.receiverId, result: i2 ? i2.code : 200, failReason: n2 || (null == i2 ? void 0 : i2.message) || "", rt: s2 - t2.apiCallingTime, apiCallingTime: t2.apiCallingTime, sendTime: t2.sendTime, attachUploadDuration: t2.attachUploadDuration, apiCallbackTime: s2 });
        }
        generateSendMessage(e2) {
          var t2, r2, { conversationId: i2, replyMessage: s2, resend: n2, message: a2, params: o2 } = e2, c2 = {};
          if (s2) {
            var d2 = s2.threadRoot;
            c2 = { threadReply: { senderId: s2.senderId, receiverId: s2.receiverId, messageServerId: s2.messageServerId, createTime: s2.createTime, messageClientId: s2.messageClientId, conversationType: s2.conversationType, conversationId: s2.conversationId }, threadRoot: { senderId: d2 ? d2.senderId : s2.senderId, receiverId: d2 ? d2.receiverId : s2.receiverId, messageServerId: d2 ? d2.messageServerId : s2.messageServerId, createTime: d2 ? d2.createTime : s2.createTime, messageClientId: d2 ? d2.messageClientId : s2.messageClientId, conversationType: d2 ? d2.conversationType : s2.conversationType, conversationId: d2 ? d2.conversationId : s2.conversationId } };
          }
          var l2 = this.core.V2NIMConversationIdUtil.parseConversationType(i2), m2 = this.core.V2NIMConversationIdUtil.parseConversationTargetId(i2);
          o2.pushConfig && true !== o2.pushConfig.forcePush && (delete o2.pushConfig.forcePushContent, delete o2.pushConfig.forcePushAccountIds);
          var p2 = {}, u2 = {};
          if (o2.aiConfig) {
            var h2 = get(o2, "aiConfig.content.msg"), g2 = get(o2, "aiConfig.content.type") || 0;
            h2 ? u2 = { msg: h2, type: g2 } : void 0 === h2 && 0 === a2.messageType && (u2 = { msg: a2.text || "", type: g2 }), (p2 = Object.assign({ aiStreamStatus: 0, aiStream: false }, o2.aiConfig)).aiStatus = 1, void 0 !== u2.msg && (p2.content = u2);
          }
          var v2 = null === (r2 = null === (t2 = this.core.V2NIMUserService) || void 0 === t2 ? void 0 : t2.model) || void 0 === r2 ? void 0 : r2.getUser(this.core.account), y2 = (null == v2 ? void 0 : v2.updateTime) || 0;
          return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, a2), c2), { messageConfig: Object.assign(Object.assign({}, a2.messageConfig), o2.messageConfig), routeConfig: Object.assign(Object.assign({}, a2.routeConfig), o2.routeConfig), pushConfig: Object.assign(Object.assign({}, a2.pushConfig), o2.pushConfig), antispamConfig: Object.assign(Object.assign({}, a2.antispamConfig), o2.antispamConfig), robotConfig: Object.assign(Object.assign({}, a2.robotConfig), o2.robotConfig) }), p2 && p2.accountId ? { aiConfig: p2 } : {}), a2.attachment ? { attachment: Object.assign({}, a2.attachment) } : {}), { resend: n2, senderId: this.core.account, conversationType: l2, receiverId: m2, conversationId: this.core.V2NIMConversationIdUtil.messageConversationId({ conversationType: l2, senderId: this.core.account, receiverId: m2 }) }), y2 ? { userUpdateTime: y2 } : {}), { sendingState: 3 });
        }
      }
      class ModifyUtil {
        constructor(e2, t2) {
          this.core = e2, this.service = t2;
        }
        checkIfModify(e2, t2) {
          if ("0" === e2.messageServerId)
            throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "modifyMessage: messageServerId cannot be empty" } });
          if (![0, 1, 2, 3, 4, 6, 10, 12, 100].includes(e2.messageType))
            throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: `modifyMessage: messageType ${e2.messageType} not correct` } });
          if ([0, 1, 2, 3, 6, 10, 12].includes(e2.messageType) && t2.attachment)
            throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: `modifyMessage: messageType ${e2.messageType} can not modify attachment` } });
          var r2 = ["subType", "text", "serverExtension", "attachment"];
          if (!r2.some((e3) => void 0 !== get(t2, e3)))
            throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "modifyMessage: missing modified params" } });
          if (r2.every((r3) => "attachment" === r3 ? e2.attachment && t2.attachment ? attachmentToRaw(e2.messageType, e2.attachment) === attachmentToRaw(e2.messageType, t2.attachment) : !t2.attachment : get(e2, r3) === get(t2, r3)))
            throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "modifyMessage: no change" } });
        }
        prepareMessage(e2, t2) {
          var r2 = this.generateSendMessage(e2, t2), { clientAntispamResult: i2, text: s2 } = this.checkIfAntispam(t2, r2);
          return r2.text = s2, r2.clientAntispamHit = !!i2 && 3 === i2.operateType, { messageBeforeSend: r2, clientAntispamResult: i2 };
        }
        modifyMessage(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            var r2;
            if (1 === e2.conversationType)
              r2 = "v2MessageP2pModify";
            else if (2 === e2.conversationType)
              r2 = "v2MessageTeamModify";
            else {
              if (3 !== e2.conversationType)
                throw new ValidateErrorV2({ detail: { reason: `conversationType: ${e2.conversationType} is not supported` } });
              r2 = "v2MessageSuperTeamModify";
            }
            var i2 = yield this.core.sendCmd(r2, { tag: e2 });
            if (t2 && 3 === t2.operateType)
              return { errorCode: ce.V2NIM_ERROR_CODE_CLIENT_ANTISPAM, clientAntispamResult: t2 };
            var s2 = Object.assign(Object.assign({}, e2), i2.content.data), n2 = s2.antispamResult;
            if (n2)
              return Object.assign({ errorCode: ce.V2NIM_ERROR_CODE_SERVER_ANTISPAM, antispamResult: n2 }, t2 ? { clientAntispamResult: t2 } : {});
            delete s2.antispamResult;
            var a2 = completeMessage(this.core, s2);
            return this.service.model.upsertMessages([a2]), this.core.eventBus.emit("V2NIMMessageService/modifyMsg", a2), this.core.eventBus.emit("forwardSend/V2NIMMessageService/modifyMsg", a2), Object.assign(Object.assign({ errorCode: 200, message: a2 }, n2 ? { antispamResult: n2 } : {}), t2 ? { clientAntispamResult: t2 } : {});
          });
        }
        checkIfAntispam(e2, t2) {
          var r2, i2 = t2.text;
          if (e2.clientAntispamEnabled && (0 === t2.messageType || 10 === t2.messageType)) {
            if (1 === (r2 = this.core.V2NIMClientAntispamUtil.checkTextAntispam ? this.core.V2NIMClientAntispamUtil.checkTextAntispam(t2.text || "", e2.clientAntispamReplace) : { operateType: 0, replacedText: "" }).operateType)
              i2 = r2.replacedText;
            else if (2 === r2.operateType)
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_CLIENT_ANTISPAM, detail: { reason: "sendMessage: text intercepted by client antispam" } });
          }
          return { clientAntispamResult: r2, text: i2 };
        }
        generateSendMessage(e2, t2) {
          var r2;
          return Object.assign(Object.assign({ messageConfig: { lastMessageUpdateEnabled: null === (r2 = e2.messageConfig) || void 0 === r2 ? void 0 : r2.lastMessageUpdateEnabled }, routeConfig: Object.assign({ routeEnabled: true }, t2.routeConfig), pushConfig: Object.assign({ pushEnabled: true, pushNickEnabled: true, forcePush: false }, t2.pushConfig), antispamConfig: Object.assign({ antispamEnabled: true }, t2.antispamConfig) }, t2.attachment ? { attachment: t2.attachment } : {}), { conversationType: e2.conversationType, senderId: e2.senderId, receiverId: e2.receiverId, createTime: e2.createTime, messageClientId: e2.messageClientId, messageServerId: e2.messageServerId, messageType: e2.messageType, subType: t2.subType, text: t2.text, serverExtension: t2.serverExtension });
        }
      }
      class DeleteUtil {
        constructor(e2, t2) {
          this.emitRevokeMessage = (e3) => {
            var t3 = e3.map((e4) => {
              var t4 = formatRevokeMessage(this.core, e4);
              return 3 === t4.messageRefer.conversationType ? this.core.eventBus.emit("V2NIMSync/updateTimetag", { deleteSuperTeamMsg: e4.createTime }) : this.core.eventBus.emit("V2NIMSync/updateTimetag", { recallMsg: e4.createTime }), t4;
            });
            t3.forEach((e4) => {
              this.service.model.deleteMessage(e4.messageRefer.messageClientId);
            }), this.service.emit("onMessageRevokeNotifications", t3), this.core.eventBus.emit("V2NIMMessageService/revokeMessages", t3);
          }, this.core = e2, this.service = t2, this.logger = e2.logger;
        }
        revokeMessage(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            if (validate(gn, { message: e2, params: t2 }, "", true), validateConversationId(this.core.account, e2.conversationId), 1 === e2.conversationType && e2.senderId !== this.core.account)
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "revokeMessage: p2p message senderId is not current user" } });
            if (!e2.messageServerId || "0" === e2.messageServerId)
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "revokeMessage: cannot revoke message with invalid messageServerId: " + e2.messageServerId } });
            var r2 = 3 === e2.conversationType ? "v2RevokeSuperTeamMessage" : "v2RevokeMessage", i2 = { 1: 7, 2: 8, 3: 12 }, s2 = Object.assign(Object.assign(Object.assign({}, e2), t2), { attach: t2 && t2.serverExtension, sysMsgType: i2[e2.conversationType], opeAccount: this.core.account });
            yield this.core.sendCmd(r2, { tag: s2 });
            var n2 = { 1: 1, 2: 2, 3: 3 }, a2 = [JSON.parse(JSON.stringify({ postscript: t2 && t2.postscript, revokeType: n2[e2.conversationType], revokeAccountId: this.core.account, serverExtension: t2 && t2.serverExtension, messageRefer: formatMessageRefer(this.core, e2) }))];
            this.revokeMessagesFn(a2), this.core.eventBus.emit("forwardSend/V2NIMMessageService/revokeMessage", s2);
          });
        }
        deleteMessage(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            if (validate(In, e2, "", true), 3 === e2.sendingState)
              this.service.fileUtil.cancelMessageAttachmentUpload(e2);
            else if (e2.sendingState && 1 !== e2.sendingState)
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "deleteMessage: cannot delete unsent message" } });
            var r2 = { messageRefer: formatMessageRefer(this.core, e2), serverExtension: t2 }, i2 = Date.now();
            e2.messageServerId && "0" !== e2.messageServerId && (i2 = (yield this.core.sendCmd("v2DeleteMessage", { tag: r2 })).content.timetag);
            var s2 = [{ serverExtension: t2, messageRefer: formatMessageRefer(this.core, e2), deleteTime: i2 }];
            this.core.eventBus.emit("forwardSend/V2NIMMessageService/deleteSelfMsgs", [Object.assign(Object.assign({}, r2), { deleteTime: i2 })]), this.deleteMessagesFn(s2);
          });
        }
        deleteMessages(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate(Mn, { messages: e2 }, "", true);
            var r2 = [], i2 = [];
            if (0 === e2.length)
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "deleteMessages: message array length is 0" } });
            for (var s2 = e2[0].conversationId, n2 = 0; n2 < e2.length; n2++) {
              if (3 === e2[n2].sendingState)
                this.service.fileUtil.cancelMessageAttachmentUpload(e2[n2]);
              else if (e2[n2].sendingState && 1 !== e2[n2].sendingState)
                throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: `deleteMessage: sendingState should be succeeded, please check message at index: ${n2}` } });
              if (n2 >= 1 && e2[n2].conversationId !== s2)
                throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "deleteMessages: only allow to delete messages from same conversation" } });
              e2[n2].messageServerId && "0" !== e2[n2].messageServerId ? r2.push(e2[n2]) : i2.push(e2[n2]);
            }
            var a2 = Date.now(), o2 = [...i2];
            try {
              if (r2.length > 0) {
                var c2 = yield this.core.sendCmd("v2DeleteMessages", { tag: r2.map((e3) => ({ messageRefer: e3, serverExtension: t2 })) });
                a2 = c2.content.timetag, o2 = [...o2, ...r2];
              }
            } catch (e3) {
              if (0 === i2.length)
                throw e3;
              this.logger.warn("V2NIMMessageService:deleteMessages: delete messages with serverId failed");
            }
            var d2 = o2.map((e3) => ({ serverExtension: t2, messageRefer: formatMessageRefer(this.core, e3), deleteTime: a2 }));
            this.core.eventBus.emit("forwardSend/V2NIMMessageService/deleteSelfMsgs", o2.map((e3) => ({ messageRefer: e3, serverExtension: t2, deleteTime: a2 }))), this.deleteMessagesFn(d2);
          });
        }
        revokeMessagesFn(e2) {
          e2.forEach((e3) => {
            this.service.model.deleteMessage(e3.messageRefer.messageClientId);
          }), this.service.emit("onMessageRevokeNotifications", e2), this.core.eventBus.emit("V2NIMMessageService/revokeMessages", e2);
        }
        deleteMessagesFn(e2) {
          e2.forEach((e3) => {
            this.service.model.deleteMessage(e3.messageRefer.messageClientId), this.core.eventBus.emit("V2NIMSync/updateTimetag", { deleteSelfMsgs: e3.deleteTime });
          }), this.service.emit("onMessageDeletedNotifications", e2), this.core.eventBus.emit("V2NIMMessageService/deleteMessages", e2);
        }
      }
      class AIUtil {
        constructor(e2, t2) {
          this.core = e2, this.service = t2, this.logger = e2.logger;
        }
        stopAIStreamMessage(e2, t2) {
          var r2;
          return __awaiter(this, void 0, void 0, function* () {
            this.checkAI(), yield this.core.sendCmd("v2AIStopModelStreamCall", { tag: { serverId: e2.messageServerId, clientId: e2.messageClientId, type: e2.conversationType, from: e2.senderId, to: e2.receiverId, aiAccount: null === (r2 = e2.aiConfig) || void 0 === r2 ? void 0 : r2.accountId, opeType: t2.operationType, updateContent: t2.updateContent, messageTime: e2.createTime } }), this.logger.log(`V2AIUtil::streamMessageStop,clientId:${e2.messageClientId}`), this.core.V2NIMAIService.model.completeAiStream(e2.messageClientId);
          });
        }
        regenAIMessage(e2, t2) {
          var r2, i2, s2, n2, a2, o2, c2, d2;
          return __awaiter(this, void 0, void 0, function* () {
            this.checkAI();
            var l2 = this.core.V2NIMAIService.model.getAiStream(e2.messageClientId);
            if (l2) {
              if (!(null == l2 ? void 0 : l2.isComplete))
                throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_MISUSE, detail: { reason: `msg::regenAIMessage streamCache is not complete, msgId:${e2.messageClientId}` } });
            } else if (-1 === (null === (r2 = e2.streamConfig) || void 0 === r2 ? void 0 : r2.status) || 1 === (null === (i2 = e2.streamConfig) || void 0 === i2 ? void 0 : i2.status))
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_MISUSE, detail: { reason: `msg::regenAIMessage message streamConfig.status forbidden ${e2.streamConfig.status}` } });
            yield this.core.sendCmd("v2AIRegenMessage", { tag: { fromAccount: e2.senderId, to: e2.receiverId, aiAccount: null === (s2 = e2.aiConfig) || void 0 === s2 ? void 0 : s2.accountId, serverId: e2.messageServerId, clientId: e2.messageClientId, time: e2.createTime, type: e2.conversationType, opeType: t2.operationType, replyMsgFromAccount: null === (n2 = e2.threadReply) || void 0 === n2 ? void 0 : n2.senderId, replyMsgToAccount: null === (a2 = e2.threadReply) || void 0 === a2 ? void 0 : a2.receiverId, replyMsgTime: null === (o2 = e2.threadReply) || void 0 === o2 ? void 0 : o2.createTime, replyMsgIdServer: null === (c2 = e2.threadReply) || void 0 === c2 ? void 0 : c2.messageServerId, replyMsgIdClient: null === (d2 = e2.threadReply) || void 0 === d2 ? void 0 : d2.messageClientId } }), 1 === t2.operationType && this.core.V2NIMAIService.model.setAiStream(e2.messageClientId, { isComplete: false, queryStatus: 0, chunks: [] });
          });
        }
        checkAI() {
          if (!this.hasAI())
            throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_MISUSE, detail: { reason: "V2NIMAIService is not registered" } });
        }
        hasAI() {
          var e2;
          return !!(null === (e2 = this.core.V2NIMAIService) || void 0 === e2 ? void 0 : e2.name);
        }
      }
      class V2NIMMMessageHandlerImpl {
        constructor(e2, t2) {
          this.core = e2, this.service = t2, this.model = t2.model, this.receiptUtil = t2.receiptUtil, this.logger = this.core.logger;
        }
        setAIStreamPlaceholder(e2) {
          this.service.aiUtil.hasAI() && e2.forEach((e3) => {
            var t2;
            1 === (null === (t2 = e3.streamConfig) || void 0 === t2 ? void 0 : t2.status) && this.core.V2NIMAIService.model.setAiStream(e3.messageClientId, { isComplete: false, queryStatus: 0, chunks: [], msg: e3 }, true);
          });
        }
        onMsgHandler(e2) {
          var t2 = fillIdServer(e2, e2.content.msg, "messageServerId"), { _conversationOnlineSyncNotify: r2, _conversationOnlineSyncData: i2 } = t2, s2 = __rest(t2, ["_conversationOnlineSyncNotify", "_conversationOnlineSyncData"]), n2 = completeMessage(this.core, s2, 1), a2 = this.service._filterMessage(n2);
          this.logger.log(`v2OnMsgHandler::recvMsg ${n2.messageClientId}/${n2.messageServerId}/${n2.createTime};isHitFilter:${a2}`), 3 === n2.conversationType ? this.core.eventBus.emit("V2NIMSync/updateTimetag", { superTeamRoamingMsgs: n2.createTime, offlineMsgs: n2.createTime }) : this.core.eventBus.emit("V2NIMSync/updateTimetag", { roamingMsgs: n2.createTime, offlineMsgs: n2.createTime }), this.service.config.compatibleWithV1 || (this.service.markMsgsAck([n2]), this.service.sendUtil.doMsgReceiveReport(n2, e2)), delete n2.__clientExt, this.setAIStreamPlaceholder([n2]), 5 !== n2.messageType && this.core.V2NIMUserService.checkUserUpdate && this.core.V2NIMUserService.checkUserUpdate(n2, n2.userUpdateTime), 5 === n2.messageType && this.core.eventBus.emit("V2NIMTeamService/notification", t2), a2 || (this.service.emit("onReceiveMessages", [n2]), this.model.upsertMessages([n2]), r2 && this.core.eventBus.emit("V2NIMConversationService/conversationOnlineSyncNotify", { content: { info: JSON.parse(r2), data: JSON.parse(i2) } }, n2), this.core.eventBus.emit("V2NIMMessageService/onMsg", n2));
        }
        syncOfflineMsgsHandler(e2) {
          var t2 = e2.content.datas;
          t2 = t2.map((e3) => completeMessage(this.core, e3, 2)), 0 !== (t2 = this.service._filterMessagesByFn(t2)).length && (!this.service.config.compatibleWithV1 && this.service.markMsgsAck(t2), this.service.emit("onReceiveMessages", t2), this.model.upsertMessages(t2), this.core.eventBus.emit("V2NIMMessageService/offlineMsgs", t2));
        }
        syncRoamingMsgsHandler(e2) {
          var t2 = e2.content.datas;
          t2 = t2.map((e3) => completeMessage(this.core, e3, 3)), this.setAIStreamPlaceholder(t2), 0 !== (t2 = this.service._filterMessagesByFn(t2)).length && (this.service.emit("onReceiveMessages", t2), this.model.upsertMessages(t2), this.core.eventBus.emit("V2NIMMessageService/roamingMsgs", t2));
        }
        onP2PMessageReceiptsHandler(e2) {
          this.receiptUtil.onP2PMessageReceiptsHandler(e2);
        }
        onTeamMessageReceiptsHandler(e2) {
          this.receiptUtil.onTeamMessageReceiptsHandler(e2);
        }
        syncP2PMessagReceiptsHandler(e2) {
          this.receiptUtil.syncP2PMessagReceiptsHandler(e2);
        }
        syncRevokeMessageHandler(e2) {
          this.service.deleteUtil.emitRevokeMessage(e2.content.datas);
        }
        onRevokeMessageHandler(e2) {
          var t2 = e2.content.data;
          this.service.deleteUtil.emitRevokeMessage([t2]);
        }
        onDeleteMessageHandler(e2) {
          var t2 = e2.content.data, r2 = { serverExtension: t2.serverExtension, deleteTime: t2.deleteTime, messageRefer: completeMessageRefer(this.core, t2.messageRefer) };
          this.service.deleteUtil.deleteMessagesFn([r2]);
        }
        onDeleteMessagesHandler(e2) {
          var t2 = e2.content.data.map((e3) => ({ serverExtension: e3.serverExtension, deleteTime: e3.deleteTime, messageRefer: completeMessageRefer(this.core, e3.messageRefer) }));
          this.service.deleteUtil.deleteMessagesFn(t2);
        }
        syncOnDeleteMessagesHandler(e2) {
          var t2 = e2.content.datas.map((e3) => ({ serverExtension: e3.serverExtension, deleteTime: e3.deleteTime, messageRefer: completeMessageRefer(this.core, e3.messageRefer) }));
          this.service.emit("onMessageDeletedNotifications", t2);
        }
        v2MessageOnModifiedHandler(e2) {
          var t2 = completeMessage(this.core, e2.content.data);
          this.model.upsertMessages([t2]), this.service.aiUtil.hasAI() && this.core.V2NIMAIService.model.completeAiStream(t2.messageClientId), this.core.eventBus.emit("forwardSend/V2NIMMessageService/modifyMsg", t2), this.core.eventBus.emit("V2NIMMessageService/modifyMsg", t2), this.core.eventBus.emit("V2NIMSync/updateTimetag", 3 === t2.conversationType ? { superTeamModifyMessage: t2.modifyTime } : { p2pTeamModifyMessage: t2.modifyTime }), this.service.emit("onReceiveMessagesModified", [t2]);
        }
        v2MessageSyncModifiedHandler(e2) {
          var t2 = e2.content.datas.map((e3) => completeMessage(this.core, e3)).filter((e3) => {
            var t3, r2 = (null === (t3 = this.model.getMessageById(e3.messageClientId)) || void 0 === t3 ? void 0 : t3.modifyTime) || 0;
            return (e3.modifyTime || 0) > r2;
          });
          t2.length > 0 && (this.model.upsertMessages(t2), t2.forEach((e3) => {
            this.service.aiUtil.hasAI() && this.core.V2NIMAIService.model.completeAiStream(e3.messageClientId), this.core.eventBus.emit("forwardSend/V2NIMMessageService/modifyMsg", e3);
          }), this.service.emit("onReceiveMessagesModified", t2));
        }
        v2MessageSyncSuperTeamModifiedHandler(e2) {
          this.v2MessageSyncModifiedHandler(e2);
        }
      }
      class V2NIMMessageEventImpl {
        constructor(e2, t2) {
          this.core = e2, this.service = t2, this.logger = this.core.logger;
        }
        setListener() {
          this.core.eventBus.on("forwardReceive/V2NIMMessageService/sendMsg", this.service.sendMessageFn.bind(this.service)), this.core.eventBus.on("forwardReceive/V2NIMMessageService/revokeMessages", this.service.deleteUtil.emitRevokeMessage.bind(this.service.deleteUtil)), this.core.eventBus.on("forwardReceive/V2NIMMessageService/deleteMessages", this.service.deleteUtil.deleteMessagesFn.bind(this.service.deleteUtil)), this.core.eventBus.on("V2NIMConversationService/deleteConversation", (e2) => {
            e2.forEach((e3) => this.service.model.deleteMessages(e3));
          }), this.core.eventBus.on("V2NIMAIService/receiveMessagesModified", (e2) => this.service.emit("onReceiveMessagesModified", e2));
        }
        beforeEmit(e2, ...t2) {
          var r2, i2, s2, n2 = `${this.service.name}::emit ${e2.toString()}`;
          if ("onSendMessage" === e2) {
            var a2 = t2[0];
            this.logger.log(`${n2}`, `${a2.messageClientId}/${a2.messageServerId}/${a2.createTime};`, `sendingState:${a2.sendingState};attachmentUploadState:${a2.attachmentUploadState || 0};messageStatus:${null === (r2 = a2.messageStatus) || void 0 === r2 ? void 0 : r2.errorCode};config.lastMsg:${null === (i2 = a2.messageConfig) || void 0 === i2 ? void 0 : i2.lastMessageUpdateEnabled};config.unread:${null === (s2 = a2.messageConfig) || void 0 === s2 ? void 0 : s2.unreadEnabled}`);
          } else if ("onReceiveMessages" === e2 || "onReceiveMessagesModified" === e2) {
            var o2 = t2[0];
            this.logger.log(`${n2}`, o2.map((e3) => {
              var t3, r3;
              return `${e3.messageClientId}/${e3.messageServerId}/${e3.createTime};config.lastMsg:${null === (t3 = e3.messageConfig) || void 0 === t3 ? void 0 : t3.lastMessageUpdateEnabled};config.unread:${null === (r3 = e3.messageConfig) || void 0 === r3 ? void 0 : r3.unreadEnabled}`;
            }));
          } else if ("onMessageRevokeNotifications" === e2) {
            var c2 = t2[0];
            this.logger.log(`${n2}`, c2.map((e3) => `msg:${e3.messageRefer.messageClientId}/${e3.messageRefer.messageServerId};revokeAccountId:${e3.revokeAccountId}`));
          } else if ("onMessageDeletedNotifications" === e2) {
            var d2 = t2[0];
            this.logger.log(`${n2}`, d2.map((e3) => `msg:${e3.messageRefer.messageClientId}/${e3.messageRefer.messageServerId};deleteTime:${e3.deleteTime}`));
          } else
            this.logger.log(`${n2}`, ...t2);
        }
      }
      class V2NIMMessageServiceImpl extends V2Service {
        constructor(e2, t2 = {}) {
          super("V2NIMMessageService", e2), this.customAttachmentParsers = [], this.config = { compatibleWithV1: true }, this.filterFn = void 0, this.core._registerDep(V2NIMConversationIdUtilImpl, "V2NIMConversationIdUtil"), this.core._registerDep(V2NIMMessageCreatorImpl, "V2NIMMessageCreator"), this.core._registerDep(V2NIMMessageAttachmentCreatorImpl, "V2NIMMessageAttachmentCreator"), this.core._registerDep(V2NIMClientAntispamUtilImpl, "V2NIMClientAntispamUtil"), this.receiptUtil = new ReceiptUtil(this.core, this), this.fileUtil = new FileUtil(this.core), this.sendUtil = new SendUtil(this.core, this), this.modifyUtil = new ModifyUtil(this.core, this), this.deleteUtil = new DeleteUtil(this.core, this), this.aiUtil = new AIUtil(this.core, this), this.model = new V2NIMMessageModelImpl(), this.event = new V2NIMMessageEventImpl(this.core, this), this.handler = new V2NIMMMessageHandlerImpl(this.core, this), "v2" === this.core.options.apiVersion && (registerParser({ cmdMap: ra, cmdConfig: da }), this.setOptions(t2), this.setListener());
        }
        setOptions(e2) {
          var t2;
          (null === (t2 = this.core.msg) || void 0 === t2 ? void 0 : t2.name) ? this.config.compatibleWithV1 = true : this.config.compatibleWithV1 = false, this.config = Object.assign(this.config, e2);
        }
        setListener() {
          this.event.setListener();
        }
        reset() {
          this.model.reset(), this.receiptUtil.reset();
        }
        emit(e2, ...t2) {
          return this.event.beforeEmit(e2, ...t2), super.emit(e2, ...t2);
        }
        checkExtendUtil() {
          var e2;
          if (!(null === (e2 = this.core.V2NIMMessageExtendUtil) || void 0 === e2 ? void 0 : e2.name))
            throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_MISUSE, detail: { reason: "V2NIMMessageLogUtil is not registered" } });
        }
        checkLogUtil() {
          var e2;
          if (!(null === (e2 = this.core.V2NIMMessageLogUtil) || void 0 === e2 ? void 0 : e2.name))
            throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_MISUSE, detail: { reason: "V2NIMMessageExtendUtil is not registered" } });
        }
        getMessageList(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), this.checkLogUtil();
            var t2 = yield this.core.V2NIMMessageLogUtil.getMessageList(e2);
            return t2 = this._filterMessageByClearTime(e2.conversationId, t2), t2 = this._filterMessagesByFn(t2);
          });
        }
        getMessageListEx(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), this.checkLogUtil();
            var t2 = yield this.core.V2NIMMessageLogUtil.getMessageList(e2);
            return t2 = this._filterMessageByClearTime(e2.conversationId, t2), { messages: this._filterMessagesByFn(t2), anchorMessage: t2.length > 0 ? t2[t2.length - 1] : null };
          });
        }
        getMessageListByRefers(e2) {
          return this.checkV2(), this.checkLogUtil(), this.core.V2NIMMessageLogUtil.getMessageListByRefers(e2);
        }
        clearHistoryMessage(e2) {
          return this.checkV2(), this.checkLogUtil(), this.core.V2NIMMessageLogUtil.clearHistoryMessage(e2);
        }
        clearRoamingMessage(e2) {
          return this.checkV2(), this.checkLogUtil(), this.core.V2NIMMessageLogUtil.clearRoamingMessage(e2);
        }
        pinMessage(e2, t2) {
          return this.checkV2(), this.checkExtendUtil(), this.core.V2NIMMessageExtendUtil.pinMessage(e2, t2);
        }
        unpinMessage(e2, t2) {
          return this.checkV2(), this.checkExtendUtil(), this.core.V2NIMMessageExtendUtil.unpinMessage(e2, t2);
        }
        updatePinMessage(e2, t2) {
          return this.checkV2(), this.checkExtendUtil(), this.core.V2NIMMessageExtendUtil.updatePinMessage(e2, t2);
        }
        voiceToText(e2) {
          return this.checkV2(), this.checkExtendUtil(), "string" == typeof e2.duration && (e2.duration = Number(e2.duration)), this.core.V2NIMMessageExtendUtil.voiceToText(e2);
        }
        getPinnedMessageList(e2) {
          return this.checkV2(), this.checkExtendUtil(), this.core.V2NIMMessageExtendUtil.getPinnedMessageList(e2);
        }
        addQuickComment(e2, t2, r2, i2) {
          return this.checkV2(), this.checkExtendUtil(), this.core.V2NIMMessageExtendUtil.addQuickComment(e2, t2, r2, i2);
        }
        removeQuickComment(e2, t2, r2) {
          return this.checkV2(), this.checkExtendUtil(), this.core.V2NIMMessageExtendUtil.removeQuickComment(e2, t2, r2);
        }
        getQuickCommentList(e2) {
          return this.checkV2(), this.checkExtendUtil(), this.core.V2NIMMessageExtendUtil.getQuickCommentList(e2);
        }
        addCollection(e2) {
          return this.checkV2(), this.checkExtendUtil(), this.core.V2NIMMessageExtendUtil.addCollection(e2);
        }
        removeCollections(e2) {
          return this.checkV2(), this.checkExtendUtil(), this.core.V2NIMMessageExtendUtil.removeCollections(e2);
        }
        updateCollectionExtension(e2, t2) {
          return this.checkV2(), this.checkExtendUtil(), this.core.V2NIMMessageExtendUtil.updateCollectionExtension(e2, t2);
        }
        getCollectionListByOption(e2) {
          return this.checkV2(), this.checkExtendUtil(), this.core.V2NIMMessageExtendUtil.getCollectionListByOption(e2);
        }
        getCollectionListExByOption(e2) {
          return this.checkV2(), this.checkExtendUtil(), this.core.V2NIMMessageExtendUtil.getCollectionListExByOption(e2);
        }
        searchCloudMessages(e2) {
          return this.checkV2(), this.checkExtendUtil(), this.core.V2NIMMessageExtendUtil.searchCloudMessages(e2);
        }
        searchCloudMessagesEx(e2) {
          return this.checkV2(), this.checkExtendUtil(), this.core.V2NIMMessageExtendUtil.searchCloudMessagesEx(e2);
        }
        getThreadMessageList(e2) {
          return this.checkV2(), this.checkExtendUtil(), this.core.V2NIMMessageExtendUtil.getThreadMessageList(e2);
        }
        registerCustomAttachmentParser(e2) {
          "function" == typeof e2 && -1 === this.customAttachmentParsers.indexOf(e2) && this.customAttachmentParsers.unshift(e2);
        }
        unregisterCustomAttachmentParser(e2) {
          var t2 = this.customAttachmentParsers.indexOf(e2);
          t2 > -1 && this.customAttachmentParsers.splice(t2, 1);
        }
        sendP2PMessageReceipt(e2) {
          return this.checkV2(), this.receiptUtil.sendP2PMessageReceipt(e2);
        }
        isPeerRead(e2) {
          return this.checkV2(), this.receiptUtil.isPeerRead(e2);
        }
        getP2PMessageReceipt(e2) {
          return this.checkV2(), this.receiptUtil.getP2PMessageReceipt(e2);
        }
        getTeamMessageReceipts(e2) {
          return this.checkV2(), this.receiptUtil.getTeamMessageReceipts(e2);
        }
        getTeamMessageReceiptDetail(e2) {
          return this.checkV2(), this.receiptUtil.getTeamMessageReceiptDetail(e2);
        }
        sendTeamMessageReceipts(e2) {
          return this.checkV2(), this.receiptUtil.sendTeamMessageReceipts(e2);
        }
        revokeMessage(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.checkV2(), this.deleteUtil.revokeMessage(e2, t2);
          });
        }
        deleteMessage(e2, t2) {
          return this.checkV2(), this.deleteUtil.deleteMessage(e2, t2);
        }
        deleteMessages(e2, t2) {
          return this.checkV2(), this.deleteUtil.deleteMessages(e2, t2);
        }
        cancelMessageAttachmentUpload(e2) {
          return this.checkV2(), this.fileUtil.cancelMessageAttachmentUpload(e2);
        }
        markMsgsAck(e2) {
          if (e2 && e2.length > 0) {
            var t2 = [], r2 = [];
            e2.forEach((e3) => {
              e3.senderId === this.core.account && e3.senderId !== e3.receiverId || (1 === e3.conversationType ? t2.push(e3) : 2 === e3.conversationType && r2.push(e3));
            }), t2.length > 0 && this.core.sendCmd("v2BatchMarkRead", { sid: 7, cid: 2, ids: t2.map((e3) => e3.messageServerId) }), r2.length > 0 && this.core.sendCmd("v2BatchMarkRead", { sid: 8, cid: 3, ids: r2.map((e3) => e3.messageServerId) });
          }
        }
        sendMessage(e2, t2, r2 = {}, i2) {
          var s2;
          return __awaiter(this, void 0, void 0, function* () {
            if (this.checkV2(), validate({ message: { type: "object" } }, { message: e2 }, "", true), e2.messageClientId = e2.messageClientId || Ie(), e2.conversationId && e2.conversationId !== t2)
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "sendMessage: message.conversationId is not equal to conversationId" } });
            validate(hn, { conversationId: t2, message: e2, params: r2 }, "", true), validateConversationId(this.core.account, t2);
            var n2 = this.core.V2NIMConversationIdUtil.parseConversationType(t2);
            if ((2 === n2 || 3 === n2) && r2.robotConfig && !r2.robotConfig.accountId)
              throw new ValidateErrorV2({ detail: { reason: "When conversationType is team or superTeam, account is required in robotInfo account is required" } });
            if (2 !== n2 && 3 !== n2 || !r2.targetConfig)
              r2.targetConfig = void 0;
            else {
              var a2 = r2.targetConfig.receiverIds;
              if (3 === n2 && false === r2.targetConfig.inclusive)
                throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "setting inclusive to false for super teams is not allowed" } });
              if (0 === (a2 = a2.filter((e3) => e3 && e3 !== this.core.account)).length)
                throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "receiverIds cannot be empty or only contain yourself" } });
              r2.targetConfig.receiverIds = a2;
            }
            (null === (s2 = r2.aiConfig) || void 0 === s2 ? void 0 : s2.aiStream) && this.aiUtil.checkAI();
            var o2, c2 = this.core.timeOrigin.getTimeNode(), { messageBeforeSend: d2, clientAntispamResult: l2, hiddenParams: m2 } = this.sendUtil.prepareMessage(e2, t2, r2);
            this.logger.log(`V2SendMessage start:${d2.messageClientId}/${d2.createTime};conversation:${t2};`, `NTPTime:${this.core.timeOrigin.getNTPTime(c2)}`);
            try {
              o2 = yield this.sendUtil.doSendMessage({ apiCallingTimeNode: c2, messageBeforeSend: d2, clientAntispamResult: l2, hiddenParams: m2, progress: i2 });
            } catch (e3) {
              throw this.logger.warn(`V2SendMessage end:${d2.messageClientId}.`, e3 instanceof V2NIMErrorImpl ? `failed:${e3.code}` : "failed"), e3;
            }
            return o2.message.senderId === o2.message.receiverId && this.markMsgsAck([o2.message]), this.logger.log(`V2SendMessage end:${o2.message.messageClientId}/${o2.message.messageServerId}/${o2.message.createTime}`), o2;
          });
        }
        replyMessage(e2, t2, r2 = {}, i2) {
          return __awaiter(this, void 0, void 0, function* () {
            if (this.checkV2(), validate({ message: { type: "object" } }, { message: e2 }, "", true), e2.messageClientId = e2.messageClientId || Ie(), validate(un, { message: e2, replyMessage: t2, params: r2 }, "", true), validateConversationId(this.core.account, t2.conversationId), (2 === e2.conversationType || 3 === e2.conversationType) && r2.robotConfig && !r2.robotConfig.accountId)
              throw new ValidateErrorV2({ detail: { reason: "When conversationType is team or superTeam, account is required in robotInfo account is required" } });
            var s2 = this.core.timeOrigin.getTimeNode(), { messageBeforeSend: n2, clientAntispamResult: a2, hiddenParams: o2 } = this.sendUtil.prepareMessage(e2, t2.conversationId, r2, t2), c2 = yield this.sendUtil.doSendMessage({ apiCallingTimeNode: s2, messageBeforeSend: n2, clientAntispamResult: a2, hiddenParams: o2, progress: i2 });
            return c2.message.senderId === c2.message.receiverId && this.markMsgsAck([c2.message]), c2;
          });
        }
        modifyMessage(e2, t2) {
          this.checkV2(), this.checkLogin(), validate(Fn, e2, "message", true), validate(jn, t2, "params", true), this.modifyUtil.checkIfModify(e2, t2);
          var { messageBeforeSend: r2, clientAntispamResult: i2 } = this.modifyUtil.prepareMessage(e2, t2);
          return this.modifyUtil.modifyMessage(r2, i2);
        }
        stopAIStreamMessage(e2, t2) {
          if (this.checkV2(), this.aiUtil.checkAI(), validate($n, e2, "message", true), validate(Gn, t2, "params", true), 2 === t2.operationType && !t2.updateContent)
            throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "V2NIMMessage::stopAIStreamMessage updateContent empty" } });
          return this.aiUtil.stopAIStreamMessage(e2, t2);
        }
        regenAIMessage(e2, t2) {
          return this.checkV2(), this.aiUtil.checkAI(), validate($n, e2, "message", true), validate(Hn, t2, "params", true), this.aiUtil.regenAIMessage(e2, t2);
        }
        sendMessageFn(e2) {
          if (e2.msgAckSnapshot) {
            var t2 = e2.msgAckSnapshot, r2 = { conversationId: e2.conversationId, messageServerId: e2.messageServerId, messageClientId: e2.messageClientId, readCount: 0, unreadCount: Number(t2) };
            delete e2.msgAckSnapshot, this.emit("onReceiveTeamMessageReadReceipts", [r2]);
          }
          e2 = formatMessageAttachment(e2, this.core), this.model.upsertMessages([e2]), this.core.eventBus.emit("V2NIMMessageService/sendMessage", e2, e2.sendingState);
        }
        setMessageFilter(e2) {
          null != e2 ? e2 && "function" == typeof e2.shouldIgnore && (this.filterFn = e2.shouldIgnore) : this.filterFn = void 0;
        }
        _filterMessage(e2) {
          if ("function" == typeof this.filterFn)
            try {
              return true === this.filterFn(e2);
            } catch (t2) {
              return this.logger.error(`V2NIMMessage::triggerMessageFilter ${e2.messageClientId} error:`, t2), false;
            }
          return false;
        }
        _filterMessagesByFn(e2) {
          return e2.filter((e3) => !this._filterMessage(e3));
        }
        _filterMessageByClearTime(e2, t2) {
          var r2 = ge.localStorage.getItem(`nim_${this.core.account}_${e2}_clearTime`), i2 = r2 ? parseInt(r2) : 0;
          return i2 > 0 ? t2.filter((e3) => e3.createTime >= i2) : t2;
        }
      }
      var Ma = { super_team: 3, p2p: 1, team: 2 }, Sa = { 3: "super_team", 1: "p2p", 0: "p2p", 2: "team" };
      function getConvInfoFromSessionId(e2, t2 = "|") {
        var r2 = e2.indexOf(t2);
        if (-1 === r2)
          return { target: "", type: 0 };
        var i2 = e2.slice(0, r2);
        return { target: e2.slice(r2 + 1), type: Ma[i2] || 0 };
      }
      function getSessionIdFromConvInfo(e2, t2) {
        return `${Sa[e2]}|${t2}`;
      }
      class V2NIMLocalConversationModelImpl {
        constructor() {
          this.map = /* @__PURE__ */ new Map(), this.capacity = 1e4, this.readTimeMap = /* @__PURE__ */ new Map(), this.stickTopMap = /* @__PURE__ */ new Map();
        }
        reset() {
          this.map.clear(), this.readTimeMap.clear(), this.stickTopMap.clear();
        }
        count() {
          return this.map.size;
        }
        sort() {
          var e2 = Array.from(this.map.values());
          e2.sort((e3, t2) => t2.sortOrder - e3.sortOrder), this.map.clear(), e2.forEach((e3) => {
            this.map.set(e3.conversationId, e3);
          });
        }
        processConversation(e2) {
          return "string" == typeof e2.lastMessage && delete e2.lastMessage, void 0 === e2.localExtension && (e2.localExtension = ""), e2;
        }
        getById(e2) {
          return this.map.get(e2);
        }
        getAll() {
          return Array.from(this.map.values()).sort((e2, t2) => t2.sortOrder - e2.sortOrder);
        }
        getStickTopList() {
          return Array.from(this.map.values()).filter((e2) => e2.stickTop).sort((e2, t2) => t2.sortOrder - e2.sortOrder);
        }
        getByOption(e2, t2, r2) {
          var { conversationTypes: i2, onlyUnread: s2 } = r2, n2 = [];
          this.map.forEach((e3) => {
            i2 && i2.length > 0 && !i2.includes(e3.type) || s2 && !e3.unreadCount || r2.ignoreMuted && e3.mute || n2.push(e3);
          }), n2 = n2.sort((e3, t3) => t3.sortOrder - e3.sortOrder);
          var a2 = 0;
          e2 > 0 && (a2 = findIndexWithinTargetValue(n2, "sortOrder", e2), n2[a2] && n2[a2].sortOrder === e2 && (a2 += 1));
          var o2 = n2.slice(a2).length;
          return (n2 = n2.slice(a2, a2 + t2)).length > 0 ? { offset: o2 > t2 ? n2[n2.length - 1].sortOrder : 0, finished: !(o2 > t2), conversationList: n2 } : { offset: 0, finished: true, conversationList: n2 };
        }
        upsert(e2) {
          var t2 = e2.conversationId, r2 = this.map.get(t2);
          if (!r2) {
            var i2 = this.processConversation(Object.assign({ stickTop: this.getStickTop(t2), localExtension: "", lastMessage: null, unreadCount: 0, sortOrder: 0, createTime: 0, updateTime: 0 }, e2));
            return this.setLRU(t2, i2), i2.unreadCount > 0;
          }
          var s2 = e2.unreadCount !== r2.unreadCount, n2 = Object.assign({}, r2, e2);
          return n2 = this.processConversation(n2), this.setLRU(t2, n2), s2;
        }
        setLRU(e2, t2) {
          if (this.map.has(e2))
            this.map.delete(e2);
          else if (this.map.size >= this.capacity) {
            var r2 = this.map.keys().next().value;
            r2 && this.map.delete(r2);
          }
          this.map.set(e2, t2);
        }
        bulkUpsert(e2) {
          var t2 = false;
          return e2.forEach((e3) => {
            this.upsert(e3) && (t2 = true);
          }), t2;
        }
        deleteById(e2) {
          var t2 = this.getById(e2);
          if (t2)
            return this.map.delete(e2), t2;
        }
        updateReadTime(e2, t2) {
          this.readTimeMap.set(e2, t2);
        }
        getReadTime(e2) {
          return this.readTimeMap.get(e2) || 0;
        }
        updateStickTop(e2, t2) {
          t2 ? this.stickTopMap.set(e2, true) : this.stickTopMap.delete(e2);
        }
        getStickTop(e2) {
          return this.stickTopMap.get(e2) || false;
        }
      }
      var Ta, _a = { "4_14": "v2LocalConvSyncReadTime", "4_20": "v2LocalConvSyncSuperTeamReadTime", "4_22": "v2LocalConvSyncMoreRoaming", "4_23": "v2LocalConvSyncStickTop", "4_25": "v2LocalConvSyncReliableInfo", "7_16": "v2LocalConvMarkReadTime", "7_25": "v2LocalConvMultiMarkReadTime", "7_116": "v2LocalConvMultiSyncReadTime", "21_25": "v2LocalConvSuperTeamMarkReadTime", "21_32": "v2LocalConvSuperTeamMultiMarkReadTime", "21_125": "v2LocalConvSuperTeamMultiSyncReadTime", "33_12": "v2LocalConvStickTopAdd", "33_13": "v2LocalConvStickTopDelete", "23_112": "v2LocalConvStickTopMultiSyncAdd", "23_113": "v2LocalConvStickTopMultiSyncDelete", "23_114": "v2LocalConvStickTopMultiSyncUpdate" }, Ca = "V2NIMLocalConversationService", Ea = { id: 1, ext: 2, createTime: { id: 3, retType: "number" }, updateTime: { id: 4, retType: "number" } }, ba = { scene: 1, to: 2, timetag: 3 }, Ra = { v2LocalConvSyncReadTime: { sid: 4, cid: 14, service: Ca, response: [{ type: "StrLongMap", name: "p2p" }, { type: "LongLongMap", name: "team" }, { type: "Long", name: "timetag" }] }, v2LocalConvSyncSuperTeamReadTime: { sid: 4, cid: 20, service: Ca, response: [{ type: "LongLongMap", name: "superTeam" }] }, v2LocalConvSyncMoreRoaming: { sid: 4, cid: 22, service: Ca, response: [] }, v2LocalConvSyncStickTop: { sid: 4, cid: 23, service: Ca, response: [{ type: "Long", name: "timetag" }, { type: "Bool", name: "isThereAnyChange" }, { type: "PropertyArray", name: "datas", reflectMapper: invertSerializeItem(Ea) }] }, v2LocalConvSyncReliableInfo: { sid: 4, cid: 25, service: Ca, response: [] }, v2LocalConvMarkReadTime: { sid: 7, cid: 16, service: Ca, params: [{ type: "Byte", name: "scene" }, { type: "String", name: "to" }, { type: "Long", name: "timetag" }] }, v2LocalConvMultiMarkReadTime: { sid: 7, cid: 25, service: Ca, ignoreErrCodes: [700], params: [{ type: "PropertyArray", name: "tags", reflectMapper: ba }] }, v2LocalConvMultiSyncReadTime: { sid: 7, cid: 116, service: Ca, response: [{ type: "Byte", name: "scene" }, { type: "String", name: "to" }, { type: "Long", name: "timetag" }] }, v2LocalConvSuperTeamMarkReadTime: { sid: 21, cid: 25, service: Ca, params: [{ type: "Long", name: "to" }, { type: "Long", name: "timetag" }] }, v2LocalConvSuperTeamMultiMarkReadTime: { sid: 21, cid: 32, service: Ca, ignoreErrCodes: [700], params: [{ type: "PropertyArray", name: "tags", reflectMapper: ba }] }, v2LocalConvSuperTeamMultiSyncReadTime: { sid: 21, cid: 125, service: Ca, response: [{ type: "Long", name: "to" }, { type: "Long", name: "timetag" }] }, v2LocalConvStickTopAdd: { sid: 33, cid: 12, service: Ca, params: [{ type: "Property", name: "tag", reflectMapper: Ea }], response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(Ea) }] }, v2LocalConvStickTopDelete: { sid: 33, cid: 13, service: Ca, params: [{ type: "Property", name: "tag", reflectMapper: Ea }], response: [{ type: "Long", name: "timetag" }] }, v2LocalConvStickTopMultiSyncAdd: { sid: 23, cid: 112, service: Ca, response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(Ea) }] }, v2LocalConvStickTopMultiSyncDelete: { sid: 23, cid: 113, service: Ca, response: [{ type: "Long", name: "timetag" }, { type: "Property", name: "data", reflectMapper: invertSerializeItem(Ea) }] }, v2LocalConvStickTopMultiSyncUpdate: { sid: 23, cid: 114, service: Ca, response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(Ea) }] } };
      class V2NIMLocalConversationUnreadImpl {
        constructor(e2, t2) {
          this.totalUnreadCount = void 0, this.unreadCountByFilter = {}, this.currentConversationId = void 0, this._setCurrConvThrottle = throttle(() => {
            this.currentConversationId && this._setCurrConv(this.currentConversationId);
          }, 5e3, { leading: false }), this.core = e2, this.service = t2, this.model = t2.model, this.logger = t2.logger;
        }
        reset() {
          this.totalUnreadCount = void 0, this.unreadCountByFilter = {}, this.currentConversationId = void 0, this._setCurrConvThrottle.flush();
        }
        getTotalUnreadCount() {
          return this.totalUnreadCount;
        }
        resetTotalAfterSyncDone() {
          var e2 = this.service.model.getAll().reduce((e3, t3) => e3 + (t3.unreadCount || 0), 0), t2 = this.totalUnreadCount;
          return void 0 !== t2 && t2 === e2 || (this.totalUnreadCount = e2, this.service.emit("onTotalUnreadCountChanged", e2)), e2;
        }
        digestUnreadCountChange() {
          this._digest();
        }
        _digest() {
          var e2 = this.totalUnreadCount, t2 = this.service.model.getAll().reduce((e3, t3) => e3 + (t3.unreadCount || 0), 0);
          this.core.logger.log(`V2NIMConversation::digestUnreadCountChange:oldUnreadCount ${e2}, newUnreadCount ${t2}`), e2 !== t2 && (this.totalUnreadCount = t2, this.service.emit("onTotalUnreadCountChanged", t2)), Object.keys(this.unreadCountByFilter).forEach((e3) => {
            var t3 = JSON.parse(e3), r2 = this.getUnreadCountByFilter(t3), i2 = this.unreadCountByFilter[e3];
            this.unreadCountByFilter[e3] = r2, t3.equals = equals$1.bind(t3), i2 !== r2 && this.service.emit("onUnreadCountChangedByFilter", t3, r2);
          });
        }
        clearUnreadCount(e2) {
          var t2 = e2.reduce((e3, t3) => (this.service.model.upsert({ conversationId: t3.conversationId, type: t3.type, unreadCount: 0 }) && e3.push(t3.conversationId), e3), []);
          if (t2.length > 0) {
            var r2 = t2.map((e3) => this.service.model.getById(e3));
            this.service.triggerConversationChanged(r2), this.digestUnreadCountChange();
          }
        }
        getUnreadCountByIds(e2) {
          return (e2 = uniq(e2)).reduce((e3, t2) => {
            var r2 = this.service.model.getById(t2);
            return e3 + (r2 && r2.unreadCount || 0);
          }, 0);
        }
        getUnreadCountByFilter(e2) {
          var t2 = this.service.model.count();
          return this.service.model.getByOption(0, t2, { conversationTypes: e2.conversationTypes, ignoreMuted: e2.ignoreMuted }).conversationList.reduce((e3, t3) => e3 + (t3.unreadCount || 0), 0);
        }
        isMessageUnread(e2, t2 = 0) {
          var r2;
          return e2.createTime > t2 && e2.senderId !== this.core.account && 200 === e2.messageStatus.errorCode && false !== (null === (r2 = e2.messageConfig) || void 0 === r2 ? void 0 : r2.unreadEnabled);
        }
        isMessageReferUnread(e2, t2 = 0) {
          var r2 = this.core.V2NIMMessageService.model.getMessageById(e2.messageClientId);
          return r2 ? this.isMessageUnread(r2, t2) : e2.createTime > t2 && e2.senderId !== this.core.account;
        }
        countUnreadByMessageInMemory(e2, t2 = 0) {
          var r2 = 0;
          return this.core.V2NIMMessageService.model.getMessagesByConversationId(e2).forEach((e3) => {
            this.isMessageUnread(e3, t2) && r2++;
          }), r2;
        }
        addFilter(e2) {
          var t2 = generateFilterKey$1(e2);
          if (void 0 !== this.unreadCountByFilter[t2])
            throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_RESOURCE_ALREADY_EXIST });
          var r2 = JSON.parse(t2), i2 = this.getUnreadCountByFilter(r2);
          this.unreadCountByFilter[t2] = i2, this.service.emit("onUnreadCountChangedByFilter", r2, i2);
        }
        deleteFilter(e2) {
          var t2 = generateFilterKey$1(e2);
          if (void 0 === this.unreadCountByFilter[t2])
            throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_RESOURCE_NOT_EXIST });
          delete this.unreadCountByFilter[t2];
        }
        markConversationRead(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            var t2 = this.model.getById(e2), r2 = this.core.V2NIMConversationIdUtil.parseConversationTargetId(e2), i2 = this.core.V2NIMConversationIdUtil.parseConversationType(e2), s2 = this.model.getReadTime(e2);
            if (!t2)
              return s2 || this.core.timeOrigin.getNTPTime();
            var n2 = this.service.compute.computeReadTimeForMark(t2);
            return s2 >= n2 ? (this.logger.log(`V2LocalConv::markConversationRead currentReadTime >= readTime ${e2},${s2},${n2}`), s2) : (3 === i2 ? yield this.core.sendCmd("v2LocalConvSuperTeamMarkReadTime", { timetag: n2, to: r2 }) : yield this.core.sendCmd("v2LocalConvMarkReadTime", { scene: 1 === i2 ? 0 : 2 === i2 ? 1 : 2, timetag: n2, to: r2 }), this.model.updateReadTime(e2, n2), n2);
          });
        }
        markMultiConversationRead(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            var t2 = { cmd: "v2LocalConvSuperTeamMultiMarkReadTime", params: [] }, r2 = { cmd: "v2LocalConvMultiMarkReadTime", params: [] };
            e2.forEach((e3) => {
              var i3 = this.model.getById(e3);
              if (i3) {
                var s3 = this.core.V2NIMConversationIdUtil.parseConversationTargetId(e3), n3 = this.core.V2NIMConversationIdUtil.parseConversationType(e3), a3 = this.model.getReadTime(e3), o2 = this.service.compute.computeReadTimeForMark(i3);
                if (!(a3 >= o2)) {
                  var c2 = { conversationId: e3, scene: 1 === n3 ? 0 : 2 === n3 ? 1 : 2, timetag: o2, to: s3 };
                  3 === n3 ? t2.params.push(c2) : r2.params.push(c2);
                }
              }
            });
            var i2 = chunk(t2.params, 50), s2 = chunk(r2.params, 50);
            for (var n2 of i2) {
              try {
                yield this.core.sendCmd(t2.cmd, { tags: n2 });
              } catch (e3) {
                this.logger.warn("markMultiConversationRead::error:", n2.map((e4) => e4.conversationId), e3);
              }
              n2.forEach((e3) => {
                this.model.updateReadTime(e3.conversationId, e3.timetag);
              });
            }
            for (var a2 of s2) {
              try {
                yield this.core.sendCmd(r2.cmd, { tags: a2 });
              } catch (e3) {
                this.logger.warn("markMultiConversationRead::error:", a2.map((e4) => e4.conversationId), e3);
              }
              a2.forEach((e3) => {
                this.model.updateReadTime(e3.conversationId, e3.timetag);
              });
            }
          });
        }
        setCurrentConversation(e2) {
          var t2 = this.currentConversationId;
          this.currentConversationId = e2, this.currentConversationId && this._setCurrConv(this.currentConversationId), t2 && t2 !== this.currentConversationId && (this._setCurrConvThrottle.flush(), this._setCurrConv(t2));
        }
        _setCurrConv(e2) {
          var t2 = this.model.getById(e2), r2 = (null == t2 ? void 0 : t2.unreadCount) || 0;
          t2 && (t2.unreadCount = 0), t2 && r2 > 0 && (this.service.triggerConversationChanged([t2]), this._digest()), this.markConversationRead(e2).catch((e3) => {
            this.logger.warn("_setConv markRead failed", e3);
          });
        }
      }
      function generateFilterKey$1(e2) {
        var { conversationTypes: t2 } = e2;
        return t2 && (t2 = t2.sort()), JSON.stringify({ conversationGroupId: e2.conversationGroupId, conversationTypes: t2, ignoreMuted: e2.ignoreMuted });
      }
      function equals$1(e2) {
        return JSON.stringify(this) === generateFilterKey$1(e2);
      }
      function formatLastMessageFromMessage(e2, t2, r2 = 0, i2) {
        var s2, n2;
        t2 = formatMessageAttachment(t2, e2);
        var { messageType: a2, subType: o2, text: c2, attachment: d2, serverExtension: l2 } = t2, m2 = "";
        if (t2.senderId !== e2.account && 5 !== a2) {
          m2 = get(t2, "fromNick");
          var p2 = null === (n2 = null === (s2 = e2.V2NIMFriendService) || void 0 === s2 ? void 0 : s2.model) || void 0 === n2 ? void 0 : n2.getFriend(t2.senderId);
          p2 && p2.alias && (m2 = p2.alias);
        }
        return JSON.parse(JSON.stringify({ lastMessageState: r2, messageRefer: formatMessageRefer(e2, t2), messageType: a2, subType: o2, text: c2, attachment: d2, serverExtension: l2, callbackExtension: t2.callbackExtension, sendingState: i2, senderName: m2 }));
      }
      function formatConversationFields(e2, t2) {
        return t2 && t2.length > 0 ? t2.map((t3) => formatConversationField(e2, t3)) : [];
      }
      function formatConversationField(e2, t2) {
        var r2 = t2;
        if ("string" == typeof r2.lastMessage)
          if ("" === r2.lastMessage)
            ;
          else if (1 === r2.lastMessageState) {
            var i2 = formatRevokeMessage(e2, deserialize(JSON.parse(r2.lastMessage), invertSerializeItem(oa)));
            r2.lastMessage = function formatLastMessageFromNotification(e3, t3) {
              var { messageRefer: r3, revokeAccountId: i3, revokeType: s3, callbackExtension: n2, serverExtension: a2, postscript: o2 } = t3, c2 = function calcSenderNameFromNotification(e4, t4, r4, i4) {
                var s4, n3, a3, o3, c3, d2, l2, m2;
                if (t4 !== e4.account) {
                  var p2 = null === (n3 = null === (s4 = e4.V2NIMFriendService) || void 0 === s4 ? void 0 : s4.model) || void 0 === n3 ? void 0 : n3.getFriend(t4);
                  if (p2 && p2.alias)
                    return p2.alias;
                  if (2 === r4) {
                    var u2 = null === (o3 = null === (a3 = e4.V2NIMTeamService) || void 0 === a3 ? void 0 : a3.memberModel) || void 0 === o3 ? void 0 : o3.getById(i4, 1, t4);
                    if (u2 && u2.teamNick)
                      return u2.teamNick;
                  } else if (3 === r4) {
                    var h2 = null === (d2 = null === (c3 = e4.V2NIMTeamService) || void 0 === c3 ? void 0 : c3.memberModel) || void 0 === d2 ? void 0 : d2.getById(i4, 1, t4);
                    if (h2 && h2.teamNick)
                      return h2.teamNick;
                  }
                  var g2 = null === (m2 = null === (l2 = e4.V2NIMUserService) || void 0 === l2 ? void 0 : l2.model) || void 0 === m2 ? void 0 : m2.getUser(t4);
                  return g2 && g2.name ? g2.name : void 0;
                }
              }(e3, t3.revokeAccountId, t3.messageRefer.conversationType, t3.messageRefer.receiverId) || "";
              return JSON.parse(JSON.stringify({ lastMessageState: 1, messageRefer: r3, revokeAccountId: i3, revokeType: s3, callbackExtension: n2, serverExtension: a2, text: o2 || "", senderName: c2 }));
            }(e2, i2);
          } else if (0 === r2.lastMessageState) {
            var s2 = deserialize(JSON.parse(r2.lastMessage), invertSerializeItem(ia));
            r2.lastMessage = formatLastMessageFromMessage(e2, s2, r2.lastMessageState, s2.senderId === e2.account ? 1 : void 0);
          } else
            2 === r2.lastMessageState && delete r2.lastMessage;
        return r2;
      }
      function formatConversationByField(e2) {
        var { version: t2, deleteFlag: r2 } = e2;
        return { conversation: __rest(e2, ["version", "deleteFlag"]), version: t2, deleteFlag: r2 };
      }
      !function(e2) {
        e2[e2.createConversation = 1] = "createConversation", e2[e2.deleteConversation = 2] = "deleteConversation", e2[e2.updateConversation = 3] = "updateConversation", e2[e2.setConversationTop = 4] = "setConversationTop", e2[e2.clearConversationUnread = 5] = "clearConversationUnread", e2[e2.addConversationToGroup = 6] = "addConversationToGroup", e2[e2.removeConversationFromGroup = 7] = "removeConversationFromGroup", e2[e2.modifyConversationOnSendMessage = 8] = "modifyConversationOnSendMessage", e2[e2.modifyConversationOnDeleteMessage = 9] = "modifyConversationOnDeleteMessage", e2[e2.modifyConversationOnRecallMessage = 10] = "modifyConversationOnRecallMessage", e2[e2.modifyConversationOnClearMessage = 11] = "modifyConversationOnClearMessage", e2[e2.oneClickClearConversationUnread = 12] = "oneClickClearConversationUnread", e2[e2.modifyConversationOnUpdateMessage = 13] = "modifyConversationOnUpdateMessage";
      }(Ta || (Ta = {}));
      class V2NIMLocalConversationComputeImpl {
        constructor(e2, t2) {
          this.core = e2, this.service = t2;
        }
        get hasUserService() {
          var e2;
          return !!(null === (e2 = this.core.V2NIMUserService) || void 0 === e2 ? void 0 : e2.name);
        }
        get hasFriendService() {
          var e2;
          return !!(null === (e2 = this.core.V2NIMFriendService) || void 0 === e2 ? void 0 : e2.name);
        }
        get hasTeamService() {
          var e2;
          return !!(null === (e2 = this.core.V2NIMTeamService) || void 0 === e2 ? void 0 : e2.name);
        }
        get hasMessageService() {
          var e2;
          return !!(null === (e2 = this.core.V2NIMMessageService) || void 0 === e2 ? void 0 : e2.name);
        }
        computeFromExternal(e2) {
          var t2, r2, i2;
          if (0 === e2.type)
            return e2;
          var s2 = this.core.V2NIMConversationIdUtil.parseConversationType(e2.conversationId), n2 = this.core.V2NIMConversationIdUtil.parseConversationTargetId(e2.conversationId), a2 = {};
          if ((null === (t2 = this.core.V2NIMSettingService) || void 0 === t2 ? void 0 : t2.name) && (a2.mute = this.core.V2NIMSettingService.getConversationMuteStatus(e2.conversationId)), 1 === s2 && this.hasUserService) {
            var o2, c2 = this.core.V2NIMUserService.model.getUser(n2), d2 = this.hasFriendService ? this.core.V2NIMFriendService.model.getFriend(n2) : void 0;
            e2.conversationId === (null === (r2 = e2.lastMessage) || void 0 === r2 ? void 0 : r2.messageRefer.conversationId) && (o2 = null === (i2 = e2.lastMessage) || void 0 === i2 ? void 0 : i2.senderName), a2.name = (null == d2 ? void 0 : d2.alias) || (null == c2 ? void 0 : c2.name) || o2 || n2, a2.avatar = (null == c2 ? void 0 : c2.avatar) || "";
          } else if (2 === s2 && this.hasTeamService) {
            var l2 = this.core.V2NIMTeamService.model.getById(n2, 1);
            a2.name = (null == l2 ? void 0 : l2.name) || n2, a2.avatar = (null == l2 ? void 0 : l2.avatar) || "";
          } else if (3 === s2 && this.hasTeamService) {
            var m2 = this.core.V2NIMTeamService.model.getById(n2, 2);
            a2.name = (null == m2 ? void 0 : m2.name) || n2, a2.avatar = (null == m2 ? void 0 : m2.avatar) || "";
          }
          return Object.assign(e2, a2), e2;
        }
        computeSortOrder(e2, t2) {
          return t2 ? e2 ? t2 + 1e15 : t2 : e2 ? 1e15 : 0;
        }
        computeReadTimeForMark(e2) {
          var t2, r2, i2, s2 = e2.conversationId, n2 = this.service.model.getReadTime(s2);
          if (null === (r2 = null === (t2 = null == e2 ? void 0 : e2.lastMessage) || void 0 === t2 ? void 0 : t2.messageRefer) || void 0 === r2 ? void 0 : r2.createTime)
            i2 = e2.lastMessage.messageRefer.createTime;
          else {
            if (0 === e2.unreadCount && n2 > 0)
              return n2;
            if (!this.core.timeOrigin.checkNodeReliable())
              return n2 || 0;
            i2 = this.core.timeOrigin.getNTPTime();
          }
          return i2;
        }
        computeConvWithLastMsg(e2, t2) {
          var r2, i2 = t2 || this.core.V2NIMMessageService.model.getLastMessageOfConversation(e2.conversationId);
          if (i2 && false !== (null === (r2 = i2.messageConfig) || void 0 === r2 ? void 0 : r2.lastMessageUpdateEnabled)) {
            var s2 = formatLastMessageFromMessage(this.core, i2, 0, i2.sendingState);
            e2.lastMessage = s2, e2.createTime = e2.createTime || i2.createTime, e2.updateTime = i2.createTime, e2.sortOrder = this.computeSortOrder(e2.stickTop, i2.createTime);
          }
          return e2;
        }
        computeConvWithUnread(e2, t2) {
          var r2 = this.service.model.getReadTime(e2.conversationId), i2 = this.service.unread.currentConversationId;
          if (i2 && (null == t2 ? void 0 : t2.conversationId) === i2)
            return e2.unreadCount = 0, this.service.unread._setCurrConvThrottle(), e2;
          var s2 = e2.unreadCount || 0;
          return t2 ? t2 && this.service.unread.isMessageUnread(t2) && (s2 += 1) : s2 = this.service.unread.countUnreadByMessageInMemory(e2.conversationId, r2), e2.unreadCount = s2, e2;
        }
        computeConvByMsgsCache(e2, t2) {
          var r2, i2 = this.service.model.getById(e2), s2 = this.core.V2NIMConversationIdUtil.parseConversationType(e2), n2 = this.core.V2NIMMessageService.model.getLastMessageOfConversation(e2), a2 = null == t2 ? void 0 : t2.updateTime, o2 = 0;
          o2 = a2 || (n2 && n2.createTime ? n2.createTime : i2 && i2.updateTime ? i2.updateTime : this.core.timeOrigin.getNTPTime());
          var c2 = this.service.model.getStickTop(e2), d2 = Object.assign(Object.assign({ conversationId: e2, type: s2, stickTop: c2, localExtension: (null == i2 ? void 0 : i2.localExtension) || "", lastMessage: null, unreadCount: 0 }, t2), { createTime: (null == i2 ? void 0 : i2.createTime) || o2, updateTime: o2, sortOrder: this.computeSortOrder(c2, o2) });
          if (n2 && false !== (null === (r2 = n2.messageConfig) || void 0 === r2 ? void 0 : r2.lastMessageUpdateEnabled)) {
            var l2 = formatLastMessageFromMessage(this.core, n2, 0, n2.sendingState);
            d2.lastMessage = l2;
          }
          return d2;
        }
      }
      class V2NIMLocalConversationHandlerImpl {
        constructor(e2, t2) {
          this.core = e2, this.service = t2, this.model = this.service.model, this.logger = this.core.logger;
        }
        v2LocalConvSyncStickTopHandler(e2) {
          var { timetag: t2, isThereAnyChange: r2, datas: i2 } = e2.content;
          if (r2) {
            var s2 = this.model.getAll(), n2 = i2.map((e3) => {
              var { target: t3, type: r3 } = getConvInfoFromSessionId(e3.id), i3 = this.core.V2NIMConversationIdUtil.conversationId(r3, t3);
              return this.model.updateStickTop(i3, true), i3;
            });
            s2.forEach((e3) => {
              n2.includes(e3.conversationId) ? (e3.stickTop = true, e3.updateTime = e3.updateTime > t2 ? e3.updateTime : t2) : e3.stickTop = false, this.model.updateStickTop(e3.conversationId, e3.stickTop);
            }), this.model.bulkUpsert(s2);
          }
        }
        v2LocalConvSyncReadTimeHandler(e2) {
          var t2 = e2.content.p2p || {}, r2 = e2.content.team.m_map || {};
          this.logger.log("v2SyncLocalConvAck::", t2, r2), Object.keys(t2).forEach((e3) => {
            var r3 = this.core.V2NIMConversationIdUtil.p2pConversationId(e3), i2 = this.model.getReadTime(r3);
            t2[e3] > i2 && (this.model.updateReadTime(r3, t2[e3]), this.service.emit("onConversationReadTimeUpdated", r3, t2[e3]));
          }), Object.keys(r2).forEach((e3) => {
            var t3 = this.core.V2NIMConversationIdUtil.teamConversationId(e3), i2 = this.model.getReadTime(t3);
            r2[e3] > i2 && (this.model.updateReadTime(t3, r2[e3]), this.service.emit("onConversationReadTimeUpdated", t3, r2[e3]));
          });
        }
        v2LocalConvSyncSuperTeamReadTimeHandler(e2) {
          var t2 = e2.content.superTeam.m_map;
          this.logger.log("v2SyncLocalSuperTeamConvAck::", t2), Object.keys(t2).forEach((e3) => {
            var r2 = this.core.V2NIMConversationIdUtil.superTeamConversationId(e3), i2 = this.model.getReadTime(r2);
            t2[e3] > i2 && (this.model.updateReadTime(r2, t2[e3]), this.service.emit("onConversationReadTimeUpdated", r2, t2[e3]));
          });
        }
        v2LocalConvMultiSyncReadTimeHandler(e2) {
          var t2 = e2.content, r2 = `${0 === t2.scene ? "p2p" : 1 === t2.scene ? "team" : "super_team"}-${t2.to}`, { type: i2, target: s2 } = getConvInfoFromSessionId(r2, "-"), n2 = this.core.V2NIMConversationIdUtil.conversationId(i2, s2), a2 = this.model.getById(n2), o2 = null == a2 ? void 0 : a2.unreadCount, c2 = this.model.getReadTime(n2);
          t2.timetag <= c2 ? this.logger.warn(`v2LocalConvMultiSyncReadTimeHandler: ${n2} do not need update ack ${t2.timetag}/${c2}`) : (this.model.updateReadTime(n2, t2.timetag), this.service.emit("onConversationReadTimeUpdated", n2, t2.timetag), a2 ? (a2 = this.service.compute.computeConvWithUnread(a2), this.model.upsert(a2), this.service.unread.digestUnreadCountChange(), void 0 === o2 && a2.unreadCount > 0 ? this.service.triggerConversationCreated(a2) : "number" == typeof o2 && a2.unreadCount !== o2 && this.service.triggerConversationChanged([a2])) : this.logger.log(`v2LocalConvMultiSyncReadTimeHandler: ${n2} not exist`));
        }
        v2LocalConvSuperTeamMultiSyncReadTimeHandler(e2) {
          this.v2LocalConvMultiSyncReadTimeHandler(e2);
        }
        v2LocalConvStickTopMultiSyncAddHandler(e2) {
          var { data: t2 } = e2.content, { target: r2, type: i2 } = getConvInfoFromSessionId(t2.id), s2 = this.core.V2NIMConversationIdUtil.conversationId(i2, r2);
          this.model.updateStickTop(s2, true);
          var n2 = this.model.getById(s2);
          n2 && (n2.stickTop = true, n2.updateTime = n2.updateTime > t2.updateTime ? n2.updateTime : t2.updateTime, n2.sortOrder = this.service.compute.computeSortOrder(true, t2.updateTime), this.model.upsert(n2), this.service.triggerConversationChanged([n2]));
        }
        v2LocalConvStickTopMultiSyncDeleteHandler(e2) {
          var { data: t2, timetag: r2 } = e2.content, { target: i2, type: s2 } = getConvInfoFromSessionId(t2.id), n2 = this.core.V2NIMConversationIdUtil.conversationId(s2, i2);
          this.model.updateStickTop(n2, false);
          var a2 = this.model.getById(n2);
          a2 && (a2.stickTop = false, a2.updateTime = a2.updateTime > r2 ? a2.updateTime : r2, a2.sortOrder = this.service.compute.computeSortOrder(false, r2), this.model.upsert(a2), this.service.triggerConversationChanged([a2]));
        }
      }
      class V2NIMLocalConversationEventImpl {
        constructor(e2, t2) {
          this.core = e2, this.service = t2, this.model = this.service.model, this.compute = this.service.compute, this.logger = this.core.logger;
        }
        setListener() {
          this.core.eventBus.on("V2NIMLoginService/syncing", () => this.service.emit("onSyncStarted")), this.core.eventBus.on("V2NIMLoginService/syncDone", this.onSyncDone.bind(this)), this.core.eventBus.on("V2NIMMessageService/sendMessage", this.sendMsg.bind(this)), this.core.eventBus.on("V2NIMMessageService/onMsg", this.recvMsg.bind(this)), this.core.eventBus.on("V2NIMMessageService/modifyMsg", this.modifyMsg.bind(this)), this.core.eventBus.on("V2NIMMessageService/deleteMessages", this.deleteMessages.bind(this)), this.core.eventBus.on("V2NIMMessageService/revokeMessages", this.deleteMessages.bind(this)), this.core.eventBus.on("V2NIMMessageLogUtil/onClearHistoryNotifications", this.clearMessages.bind(this)), this.core.eventBus.on("V2NIMMessageService/roamingMsgs", this.generateConv.bind(this)), this.core.eventBus.on("V2NIMMessageService/offlineMsgs", this.generateConv.bind(this)), this.core.eventBus.on("V2NIMSettingService/setMute", this.setMute.bind(this));
        }
        beforeEmit(e2, ...t2) {
          var r2, i2 = `${this.service.name}::emit ${e2.toString()}`;
          if ("onConversationCreated" === e2) {
            var s2 = t2[0], n2 = null === (r2 = s2.lastMessage) || void 0 === r2 ? void 0 : r2.messageRefer;
            this.logger.log(`${i2}`, `id:${s2.conversationId};unread:${s2.unreadCount};lastMsg:${(null == n2 ? void 0 : n2.messageClientId) || ""}/${(null == n2 ? void 0 : n2.messageServerId) || ""}`);
          } else if ("onConversationChanged" === e2) {
            var a2 = t2[0];
            this.logger.log(`${i2}`, a2.map((e3) => {
              var t3, r3 = null === (t3 = e3.lastMessage) || void 0 === t3 ? void 0 : t3.messageRefer;
              return `id:${e3.conversationId};unread:${e3.unreadCount};lastMsg:${(null == r3 ? void 0 : r3.messageClientId) || ""}/${(null == r3 ? void 0 : r3.messageServerId) || ""}`;
            }));
          } else
            this.logger.log(`${i2}`, ...t2);
        }
        onSyncDone(e2) {
          if (e2)
            this.service.emit("onSyncFailed", e2);
          else {
            var t2 = this.model.getAll();
            (t2 = t2.map((e3) => {
              var t3 = e3.conversationId, r2 = this.compute.computeConvByMsgsCache(t3);
              return r2 = this.compute.computeConvWithUnread(r2), r2 = this.compute.computeFromExternal(r2), this.model.upsert(r2), this.model.getById(t3);
            })).length > 0 && (this.service.triggerConversationChanged(t2), this.service.unread.resetTotalAfterSyncDone()), this.service.emit("onSyncFinished");
          }
        }
        generateConv(e2) {
          uniq(e2.map((e3) => e3.conversationId)).forEach((e3) => {
            var t2 = this.compute.computeConvByMsgsCache(e3);
            this.model.upsert(t2);
          });
        }
        setMute(e2, t2) {
          var r2 = this.model.getById(e2);
          r2 && r2.mute !== t2 && (r2.mute = t2, this.model.upsert(r2), this.service.triggerConversationChanged([r2]));
        }
        deleteMessages(e2) {
          var t2 = /* @__PURE__ */ new Set();
          e2.forEach((e3) => {
            var r3, i2 = e3.messageRefer.conversationId, s2 = this.model.getById(i2);
            if (s2) {
              if (e3.messageRefer.messageClientId === (null === (r3 = s2.lastMessage) || void 0 === r3 ? void 0 : r3.messageRefer.messageClientId)) {
                t2.add(i2);
                var n2 = this.core.V2NIMMessageService.model.getLastMessageOfConversation(i2);
                s2.lastMessage = n2 ? formatLastMessageFromMessage(this.core, n2, 0, n2.sendingState) : void 0;
              }
              var a2 = this.model.getReadTime(i2);
              if (s2.unreadCount > 0 && this.service.unread.isMessageReferUnread(e3.messageRefer, a2) && (t2.add(i2), s2.unreadCount--), "deleteTime" in e3)
                e3.deleteTime > s2.updateTime && (s2.updateTime = e3.deleteTime, s2.sortOrder = this.compute.computeSortOrder(s2.stickTop, s2.updateTime));
              else {
                var o2 = this.core.timeOrigin.getNTPTime();
                s2.updateTime = o2, s2.sortOrder = this.compute.computeSortOrder(s2.stickTop, o2);
              }
              this.model.upsert(s2);
            }
          });
          var r2 = Array.from(t2);
          !this.core.V2NIMLoginService.dataSync.checkSyncing() && r2.length > 0 && (this.service.triggerConversationChanged(r2.map((e3) => this.model.getById(e3))), this.service.unread.digestUnreadCountChange());
        }
        sendMsg(e2) {
          var t2 = e2.conversationId, r2 = this.model.getById(t2);
          if (r2) {
            var i2 = r2.lastMessage, s2 = this.updateCauseMessage(r2, e2);
            i2 !== s2.lastMessage && this.service.triggerConversationChanged([s2]);
          } else {
            var n2 = this.createCauseMessage(t2, e2);
            if (!n2)
              return;
            this.service.triggerConversationCreated(n2);
          }
        }
        recvMsg(e2) {
          var t2 = e2.conversationId, r2 = this.model.getById(t2);
          if (r2) {
            var i2 = r2.lastMessage, s2 = r2.unreadCount, n2 = this.updateCauseMessage(r2, e2);
            n2 = this.compute.computeConvWithUnread(n2, e2);
            var a2 = i2 !== (n2 = this.compute.computeFromExternal(n2)).lastMessage, o2 = s2 !== n2.unreadCount;
            this.model.upsert(n2), (a2 || o2) && this.service.triggerConversationChanged([n2]);
          } else {
            var c2 = this.createCauseMessage(t2, e2);
            if (!c2)
              return;
            c2 = this.compute.computeConvWithUnread(c2, e2), c2 = this.compute.computeFromExternal(c2), this.model.upsert(c2), this.service.triggerConversationCreated(c2);
          }
          this.service.unread.digestUnreadCountChange();
        }
        updateCauseMessage(e2, t2) {
          return e2 = this.compute.computeConvWithLastMsg(e2, t2), this.model.upsert(e2), this.model.getById(e2.conversationId);
        }
        createCauseMessage(e2, t2) {
          var r2, i2, s2;
          if (false !== (null === (r2 = t2.messageConfig) || void 0 === r2 ? void 0 : r2.unreadEnabled) || false !== (null === (i2 = t2.messageConfig) || void 0 === i2 ? void 0 : i2.lastMessageUpdateEnabled)) {
            var n2 = this.core.V2NIMConversationIdUtil.parseConversationType(e2), a2 = this.model.getStickTop(e2), o2 = false === (null === (s2 = t2.messageConfig) || void 0 === s2 ? void 0 : s2.lastMessageUpdateEnabled) ? void 0 : formatLastMessageFromMessage(this.core, t2, 0, t2.sendingState), c2 = this.core.timeOrigin.getNTPTime(), d2 = { conversationId: e2, type: n2, createTime: o2 ? t2.createTime : c2, updateTime: o2 ? t2.createTime : c2, sortOrder: this.compute.computeSortOrder(a2, o2 ? t2.createTime : c2), stickTop: a2, localExtension: "", lastMessage: o2, unreadCount: 0 };
            return this.model.upsert(d2), d2;
          }
        }
        clearMessages(e2) {
          var t2 = /* @__PURE__ */ new Set();
          e2.forEach((e3) => {
            var { conversationId: r3, deleteTime: i2 } = e3, s2 = this.model.getById(r3);
            s2 && (s2.unreadCount > 0 && (s2.unreadCount = 0, t2.add(r3)), s2.lastMessage && s2.lastMessage.messageRefer.createTime <= e3.deleteTime && (s2.lastMessage = void 0, t2.add(r3)), i2 > s2.updateTime && (s2.updateTime = i2, s2.sortOrder = this.compute.computeSortOrder(s2.stickTop, s2.updateTime)), this.model.upsert(s2));
          });
          var r2 = Array.from(t2);
          !this.core.V2NIMLoginService.dataSync.checkSyncing() && r2.length > 0 && (this.service.triggerConversationChanged(r2.map((e3) => this.model.getById(e3))), this.service.unread.digestUnreadCountChange());
        }
        modifyMsg(e2) {
          var t2, r2 = e2.conversationId, i2 = e2.messageClientId, s2 = this.model.getById(r2), n2 = this.core.V2NIMMessageService.model.getMessageById(i2);
          if (s2 || n2)
            if (s2)
              e2.messageClientId === (null === (t2 = s2.lastMessage) || void 0 === t2 ? void 0 : t2.messageRefer.messageClientId) && (s2.lastMessage = formatLastMessageFromMessage(this.core, e2, 0, e2.sendingState), this.service.triggerConversationChanged([s2]));
            else {
              var a2 = this.createCauseMessage(r2, e2);
              if (!a2)
                return;
              this.service.triggerConversationCreated(a2);
            }
        }
      }
      var Na = { type: "array", itemRules: { type: "enum", values: [1, 2, 3] }, min: 1 };
      class V2NIMConversationModelImpl {
        constructor() {
          this.map = /* @__PURE__ */ new Map(), this.readTimeMap = /* @__PURE__ */ new Map();
        }
        set(e2) {
          e2.forEach((e3) => {
            e3 = this.processConversation(e3), this.map.set(e3.conversationId, e3);
          });
        }
        reset() {
          this.map.clear(), this.readTimeMap.clear();
        }
        count() {
          return this.map.size;
        }
        sort() {
          var e2 = Array.from(this.map.values());
          e2.sort((e3, t2) => t2.sortOrder - e3.sortOrder), this.map.clear(), e2.forEach((e3) => {
            this.map.set(e3.conversationId, e3);
          });
        }
        processConversation(e2) {
          return "string" == typeof e2.lastMessage && delete e2.lastMessage, void 0 === e2.localExtension && (e2.localExtension = ""), e2;
        }
        getById(e2) {
          return this.map.get(e2);
        }
        getStickTopList() {
          return Array.from(this.map.values()).filter((e2) => e2.stickTop).sort((e2, t2) => t2.sortOrder - e2.sortOrder);
        }
        getAll() {
          return Array.from(this.map.values()).sort((e2, t2) => t2.sortOrder - e2.sortOrder);
        }
        getByOption(e2, t2, r2) {
          var { conversationTypes: i2, onlyUnread: s2, conversationGroupIds: n2 } = r2, a2 = [];
          this.map.forEach((e3) => {
            if ((!(i2 && i2.length > 0) || i2.includes(e3.type)) && (!s2 || e3.unreadCount) && (!r2.ignoreMuted || !e3.mute)) {
              if (n2) {
                var t3 = e3.groupIds, o3 = (null == t3 ? void 0 : t3.length) || 0;
                if (0 === n2.length && o3 > 0)
                  return;
                if (n2.length > 0 && 0 === o3)
                  return;
                if (n2.length > 0 && o3 > 0 && !n2.some((e4) => t3 && t3.includes(e4)))
                  return;
              }
              a2.push(e3);
            }
          }), a2 = a2.sort((e3, t3) => t3.sortOrder - e3.sortOrder);
          var o2 = 0;
          e2 > 0 && (o2 = findIndexWithinTargetValue(a2, "sortOrder", e2), a2[o2] && a2[o2].sortOrder === e2 && (o2 += 1));
          var c2 = a2.slice(o2).length;
          return (a2 = a2.slice(o2, o2 + t2)).length > 0 ? { offset: c2 > t2 ? a2[a2.length - 1].sortOrder : 0, finished: !(c2 > t2), conversationList: a2 } : { offset: 0, finished: true, conversationList: a2 };
        }
        upsert(e2) {
          var t2 = e2.conversationId, r2 = this.map.get(t2);
          if (!r2)
            return e2 = this.processConversation(Object.assign({}, e2)), this.map.set(t2, e2), e2.unreadCount > 0;
          var i2 = e2.unreadCount !== r2.unreadCount, s2 = Object.assign({}, r2, e2);
          return s2 = this.processConversation(s2), this.map.set(t2, s2), i2;
        }
        bulkUpsert(e2) {
          var t2 = false;
          return e2.forEach((e3) => {
            this.upsert(e3) && (t2 = true);
          }), t2;
        }
        deleteById(e2) {
          var t2 = this.getById(e2);
          if (t2)
            return this.map.delete(e2), t2;
        }
        updateReadTime(e2, t2) {
          this.readTimeMap.set(e2, t2);
        }
        getReadTime(e2) {
          return this.readTimeMap.get(e2) || 0;
        }
      }
      function isEqual(e2, t2) {
        var r2 = typeof e2;
        if (r2 !== typeof t2)
          return false;
        if ("object" === r2) {
          if (Object.prototype.toString.call(e2) !== Object.prototype.toString.call(t2))
            return false;
          if (Array.isArray(e2)) {
            if (e2.length !== t2.length)
              return false;
            for (var i2 = 0; i2 < e2.length; i2++)
              if (!isEqual(e2[i2], t2[i2]))
                return false;
            return true;
          }
          if (e2 instanceof RegExp && t2 instanceof RegExp)
            return e2.toString() === t2.toString();
          if (e2 instanceof Date && t2 instanceof Date)
            return e2.getTime() === t2.getTime();
          if (null === e2 && null === t2)
            return true;
          if (Object.keys(e2).length !== Object.keys(t2).length)
            return false;
          for (var s2 in e2)
            if (!isEqual(e2[s2], t2[s2]))
              return false;
          return true;
        }
        return e2 === t2;
      }
      class V2NIMConversationVersionCacheImpl {
        constructor(e2, t2) {
          this.fieldVersion = {}, this.conversationIdsForBackFill = {}, this.tempPacket = [], this.isSyncing = false, this.nextCursor = 0, this.core = e2, this.service = t2;
        }
        reset() {
          this.tempPacket = [], this.fieldVersion = {}, this.conversationIdsForBackFill = {}, this.isSyncing = false, this.nextCursor = 0;
        }
        doSync() {
          return __awaiter(this, void 0, void 0, function* () {
            var e2;
            this.isSyncing = true, this.service.emit("onSyncStarted"), this.core.V2NIMLoginService.dataSync.switchDataSync({ type: 1, state: 2, subType: "conversationSync" });
            try {
              e2 = yield this.core.sendCmd("v2ConversationSync", { tag: { cursor: this.nextCursor } });
            } catch (e3) {
              var t2 = e3;
              if (t2.code === ce.V2NIM_ERROR_CODE_CANCELLED)
                return;
              return this.isSyncing = false, this.service.emit("onSyncFailed", t2), this.core.V2NIMLoginService.dataSync.switchDataSync({ type: 1, state: 3, error: t2, subType: "conversationSync" }), void this.processTempPacket();
            }
            var r2 = 0 === parseInt(get(e2, "content.info.syncType")), i2 = get(e2, "content.info.nextCursor");
            this.doSyncAndSuccess(r2, i2);
          });
        }
        doSyncAndSuccess(e2, t2) {
          e2 && this.service.model.sort(), this.isSyncing = false, this.nextCursor = parseInt(t2) || 0, this.service.unread.resetTotalAfterSyncDone(), this.service.unread.digestUnreadCountChange(), this.service.emit("onSyncFinished"), this.core.V2NIMLoginService.dataSync.switchDataSync({ type: 1, state: 3, subType: "conversationSync" }), this.processTempPacket();
        }
        setBackFillIds(e2) {
          return e2.forEach((e3) => {
            if (2 === e3.lastMessageState && this.service.compute.hasMessageService) {
              this.conversationIdsForBackFill[e3.conversationId] = true;
              var t2 = this.core.V2NIMMessageService.model.getLastMessageOfConversation(e3.conversationId);
              e3.lastMessage = t2 ? formatLastMessageFromMessage(this.core, t2, e3.lastMessageState, t2.sendingState) : "";
            } else
              this.conversationIdsForBackFill[e3.conversationId] = false;
            delete e3.lastMessageState;
          }), e2;
        }
        recvConversationFromSyncAction(e2) {
          var { syncType: t2 } = get(e2, "content.info"), r2 = formatConversationFields(this.core, get(e2, "content.datas"));
          0 === (t2 = parseInt(t2)) ? (r2.forEach((e3) => {
            this.initFieldVersion(e3.conversationId, e3.version);
          }), r2 = this.setBackFillIds(r2), this.setModel(r2)) : (r2 = this.setBackFillIds(r2), this.recvConversationForCreated(r2) < r2.length && this.recvConversationForChanged(r2));
        }
        recvConversation(e2) {
          if (this.isSyncing)
            this.tempPacket.push(e2);
          else {
            var t2 = formatConversationFields(this.core, get(e2, "content.datas")).filter((e3) => !!e3.conversationId), r2 = get(e2, "content.info"), i2 = t2.map((e3) => `id:${e3.conversationId}, ver:${e3.version}`).join(";");
            if (this.core.logger.getDebugMode() ? this.core.logger.debug(`V2NIMConversation::recvConversation: ${i2}.`, r2, t2) : this.core.logger.log(`V2NIMConversation::recvConversation: ${i2}.`, r2), 2 === r2.type) {
              var s2 = t2.map((e3) => (delete this.fieldVersion[e3.conversationId], this.service.model.deleteById(e3.conversationId), e3.conversationId));
              return this.service.emit("onConversationDeleted", s2), void this.service.unread.digestUnreadCountChange();
            }
            if (12 !== r2.type)
              r2.type, t2 = this.setBackFillIds(t2), this.recvConversationForCreated(t2) < t2.length && this.recvConversationForChanged(t2);
            else
              this.compareAndClearUnreadInModel(r2);
          }
        }
        recvConversationForCreated(e2) {
          var t2 = e2.filter((e3) => !this.fieldVersion[e3.conversationId]);
          return t2.reduce((e3, t3) => {
            if (!this.fieldVersion[t3.conversationId]) {
              this.initFieldVersion(t3.conversationId, t3.version), e3 = !!this.updateModel(t3) || e3;
              var r2 = this.service.model.getById(t3.conversationId);
              return r2 && this.service.triggerConversationCreated(r2), e3;
            }
            return e3;
          }, false) && this.service.unread.digestUnreadCountChange(), t2.length;
        }
        recvConversationForChanged(e2) {
          var t2 = this.bulkCompare(e2);
          if (0 !== t2.length) {
            this.bulkUpdateModel(t2);
            var r2 = t2.map((e3) => this.service.model.getById(e3.conversationId)).filter((e3) => !!e3);
            this.service.triggerConversationChanged(r2);
          }
        }
        processTempPacket() {
          this.tempPacket.forEach((e2) => {
            this.recvConversation(e2);
          }), this.tempPacket = [];
        }
        bulkCompare(e2) {
          return e2.map((e3) => this.compare(e3)).filter((e3) => !!e3);
        }
        compare(e2) {
          var { version: t2, conversationId: r2, deleteFlag: i2, type: s2 } = e2, n2 = {}, a2 = 0;
          return ["stickTop", "groupIds", "serverExtension", "localExtension", "lastMessage", "lastMessageState", "unreadCount", "sortOrder", "createTime", "updateTime", "lastReadTime"].forEach((i3) => {
            var s3 = i3;
            if (void 0 !== e2[s3]) {
              var o2 = this.fieldVersion[r2];
              o2 && "number" == typeof o2[s3] && o2[s3] >= t2 || (this.fieldVersion[r2] = this.fieldVersion[r2] || {}, this.fieldVersion[r2][s3] = t2, n2[s3] = e2[s3], a2 += 1);
            }
          }), a2 ? Object.assign(Object.assign({}, n2), { conversationId: r2, deleteFlag: i2, version: t2, type: s2 }) : void 0;
        }
        bulkUpdateModel(e2) {
          var t2 = false;
          e2.forEach((e3) => {
            this.updateModel(e3) && (t2 = true);
          }), t2 && this.service.unread.digestUnreadCountChange();
        }
        initFieldVersion(e2, t2) {
          this.fieldVersion[e2] = { stickTop: t2, groupIds: t2, serverExtension: t2, lastMessage: t2, lastMessageState: t2, unreadCount: t2, sortOrder: t2, createTime: t2, updateTime: t2, lastReadTime: t2 };
        }
        initConversation(e2, t2) {
          var r2 = Date.now();
          return Object.assign({ conversationId: e2, type: this.core.V2NIMConversationIdUtil.parseConversationType(e2), stickTop: false, localExtension: "", serverExtension: "", unreadCount: 0, lastReadTime: 0, createTime: r2, updateTime: r2, sortOrder: r2 }, t2);
        }
        updateModel(e2) {
          var { deleteFlag: t2, conversation: r2 } = formatConversationByField(e2);
          if (t2) {
            var i2 = this.service.model.deleteById(r2.conversationId);
            return !!(i2 && i2.unreadCount > 0);
          }
          return this.service.model.upsert(r2);
        }
        setModel(e2) {
          var t2 = e2.filter((e3) => !e3.deleteFlag).map((e3) => formatConversationByField(e3).conversation);
          this.service.model.set(t2);
        }
        updateModelWithLastMessage(e2, t2, r2, i2) {
          var s2 = this.service.model.getById(e2), n2 = t2 ? formatLastMessageFromMessage(this.core, t2, r2, i2) : void 0;
          if (!isEqual(null == s2 ? void 0 : s2.lastMessage, n2))
            if (s2) {
              var a2 = Object.assign(Object.assign({}, s2), { sortOrder: n2 ? s2.stickTop ? n2.messageRefer.createTime + 1e15 : n2.messageRefer.createTime : s2.sortOrder, lastMessage: n2 });
              this.service.model.upsert(a2), this.service.triggerConversationChanged([a2]);
            } else {
              this.initFieldVersion(e2, -1);
              var o2 = this.initConversation(e2, { lastMessage: n2 });
              this.service.model.upsert(o2), this.service.triggerConversationCreated(o2);
            }
        }
        updateModelByRevoke(e2) {
          var t2 = [];
          e2.forEach((e3) => {
            var { postscript: r2, messageRefer: i2 } = e3, s2 = __rest(e3, ["postscript", "messageRefer"]), n2 = i2.conversationId, a2 = this.service.model.getById(n2);
            a2 && a2.lastMessage && a2.lastMessage.messageRefer.messageClientId === i2.messageClientId && 1 !== a2.lastMessage.lastMessageState && (a2.lastMessage.lastMessageState = 1, r2 && (a2.lastMessage.text = r2), Object.assign(a2.lastMessage, s2), this.service.model.upsert(a2), t2.push(a2));
          }), t2.length > 0 && this.service.triggerConversationChanged(t2);
        }
        compareAndUpdateModel(e2) {
          this.core.logger.log("V2NIMConversation::compareAndUpdateModel", e2.map((e3) => e3.conversationId));
          var t2 = false, r2 = [];
          e2.forEach((e3) => {
            var i2 = this.compare(e3);
            if (i2) {
              var s2 = this.service.model.getById(e3.conversationId);
              this.updateModel(i2) && (t2 = true);
              var n2 = this.service.model.getById(e3.conversationId);
              n2 && (s2 ? r2.push(n2) : this.service.triggerConversationCreated(n2));
            }
          }), r2.length > 0 && this.service.triggerConversationChanged(r2), t2 && this.service.unread.digestUnreadCountChange();
        }
        compareAndDeleteModel(e2) {
          this.core.logger.log("V2NIMConversation::compareAndDeleteModel", e2);
          var t2 = e2.reduce((e3, t3) => {
            delete this.fieldVersion[t3];
            var r2 = this.service.model.deleteById(t3);
            return !!!!(r2 && r2.unreadCount > 0) || e3;
          }, false);
          this.service.emit("onConversationDeleted", e2), t2 && this.service.unread.digestUnreadCountChange();
        }
        compareAndDeleteGroupInModel(e2, t2) {
          this.core.logger.log("V2NIMConversation::compareAndDeleteGroupInModel", e2, t2);
          var r2 = [];
          Object.keys(this.fieldVersion).forEach((i2) => {
            var s2 = this.fieldVersion[i2];
            if (void 0 === s2.groupIds || e2 > s2.groupIds) {
              s2.groupIds = e2;
              var n2 = this.service.model.getById(i2);
              if (n2 && n2.groupIds && n2.groupIds.length > 0) {
                var a2 = n2.groupIds.filter((e3) => e3 !== t2);
                if (a2.length !== n2.groupIds.length) {
                  var o2 = Object.assign(Object.assign({}, n2), { groupIds: a2 });
                  this.service.model.upsert(o2), o2 && r2.push(o2);
                }
              }
            }
          }), r2.length > 0 && this.service.triggerConversationChanged(r2);
        }
        compareAndClearUnreadInModel(e2) {
          var { oneClickClearUnreadType: t2, oneClickClearUnreadVersion: r2, oneClickClearUnreadLastReadTime: i2, oneClickClearUnreadConversationType: s2, oneClickClearUnreadGroupId: n2 } = e2;
          this.core.logger.log(`V2NIMConversation::compareAndClearUnreadInModel.ver:${r2};type:${t2};lastReadTime:${i2};filter:${s2 || ""};grounp:${n2 || ""}`);
          var a2 = [], o2 = [];
          if (1 === t2)
            o2 = this.service.model.getAll();
          else if (s2 || n2) {
            var c2 = this.service.model.count();
            o2 = this.service.model.getByOption(0, c2, { conversationTypes: s2, conversationGroupIds: n2 ? [n2] : void 0 }).conversationList;
          }
          o2.forEach((e3) => {
            var t3 = e3.conversationId, s3 = this.fieldVersion[t3];
            if (void 0 === s3.unreadCount || r2 > s3.unreadCount) {
              s3.unreadCount = r2, s3.lastReadTime = r2;
              var n3 = e3.unreadCount, o3 = Object.assign(Object.assign({}, e3), { lastReadTime: i2, unreadCount: 0 });
              this.service.model.upsert(o3), n3 > 0 && a2.push(o3);
            }
          }), a2.length > 0 && this.service.triggerConversationChanged(a2), this.service.unread.digestUnreadCountChange();
        }
        backfillLastMsg(e2, t2) {
          var r2 = e2 = uniq(e2);
          (t2 || 0 !== (r2 = e2.filter((e3) => this.conversationIdsForBackFill[e3])).length) && r2.forEach((e3) => {
            var t3 = get(this.service.model.getById(e3), "lastMessage.messageRefer.messageClientId"), r3 = this.service.compute.hasMessageService ? this.core.V2NIMMessageService.model.getLastMessageOfConversation(e3) : void 0;
            (r3 && r3.messageClientId) !== t3 && (this.conversationIdsForBackFill[e3] = false, r3 ? this.updateModelWithLastMessage(e3, r3, 2, r3.sendingState) : this.updateModelWithLastMessage(e3, void 0, 2, 0));
          });
        }
      }
      var Aa = { "28_1": "v2ConversationCreate", "28_2": "v2ConversationDelete", "28_3": "v2ConversationUpdate", "28_4": "v2ConversationSetTop", "28_5": "v2ConversationUnreadClear", "28_6": "v2ConversationGet", "28_7": "v2ConversationGetByIds", "28_8": "v2ConversationGetList", "28_17": "v2ConversationsDelete", "28_18": "v2ConversationsUnreadClear", "28_19": "v2ConversationSync", "28_20": "v2ConversationNotifySync", "28_21": "v2ConversationNotifySyncOnline", "28_23": "v2ConversationClearTotalUnread", "28_24": "v2ConversationClearTypeUnread", "28_25": "v2ConversationClearGroupUnread", "4_14": "syncConversationReadTime", "4_20": "syncSuperTeamReadTime", "4_22": "v2SyncSessionsWithMoreRoaming", "4_25": "v2SyncSessionReliableInfo", "30_16": "v2MarkConversationReadTime", "32_25": "v2MarkSuperTeamReadTime", "7_116": "v2MultiDeviceConversationReadTime", "21_125": "v2MultiDeviceSuperTeamReadTime" }, Oa = "V2NIMConversationService", ka = { conversationId: 1, type: { id: 2, retType: "number" }, serverExtension: 3, groupIds: { id: 4, retConverter: (e2) => e2 ? JSON.parse(e2) : void 0 }, lastMessage: 5, lastMessageState: { id: 6, retType: "number" }, unreadCount: { id: 7, retType: "number" }, stickTop: { id: 8, retType: "boolean" }, sortOrder: { id: 9, retType: "number" }, version: { id: 10, retType: "number" }, deleteFlag: { id: 11, retType: "boolean" }, createTime: { id: 12, retType: "number" }, updateTime: { id: 13, retType: "number" }, lastReadTime: { id: 14, retType: "number" } }, wa = { type: { id: 1, retType: "number" }, oneClickClearUnreadType: { id: 2, retType: "number" }, oneClickClearUnreadConversationType: { id: 3, retConverter: stringToJSONObject }, oneClickClearUnreadGroupId: { id: 4, retType: "string" }, oneClickClearUnreadVersion: { id: 5, retType: "number" }, oneClickClearUnreadLastReadTime: { id: 6, retType: "number" } }, Pa = { v2ConversationCreate: { sid: 28, cid: 1, service: Oa, params: [{ type: "Property", name: "tag", reflectMapper: { conversationId: 1 } }], response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(ka) }] }, v2ConversationDelete: { sid: 28, cid: 2, service: Oa, params: [{ type: "Property", name: "tag", reflectMapper: { conversationId: 1, clearMessage: 2 } }], response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(ka) }] }, v2ConversationUpdate: { sid: 28, cid: 3, service: Oa, params: [{ type: "Property", name: "tag", reflectMapper: { conversationId: 1, serverExtension: 2 } }], response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(ka) }] }, v2ConversationSetTop: { sid: 28, cid: 4, service: Oa, params: [{ type: "Property", name: "tag", reflectMapper: { conversationId: 1, stickTop: 2 } }], response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(ka) }] }, v2ConversationUnreadClear: { sid: 28, cid: 5, service: Oa, params: [{ type: "Property", name: "tag", reflectMapper: { conversationId: 1 } }], response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(ka) }] }, v2ConversationGet: { sid: 28, cid: 6, service: Oa, params: [{ type: "Property", name: "tag", reflectMapper: { conversationId: 1 } }], response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(ka) }] }, v2ConversationGetByIds: { sid: 28, cid: 7, service: Oa, params: [{ type: "Property", name: "tag", reflectMapper: { conversationIds: 1 } }], response: [{ type: "PropertyArray", name: "datas", reflectMapper: invertSerializeItem(ka) }, { type: "Property", name: "info", reflectMapper: { 1: "failedMap" } }] }, v2ConversationGetList: { sid: 28, cid: 8, service: Oa, params: [{ type: "Property", name: "tag", reflectMapper: { cursor: 1, limit: 2 } }], response: [{ type: "PropertyArray", name: "datas", reflectMapper: invertSerializeItem(ka) }, { type: "Property", name: "info", reflectMapper: { 1: "hasMore", 2: "offset" } }] }, v2ConversationsDelete: { sid: 28, cid: 17, service: Oa, params: [{ type: "Property", name: "tag", reflectMapper: { conversationIds: 1, clearMessage: 2 } }], response: [{ type: "PropertyArray", name: "datas", reflectMapper: invertSerializeItem(ka) }, { type: "Property", name: "info", reflectMapper: { 1: "failedMap" } }] }, v2ConversationsUnreadClear: { sid: 28, cid: 18, service: Oa, params: [{ type: "Property", name: "tag", reflectMapper: { conversationIds: 1 } }], response: [{ type: "PropertyArray", name: "datas", reflectMapper: invertSerializeItem(ka) }, { type: "Property", name: "info", reflectMapper: { 1: "failedMap" } }] }, v2ConversationSync: { sid: 28, cid: 19, service: Oa, params: [{ type: "Property", name: "tag", reflectMapper: { cursor: 1 } }], response: [{ type: "Property", name: "info", reflectMapper: { 1: "nextCursor", 2: "syncType" } }] }, v2ConversationNotifySync: { sid: 28, cid: 20, service: Oa, response: [{ type: "Property", name: "info", reflectMapper: { 1: "nextCursor", 2: "syncType" } }, { type: "PropertyArray", name: "datas", reflectMapper: invertSerializeItem(ka) }] }, v2ConversationNotifySyncOnline: { sid: 28, cid: 21, service: Oa, response: [{ type: "Property", name: "info", reflectMapper: invertSerializeItem(wa) }, { type: "PropertyArray", name: "datas", reflectMapper: invertSerializeItem(ka) }] }, v2ConversationClearTotalUnread: { sid: 28, cid: 23, service: Oa, response: [{ type: "Property", name: "info", reflectMapper: invertSerializeItem(wa) }] }, v2ConversationClearTypeUnread: { sid: 28, cid: 24, service: Oa, params: [{ type: "Property", name: "tag", reflectMapper: { conversationType: 1 } }], response: [{ type: "Property", name: "info", reflectMapper: invertSerializeItem(wa) }] }, v2ConversationClearGroupUnread: { sid: 28, cid: 25, service: Oa, params: [{ type: "Property", name: "tag", reflectMapper: { groupId: 1 } }], response: [{ type: "Property", name: "info", reflectMapper: invertSerializeItem(wa) }] }, syncConversationReadTime: { sid: 4, cid: 14, service: Oa, response: [{ type: "StrLongMap", name: "p2p" }, { type: "LongLongMap", name: "team" }, { type: "Long", name: "timetag" }] }, syncSuperTeamReadTime: { sid: 4, cid: 20, service: Oa, response: [{ type: "LongLongMap", name: "superTeam" }] }, v2SyncSessionsWithMoreRoaming: { sid: 4, cid: 22, service: Oa, response: [] }, v2SyncSessionReliableInfo: { sid: 4, cid: 25, service: Oa, response: [] }, v2MarkConversationReadTime: { sid: 30, cid: 16, service: Oa, params: [{ type: "Byte", name: "scene" }, { type: "String", name: "to" }, { type: "Long", name: "timetag" }] }, v2MarkSuperTeamReadTime: { sid: 32, cid: 25, service: Oa, params: [{ type: "Long", name: "to" }, { type: "Long", name: "timetag" }] }, v2MultiDeviceConversationReadTime: { sid: 30, cid: 116, service: Oa, response: [{ type: "Byte", name: "scene" }, { type: "String", name: "to" }, { type: "Long", name: "timetag" }] }, v2MultiDeviceSuperTeamReadTime: { sid: 21, cid: 125, service: Oa, response: [{ type: "Long", name: "to" }, { type: "Long", name: "timetag" }] } };
      class V2NIMConversationUnreadImpl {
        constructor(e2, t2) {
          this.totalUnreadCount = void 0, this.unreadCountByFilter = {}, this.core = e2, this.service = t2;
        }
        reset() {
          this.totalUnreadCount = void 0, this.unreadCountByFilter = {};
        }
        getTotalUnreadCount() {
          return this.totalUnreadCount;
        }
        resetTotalAfterSyncDone() {
          var e2 = this.service.model.getAll().reduce((e3, t3) => e3 + (t3.unreadCount || 0), 0), t2 = this.totalUnreadCount;
          return void 0 !== t2 && t2 === e2 || (this.totalUnreadCount = e2, this.service.emit("onTotalUnreadCountChanged", e2)), e2;
        }
        digestUnreadCountChange() {
          this._digest();
        }
        _digest() {
          var e2 = this.totalUnreadCount, t2 = this.service.model.getAll().reduce((e3, t3) => e3 + (t3.unreadCount || 0), 0);
          this.core.logger.log(`V2NIMConversation::digestUnreadCountChange:oldUnreadCount ${e2}, newUnreadCount ${t2}`), e2 !== t2 && (this.totalUnreadCount = t2, this.service.emit("onTotalUnreadCountChanged", t2)), Object.keys(this.unreadCountByFilter).forEach((e3) => {
            var t3 = JSON.parse(e3), r2 = this.getUnreadCountByFilter(t3), i2 = this.unreadCountByFilter[e3];
            this.unreadCountByFilter[e3] = r2, t3.equals = equals.bind(t3), i2 !== r2 && this.service.emit("onUnreadCountChangedByFilter", t3, r2);
          });
        }
        getUnreadCountByIds(e2) {
          return e2.reduce((e3, t2) => {
            var r2 = this.service.model.getById(t2);
            return e3 + (r2 && r2.unreadCount || 0);
          }, 0);
        }
        getUnreadCountByFilter(e2) {
          var t2 = this.service.model.count();
          return this.service.model.getByOption(0, t2, { conversationTypes: e2.conversationTypes, conversationGroupIds: e2.conversationGroupId ? [e2.conversationGroupId] : void 0, ignoreMuted: e2.ignoreMuted }).conversationList.reduce((e3, t3) => e3 + (t3.unreadCount || 0), 0);
        }
        addFilter(e2) {
          var t2 = generateFilterKey(e2);
          if (void 0 !== this.unreadCountByFilter[t2])
            throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_RESOURCE_ALREADY_EXIST });
          var r2 = JSON.parse(t2), i2 = this.getUnreadCountByFilter(r2);
          this.unreadCountByFilter[t2] = i2, this.service.emit("onUnreadCountChangedByFilter", r2, i2);
        }
        deleteFilter(e2) {
          var t2 = generateFilterKey(e2);
          if (void 0 === this.unreadCountByFilter[t2])
            throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_RESOURCE_NOT_EXIST });
          delete this.unreadCountByFilter[t2];
        }
      }
      function generateFilterKey(e2) {
        var { conversationTypes: t2 } = e2;
        return t2 && (t2 = t2.sort()), JSON.stringify({ conversationGroupId: e2.conversationGroupId, conversationTypes: t2, ignoreMuted: e2.ignoreMuted });
      }
      function equals(e2) {
        return JSON.stringify(this) === generateFilterKey(e2);
      }
      var Va = { createTime: { type: "number" }, updateTime: { type: "number" } };
      function formatConversationGroups(e2) {
        return e2 && e2.length > 0 ? e2.map((e3) => formatConversationGroup(e3)) : [];
      }
      function formatConversationGroup(e2) {
        return format(Va, e2);
      }
      function formatFailedMap(e2) {
        var t2 = JSON.parse(e2);
        return Object.keys(t2).map((e3) => ({ conversationId: e3, error: new V2NIMErrorImpl({ code: t2[e3] }) }));
      }
      var La, Ua = { type: { type: "number" }, deleteVersion: { type: "number" }, conversationIds: { type: "object" } };
      function formatConversationGroupNotify(e2) {
        return format(Ua, e2);
      }
      !function(e2) {
        e2[e2.createConversationGroup = 1] = "createConversationGroup", e2[e2.deleteConversationGroup = 2] = "deleteConversationGroup", e2[e2.updateConversationGroup = 3] = "updateConversationGroup", e2[e2.addConversationToGroup = 4] = "addConversationToGroup", e2[e2.removeConversationFromGroup = 5] = "removeConversationFromGroup";
      }(La || (La = {}));
      class V2NIMConversationComputeImpl {
        constructor(e2, t2) {
          this.core = e2, this.service = t2;
        }
        get hasUserService() {
          var e2;
          return !!(null === (e2 = this.core.V2NIMUserService) || void 0 === e2 ? void 0 : e2.name);
        }
        get hasFriendService() {
          var e2;
          return !!(null === (e2 = this.core.V2NIMFriendService) || void 0 === e2 ? void 0 : e2.name);
        }
        get hasTeamService() {
          var e2;
          return !!(null === (e2 = this.core.V2NIMTeamService) || void 0 === e2 ? void 0 : e2.name);
        }
        get hasMessageService() {
          var e2;
          return !!(null === (e2 = this.core.V2NIMMessageService) || void 0 === e2 ? void 0 : e2.name);
        }
        computeConvs(e2) {
          return e2.map((e3) => this.computeConv(e3));
        }
        computeConv(e2) {
          var t2, r2, i2, s2, n2;
          if (0 === e2.type)
            return e2;
          var a2 = this.core.V2NIMConversationIdUtil.parseConversationType(e2.conversationId), o2 = this.core.V2NIMConversationIdUtil.parseConversationTargetId(e2.conversationId), c2 = {};
          if (e2.lastReadTime || (c2.lastReadTime = this.service.model.getReadTime(e2.conversationId)), (null === (t2 = this.core.V2NIMSettingService) || void 0 === t2 ? void 0 : t2.name) && (c2.mute = this.core.V2NIMSettingService.getConversationMuteStatus(e2.conversationId)), 1 === a2 && this.hasUserService) {
            var d2, l2 = this.core.V2NIMUserService.model.getUser(o2), m2 = this.hasFriendService ? this.core.V2NIMFriendService.model.getFriend(o2) : void 0;
            e2.conversationId !== (null === (r2 = e2.lastMessage) || void 0 === r2 ? void 0 : r2.messageRefer.conversationId) || 0 !== (null === (i2 = e2.lastMessage) || void 0 === i2 ? void 0 : i2.lastMessageState) && 2 !== (null === (s2 = e2.lastMessage) || void 0 === s2 ? void 0 : s2.lastMessageState) || (d2 = null === (n2 = e2.lastMessage) || void 0 === n2 ? void 0 : n2.senderName), c2.name = (null == m2 ? void 0 : m2.alias) || (null == l2 ? void 0 : l2.name) || d2 || o2, c2.avatar = (null == l2 ? void 0 : l2.avatar) || "";
          } else if (2 === a2 && this.hasTeamService) {
            var p2 = this.core.V2NIMTeamService.model.getById(o2, 1);
            c2.name = (null == p2 ? void 0 : p2.name) || o2, c2.avatar = (null == p2 ? void 0 : p2.avatar) || "";
          } else if (3 === a2 && this.hasTeamService) {
            var u2 = this.core.V2NIMTeamService.model.getById(o2, 2);
            c2.name = (null == u2 ? void 0 : u2.name) || o2, c2.avatar = (null == u2 ? void 0 : u2.avatar) || "";
          }
          return Object.assign(e2, c2), e2;
        }
        computeReadTimeForMark(e2) {
          var t2, r2, i2, s2 = e2.conversationId, n2 = this.service.model.getReadTime(s2);
          if (null === (r2 = null === (t2 = null == e2 ? void 0 : e2.lastMessage) || void 0 === t2 ? void 0 : t2.messageRefer) || void 0 === r2 ? void 0 : r2.createTime)
            i2 = e2.lastMessage.messageRefer.createTime;
          else {
            if (!this.core.timeOrigin.checkNodeReliable())
              return n2 || 0;
            i2 = this.core.timeOrigin.getNTPTime();
          }
          return i2;
        }
      }
      class V2NIMConversationHandlerImpl {
        constructor(e2, t2) {
          this.core = e2, this.service = t2, this.model = this.service.model, this.logger = this.core.logger;
        }
        get ifEnabled() {
          return true === this.core.options.enableV2CloudConversation;
        }
        v2ConversationNotifySyncHandler(e2) {
          this.ifEnabled && this.service.versionCache.recvConversationFromSyncAction(e2);
        }
        v2ConversationNotifySyncOnlineHandler(e2) {
          this.ifEnabled && this.service.versionCache.recvConversation(e2);
        }
        syncConversationReadTimeHandler(e2) {
          var t2, r2, i2;
          if (this.ifEnabled) {
            if (null === (t2 = null == e2 ? void 0 : e2.content) || void 0 === t2 ? void 0 : t2.p2p)
              for (var [s2, n2] of Object.entries(e2.content.p2p))
                this.model.updateReadTime(this.core.V2NIMConversationIdUtil.p2pConversationId(s2), n2), this.service.emit("onConversationReadTimeUpdated", this.core.V2NIMConversationIdUtil.p2pConversationId(s2), n2);
            if (null === (i2 = null === (r2 = null == e2 ? void 0 : e2.content) || void 0 === r2 ? void 0 : r2.team) || void 0 === i2 ? void 0 : i2.m_map)
              for (var [a2, o2] of Object.entries(e2.content.team.m_map))
                this.model.updateReadTime(this.core.V2NIMConversationIdUtil.teamConversationId(a2), o2), this.service.emit("onConversationReadTimeUpdated", this.core.V2NIMConversationIdUtil.teamConversationId(a2), o2);
          }
        }
        syncSuperTeamReadTimeHandler(e2) {
          var t2, r2;
          if (this.ifEnabled && (null === (r2 = null === (t2 = null == e2 ? void 0 : e2.content) || void 0 === t2 ? void 0 : t2.superTeam) || void 0 === r2 ? void 0 : r2.m_map))
            for (var [i2, s2] of Object.entries(e2.content.superTeam.m_map))
              this.model.updateReadTime(this.core.V2NIMConversationIdUtil.superTeamConversationId(i2), s2), this.service.emit("onConversationReadTimeUpdated", this.core.V2NIMConversationIdUtil.superTeamConversationId(i2), s2);
        }
        v2MultiDeviceConversationReadTimeHandler(e2) {
          var t2;
          this.ifEnabled && (null === (t2 = null == e2 ? void 0 : e2.content) || void 0 === t2 ? void 0 : t2.to) && (0 === e2.content.scene ? (this.model.updateReadTime(this.core.V2NIMConversationIdUtil.p2pConversationId(e2.content.to), e2.content.timetag), this.service.emit("onConversationReadTimeUpdated", this.core.V2NIMConversationIdUtil.p2pConversationId(e2.content.to), e2.content.timetag)) : (this.model.updateReadTime(this.core.V2NIMConversationIdUtil.teamConversationId(e2.content.to), e2.content.timetag), this.service.emit("onConversationReadTimeUpdated", this.core.V2NIMConversationIdUtil.teamConversationId(e2.content.to), e2.content.timetag)));
        }
        v2MultiDeviceSuperTeamReadTimeHandler(e2) {
          var t2;
          this.ifEnabled && (null === (t2 = null == e2 ? void 0 : e2.content) || void 0 === t2 ? void 0 : t2.to) && (this.model.updateReadTime(this.core.V2NIMConversationIdUtil.superTeamConversationId(e2.content.to), e2.content.timetag), this.service.emit("onConversationReadTimeUpdated", this.core.V2NIMConversationIdUtil.superTeamConversationId(e2.content.to), e2.content.timetag));
        }
      }
      class V2NIMConversationEventImpl {
        constructor(e2, t2) {
          this.core = e2, this.service = t2, this.model = this.service.model, this.versionCache = this.service.versionCache, this.logger = this.core.logger;
        }
        setListener() {
          this.core.eventBus.on("V2NIMLoginService/loginLifeCycleLoginSucc", () => this.versionCache.doSync()), this.core.eventBus.on("V2NIMConversationService/conversationOnlineSyncNotify", this.conversationOnlineSyncNotify.bind(this)), this.core.eventBus.on("V2NIMMessageService/sendMessage", this.sendMessage.bind(this)), this.core.eventBus.on("V2NIMMessageService/deleteMessages", this.deleteMessages.bind(this)), this.core.eventBus.on("V2NIMMessageService/revokeMessages", this.revokeMessages.bind(this)), this.core.eventBus.on("V2NIMMessageService/roamingMsgs", this.roamingOrOfflineMsgs.bind(this)), this.core.eventBus.on("V2NIMMessageService/offlineMsgs", this.roamingOrOfflineMsgs.bind(this)), this.core.eventBus.on("V2NIMSettingService/setMute", this.setMute.bind(this));
        }
        beforeEmit(e2, ...t2) {
          var r2, i2, s2 = `${this.service.name}::emit ${e2.toString()}`;
          if ("onConversationCreated" === e2) {
            var n2 = t2[0];
            this.logger.log(`${s2}`, `id:${n2.conversationId};unread:${n2.unreadCount};lastMsg:${null === (r2 = n2.lastMessage) || void 0 === r2 ? void 0 : r2.messageRefer.messageClientId}/${null === (i2 = n2.lastMessage) || void 0 === i2 ? void 0 : i2.messageRefer.messageServerId}`);
          } else if ("onConversationChanged" === e2) {
            var a2 = t2[0];
            this.logger.log(`${s2}`, a2.map((e3) => {
              var t3, r3;
              return `id:${e3.conversationId};unread:${e3.unreadCount};lastMsg:${null === (t3 = e3.lastMessage) || void 0 === t3 ? void 0 : t3.messageRefer.messageClientId}/${null === (r3 = e3.lastMessage) || void 0 === r3 ? void 0 : r3.messageRefer.messageServerId}`;
            }));
          } else
            this.logger.log(`${s2}`, ...t2);
        }
        conversationOnlineSyncNotify(e2, t2) {
          var r2;
          false !== (null === (r2 = null == t2 ? void 0 : t2.messageConfig) || void 0 === r2 ? void 0 : r2.lastMessageUpdateEnabled) && (e2.content.info = deserialize(e2.content.info, invertSerializeItem(wa)), e2.content.data = deserialize(e2.content.data, invertSerializeItem(ka)), t2 && (e2.content.data.lastMessage = formatLastMessageFromMessage(this.core, t2, 0)), e2.content.datas = [e2.content.data], this.service.handler.v2ConversationNotifySyncOnlineHandler.call(this, e2));
        }
        sendMessage(e2, t2) {
          var r2, i2;
          1 === t2 && true === (null === (r2 = e2.messageConfig) || void 0 === r2 ? void 0 : r2.historyEnabled) || false !== (null === (i2 = null == e2 ? void 0 : e2.messageConfig) || void 0 === i2 ? void 0 : i2.lastMessageUpdateEnabled) && this.versionCache.updateModelWithLastMessage(e2.conversationId, e2, 2, t2);
        }
        deleteMessages(e2) {
          var t2 = e2.map((e3) => e3.messageRefer.conversationId);
          this.versionCache.backfillLastMsg(t2, true);
        }
        revokeMessages(e2) {
          this.versionCache.updateModelByRevoke(e2);
        }
        roamingOrOfflineMsgs(e2) {
          var t2 = uniq(e2.map((e3) => e3.conversationId));
          this.versionCache.backfillLastMsg(t2, false);
        }
        setMute(e2, t2) {
          var r2 = this.model.getById(e2);
          r2 && r2.mute !== t2 && (r2.mute = t2, this.model.upsert(r2), this.service.triggerConversationChanged([r2]));
        }
      }
      class V2NIMConversationServiceImpl extends V2Service {
        constructor(e2, t2 = {}) {
          super("V2NIMConversationService", e2), this.config = {}, this.model = new V2NIMConversationModelImpl(), this.versionCache = new V2NIMConversationVersionCacheImpl(this.core, this), this.unread = new V2NIMConversationUnreadImpl(this.core, this), this.compute = new V2NIMConversationComputeImpl(this.core, this), this.event = new V2NIMConversationEventImpl(this.core, this), this.handler = new V2NIMConversationHandlerImpl(this.core, this), this.core._registerDep(V2NIMConversationIdUtilImpl, "V2NIMConversationIdUtil"), "v2" === this.core.options.apiVersion && true === this.core.options.enableV2CloudConversation && (registerParser({ cmdMap: Aa, cmdConfig: Pa }), this.setOptions(t2), this.setListener());
        }
        setOptions(e2) {
          this.config = Object.assign(this.config, e2);
        }
        setListener() {
          this.event.setListener();
        }
        reset() {
          this.versionCache.reset(), this.model.reset(), this.unread.reset();
        }
        emit(e2, ...t2) {
          return this.event.beforeEmit(e2, ...t2), super.emit(e2, ...t2);
        }
        checkEnable() {
          if (true !== this.core.options.enableV2CloudConversation)
            throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_MISUSE, detail: { reason: "V2CloudConversation is not enabled" } });
        }
        getConversationList(e2, t2) {
          this.checkEnable(), this.checkV2(), validate({ offset: { type: "number", min: 0 } }, { offset: e2 }, "", true), validate({ limit: { type: "number", min: 1 } }, { limit: t2 }, "", true), this.core.V2NIMLoginService.checkIllegalState();
          var r2 = this.model.getByOption(e2, t2, {});
          return r2.conversationList = this.compute.computeConvs(r2.conversationList), Promise.resolve(r2);
        }
        getConversationListByOption(e2, t2, r2) {
          this.checkEnable(), this.checkV2(), validate({ offset: { type: "number", min: 0 } }, { offset: e2 }, "", true), validate({ limit: { type: "number", min: 1 } }, { limit: t2 }, "", true), validate({ option: { type: "object", required: true, rules: { conversationTypes: { type: "array", itemType: "number", required: false }, onlyUnread: { type: "boolean", required: false }, conversationGroupIds: { type: "array", itemType: "string", required: false } } } }, { option: r2 }, "", true), this.core.V2NIMLoginService.checkIllegalState();
          var i2 = this.model.getByOption(e2, t2, r2);
          return i2.conversationList = this.compute.computeConvs(i2.conversationList), Promise.resolve(i2);
        }
        getConversation(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkEnable(), this.checkV2(), validateConversationId(this.core.account, e2);
            var t2 = this.model.getById(e2);
            if (t2)
              return this.compute.computeConv(t2);
            throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_RESOURCE_NOT_EXIST });
          });
        }
        getConversationListByIds(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkEnable(), this.checkV2(), validate({ conversationIds: { type: "array", itemType: "string", min: 1 } }, { conversationIds: e2 }, "", true), this.core.V2NIMLoginService.checkIllegalState();
            var t2 = e2.map((e3) => this.model.getById(e3)).filter((e3) => !!e3);
            return t2 = this.compute.computeConvs(t2);
          });
        }
        createConversation(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkEnable(), this.checkV2(), validateConversationId(this.core.account, e2);
            var t2 = get(yield this.core.sendCmd("v2ConversationCreate", { tag: { conversationId: e2 } }), "content.data"), r2 = formatConversationField(this.core, t2);
            this.versionCache.compareAndUpdateModel([r2]);
            var i2 = this.model.getById(e2);
            if (i2)
              return this.compute.computeConv(i2);
            throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_RESOURCE_NOT_EXIST });
          });
        }
        deleteConversation(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkEnable(), this.checkV2(), validateConversationId(this.core.account, e2), validate({ clearMessage: { type: "boolean", required: false } }, { clearMessage: t2 }, "", true);
            try {
              yield this.core.sendCmd("v2ConversationDelete", { tag: { conversationId: e2, clearMessage: Number(t2 || false) } });
            } catch (t3) {
              this.logger.warn(`V2NIMConversationService:deleteConversation: delete conversation failed: ${e2}`);
            }
            this.model.getById(e2) && (t2 && this.core.eventBus.emit("V2NIMConversationService/deleteConversation", [e2]), this.versionCache.compareAndDeleteModel([e2]));
          });
        }
        deleteConversationListByIds(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkEnable(), this.checkV2(), validate({ conversationIds: { type: "array", itemType: "string", min: 1 } }, { conversationIds: e2 }, "", true), validate({ clearMessage: { type: "boolean", required: false } }, { clearMessage: t2 }, "", true);
            var r2 = formatFailedMap(get(yield this.core.sendCmd("v2ConversationsDelete", { tag: { conversationIds: JSON.stringify(e2), clearMessage: Number(t2 || false) } }), "content.info.failedMap")).filter((e3) => e3.error.code !== ce.V2NIM_ERROR_CODE_CONVERSATION_NOT_EXIST || !this.model.getById(e3.conversationId));
            return r2.length < e2.length && (t2 && this.core.eventBus.emit("V2NIMConversationService/deleteConversation", e2), this.versionCache.compareAndDeleteModel(e2)), r2;
          });
        }
        getStickTopConversationList() {
          return __awaiter(this, void 0, void 0, function* () {
            return this.checkV2(), this.core.V2NIMLoginService.checkIllegalState(), this.model.getStickTopList();
          });
        }
        stickTopConversation(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkEnable(), this.checkV2(), validateConversationId(this.core.account, e2), validate({ stickTop: { type: "boolean" } }, { stickTop: t2 }, "", true);
            var r2 = get(yield this.core.sendCmd("v2ConversationSetTop", { tag: { conversationId: e2, stickTop: Number(t2) } }), "content.data"), i2 = formatConversationField(this.core, r2);
            this.versionCache.compareAndUpdateModel([i2]);
          });
        }
        updateConversation(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkEnable(), this.checkV2(), validateConversationId(this.core.account, e2), validate({ updateInfo: { type: "object", required: true, rules: { serverExtension: { type: "string" } } } }, { updateInfo: t2 }, "", true);
            var r2 = get(yield this.core.sendCmd("v2ConversationUpdate", { tag: Object.assign({ conversationId: e2 }, t2) }), "content.data"), i2 = formatConversationField(this.core, r2);
            this.versionCache.compareAndUpdateModel([i2]);
          });
        }
        updateConversationLocalExtension(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkEnable(), this.checkV2(), validateConversationId(this.core.account, e2), validate({ localExtension: { type: "string" } }, { localExtension: t2 }, "", true);
            var r2 = this.model.getById(e2);
            if (!r2)
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_RESOURCE_NOT_EXIST });
            if (r2.localExtension !== t2) {
              var i2 = Object.assign(Object.assign({}, r2), { localExtension: t2 });
              this.model.upsert(i2), this.triggerConversationChanged([i2]);
            }
          });
        }
        getTotalUnreadCount() {
          return this.checkEnable(), this.checkV2(), this.unread.getTotalUnreadCount() || 0;
        }
        getUnreadCountByIds(e2) {
          this.checkEnable(), this.checkV2(), validate({ conversationIds: { type: "array", itemType: "string", min: 1 } }, { conversationIds: e2 }, "", true);
          var t2 = this.unread.getUnreadCountByIds(e2);
          return Promise.resolve(t2);
        }
        getUnreadCountByFilter(e2) {
          this.checkEnable(), this.checkV2(), this.valiteFilter(e2);
          var t2 = this.unread.getUnreadCountByFilter(e2);
          return Promise.resolve(t2);
        }
        clearTotalUnreadCount() {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkEnable(), this.checkV2();
            var e2 = get(yield this.core.sendCmd("v2ConversationClearTotalUnread"), "content.info");
            this.versionCache.compareAndClearUnreadInModel(e2);
          });
        }
        clearUnreadCountByIds(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkEnable(), this.checkV2(), validate({ conversationIds: { type: "array", itemType: "string", min: 1 } }, { conversationIds: e2 }, "", true);
            var t2 = yield this.core.sendCmd("v2ConversationsUnreadClear", { tag: { conversationIds: JSON.stringify(e2) } }), r2 = formatConversationFields(this.core, get(t2, "content.datas")), i2 = formatFailedMap(get(t2, "content.info.failedMap"));
            return this.versionCache.compareAndUpdateModel(r2), i2;
          });
        }
        clearUnreadCountByGroupId(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkEnable(), this.checkV2(), validate({ groupId: { type: "string" } }, { groupId: e2 }, "", true), yield this.core.sendCmd("v2ConversationClearGroupUnread", { tag: { groupId: e2 } });
          });
        }
        clearUnreadCountByTypes(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkEnable(), this.checkV2(), validate({ types: Na }, { types: e2 }, "", true);
            var t2 = get(yield this.core.sendCmd("v2ConversationClearTypeUnread", { tag: { conversationType: JSON.stringify(e2) } }), "content.info");
            this.versionCache.compareAndClearUnreadInModel(t2);
          });
        }
        markConversationRead(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkEnable(), this.checkV2(), this.checkLogin(), validateConversationId(this.core.account, e2);
            var t2 = this.model.getById(e2);
            if (!t2)
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "Conversation not exist" } });
            var r2 = this.core.V2NIMConversationIdUtil.parseConversationTargetId(e2), i2 = this.core.V2NIMConversationIdUtil.parseConversationType(e2), s2 = this.model.getReadTime(e2), n2 = this.compute.computeReadTimeForMark(t2);
            return s2 >= n2 ? (this.logger.log(`V2Conv::markConversationRead currentReadTime >= readTime ${e2},${s2},${n2}`), s2) : (3 === i2 ? yield this.core.sendCmd("v2MarkSuperTeamReadTime", { timetag: n2, to: r2 }) : yield this.core.sendCmd("v2MarkConversationReadTime", { scene: 1 === i2 ? 0 : 2 === i2 ? 1 : 2, timetag: n2, to: r2 }), this.model.updateReadTime(e2, n2), n2);
          });
        }
        getConversationReadTime(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.checkEnable(), this.checkV2(), validateConversationId(this.core.account, e2), this.model.getReadTime(e2);
          });
        }
        subscribeUnreadCountByFilter(e2) {
          var t2;
          this.checkEnable(), this.checkV2(), this.checkLogin(), this.valiteFilter(e2), 0 === (null === (t2 = e2.conversationTypes) || void 0 === t2 ? void 0 : t2.length) && delete e2.conversationTypes, this.unread.addFilter(e2);
        }
        unsubscribeUnreadCountByFilter(e2) {
          var t2;
          this.checkEnable(), this.checkV2(), this.checkLogin(), this.valiteFilter(e2), 0 === (null === (t2 = e2.conversationTypes) || void 0 === t2 ? void 0 : t2.length) && delete e2.conversationTypes, this.unread.deleteFilter(e2);
        }
        valiteFilter(e2) {
          if (validate({ filter: { type: "object", required: true, rules: { conversationTypes: { type: "array", itemType: "number", required: false }, conversationGroupId: { type: "string", allowEmpty: false, required: false }, ignoreMuted: { type: "boolean", required: false } } } }, { filter: e2 }, "", true), void 0 === e2.conversationTypes && void 0 === e2.conversationGroupId && true !== e2.ignoreMuted)
            throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "Filter cannot be empty" } });
        }
        triggerConversationChanged(e2) {
          e2 = this.compute.computeConvs(e2), (e2 = JSON.parse(JSON.stringify(e2))).forEach((e3) => {
            e3.lastMessage || (e3.lastMessage = void 0), delete e3.lastMessageState;
          }), this.emit("onConversationChanged", e2);
        }
        triggerConversationCreated(e2) {
          e2 = this.compute.computeConv(e2), delete (e2 = JSON.parse(JSON.stringify(e2))).lastMessageState, this.emit("onConversationCreated", e2);
        }
      }
      var Da = { "28_9": "v2ConversationGroupCreate", "28_10": "v2ConversationGroupDelete", "28_11": "v2ConversationGroupUpdate", "28_12": "v2ConversationGroupGet", "28_13": "v2ConversationGroupsGet", "28_14": "v2ConversationGroupListGet", "28_15": "v2ConversationGroupAddTo", "28_16": "v2ConversationGroupRemoveFrom", "28_22": "v2ConversationGroupNotifySyncOnline" }, qa = "V2NIMConversationGroupService", xa = { groupId: 1, name: 2, serverExtension: 3, createTime: 4, updateTime: 5 }, Ba = { v2ConversationGroupCreate: { sid: 28, cid: 9, service: qa, params: [{ type: "Property", name: "tag", reflectMapper: { conversationIds: 1, name: 2, serverExtension: 3 } }], response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(xa) }, { type: "PropertyArray", name: "conversations", reflectMapper: invertSerializeItem(ka) }, { type: "Property", name: "info", reflectMapper: { 1: "failedMap" } }] }, v2ConversationGroupDelete: { sid: 28, cid: 10, service: qa, params: [{ type: "Property", name: "tag", reflectMapper: { groupId: 1 } }], response: [{ type: "Property", name: "info", reflectMapper: { 1: "type", 2: "deleteVersion", 3: "groupList" } }] }, v2ConversationGroupUpdate: { sid: 28, cid: 11, service: qa, params: [{ type: "Property", name: "tag", reflectMapper: { groupId: 1, name: 2, serverExtension: 3 } }], response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(xa) }] }, v2ConversationGroupGet: { sid: 28, cid: 12, service: qa, params: [{ type: "Property", name: "tag", reflectMapper: { groupId: 1 } }], response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(xa) }] }, v2ConversationGroupsGet: { sid: 28, cid: 13, service: qa, params: [{ type: "Property", name: "tag", reflectMapper: { groupIds: 1 } }], response: [{ type: "PropertyArray", name: "datas", reflectMapper: invertSerializeItem(xa) }, { type: "Property", name: "info", reflectMapper: { 1: "failedMap" } }] }, v2ConversationGroupListGet: { sid: 28, cid: 14, service: qa, response: [{ type: "PropertyArray", name: "datas", reflectMapper: invertSerializeItem(xa) }] }, v2ConversationGroupAddTo: { sid: 28, cid: 15, service: qa, params: [{ type: "Property", name: "tag", reflectMapper: { groupId: 1, conversationIds: 2 } }], response: [{ type: "PropertyArray", name: "datas", reflectMapper: invertSerializeItem(ka) }, { type: "Property", name: "info", reflectMapper: { 1: "failedMap" } }] }, v2ConversationGroupRemoveFrom: { sid: 28, cid: 16, service: qa, params: [{ type: "Property", name: "tag", reflectMapper: { groupId: 1, conversationIds: 2 } }], response: [{ type: "PropertyArray", name: "datas", reflectMapper: invertSerializeItem(ka) }, { type: "Property", name: "info", reflectMapper: { 1: "failedMap" } }] }, v2ConversationGroupNotifySyncOnline: { sid: 28, cid: 22, service: qa, response: [{ type: "Property", name: "info", reflectMapper: { 1: "type", 2: "deleteVersion", 3: "conversationIds" } }, { type: "Property", name: "data", reflectMapper: invertSerializeItem(xa) }] } };
      var Fa = "V2NIMMessageLogUtil", ja = { "30_6": "v2GetMessageList", "33_2": "v2GetMessageListByRefers", "30_9": "v2ClearRoamingMessage", "30_18": "v2ClearHistoryMessage", "7_118": "onClearHistoryMessage", "4_24": "syncClearHistoryMessage", "31_23": "v2GetTeamMessageList", "32_14": "v2GetSuperTeamMessageList" }, $a = { conversationType: { id: 0, retType: "number" }, receiverId: 1, deleteRoam: { id: 2, converter: boolToInt }, teamId: 3, onlineSync: { id: 4, converter: boolToInt }, deleteTime: { id: 6, retType: "number" }, serverExtension: 7 }, Ga = [{ type: "Long", name: "beginTime" }, { type: "Long", name: "endTime" }, { type: "Long", name: "lastMsgId" }, { type: "Int", name: "limit" }, { type: "Bool", name: "direction" }, { type: "LongArray", name: "msgTypes" }], Ha = { v2GetMessageList: { sid: 30, cid: 6, service: Fa, params: [{ type: "String", name: "to" }, ...Ga], response: [{ type: "PropertyArray", name: "msgs", reflectMapper: invertSerializeItem(ia) }] }, v2GetMessageListByRefers: { sid: 33, cid: 2, service: Fa, params: [{ type: "PropertyArray", name: "tag", reflectMapper: ia, select: ["conversationType", "senderId", "receiverId", "createTime", "messageServerId"] }], response: [{ type: "PropertyArray", name: "msgs", reflectMapper: invertSerializeItem(ia) }] }, v2ClearRoamingMessage: { sid: 30, cid: 9, service: Fa, params: [{ type: "StrArray", name: "conversationIds" }] }, v2ClearHistoryMessage: { sid: 30, cid: 18, service: Fa, params: [{ type: "Property", name: "tag", reflectMapper: $a }], response: [{ type: "Long", name: "timetag" }] }, v2GetTeamMessageList: { sid: 31, cid: 23, service: Fa, params: [{ type: "Long", name: "to" }, ...Ga], response: [{ type: "PropertyArray", name: "msgs", reflectMapper: invertSerializeItem(ia) }] }, v2GetSuperTeamMessageList: { sid: 32, cid: 14, service: Fa, params: [{ type: "Long", name: "to" }, ...Ga], response: [{ type: "PropertyArray", name: "msgs", reflectMapper: invertSerializeItem(ia) }] }, onClearHistoryMessage: { sid: 7, cid: 118, service: Fa, response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem($a) }] }, syncClearHistoryMessage: { sid: 4, cid: 24, service: Fa, response: [{ type: "PropertyArray", name: "data", reflectMapper: invertSerializeItem($a) }] } };
      var za = "V2NIMMessageExtendUtil", Wa = { "29_5": "v2VoiceToText", "33_15": "v2PinMessage", "33_16": "v2UpdatePinMessage", "33_17": "v2UnpinMessage", "23_18": "onPinMessage", "23_19": "onUpdatePinMessage", "23_20": "onUnpinMessage", "23_115": "onPinMessage", "23_116": "onUpdatePinMessage", "23_117": "onUnpinMessage", "33_21": "v2GetPinMessageList", "33_3": "v2AddQuickComment", "33_4": "v2RemoveQuickComment", "33_7": "v2GetQuickComment", "23_5": "onAddQuickComment", "23_6": "onRemoveQuickComment", "23_103": "onAddQuickComment", "23_104": "onRemoveQuickComment", "33_8": "v2AddCollection", "33_9": "v2RemoveCollections", "33_10": "v2UpdateCollectionExtension", "33_11": "v2GetCollectionListByOption", "30_26": "v2SearchCloudMessagesGroupByConversation", "30_27": "v2SearchCloudMessages", "30_34": "v2SearchCloudMessagesEx", "33_1": "v2GetThreadMessageList" }, Ka = { conversationType: { id: 1, converter: conversationTypeV2ToV1, retConverter: conversationTypeV1ToV2, access: "messageRefer.conversationType" }, senderId: { id: 2, access: "messageRefer.senderId" }, receiverId: { id: 3, access: "messageRefer.receiverId" }, createTime: { id: 4, retType: "number", access: "messageRefer.createTime" }, messageServerId: { id: 5, access: "messageRefer.messageServerId" }, messageClientId: { id: 6, access: "messageRefer.messageClientId" }, detail: 7, modify: { id: 8, retType: "number" } }, Ya = { conversationType: { id: 1, access: "messageRefer.conversationType", retConverter: conversationTypeV1ToV2 }, senderId: { id: 2, access: "messageRefer.senderId" }, receiverId: { id: 3, access: "messageRefer.receiverId" }, time: { id: 4, access: "messageRefer.createTime", converter: boolToInt, retType: "number" }, messageServerId: { id: 5, access: "messageRefer.messageServerId" }, messageClientId: { id: 6, access: "messageRefer.messageClientId" }, operatorId: 7, serverExtension: 8, createTime: { id: 9, converter: boolToInt, retType: "number" }, updateTime: { id: 10, converter: boolToInt, retType: "number" } }, Ja = { operatorId: 1, index: { id: 2, retType: "number" }, createTime: { id: 3, retType: "number" }, serverExtension: 4, pushEnabled: { id: 5, access: "pushConfig.pushEnabled", converter: boolToInt }, needBadge: { id: 6, access: "pushConfig.needBadge", converter: boolToInt }, title: { id: 7, access: "pushConfig.title" }, pushContent: { id: 8, access: "pushConfig.pushContent" }, pushPayload: { id: 9, access: "pushConfig.pushPayload" } }, Qa = { accid: 1, serverExtension: 2, createTime: { id: 3, retType: "number" }, updateTime: { id: 4, retType: "number" } }, Xa = { collectionId: 1, collectionType: { id: 2, retType: "number" }, collectionData: 3, serverExtension: 4, uniqueId: 5, createTime: { id: 6, retType: "number" }, updateTime: { id: 7, retType: "number" } }, Za = { keyword: 1, beginTime: 2, endTime: 3, messageLimit: 5, sortOrder: { id: 6, converter: (e2) => 0 === e2 ? 2 : 1 }, p2pAccountIds: { id: 7, converter: (e2) => e2.join(",") }, teamIds: { id: 8, converter: (e2) => e2.join(",") }, senderAccountIds: { id: 9, converter: (e2) => e2.join(",") }, messageTypes: { id: 10, converter: (e2) => e2.join(",") }, messageSubtypes: { id: 11, converter: (e2) => e2.join(",") } }, eo = { keywordList: { id: 1, converter: (e2) => objectToJSONString(e2) }, keywordMatchType: 2, searchStartTime: 3, searchTimePeriod: 4, pageToken: 5, limit: 7, direction: 8, conversationId: 9, senderAccountIds: { id: 12, converter: (e2) => e2.join(",") }, messageTypes: { id: 13, converter: (e2) => e2.join(",") }, messageSubtypes: { id: 14, converter: (e2) => e2.join(",") } }, to = Object.assign(Object.assign({}, Za), { conversationLimit: 4 }), ro = { v2PinMessage: { sid: 33, cid: 15, service: za, params: [{ type: "Property", name: "msg", reflectMapper: ia, select: ["conversationType", "receiverId", "senderId", "createTime", "messageClientId", "messageServerId"] }, { type: "Property", name: "msgPin", reflectMapper: Qa }], response: [{ type: "Long", name: "timetag" }] }, v2UnpinMessage: { sid: 33, cid: 17, service: za, params: [{ type: "Property", name: "msg", reflectMapper: ia, select: ["conversationType", "receiverId", "senderId", "createTime", "messageClientId", "messageServerId"] }, { type: "Property", name: "msgPin", reflectMapper: Qa }], response: [{ type: "Long", name: "timetag" }] }, v2UpdatePinMessage: { sid: 33, cid: 16, service: za, params: [{ type: "Property", name: "msg", reflectMapper: ia, select: ["conversationType", "receiverId", "senderId", "createTime", "messageClientId", "messageServerId"] }, { type: "Property", name: "msgPin", reflectMapper: Qa }], response: [{ type: "Long", name: "timetag" }] }, v2GetPinMessageList: { sid: 33, cid: 21, service: za, params: [{ type: "Property", name: "tag", reflectMapper: { conversationId: 1, timetag: 2 } }], response: [{ type: "Long", name: "timetag" }, { type: "Bool", name: "changed" }, { type: "PropertyArray", name: "data", reflectMapper: invertSerializeItem(Ya) }] }, v2VoiceToText: { sid: 29, cid: 5, service: za, params: [{ type: "Property", name: "tag", reflectMapper: { mimeType: 0, sampleRate: 1, voiceUrl: 2, duration: 3 } }], response: [{ type: "String", name: "data" }] }, v2AddQuickComment: { sid: 33, cid: 3, service: za, params: [{ type: "Property", name: "message", reflectMapper: ia, select: ["conversationType", "senderId", "receiverId", "createTime", "messageClientId", "messageServerId"] }, { type: "Property", name: "quickComment", reflectMapper: Ja }], response: [{ type: "Long", name: "timetag" }] }, v2RemoveQuickComment: { sid: 33, cid: 4, service: za, params: [{ type: "Property", name: "message", reflectMapper: ia, select: ["conversationType", "senderId", "receiverId", "createTime", "messageClientId", "messageServerId"] }, { type: "Property", name: "quickComment", reflectMapper: Ja }], response: [{ type: "Long", name: "timetag" }] }, onAddQuickComment: { sid: 23, cid: 5, service: za, response: [{ type: "Property", name: "message", reflectMapper: invertSerializeItem(ia) }, { type: "Property", name: "quickComment", reflectMapper: invertSerializeItem(Ja) }] }, onRemoveQuickComment: { sid: 23, cid: 6, service: za, response: [{ type: "Property", name: "message", reflectMapper: invertSerializeItem(ia) }, { type: "Property", name: "quickComment", reflectMapper: invertSerializeItem(Ja) }] }, v2GetQuickComment: { sid: 33, cid: 7, service: za, params: [{ type: "PropertyArray", name: "tag", reflectMapper: Ka }], response: [{ type: "PropertyArray", name: "data", reflectMapper: invertSerializeItem(Ka) }] }, onPinMessage: { sid: 23, cid: 18, service: za, response: [{ type: "Property", name: "msg", reflectMapper: invertSerializeItem(ia) }, { type: "Property", name: "pinInfo", reflectMapper: invertSerializeItem(Qa) }] }, onUpdatePinMessage: { sid: 23, cid: 19, service: za, response: [{ type: "Property", name: "msg", reflectMapper: invertSerializeItem(ia) }, { type: "Property", name: "pinInfo", reflectMapper: invertSerializeItem(Qa) }] }, onUnpinMessage: { sid: 23, cid: 20, service: za, response: [{ type: "Property", name: "msg", reflectMapper: invertSerializeItem(ia) }, { type: "Property", name: "pinInfo", reflectMapper: invertSerializeItem(Qa) }] }, v2AddCollection: { sid: 33, cid: 8, service: za, params: [{ type: "Property", name: "tag", reflectMapper: Xa }], response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(Xa) }] }, v2RemoveCollections: { sid: 33, cid: 9, service: za, params: [{ type: "PropertyArray", name: "tag", reflectMapper: Xa, select: ["collectionId", "createTime"] }], response: [{ type: "Int", name: "data" }] }, v2UpdateCollectionExtension: { sid: 33, cid: 10, service: za, params: [{ type: "Property", name: "tag", reflectMapper: Xa }], response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(Xa) }] }, v2GetCollectionListByOption: { sid: 33, cid: 11, service: za, params: [{ type: "Property", name: "tag", reflectMapper: { beginTime: 1, endTime: 2, excludeId: 3, limit: 4, direction: 5, collectionType: 6 } }], response: [{ type: "Long", name: "total" }, { type: "PropertyArray", name: "data", reflectMapper: invertSerializeItem(Xa) }] }, v2SearchCloudMessagesGroupByConversation: { sid: 30, cid: 26, service: za, params: [{ type: "Property", name: "tag", reflectMapper: to }], response: [{ type: "PropertyArray", name: "data", reflectMapper: invertSerializeItem(ia) }] }, v2SearchCloudMessages: { sid: 30, cid: 27, service: za, params: [{ type: "Property", name: "tag", reflectMapper: Za }], response: [{ type: "PropertyArray", name: "data", reflectMapper: invertSerializeItem(ia) }] }, v2SearchCloudMessagesEx: { sid: 30, cid: 34, service: za, params: [{ type: "Property", name: "tag", reflectMapper: eo }], response: [{ type: "PropertyArray", name: "msgs", reflectMapper: invertSerializeItem(ia) }, { type: "Int", name: "hasMore" }, { type: "String", name: "nextPageToken" }] }, v2GetThreadMessageList: { sid: 33, cid: 1, service: za, params: [{ type: "Property", name: "messageRefer", reflectMapper: ia }, { type: "Property", name: "tag", reflectMapper: { beginTime: 1, endTime: 2, excludeMessageServerId: 3, limit: 4, reverse: 5 } }], response: [{ type: "Property", name: "message", reflectMapper: invertSerializeItem(ia) }, { type: "Property", name: "replyResult", reflectMapper: invertSerializeItem({ total: { id: 1, retType: "number" }, timestamp: { id: 2, retType: "number" } }) }, { type: "PropertyArray", name: "replyList", reflectMapper: invertSerializeItem(ia) }] } };
      var io, so = { joinMode: { type: "enum", values: [1, 0, 2], required: false }, agreeMode: { type: "enum", values: [0, 1], required: false }, inviteMode: { type: "enum", values: [1, 0], required: false }, updateInfoMode: { type: "enum", values: [1, 0], required: false }, updateExtensionMode: { type: "enum", values: [1, 0], required: false }, chatBannedMode: { type: "enum", values: [0, 1], required: false } }, no = { type: "object", required: true, rules: Object.assign({ name: { type: "string", allowEmpty: false }, teamType: { type: "enum", values: [1, 2] }, memberLimit: { type: "number", min: 1, required: false } }, so) }, ao = { type: "array", min: 1, itemType: "string" }, oo = { type: "boolean" }, co = { type: "string" }, lo = { type: "string", allowEmpty: false }, mo = { type: "object", rules: { antispamBusinessId: { type: "string", required: false } }, required: false }, po = { teamId: { type: "string", regExp: /^[1-9]\d*$/, allowEmpty: false } }, uo = { teamIds: { type: "array", itemRules: { type: "string", allowEmpty: false, regExp: /^[1-9]\d*$/ }, min: 1 } }, ho = { teamType: { type: "enum", values: [1, 2] } }, go = { teamTypes: { type: "array", itemType: "enum", values: [1, 2], required: false } }, vo = { inviteeParams: { type: "object", required: true, rules: { inviteeAccountIds: ao, postscript: Object.assign(Object.assign({}, co), { required: false }), serverExtension: Object.assign(Object.assign({}, co), { required: false }) } } }, yo = { updateTeamInfoParams: { type: "object", required: true, rules: Object.assign({ name: { type: "string", allowEmpty: false, required: false }, memberLimit: { type: "number", min: 1, required: false } }, so) } }, fo = { type: "enum", values: [0, 2] }, Io = { memberInfoParams: { type: "object", rules: { teamNick: { type: "string", required: false }, serverExtension: { type: "string", required: false }, antispamConfig: { type: "object", required: false, rules: { antispamBusinessId: { type: "string", required: false } } } } } }, Mo = { chatBannedMode: { type: "enum", values: [0, 1] } }, So = { queryOption: { type: "object", rules: { roleQueryType: { type: "enum", values: [0, 2, 1] }, onlyChatBanned: { type: "boolean", required: false }, direction: { type: "enum", values: [1, 0], required: false }, limit: { type: "number", min: 1, required: false }, nextToken: { type: "string", required: false } } } }, To = { teamId: po.teamId, teamType: { type: "enum", values: [1, 2] }, operatorAccountId: { type: "string", allowEmpty: false } }, _o = { actionType: { type: "enum", values: [2, 0, 1, 3] } }, Co = { actionType: { type: "enum", values: [2] } }, Eo = { actionType: { type: "enum", values: [0] } }, bo = { types: { type: "array", itemType: "enum", values: [0, 2, 1, 3], required: false }, status: { type: "array", itemType: "enum", values: [1, 3, 0, 2], required: false }, offset: { type: "number", min: 0, required: false }, limit: { type: "number", min: 1, required: false } }, Ro = { teamId: po.teamId, teamType: ho.teamType, accountIds: ao }, No = { accountId: { type: "string", allowEmpty: false }, teamNick: { type: "string" }, antispamConfig: { type: "object", required: false, rules: { antispamBusinessId: { type: "string", required: false } } } };
      class V2NIMTeamModelImpl {
        constructor() {
          this.teamMap = /* @__PURE__ */ new Map(), this.superTeamMap = /* @__PURE__ */ new Map();
        }
        set(e2) {
          e2.forEach((e3) => {
            this.chooseMap(e3.teamType).set(e3.teamId, e3);
          });
        }
        reset() {
          this.teamMap.clear(), this.superTeamMap.clear();
        }
        count(e2, t2 = true) {
          var r2 = this.chooseMap(e2), i2 = 0;
          return r2.forEach((e3) => {
            t2 && e3.isValidTeam && i2++, t2 || i2++;
          }), i2;
        }
        chooseMap(e2) {
          return 2 === e2 ? this.superTeamMap : 1 === e2 ? this.teamMap : /* @__PURE__ */ new Map();
        }
        getById(e2, t2, r2 = true) {
          var i2 = this.chooseMap(t2).get(e2);
          if (i2) {
            if (r2 && i2.isValidTeam)
              return i2;
            if (!r2)
              return i2;
          }
        }
        getAll(e2, t2 = true) {
          var r2 = this.chooseMap(e2);
          return Array.from(r2.values()).filter((e3) => !(!t2 || !e3.isValidTeam) || (!t2 || void 0)).sort((e3, t3) => t3.updateTime - e3.updateTime);
        }
        upsert(e2) {
          var t2 = e2.teamId, r2 = e2.teamType, i2 = this.chooseMap(r2), s2 = i2.get(t2) || {}, n2 = Object.assign({}, s2, e2);
          return i2.set(t2, n2), n2;
        }
        deleteById(e2, t2) {
          var r2 = this.getById(e2, t2);
          if (r2)
            return r2.isValidTeam = false, r2;
        }
        searchTeamByKeyword(e2) {
          var t2 = [];
          return this.teamMap.forEach((r2) => {
            r2.name.includes(e2) && t2.push(r2);
          }), this.superTeamMap.forEach((r2) => {
            r2.name.includes(e2) && t2.push(r2);
          }), t2;
        }
      }
      class V2NIMTeamMemberModelImpl {
        constructor() {
          this.teamMembers = [], this.superTeamMembers = [], this.maxSize = 2e3;
        }
        reset() {
          this.teamMembers = [], this.superTeamMembers = [];
        }
        setData(e2) {
          e2.forEach((e3) => {
            this.chooseList(e3.teamType).push(e3);
          });
        }
        chooseList(e2) {
          return 2 === e2 ? this.superTeamMembers : 1 === e2 ? this.teamMembers : [];
        }
        getById(e2, t2, r2) {
          return this.chooseList(t2).find((t3) => t3.teamId === e2 && t3.accountId === r2);
        }
        upsert(e2) {
          var t2 = e2.teamType, r2 = e2.teamId, i2 = this.chooseList(t2), s2 = i2.findIndex((t3) => t3.teamId === r2 && t3.accountId === e2.accountId);
          -1 === s2 ? i2.push(e2) : i2[s2] = Object.assign(Object.assign({}, i2[s2]), e2), i2.length > this.maxSize && i2.shift();
        }
        deleteByAccount(e2, t2, r2) {
          var i2 = this.chooseList(t2), s2 = i2.findIndex((t3) => t3.teamId === e2 && t3.accountId === r2);
          if (-1 !== s2) {
            var n2 = i2[s2];
            return n2.inTeam = false, i2.splice(s2, 1), n2;
          }
        }
        deleteByTeamId(e2, t2) {
          var r2 = this.chooseList(t2).filter((t3) => t3.teamId !== e2);
          2 === t2 ? this.superTeamMembers = r2 : this.teamMembers = r2;
        }
      }
      class V2NIMTeamNotificationImpl {
        constructor(e2, t2) {
          this.core = e2, this.service = t2;
        }
        processNotification(e2) {
          var { attachment: t2, senderId: r2, receiverId: i2, createTime: s2 } = e2, { id: n2, data: a2 } = t2, o2 = n2 > 400 ? 2 : 1, { id: c2, ids: d2, tinfo: l2, mute: m2 } = formatTeamNotificationAttachData(a2, o2), p2 = this.service.model.getById(i2, o2);
          switch (this.core.logger.log(`v2Team::processNotification, notificationType:${n2}, teamId:${i2}`, a2), n2) {
            case io.SUPER_TEAM_INVITATION:
            case io.TEAM_INVITATION:
              d2.includes(this.core.account) && this.onTeamJoined(l2), this.onTeamMembersJoined(l2, d2.filter((e3) => e3 !== this.core.account));
              break;
            case io.SUPER_TEAM_INVITE_ACCEPT:
            case io.TEAM_INVITE_ACCEPT:
              r2 === this.core.account ? this.onTeamJoined(l2) : this.onTeamMemberJoined(l2, r2);
              break;
            case io.SUPER_TEAM_APPLY_ACCEPT:
            case io.TEAM_APPLY_ACCEPT:
              c2 === this.core.account ? this.onTeamJoined(l2) : this.onTeamMemberJoined(l2, c2);
              break;
            case io.SUPER_TEAM_ADD_MANAGER:
            case io.TEAM_ADD_MANAGER:
              this.updateTeamMemberRole(i2, o2, d2, { memberRole: 2, updateTime: s2 });
              break;
            case io.SUPER_TEAM_REMOVE_MANAGER:
            case io.TEAM_REMOVE_MANAGER:
              this.updateTeamMemberRole(i2, o2, d2, { memberRole: 0, updateTime: s2 });
              break;
            case io.SUPER_TEAM_KICK:
            case io.TEAM_KICK:
              this.onTeamInfoUpdated(l2), d2.forEach((e3) => {
                e3 === this.core.account ? this.onTeamLeft(i2, o2, true) : this.onTeamMemberKicked(r2, l2.teamId, l2.teamType, e3);
              });
              break;
            case io.SUPER_TEAM_LEAVE:
            case io.TEAM_LEAVE:
              l2 ? this.onTeamInfoUpdated(l2) : p2 && r2 === this.core.account && (p2.isValidTeam = false, this.onTeamInfoUpdated(p2)), r2 === this.core.account ? this.onTeamLeft(i2, o2, false) : this.onTeamMemberLeft(i2, o2, r2);
              break;
            case io.SUPER_TEAM_DISMISS:
            case io.TEAM_DISMISS:
              this.onTeamDismissed(i2, o2);
              break;
            case io.SUPER_TEAM_UPDATE:
            case io.TEAM_UPDATED:
              this.onTeamInfoUpdated(l2);
              break;
            case io.SUPER_TEAM_TRANSFER_OWNER:
            case io.TEAM_TRANSFER_OWNER:
              this.onTeamInfoUpdated(l2), this.updateTeamMemberRole(i2, o2, [r2, l2.ownerAccountId], [{ memberRole: 0, updateTime: s2 }, { memberRole: 1, updateTime: s2, joinTime: s2 }], false);
              break;
            case io.SUPER_TEAM_MEMBER_MUTE:
            case io.TEAM_MEMBER_MUTE:
              this.service.model.upsert(l2), this.updateTeamMemberRole(i2, o2, c2 ? [c2] : d2, { chatBanned: 0 !== m2, updateTime: s2 });
          }
        }
        onTeamJoined(e2) {
          this.service.model.upsert(e2), this.service.emit("onTeamJoined", e2), this.service.getTeamMemberListByIds(e2.teamId, e2.teamType, [this.core.account]).catch((e3) => {
            this.core.logger.error("Get Member error after onTeamJoined", e3);
          });
        }
        onTeamLeft(e2, t2, r2) {
          var i2 = this.service.model.deleteById(e2, t2) || generateTeamByTeamId(e2, t2, { isValidTeam: false });
          this.service.memberModel.deleteByAccount(e2, t2, this.core.account), this.service.emit("onTeamLeft", i2, r2);
        }
        onTeamDismissed(e2, t2) {
          var r2 = this.service.model.deleteById(e2, t2);
          r2 || (r2 = generateTeamByTeamId(e2, t2, { isValidTeam: false })), this.service.memberModel.deleteByTeamId(e2, t2), this.service.emit("onTeamDismissed", r2);
        }
        onTeamInfoUpdated(e2) {
          var t2 = this.service.model.upsert(e2);
          this.service.emit("onTeamInfoUpdated", t2);
        }
        onTeamMemberJoined(e2, t2) {
          this.service.model.upsert(e2), this.service.emit("onTeamInfoUpdated", e2);
          var r2 = e2.updateTime || e2.createTime, i2 = generateMemberByTeamId(e2.teamId, e2.teamType, t2, { joinTime: r2, updateTime: r2 });
          this.service.emit("onTeamMemberJoined", [i2]);
        }
        onTeamMembersJoined(e2, t2) {
          var r2 = e2.updateTime || e2.createTime, i2 = t2.map((t3) => generateMemberByTeamId(e2.teamId, e2.teamType, t3, { joinTime: r2, updateTime: r2 }));
          0 !== i2.length && (this.service.model.upsert(e2), this.service.emit("onTeamInfoUpdated", e2), this.service.emit("onTeamMemberJoined", i2));
        }
        onTeamMemberLeft(e2, t2, r2) {
          var i2 = this.service.memberModel.deleteByAccount(e2, t2, r2);
          i2 || (i2 = generateMemberByTeamId(e2, t2, r2, { inTeam: false })), this.service.emit("onTeamMemberLeft", [i2]);
        }
        onTeamMemberKicked(e2, t2, r2, i2) {
          var s2 = this.service.memberModel.deleteByAccount(t2, r2, i2);
          s2 || (s2 = generateMemberByTeamId(t2, r2, i2, { inTeam: false })), this.service.emit("onTeamMemberKicked", e2, [s2]);
        }
        onTeamMemberInfoUpdated(e2) {
          e2.forEach((e3) => {
            if (e3.accountId === this.core.account && this.core.V2NIMSettingService.name && this.core.V2NIMConversationIdUtil.name) {
              var t2 = 1 === e3.teamType ? this.core.V2NIMConversationIdUtil.teamConversationId(e3.teamId) : this.core.V2NIMConversationIdUtil.superTeamConversationId(e3.teamId), r2 = this.core.V2NIMSettingService.getConversationMuteStatus(t2);
              this.core.eventBus.emit("V2NIMSettingService/setMute", t2, r2);
            }
          }), this.service.emit("onTeamMemberInfoUpdated", e2);
        }
        updateTeamMemberRole(e2, t2, r2, i2, s2 = true) {
          return __awaiter(this, void 0, void 0, function* () {
            var n2 = r2.filter((r3, s3) => {
              var n3 = this.service.memberModel.getById(e2, t2, r3);
              return n3 && this.service.memberModel.upsert(Object.assign(Object.assign({}, n3), Array.isArray(i2) ? i2[s3] : i2)), !n3;
            });
            if (s2 && n2.length > 0)
              try {
                (yield this.service.getTeamMemberListByIds(e2, t2, n2)).forEach((e3) => this.service.memberModel.upsert(e3));
              } catch (e3) {
                this.core.logger.warn("v2Team::processNotification, getTeamMemberListByIds failed", e3);
              }
            var a2 = r2.map((r3, n3) => {
              var a3 = this.service.memberModel.getById(e2, t2, r3);
              return a3 || s2 ? a3 : generateMemberByTeamId(e2, t2, r3, Array.isArray(i2) ? i2[n3] : i2);
            }).filter((e3) => !!e3);
            a2.length > 0 && this.onTeamMemberInfoUpdated(a2);
          });
        }
        processSysNotification(e2) {
          var { receiverId: t2, postscript: r2, senderId: i2, timestamp: s2, content: n2 } = e2, a2 = {};
          try {
            a2 = JSON.parse(n2);
          } catch (e3) {
            this.core.logger.warn("v2Team::processSysNotification, parse content failed", n2);
          }
          var o2 = { actionType: { 0: 0, 1: 1, 2: 2, 3: 3, 15: 0, 16: 1, 17: 2, 18: 3 }[e2.type], teamId: t2, teamType: e2.type >= 15 ? 2 : 1, operatorAccountId: i2, postscript: r2, timestamp: s2, actionStatus: 0, read: false };
          a2.attach && (o2.serverExtension = a2.attach), this.core.logger.log("v2Team::processSysNotification, type:", e2.type, o2), this.service.notificationModel.create(o2), this.service.emit("onReceiveTeamJoinActionInfo", o2);
        }
        updateTeamActionStatus(e2, t2) {
          this.service.notificationModel.update({ teamId: e2.teamId, teamType: e2.teamType, operatorAccountId: e2.operatorAccountId, actionType: e2.actionType, actionStatus: t2 });
        }
        checkIfExpired(e2) {
          return !!e2 && (509 === e2 || !(e2 >= 500 && e2 <= 599) && !(e2 >= 19e4));
        }
      }
      !function(e2) {
        e2[e2.TEAM_INVITATION = 0] = "TEAM_INVITATION", e2[e2.TEAM_KICK = 1] = "TEAM_KICK", e2[e2.TEAM_LEAVE = 2] = "TEAM_LEAVE", e2[e2.TEAM_UPDATED = 3] = "TEAM_UPDATED", e2[e2.TEAM_DISMISS = 4] = "TEAM_DISMISS", e2[e2.TEAM_APPLY_ACCEPT = 5] = "TEAM_APPLY_ACCEPT", e2[e2.TEAM_TRANSFER_OWNER = 6] = "TEAM_TRANSFER_OWNER", e2[e2.TEAM_ADD_MANAGER = 7] = "TEAM_ADD_MANAGER", e2[e2.TEAM_REMOVE_MANAGER = 8] = "TEAM_REMOVE_MANAGER", e2[e2.TEAM_INVITE_ACCEPT = 9] = "TEAM_INVITE_ACCEPT", e2[e2.TEAM_MEMBER_MUTE = 10] = "TEAM_MEMBER_MUTE", e2[e2.SUPER_TEAM_INVITATION = 401] = "SUPER_TEAM_INVITATION", e2[e2.SUPER_TEAM_KICK = 402] = "SUPER_TEAM_KICK", e2[e2.SUPER_TEAM_LEAVE = 403] = "SUPER_TEAM_LEAVE", e2[e2.SUPER_TEAM_UPDATE = 404] = "SUPER_TEAM_UPDATE", e2[e2.SUPER_TEAM_DISMISS = 405] = "SUPER_TEAM_DISMISS", e2[e2.SUPER_TEAM_TRANSFER_OWNER = 406] = "SUPER_TEAM_TRANSFER_OWNER", e2[e2.SUPER_TEAM_ADD_MANAGER = 407] = "SUPER_TEAM_ADD_MANAGER", e2[e2.SUPER_TEAM_REMOVE_MANAGER = 408] = "SUPER_TEAM_REMOVE_MANAGER", e2[e2.SUPER_TEAM_MEMBER_MUTE = 409] = "SUPER_TEAM_MEMBER_MUTE", e2[e2.SUPER_TEAM_APPLY_ACCEPT = 410] = "SUPER_TEAM_APPLY_ACCEPT", e2[e2.SUPER_TEAM_INVITE_ACCEPT = 411] = "SUPER_TEAM_INVITE_ACCEPT";
      }(io || (io = {}));
      class V2NIMTeamNotificationModelImpl {
        constructor() {
          this.list = [], this.maxCount = 1e3;
        }
        reset() {
          this.list = [];
        }
        checkSameAction(e2, t2, r2 = false) {
          return e2.teamId === t2.teamId && e2.teamType === t2.teamType && e2.actionType === t2.actionType && e2.operatorAccountId === t2.operatorAccountId && (!r2 || e2.timestamp === t2.timestamp);
        }
        create(e2) {
          this.list.push(e2), this.list.length > this.maxCount && this.list.shift();
        }
        update(e2) {
          this.list.forEach((t2) => {
            this.checkSameAction(t2, e2) && 0 === t2.actionStatus && Object.assign(t2, e2);
          });
        }
        delete(e2) {
          this.list = this.list.map((t2) => {
            if (!this.checkSameAction(t2, e2, false))
              return t2;
          }).filter((e3) => e3);
        }
        getByOption(e2) {
          var { types: t2, status: r2, offset: i2 = 0, limit: s2 = 50 } = e2, n2 = [];
          this.list.forEach((e3) => {
            t2 && t2.length > 0 && !t2.includes(e3.actionType) || r2 && r2.length > 0 && !r2.includes(e3.actionStatus) || n2.push(e3);
          }), n2 = n2.sort((e3, t3) => t3.timestamp - e3.timestamp);
          var a2 = 0;
          i2 > 0 && (a2 = findIndexWithinTargetValue(n2, "timestamp", i2), n2[a2] && n2[a2].timestamp === i2 && (a2 += 1));
          var o2 = n2.slice(a2).length;
          return (n2 = n2.slice(a2, a2 + s2)).length > 0 ? { offset: o2 > s2 ? n2[n2.length - 1].timestamp : 0, finished: !(o2 > s2), infos: n2 } : { offset: 0, finished: true, infos: n2 };
        }
        setRead(e2) {
          for (var t2 of this.list)
            this.checkSameAction(t2, e2) && (t2.read = true);
        }
        setAllRead() {
          for (var e2 of this.list)
            e2.read = true;
        }
        getUnreadCount() {
          var e2 = /* @__PURE__ */ new Set();
          for (var t2 of this.list)
            t2.read || 0 !== t2.actionStatus || 0 !== t2.actionType && 2 !== t2.actionType || e2.add(`${t2.operatorAccountId}_${t2.teamType}_${t2.teamId}`);
          return e2.size;
        }
      }
      class V2NIMTeamEventImpl {
        constructor(e2, t2) {
          this.core = e2, this.service = t2, this.model = t2.model, this.memberModel = t2.memberModel, this.notification = t2.notification, this.logger = this.core.logger;
        }
        setListener() {
          this.core.eventBus.on("V2NIMTeamService/onSyncStarted", () => {
            this.service.emit("onSyncStarted");
          }), this.core.eventBus.on("V2NIMTeamService/onSyncFinished", () => {
            this.service.emit("onSyncFinished");
          }), this.core.eventBus.on("V2NIMTeamService/onSyncFailed", (e2) => {
            this.service.emit("onSyncFailed", e2);
          }), this.core.eventBus.on("forwardReceive/V2NIMTeamService/created", (e2) => {
            this.model.upsert(e2);
            var t2 = generateMemberByTeamId(e2.teamId, e2.teamType, this.core.account, { memberRole: 1 });
            this.memberModel.upsert(t2), this.service.emit("onTeamCreated", e2);
          }), this.core.eventBus.on("forwardReceive/V2NIMTeamService/updateSelfTeamMemberInfo", (e2) => {
            this.memberModel.upsert(e2), this.service.emit("onTeamInfoUpdated", [e2]);
          }), this.core.eventBus.on("forwardReceive/V2NIMTeamService/updateTeamActionStatus", this.notification.updateTeamActionStatus.bind(this.notification)), this.core.eventBus.on("V2NIMTeamService/sysNotification", this.notification.processSysNotification.bind(this.notification)), this.core.eventBus.on("V2NIMTeamService/notification", this.notification.processNotification.bind(this.notification));
        }
        beforeEmit(e2, ...t2) {
          var r2 = `${this.service.name}::emit ${e2.toString()}`;
          if ("onTeamCreated" === e2 || "onTeamDismissed" === e2 || "onTeamJoined" === e2 || "onTeamLeft" === e2 || "onTeamInfoUpdated" === e2) {
            var i2 = t2[0];
            this.logger.log(`${r2}`, `team:${i2.teamId}_${i2.teamType};updateTime:${i2.updateTime}`);
          } else if ("onTeamMemberJoined" === e2 || "onTeamMemberLeft" === e2 || "onTeamMemberInfoUpdated" === e2) {
            var s2 = t2[0];
            this.logger.log(`${r2}`, s2.map((e3) => `team:${e3.teamId}_${e3.teamType};account:${e3.accountId}`));
          } else if ("onTeamMemberKicked" === e2) {
            var n2 = t2[0], a2 = t2[1];
            this.logger.log(`${r2}`, `operator${n2}`, a2.map((e3) => `team:${e3.teamId}_${e3.teamType};account:${e3.accountId}`));
          } else
            this.logger.log(`${r2}`, ...t2);
        }
        onSyncDone(e2) {
          e2 ? this.service.emit("onSyncFailed", e2) : this.service.emit("onSyncFinished");
        }
      }
      class V2NIMTeamHandlerImpl {
        constructor(e2, t2) {
          this.core = e2, this.service = t2, this.model = t2.model, this.memberModel = t2.memberModel, this.logger = this.core.logger;
        }
        v2TeamSyncHandler(e2) {
          this.model.set(e2.content.datas);
        }
        v2SuperTeamSyncHandler(e2) {
          this.model.set(e2.content.datas);
        }
        v2TeamCreateMultiSyncHandler(e2) {
          var t2 = e2.content.data;
          this.model.upsert(t2);
          var r2 = generateMemberByTeamId(t2.teamId, t2.teamType, this.core.account, { memberRole: 1 });
          this.memberModel.upsert(r2), this.service.emit("onTeamCreated", t2);
        }
        v2SuperTeamCreateMultiSyncHandler(e2) {
          var t2 = e2.content.data;
          this.model.upsert(t2);
          var r2 = generateMemberByTeamId(t2.teamId, t2.teamType, this.core.account, { memberRole: 1 });
          this.memberModel.upsert(r2), this.service.emit("onTeamCreated", t2);
        }
        v2TeamMemberUpdateMultiSyncHandler(e2) {
          var t2 = e2.content.data;
          t2.teamType = 1;
          var r2 = this.memberModel.getById(t2.teamId, t2.teamType, t2.accountId);
          this.service.notification.updateTeamMemberRole(t2.teamId, t2.teamType, [t2.accountId], t2), t2.accountId === this.core.account && r2 && r2.bits !== t2.bits && this.core.eventBus.emit("V2NIMSettingService/updateBits", t2.teamId, t2.teamType, t2.bits);
        }
        v2SuperTeamMemberUpdateMultiSyncHandler(e2) {
          var t2 = e2.content.data;
          t2.teamType = 2;
          var r2 = this.memberModel.getById(t2.teamId, t2.teamType, t2.accountId);
          this.service.notification.updateTeamMemberRole(t2.teamId, t2.teamType, [t2.accountId], t2), t2.accountId === this.core.account && r2 && r2.bits !== t2.bits && this.core.eventBus.emit("V2NIMSettingService/updateBits", t2.teamId, t2.teamType, t2.bits);
        }
        v2TeamMembersOfSelfInSyncHandler(e2) {
          e2.content.datas.forEach((e3) => {
            e3.teamType = 1, this.memberModel.upsert(e3);
          });
        }
        v2SuperTeamMembersOfSelfInSyncHandler(e2) {
          e2.content.datas.forEach((e3) => {
            e3.teamType = 2, this.memberModel.upsert(e3);
          });
        }
      }
      var Ao = "V2NIMUserService", Oo = { "34_3": "v2UpdateBlockList", "34_7": "v2GetUserList", "34_10": "v2UpdateSelfUserProfile", "3_109": "v2SyncSelfUserInfo", "3_110": "onUpdateUserProfile", "3_103": "onUpdateBlockList", "3_8": "syncBlockAndMuteList", "34_5": "v2SetP2PMessageMuteMode", "3_105": "v2OnUpdateMuteList" }, ko = { accountId: 1, name: 3, avatar: 4, sign: 5, gender: { id: 6, retType: "number" }, email: 7, birthday: 8, mobile: 9, serverExtension: 10, createTime: { id: 12, retType: "number" }, updateTime: { id: 13, retType: "number" } }, wo = { v2UpdateBlockList: { sid: 34, cid: 3, service: Ao, params: [{ type: "String", name: "accountId" }, { type: "Bool", name: "addToBlockList" }] }, v2GetUserList: { sid: 34, cid: 7, service: Ao, params: [{ type: "StrArray", name: "accountIds" }], response: [{ type: "PropertyArray", name: "data", reflectMapper: invertSerializeItem(ko) }] }, v2UpdateSelfUserProfile: { sid: 34, cid: 10, service: Ao, params: [{ type: "Property", name: "tag", reflectMapper: ko }], response: [{ type: "Long", name: "updateTime" }] }, onUpdateUserProfile: { sid: 3, cid: 110, service: Ao, response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(ko) }] }, onUpdateBlockList: { sid: 3, cid: 103, service: Ao, response: [{ type: "String", name: "accountId" }, { type: "Bool", name: "addToBlockList" }] }, syncBlockAndMuteList: { sid: 3, cid: 8, service: Ao, response: [{ type: "PropertyArray", name: "data", reflectMapper: invertSerializeItem({ accountId: 0, isMute: { id: 1, retType: "boolean" }, isBlock: { id: 2, retType: "boolean" } }) }, { type: "Long", name: "timetag" }] }, v2SyncSelfUserInfo: { sid: 3, cid: 109, service: Ao, response: [{ type: "Property", name: "user", reflectMapper: invertSerializeItem(ko) }] }, v2SetP2PMessageMuteMode: { sid: 34, cid: 5, service: Ao, params: [{ type: "String", name: "accountId" }, { type: "Bool", name: "muteMode" }] }, v2OnUpdateMuteList: { sid: 3, cid: 105, service: Ao, response: [{ type: "String", name: "accountId" }, { type: "Bool", name: "mute" }] } };
      class V2NIMUserModelImpl {
        constructor() {
          this.muteList = /* @__PURE__ */ new Set(), this.userMap = /* @__PURE__ */ new Map(), this.blockList = [];
        }
        reset() {
          this.muteList.clear(), this.userMap.clear(), this.blockList = [];
        }
        setAccountMuteMode(e2, t2) {
          1 === t2 ? this.muteList.add(e2) : this.muteList.delete(e2);
        }
        setUser(e2) {
          this.userMap.set(e2.accountId, e2);
        }
        getUser(e2) {
          return this.userMap.get(e2);
        }
        getUserListBySearchOption(e2) {
          return Array.from(this.userMap.values()).filter((t2) => !(void 0 !== e2.searchName && !e2.searchName || !t2.name.includes(e2.keyword)) || (!(!e2.searchAccountId || !t2.accountId.includes(e2.keyword)) || !!(t2.mobile && e2.searchMobile && t2.mobile.includes(e2.keyword))));
        }
        addToBlockList(e2) {
          e2.forEach((e3) => {
            this.blockList.includes(e3) || this.blockList.push(e3);
          });
        }
        removeFromBlockList(e2) {
          e2.forEach((e3) => {
            var t2 = this.blockList.indexOf(e3);
            -1 !== t2 && this.blockList.splice(t2, 1);
          });
        }
        checkBlock(e2) {
          var t2 = {};
          return e2.forEach((e3) => {
            t2[e3] = this.blockList.includes(e3);
          }), t2;
        }
      }
      var Po = { type: "string", required: true, allowEmpty: false }, Vo = { type: "string", required: false, allowEmpty: true }, Lo = { name: { type: "string", required: false, allowEmpty: true }, avatar: Vo, sign: Vo, email: Vo, birthday: Vo, mobile: Vo, gender: { type: "number", required: false }, serverExtension: Vo };
      class V2NIMUserServiceImpl extends V2Service {
        constructor(e2) {
          super("V2NIMUserService", e2), registerParser({ cmdMap: Oo, cmdConfig: wo }), this.model = new V2NIMUserModelImpl(), "v2" === this.core.options.apiVersion && this.setListener();
        }
        reset() {
          this.model.reset();
        }
        setListener() {
          this.core.eventBus.on("forwardReceive/V2NIMUserService/updateBlockList", (e2, t2) => {
            t2 ? this.model.addToBlockList([e2]) : this.model.removeFromBlockList([e2]), t2 ? this.emitBlockListAdded(e2) : this.emit("onBlockListRemoved", e2);
          }), this.core.eventBus.on("forwardReceive/V2NIMUserService/updateUserProfile", (e2) => {
            this.updateUserProfileInMemory(e2);
          });
        }
        emit(e2, ...t2) {
          var r2 = `${this.name}::emit ${e2.toString()}`;
          if ("onUserProfileChanged" === e2) {
            var i2 = t2[0];
            this.logger.log(`${r2}`, i2.map((e3) => `id:${e3.accountId};name:${e3.name};updateTime:${e3.updateTime}`));
          } else if ("onBlockListAdded" === e2) {
            var s2 = t2[0];
            this.logger.log(`${r2}`, `id:${s2.accountId};name:${s2.name};updateTime:${s2.updateTime}`);
          } else
            this.logger.log(`${r2}`, ...t2);
          return super.emit(e2, ...t2);
        }
        getUserList(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.checkV2(), this._getUserList(e2);
          });
        }
        _getUserList(e2) {
          var t2;
          return __awaiter(this, void 0, void 0, function* () {
            validate({ accountIds: ao }, { accountIds: e2 }, "", true);
            var r2 = [];
            e2.forEach((e3) => {
              this.model.getUser(e3) || r2.push(e3);
            });
            var i2 = null;
            r2.length > 0 && (i2 = yield this.core.sendCmd("v2GetUserList", { accountIds: r2 })), ((null === (t2 = null == i2 ? void 0 : i2.content) || void 0 === t2 ? void 0 : t2.data) || []).forEach((e3) => {
              this.model.setUser(e3);
            });
            var s2 = [];
            return e2.forEach((e3) => {
              var t3 = this.model.getUser(e3);
              t3 && s2.push(t3);
            }), s2;
          });
        }
        getUserListFromCloud(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validate({ accountIds: { type: "array", min: 1, max: 500, itemType: "string" } }, { accountIds: e2 }, "", true);
            var t2 = (yield this.core.sendCmd("v2GetUserList", { accountIds: e2 })).content.data || [], r2 = [];
            t2.forEach((e3) => {
              var t3 = this.model.getUser(e3.accountId);
              this.compareUserForUpdate(t3, e3) && r2.push(e3), this.model.setUser(e3);
            });
            var i2 = e2.reduce((e3, t3) => {
              var r3 = this.model.getUser(t3);
              return r3 && e3.push(r3), e3;
            }, []);
            return r2.length > 0 && this.emit("onUserProfileChanged", r2), i2;
          });
        }
        compareUserForUpdate(e2, t2) {
          return !e2 || !("number" == typeof e2.updateTime && "number" == typeof t2.updateTime && e2.updateTime >= t2.updateTime);
        }
        updateSelfUserProfile(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validate(Lo, e2, "", true);
            var t2 = yield this.core.sendCmd("v2UpdateSelfUserProfile", { tag: Object.assign(Object.assign({}, e2), { accountId: this.core.account }) });
            yield this.updateUserProfileInMemory(Object.assign(Object.assign({}, e2), { updateTime: t2.content.updateTime }));
          });
        }
        addUserToBlockList(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            if (this.checkV2(), e2 === this.core.account)
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "Cannot block yourself" } });
            validate({ accountId: Po }, { accountId: e2 }, "", true), yield this.core.sendCmd("v2UpdateBlockList", { accountId: e2, addToBlockList: true }), this.model.addToBlockList([e2]), this.emitBlockListAdded(e2);
          });
        }
        removeUserFromBlockList(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            if (this.checkV2(), e2 === this.core.account)
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "Cannot unblock yourself" } });
            validate({ accountId: Po }, { accountId: e2 }, "", true), yield this.core.sendCmd("v2UpdateBlockList", { accountId: e2, addToBlockList: false }), this.model.removeFromBlockList([e2]), this.emit("onBlockListRemoved", e2);
          });
        }
        searchUserByOption(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            if (this.checkV2(), this.core.V2NIMLoginService.checkIllegalState(), validate({ keyword: { type: "string", allowEmpty: false }, searchName: { type: "boolean", required: false }, searchAccountId: { type: "boolean", required: false }, searchMobile: { type: "boolean", required: false } }, e2, "", true), false === (void 0 === e2.searchName || e2.searchName) && !e2.searchAccountId && !e2.searchMobile)
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "one of searchName, searchAccountId, searchMobile must be true" } });
            return this.model.getUserListBySearchOption(e2);
          });
        }
        getBlockList() {
          return this.checkV2(), Promise.resolve(this.model.blockList);
        }
        checkBlock(e2) {
          return this.checkV2(), validate({ accountIds: ao }, { accountIds: e2 }, "", true), Promise.resolve(this.model.checkBlock(e2));
        }
        updateUserProfileInMemory(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            var t2 = this.model.getUser(this.core.account);
            t2 ? (Object.assign(t2, e2), this.model.setUser(t2)) : t2 = (yield this._getUserList([this.core.account]))[0];
            t2 && this.emit("onUserProfileChanged", [t2]);
          });
        }
        onUpdateUserProfileHandler(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            var t2 = e2.content.data;
            yield this.updateUserProfileInMemory(t2);
          });
        }
        onUpdateBlockListHandler(e2) {
          var t2 = e2.content.accountId;
          e2.content.addToBlockList ? (this.model.addToBlockList([t2]), this.emitBlockListAdded(t2)) : (this.model.removeFromBlockList([t2]), this.emit("onBlockListRemoved", t2));
        }
        syncBlockAndMuteListHandler(e2) {
          e2.content.data.forEach((e3) => {
            e3.isBlock ? this.model.addToBlockList([e3.accountId]) : this.model.setAccountMuteMode(e3.accountId, e3.isMute ? 1 : 0);
          });
        }
        v2SyncSelfUserInfoHandler(e2) {
          var t2 = e2.content.user;
          this.model.setUser(t2);
        }
        checkUserUpdate(e2, t2) {
          var r2 = e2.senderId;
          r2 !== this.core.account && this.refreshUserInfo(r2, t2);
        }
        refreshUserInfo(e2, t2 = 0) {
          return __awaiter(this, void 0, void 0, function* () {
            if (e2 && "string" == typeof e2) {
              var r2 = this.model.getUser(e2), i2 = [];
              if (!r2 || r2 && "number" == typeof r2.updateTime && "number" == typeof t2 && !isNaN(r2.updateTime) && !isNaN(t2) && r2.updateTime < t2)
                try {
                  i2 = (yield this.core.sendCmd("v2GetUserList", { accountIds: [e2] })).content.data;
                } catch (t3) {
                  return void this.logger.warn(`V2NIMUserService:refreshUserInfo: failed for ${e2}`);
                }
              for (var s2 of i2)
                this.model.setUser(s2), this.emit("onUserProfileChanged", [s2]);
            }
          });
        }
        emitBlockListAdded(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            var t2 = yield this._getUserList([e2]);
            1 === t2.length && this.emit("onBlockListAdded", t2[0]);
          });
        }
        v2OnUpdateMuteListHandler(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            var { accountId: t2, mute: r2 } = e2.content, i2 = r2 ? 1 : 0;
            this.core.eventBus.emit("v2NIMUserService/updateMuteList", t2, i2);
          });
        }
      }
      var Uo = "V2NIMFriendService", Do = { "35_1": "v2AddFriend", "35_2": "v2DeleteFriend", "35_3": "v2SetFriendInfo", "35_4": "v2IncFriendInfo", "12_101": "v2OnAddFriend", "12_102": "v2OnDeleteFriend", "12_103": "v2OnUpdateFriendInfo", "12_5": "v2SyncFriendList", "12_6": "v2SyncFriendUserList" }, qo = { accountId: 4, relationShip: { id: 5, retType: "number" }, source: { id: 7, retType: "number" }, alias: 8, serverExtension: 10, createTime: { id: 11, retType: "number" }, updateTime: { id: 12, retType: "number" }, customerExtension: 13 }, xo = { v2AddFriend: { sid: 35, cid: 1, service: Uo, params: [{ type: "String", name: "accountId" }, { type: "Byte", name: "verifyType" }, { type: "String", name: "postscript" }], response: [] }, v2DeleteFriend: { sid: 35, cid: 2, service: Uo, params: [{ type: "String", name: "accountId" }, { type: "Property", name: "params", reflectMapper: { deleteAlias: { id: 1, converter: boolToInt } } }] }, v2SetFriendInfo: { sid: 35, cid: 3, service: Uo, params: [{ type: "Property", name: "tag", reflectMapper: qo }] }, v2OnAddFriend: { sid: 12, cid: 101, service: Uo, response: [{ type: "String", name: "accountId" }, { type: "Byte", name: "verifyType" }, { type: "String", name: "postscript" }, { type: "Property", name: "ext", reflectMapper: invertSerializeItem({ serverExt: 1 }) }] }, v2OnDeleteFriend: { sid: 12, cid: 102, service: Uo, response: [{ type: "String", name: "accountId" }] }, v2OnUpdateFriendInfo: { sid: 12, cid: 103, service: Uo, response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(qo) }] }, v2SyncFriendList: { sid: 12, cid: 5, service: Uo, response: [{ type: "PropertyArray", name: "friends", reflectMapper: invertSerializeItem(qo) }, { type: "Long", name: "timetag" }] }, v2SyncFriendUserList: { sid: 12, cid: 6, service: Uo, response: [{ type: "PropertyArray", name: "users", reflectMapper: invertSerializeItem(ko) }] }, v2IncFriendInfo: { sid: 35, cid: 4, service: Uo, params: [{ type: "Long", name: "timetag" }], response: [{ type: "PropertyArray", name: "friends", reflectMapper: invertSerializeItem(qo) }, { type: "Long", name: "timetag" }] } }, Bo = { accountId: { type: "string", required: true, allowEmpty: false }, params: { type: "object", required: true, rules: { addMode: { type: "enum", required: true, values: [1, 2] }, postscript: { type: "string", required: false, allowEmpty: true } } } }, Fo = { accountId: { type: "string", required: true, allowEmpty: false }, params: { type: "object", required: false, rules: { deleteAlias: { type: "boolean", required: false } } } }, jo = { accountId: { type: "string", required: true, allowEmpty: false }, params: { type: "object", required: false, rules: { alias: { type: "string", required: false, allowEmpty: true }, serverExtension: { type: "string", required: false, allowEmpty: true } } } }, $o = { applicantAccountId: { type: "string", allowEmpty: false }, recipientAccountId: { type: "string", allowEmpty: false }, operatorAccountId: { type: "string", required: false, allowEmpty: false }, postscript: { type: "string", required: false, allowEmpty: true }, status: { type: "enum", values: [1, 4, 3, 0, 2] }, timestamp: { type: "number", min: 1 } };
      function checkApplication(e2, t2) {
        if (validate($o, e2, "", true), e2 && e2.applicantAccountId !== t2 && e2.recipientAccountId !== t2)
          throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "Friend application is not your own" } });
      }
      var Go = { offset: { type: "number", required: false }, limit: { type: "number", required: false }, status: { type: "array", itemType: "enum", required: false, values: [1, 4, 3, 0, 2] } };
      class V2NIMFriendNotificationImpl {
        constructor(e2, t2) {
          this.core = e2, this.service = t2;
        }
        processSysNotification(e2) {
          if (6 === e2.type) {
            var t2 = e2.senderId;
            this.core.V2NIMFriendService.handleDeleteFriend(t2, 2);
          } else if (5 === e2.type)
            try {
              var r2 = JSON.parse(e2.content);
              if (1 === (null == r2 ? void 0 : r2.vt)) {
                this.core.V2NIMFriendService.handleAddFriend(e2.senderId, e2.timestamp);
                var i2 = { applicantAccountId: e2.senderId, recipientAccountId: e2.receiverId, operatorAccountId: e2.senderId, postscript: e2.postscript, timestamp: e2.timestamp, status: 4, read: false };
                this.service.notificationModel.appendFriendAddApplication(i2), this.service.notificationModel.updateFriendAddApplicationStatus(i2.applicantAccountId, 4, i2.applicantAccountId);
              } else if (2 === (null == r2 ? void 0 : r2.vt)) {
                var s2 = { applicantAccountId: e2.senderId, recipientAccountId: e2.receiverId, operatorAccountId: e2.senderId, postscript: e2.postscript, timestamp: e2.timestamp, status: 0, read: false };
                this.service.handleApplyFriend(s2), this.service.notificationModel.appendFriendAddApplication(s2);
              } else if (3 === (null == r2 ? void 0 : r2.vt)) {
                this.core.V2NIMFriendService.handleAddFriend(e2.senderId, e2.timestamp);
                var n2 = { applicantAccountId: e2.receiverId, recipientAccountId: e2.senderId, operatorAccountId: e2.senderId, timestamp: e2.timestamp, postscript: e2.postscript, status: 1, read: false };
                this.service.notificationModel.appendFriendAddApplication(n2);
              } else if (4 === (null == r2 ? void 0 : r2.vt)) {
                var a2 = { applicantAccountId: e2.receiverId, recipientAccountId: e2.senderId, operatorAccountId: e2.senderId, timestamp: e2.timestamp, postscript: e2.postscript, status: 2, read: false };
                this.service.notificationModel.appendFriendAddApplication(a2), this.service.emit("onFriendAddRejected", a2);
              }
            } catch (e3) {
              this.core.logger.warn("V2NIMFriendNotificationImpl::processSysNotification, parse content error:", e3);
            }
        }
      }
      class V2NIMFriendModelImpl {
        constructor() {
          this.validFriendIds = /* @__PURE__ */ new Set(), this.friendMap = /* @__PURE__ */ new Map(), this.friendTimetag = 0;
        }
        reset() {
          this.friendMap.clear(), this.validFriendIds.clear();
        }
        upsertFriend(e2, t2) {
          delete t2.relationShip;
          var r2 = this.friendMap.get(e2) || {}, i2 = Object.assign({ accountId: e2 }, r2, t2);
          return this.friendMap.set(e2, i2), this.validFriendIds.add(e2), i2;
        }
        addFriend(e2) {
          this.validFriendIds.add(e2);
        }
        deleteFriend(e2) {
          this.validFriendIds.delete(e2);
        }
        getFriend(e2) {
          return this.validFriendIds.has(e2) ? this.friendMap.get(e2) : void 0;
        }
        getFriendList() {
          return Array.from(this.validFriendIds.values()).map((e2) => this.getFriend(e2)).filter((e2) => !!e2);
        }
        getFriendListBySearchOption(e2) {
          return Array.from(this.validFriendIds.values()).map((e3) => this.getFriend(e3)).filter((t2) => {
            var r2 = void 0 === e2.searchAlias || e2.searchAlias;
            return void 0 !== t2 && (!!(r2 && t2.alias && t2.alias.includes(e2.keyword)) || !(!e2.searchAccountId || !t2.accountId.includes(e2.keyword)));
          });
        }
        getFriendByIds(e2) {
          return e2.map((e3) => this.getFriend(e3)).filter((e3) => !!e3);
        }
        setFriendTimetag(e2) {
          this.friendTimetag = e2;
        }
        getFriendTimetag() {
          return this.friendTimetag;
        }
      }
      class V2NIMFriendNotificationModelImpl {
        constructor() {
          this.list = [], this.maxCount = 1e3;
        }
        reset() {
          this.list = [];
        }
        updateFriendAddApplicationStatus(e2, t2, r2) {
          if (0 !== t2)
            for (var i2 of this.list)
              i2.applicantAccountId === e2 && 0 === i2.status && (i2.status = t2, i2.operatorAccountId = r2);
        }
        getAddApplicationList(e2) {
          var t2 = void 0 === e2.offset ? 0 : e2.offset, r2 = this.list.filter((t3) => {
            var r3 = e2.status || [];
            return 0 === r3.length || !!r3.includes(t3.status);
          }).reverse(), i2 = e2.limit || 50, s2 = r2.slice(t2, t2 + i2), n2 = t2 + i2 >= r2.length;
          return { infos: s2, finished: n2, offset: n2 ? 0 : t2 + i2 };
        }
        checkSameApplication(e2, t2, r2 = false) {
          return e2.applicantAccountId === t2.applicantAccountId && e2.recipientAccountId === t2.recipientAccountId && (!r2 || e2.timestamp === t2.timestamp);
        }
        setAllApplicationRead() {
          for (var e2 of this.list)
            e2.read = true;
        }
        setApplicationRead(e2) {
          for (var t2 of this.list)
            this.checkSameApplication(t2, e2) && (t2.read = true);
        }
        getAddApplicationUnreadCount() {
          var e2 = /* @__PURE__ */ new Set();
          for (var t2 of this.list)
            t2.read || 0 !== t2.status || e2.add(t2.applicantAccountId);
          return e2.size;
        }
        appendFriendAddApplication(e2) {
          this.list.push(e2), this.list.length > this.maxCount && this.list.shift();
        }
        clearApplicationList() {
          this.list = [];
        }
        deleteApplication(e2) {
          this.list = this.list.map((t2) => {
            if (!this.checkSameApplication(t2, e2, false))
              return t2;
          }).filter((e3) => e3);
        }
      }
      var Ho = { muteMode: { type: "enum", values: [2, 0, 1] } }, zo = { accountId: { type: "string", required: true, allowEmpty: false }, muteMode: { type: "enum", required: true, values: [2, 0, 1] } }, Wo = { type: "object", required: false, rules: { certificateName: { type: "string", required: true, allowEmpty: false }, appId: { type: "string", required: false, allowEmpty: false }, appKey: { type: "string", required: false, allowEmpty: false }, secret: { type: "string", required: false, allowEmpty: false } } }, Ko = { config: { type: "object", required: true, rules: { apns: Wo, hwPush: Wo, miPush: Wo, vivoPush: Wo, oppoPush: Wo, honorPush: Wo, fcmPush: Wo, mzPush: Wo } } }, Yo = "V2NIMSettingService", Jo = { "34_1": "v2SetDeviceToken", "34_2": "v2SetAppBackground", "34_15": "v2SetPushMobileOnDesktopOnline", "3_115": "v2SettingMutilSyncDonnop", "4_13": "v2SettingSyncDonnop" }, Qo = { need: { id: 1, converter: (e2) => e2 ? 2 : 1, retConverter: (e2) => "2" === e2 } }, Xo = { v2SetDeviceToken: { sid: 34, cid: 1, service: Yo, params: [{ type: "String", name: "certificateName" }, { type: "String", name: "pushDeviceToken" }, { type: "Int", name: "pushkit" }] }, v2SetAppBackground: { sid: 34, cid: 2, service: Yo, params: [{ type: "Bool", name: "isBackground" }, { type: "Int", name: "badge" }] }, v2SetPushMobileOnDesktopOnline: { sid: 34, cid: 15, service: Yo, params: [{ type: "Property", name: "tag", reflectMapper: Qo }] }, v2SettingMutilSyncDonnop: { sid: 3, cid: 115, service: Yo, response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(Qo) }, { type: "Long", name: "timetag" }] }, v2SettingSyncDonnop: { sid: 4, cid: 13, service: Yo, response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(Qo) }, { type: "Long", name: "timetag" }] } };
      class V2NIMSettingHandlerImpl {
        constructor(e2, t2) {
          this.core = e2, this.service = t2;
        }
        v2SettingMutilSyncDonnopHandler(e2) {
          var { need: t2 } = e2.content.data;
          this.service.needToPushMobileOnDesktopOnline = t2, this.service.emit("onPushMobileOnDesktopOnline", t2);
        }
        v2SettingSyncDonnopHandler(e2) {
          var { need: t2 } = e2.content.data;
          this.service.needToPushMobileOnDesktopOnline = t2, this.service.emit("onPushMobileOnDesktopOnline", t2);
        }
      }
      class V2NIMSettingPushImpl {
        constructor(e2, t2) {
          this.offlinePushPlugin = void 0, this.offlinePushConfig = void 0, this.authConfig = void 0, this.aosPushInfo = void 0, this.appBackgroundOptions = { badge: 0, isBackground: false }, this.setTokenAndBackgroundStateAfterLogin = (e3) => {
            this.aosPushInfo = e3, this.logger.log("OfflinePushService: setToken, deviceClientId:", null == e3 ? void 0 : e3.clientId), this.offlinePushPlugin && (this.logger.log("OfflinePushService: setToken plugin is provided"), this.logger.log("OfflinePushService: setToken pushType is: ", e3 && e3.pushType), this.regToken(), this.core.sendCmd("v2SetAppBackground", { isBackground: this.appBackgroundOptions.isBackground, badge: this.appBackgroundOptions.badge || 0 }));
          }, this.core = e2, this.service = t2, this.logger = e2.logger;
        }
        getRNDeviceInfo() {
          var e2;
          return this.logger.log("OfflinePushService:getDeviceInfo start"), null === (e2 = this.offlinePushPlugin) || void 0 === e2 || e2.init(JSON.stringify(this.authConfig), (e3, t2, r2) => {
            if (this.logger.log(`OfflinePushService:: type: ${e3}, tokenName: ${t2}, token: ${r2}`), r2) {
              var i2 = "", s2 = ge.getSystemInfo() || {}, n2 = s2.os ? s2.os.toLowerCase() : "";
              this.aosPushInfo && this.aosPushInfo.pushType ? i2 = this.aosPushInfo.pushType : "ios" === n2 ? i2 = "" : "android" === n2 && (i2 = "8"), this.pushTokenToServer(i2, r2);
            } else
              this.logger.warn("OfflinePushService:: token is empty. Please check your parameters");
          }), new Promise((e3, t2) => {
            var r2;
            null === (r2 = this.offlinePushPlugin) || void 0 === r2 || r2.getDeviceInfo((r3) => {
              try {
                this.logger.log(`OfflinePushService:getDeviceInfo result ${r3 ? JSON.stringify(r3) : ""}`), e3(JSON.parse(r3));
              } catch (e4) {
                t2(new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INTERNAL, detail: { reason: "OfflinePushService:getDeviceInfo error" } }));
              }
            }), setTimeout(() => {
              t2(new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INTERNAL, detail: { reason: "OfflinePushService:getDeviceInfo timeout" } }));
            }, 2e3);
          });
        }
        pushTokenToServer(e2, t2) {
          var r2, i2, s2, n2, a2, o2, c2, d2, l2 = "", m2 = this.offlinePushConfig;
          switch (e2) {
            case "5":
              l2 = null === (r2 = null == m2 ? void 0 : m2.miPush) || void 0 === r2 ? void 0 : r2.certificateName;
              break;
            case "6":
              l2 = null === (i2 = null == m2 ? void 0 : m2.hwPush) || void 0 === i2 ? void 0 : i2.certificateName;
              break;
            case "7":
              l2 = null === (s2 = null == m2 ? void 0 : m2.mzPush) || void 0 === s2 ? void 0 : s2.certificateName;
              break;
            case "8":
              l2 = null === (n2 = null == m2 ? void 0 : m2.fcmPush) || void 0 === n2 ? void 0 : n2.certificateName;
              break;
            case "9":
              l2 = null === (a2 = null == m2 ? void 0 : m2.vivoPush) || void 0 === a2 ? void 0 : a2.certificateName;
              break;
            case "10":
              l2 = null === (o2 = null == m2 ? void 0 : m2.oppoPush) || void 0 === o2 ? void 0 : o2.certificateName;
              break;
            case "11":
              l2 = null === (c2 = null == m2 ? void 0 : m2.honorPush) || void 0 === c2 ? void 0 : c2.certificateName;
              break;
            default:
              l2 = null === (d2 = null == m2 ? void 0 : m2.apns) || void 0 === d2 ? void 0 : d2.certificateName;
          }
          if ("" === l2 || void 0 === l2)
            this.logger.warn("OfflinePushService:: certificate name is empty for push type: ", e2);
          else
            try {
              if ("UNIAPP" === ge.platform) {
                var p2 = Si.parse("557d1e3cafa43e2589a588270c53d56f"), u2 = Si.stringify(Ui.decrypt(t2, p2));
                this.logger.log("OfflinePushService:: token", u2), this.core.sendCmd("v2SetDeviceToken", { certificateName: l2, pushDeviceToken: u2, pushkit: 0 });
              } else
                this.core.sendCmd("v2SetDeviceToken", { certificateName: l2, pushDeviceToken: t2, pushkit: 0 });
            } catch (e3) {
              return this.logger.log("OfflinePushService:: decrypt error", e3), void this.logger.warn("OfflinePushService:: token before decrypt", t2);
            }
        }
        regToken() {
          var e2 = ge.getSystemInfo() || {}, t2 = e2.os ? e2.os.toLowerCase() : "";
          if (this.logger.log("OfflinePushService: os", t2), "ios" === t2 || "android" === t2)
            if (!this.offlinePushPlugin || "UNIAPP" === ge.platform && "function" != typeof this.offlinePushPlugin.getDeviceToken || "React Native" === ge.platform && "android" === t2 && "function" != typeof this.offlinePushPlugin.init || "React Native" === ge.platform && "ios" === t2 && "function" != typeof this.offlinePushPlugin.checkPermissions)
              this.logger.warn("OfflinePushService: plugin is not correct, please check your plugin according to Yunxin Official Documentation");
            else {
              "React Native" === ge.platform && ge.envPayload.AppState && ge.envPayload.AppState.addEventListener("change", this.handleRNAppStateChange.bind(this));
              var r2 = "";
              this.aosPushInfo && this.aosPushInfo.pushType ? r2 = this.aosPushInfo.pushType : "ios" === t2 ? r2 = "" : "android" === t2 && (r2 = "8"), this.logger.log("OfflinePushService:: prepare to get device token. suggestPushType: " + r2), this.logger.log("OfflinePushService push config", JSON.stringify(this.authConfig, null, 2), "platform", ge.platform), "UNIAPP" === ge.platform ? this.offlinePushPlugin.getDeviceToken({ suggestPushType: r2, config: this.authConfig }, (e3) => {
                e3 ? (this.logger.log("OfflinePushService:: token is :" + e3), this.pushTokenToServer(r2, e3)) : this.logger.warn("OfflinePushService:: token is empty. Please check your parameters");
              }) : "React Native" === ge.platform && "android" === t2 ? (this.logger.log("OfflinePushService:: onLogin", this.core.account, typeof r2, r2), this.offlinePushPlugin.onLogin(this.core.account, parseInt(r2), false, "")) : "React Native" === ge.platform && "ios" === t2 ? this.offlinePushPlugin.checkPermissions(() => {
                this.logger.log("OfflinePushService addEventListener requestPermissions");
                try {
                  this.offlinePushPlugin.requestPermissions();
                } catch (e3) {
                  this.logger.log("OfflinePushService:: requestPermissions error", e3);
                }
                this.offlinePushPlugin.addEventListener("register", (e3) => {
                  this.logger.log(`OfflinePushService:: ios token: ${e3}`), this.pushTokenToServer(r2, e3);
                }), this.offlinePushPlugin.addEventListener("registrationError", (e3) => {
                  this.logger.log("OfflinePushService:: ios registerError", e3);
                });
              }) : this.logger.error(`OfflinePushService:: platform is not supported. Please check your parameters. Platform: ${ge.platform}. os: ${t2}`);
            }
          else
            this.logger.warn("OfflinePushService: only Android or IOS support offline push");
        }
        handleRNAppStateChange(e2) {
          this.logger.log(`push::handleAppStateChange: pushConfig ios/aos; state: ${e2}`), this.appBackgroundOptions = { badge: this.core.V2NIMConversationService.getTotalUnreadCount(), isBackground: "background" === e2 || "inactive" === e2 }, this.setAppBackground(this.appBackgroundOptions.isBackground, this.appBackgroundOptions.badge);
        }
        setOfflinePushConfig(e2, t2) {
          var r2, i2, s2, n2, a2, o2, c2, d2, l2, m2, p2, u2, h2, g2, v2, y2, f2, I2, M2, S2, T2, _2, C2, E2, b2, R2, N2, A2, O2, k2, w2, P2, V2, L2, U2, D2;
          this.logger.log("setOfflinePushConfig", "plugin", e2, "config", t2), this.offlinePushPlugin = e2, this.offlinePushConfig = t2, this.authConfig = { xmAppId: null === (i2 = null === (r2 = this.offlinePushConfig) || void 0 === r2 ? void 0 : r2.miPush) || void 0 === i2 ? void 0 : i2.appId, xmAppKey: null === (n2 = null === (s2 = this.offlinePushConfig) || void 0 === s2 ? void 0 : s2.miPush) || void 0 === n2 ? void 0 : n2.appKey, xmCertificateName: null === (o2 = null === (a2 = this.offlinePushConfig) || void 0 === a2 ? void 0 : a2.miPush) || void 0 === o2 ? void 0 : o2.certificateName, hwAppId: null === (d2 = null === (c2 = this.offlinePushConfig) || void 0 === c2 ? void 0 : c2.hwPush) || void 0 === d2 ? void 0 : d2.appId, hwCertificateName: null === (m2 = null === (l2 = this.offlinePushConfig) || void 0 === l2 ? void 0 : l2.hwPush) || void 0 === m2 ? void 0 : m2.certificateName, oppoAppId: null === (u2 = null === (p2 = this.offlinePushConfig) || void 0 === p2 ? void 0 : p2.oppoPush) || void 0 === u2 ? void 0 : u2.appId, oppoAppKey: null === (g2 = null === (h2 = this.offlinePushConfig) || void 0 === h2 ? void 0 : h2.oppoPush) || void 0 === g2 ? void 0 : g2.appKey, oppoAppSecret: null === (y2 = null === (v2 = this.offlinePushConfig) || void 0 === v2 ? void 0 : v2.oppoPush) || void 0 === y2 ? void 0 : y2.secret, oppoCertificateName: null === (I2 = null === (f2 = this.offlinePushConfig) || void 0 === f2 ? void 0 : f2.oppoPush) || void 0 === I2 ? void 0 : I2.certificateName, vivoAppId: null === (S2 = null === (M2 = this.offlinePushConfig) || void 0 === M2 ? void 0 : M2.vivoPush) || void 0 === S2 ? void 0 : S2.appId, vivoAppKey: null === (_2 = null === (T2 = this.offlinePushConfig) || void 0 === T2 ? void 0 : T2.vivoPush) || void 0 === _2 ? void 0 : _2.appKey, vivoCertificateName: null === (E2 = null === (C2 = this.offlinePushConfig) || void 0 === C2 ? void 0 : C2.vivoPush) || void 0 === E2 ? void 0 : E2.certificateName, fcmCertificateName: null === (R2 = null === (b2 = this.offlinePushConfig) || void 0 === b2 ? void 0 : b2.fcmPush) || void 0 === R2 ? void 0 : R2.certificateName, mzAppId: null === (A2 = null === (N2 = this.offlinePushConfig) || void 0 === N2 ? void 0 : N2.mzPush) || void 0 === A2 ? void 0 : A2.appId, mzAppKey: null === (k2 = null === (O2 = this.offlinePushConfig) || void 0 === O2 ? void 0 : O2.mzPush) || void 0 === k2 ? void 0 : k2.appKey, mzCertificateName: null === (P2 = null === (w2 = this.offlinePushConfig) || void 0 === w2 ? void 0 : w2.mzPush) || void 0 === P2 ? void 0 : P2.certificateName, apnsCertificateName: null === (L2 = null === (V2 = this.offlinePushConfig) || void 0 === V2 ? void 0 : V2.apns) || void 0 === L2 ? void 0 : L2.certificateName, honorCertificateName: null === (D2 = null === (U2 = this.offlinePushConfig) || void 0 === U2 ? void 0 : U2.honorPush) || void 0 === D2 ? void 0 : D2.certificateName };
        }
        setAppBackground(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.appBackgroundOptions = { isBackground: e2, badge: t2 || 0 }, yield this.core.sendCmd("v2SetAppBackground", { isBackground: e2, badge: t2 || 0 });
          });
        }
      }
      class V2NIMSettingMuteImpl {
        constructor(e2, t2) {
          this.p2pMessageMuteModeChangeHandler = (e3, t3) => {
            this.service.emit("onP2PMessageMuteModeChanged", e3, t3), this.hasUserService && this.core.V2NIMUserService.model.setAccountMuteMode(e3, t3);
            var r2 = this.core.V2NIMConversationIdUtil.p2pConversationId(e3), i2 = 1 === t3;
            this.core.eventBus.emit("V2NIMSettingService/setMute", r2, i2);
          }, this.core = e2, this.service = t2;
        }
        get hasUserService() {
          var e2;
          return !!(null === (e2 = this.core.V2NIMUserService) || void 0 === e2 ? void 0 : e2.name);
        }
        get hasTeamService() {
          var e2;
          return !!(null === (e2 = this.core.V2NIMTeamService) || void 0 === e2 ? void 0 : e2.name);
        }
        getConversationMuteStatus(e2) {
          if ("string" != typeof e2)
            return false;
          var t2 = this.core.V2NIMConversationIdUtil.parseConversationType(e2), r2 = this.core.V2NIMConversationIdUtil.parseConversationTargetId(e2);
          return 3 === t2 ? 0 !== this.getTeamMessageMuteMode(r2, 2) : 2 === t2 ? 0 !== this.getTeamMessageMuteMode(r2, 1) : !(1 !== t2 || !this.hasUserService) && !!this.core.V2NIMUserService.model.muteList.has(r2);
        }
        setTeamMessageMuteMode(e2, t2, r2) {
          return __awaiter(this, void 0, void 0, function* () {
            var i2 = 2 === t2 ? "v2SuperTeamUpdateSelfMemberInfo" : "v2TeamUpdateSelfMemberInfo", s2 = { teamId: e2, teamType: t2, accountId: this.core.account, bits: r2 };
            yield this.core.sendCmd(i2, { teamMember: s2 }), this.core.V2NIMTeamService.memberModel.upsert(s2), this.service.emit("onTeamMessageMuteModeChanged", e2, t2, r2);
            var n2 = 1 === t2 ? this.core.V2NIMConversationIdUtil.teamConversationId(e2) : this.core.V2NIMConversationIdUtil.superTeamConversationId(e2), a2 = this.getConversationMuteStatus(n2);
            this.core.eventBus.emit("V2NIMSettingService/setMute", n2, a2);
          });
        }
        getTeamMessageMuteMode(e2, t2) {
          var r2;
          return "string" != typeof e2 || "number" != typeof t2 ? 0 : this.hasTeamService ? 3 & ((null === (r2 = this.core.V2NIMTeamService.memberModel.getById(e2, t2, this.core.account)) || void 0 === r2 ? void 0 : r2.bits) || 0) : 0;
        }
        getAllTeamMessageMuteMode(e2) {
          if (!this.hasTeamService)
            return Promise.resolve({});
          var t2 = this.core.V2NIMTeamService.memberModel.chooseList(e2), r2 = {};
          return t2.forEach((e3) => {
            if (e3.accountId === this.core.account) {
              var t3 = e3.bits || 0;
              r2[e3.teamId] = 3 & t3;
            }
          }), Promise.resolve(r2);
        }
        setP2PMessageMuteMode(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            yield this.core.sendCmd("v2SetP2PMessageMuteMode", { accountId: e2, muteMode: 1 === t2 }), this.p2pMessageMuteModeChangeHandler(e2, t2);
          });
        }
        getP2PMessageMuteMode(e2) {
          return this.hasUserService && this.core.V2NIMUserService.model.muteList.has(e2) ? 1 : 0;
        }
        getP2PMessageMuteList() {
          return this.hasUserService ? Promise.resolve(Array.from(this.core.V2NIMUserService.model.muteList)) : Promise.resolve([]);
        }
      }
      class V2NIMSettingEventImpl {
        constructor(e2, t2) {
          this.core = e2, this.service = t2, this.push = t2.push, this.mute = t2.mute;
        }
        setListener() {
          this.core.eventBus.on("V2NIMSettingService/updateBits", (e2, t2, r2) => {
            this.service.emit("onTeamMessageMuteModeChanged", e2, t2, r2);
          }), this.core.eventBus.on("V2NIMLoginService/loginLifeCycleLoginSucc", this.push.setTokenAndBackgroundStateAfterLogin.bind(this.push)), this.core.eventBus.on("v2NIMUserService/updateMuteList", this.mute.p2pMessageMuteModeChangeHandler.bind(this.mute)), this.core.eventBus.on("forwardReceive/v2NIMSettingService/setP2PMessageMuteMode", this.mute.p2pMessageMuteModeChangeHandler.bind(this.mute));
        }
      }
      var Zo = { "27_1": "v2NIMSync", "27_10": "v2QChatSync" }, ec = { v2NIMSync: { sid: 27, cid: 1, service: "V2NIMSyncService", hasPacketTimer: false, params: [{ type: "Property", name: "tag", reflectMapper: { myInfo: 1, offlineMsgs: 2, teams: 3, roamingMsgs: 7, relations: 9, friends: 11, friendUsers: 13, msgReceipts: 14, myTeamMembers: 15, donnop: 16, recallMsg: 17, sessionAck: 18, broadcastMsgs: 20, avSignal: 21, superTeams: 22, mySuperTeamMembers: 23, superTeamRoamingMsgs: 24, deleteSuperTeamMsg: 25, superTeamSessionAck: 26, deleteSelfMsgs: 27, stickTopSessions: 28, sessionHistoryMsgsDelete: 29, p2pTeamModifyMessage: 30, superTeamModifyMessage: 31, filterMsgs: 100 } }], response: [{ type: "Long", name: "timetag" }] }, v2QChatSync: { sid: 27, cid: 10, service: "V2NIMSyncService", hasPacketTimer: false, params: [{ type: "Property", name: "tag", reflectMapper: { systemNotification: 1, pushConfig: 2 } }], response: [{ type: "Long", name: "timetag" }] } };
      class V2NIMAIModelImpl {
        constructor() {
          this.aiStreamMap = /* @__PURE__ */ new Map();
        }
        reset() {
          this.aiStreamMap.clear();
        }
        getAiStream(e2) {
          return this.aiStreamMap.get(e2);
        }
        getAiStreamIsComplete(e2) {
          var t2 = this.aiStreamMap.get(e2);
          return !t2 || t2.isComplete;
        }
        getAiStreamQueryStatus(e2) {
          var t2 = this.aiStreamMap.get(e2);
          return t2 ? t2.queryStatus : 0;
        }
        upsertAiStreamChunks(e2, t2, r2) {
          var i2 = this.aiStreamMap.get(e2);
          return i2 && !i2.isComplete && (i2.chunks[t2] = r2), i2 || { isComplete: false, queryStatus: 0, chunks: [] };
        }
        setAiStream(e2, t2, r2 = false) {
          var i2 = this.aiStreamMap.get(e2);
          return i2 ? this.aiStreamMap.set(e2, Object.assign(Object.assign({}, i2), t2)) : r2 && this.aiStreamMap.set(e2, Object.assign({ isComplete: false, queryStatus: 0, chunks: [] }, t2)), this.aiStreamMap.get(e2) || { isComplete: false, queryStatus: 0, chunks: [] };
        }
        completeAiStream(e2) {
          var t2 = this.aiStreamMap.get(e2);
          t2 && this.aiStreamMap.set(e2, Object.assign(Object.assign({}, t2), { isComplete: true, queryStatus: 0, chunks: [], aiRAGs: void 0 }));
        }
      }
      var tc = "V2NIMAIService", rc = { "4_26": "v2AIChatNotify", "29_35": "v2AIProxyModelCall", "29_36": "v2AIGetUserList", "4_29": "v2AIOnStreamMessageChunk", "4_30": "v2AIChatStreamNotify", "29_38": "v2AIStopModelStreamCall", "29_39": "v2AIStreamQuery", "29_40": "v2AIRegenMessage" }, ic = { accountId: 1, messages: { id: 2, converter: objectToJSONString, retConverter: stringToJSONObject }, requestId: 3, content: { id: 4, converter: objectToJSONString, retConverter: stringToJSONObject }, promptVariables: 5, modelConfigParams: { id: 6, converter: objectToJSONString, retConverter: stringToJSONObject }, antispamBusinessId: 7, antispamEnabled: { id: 8, converter: boolToInt }, aiStream: { id: 9, converter: boolToInt } }, sc = { accountId: 1, name: 3, avatar: 4, sign: 5, gender: { id: 6, retType: "number" }, email: 7, birthday: 8, mobile: 9, serverExtension: 10, modelType: { id: 11, retType: "number" }, modelConfig: { id: 12, retConverter: (e2) => {
        if (e2 = stringToJSONObject(e2)) {
          var t2 = Object.keys(e2).reduce((t3, r2) => (t3[function camelCase(e3) {
            return (e3 = e3 || "").split("_").map((e4, t4) => 0 === t4 ? e4 : e4[0].toUpperCase() + e4.slice(1)).join("");
          }(r2)] = e2[r2], t3), {});
          if ("string" == typeof t2.promptKeys)
            try {
              t2.promptKeys = JSON.parse(t2.promptKeys);
            } catch (e3) {
            }
          return t2;
        }
      } }, yunxinConfig: { id: 13, retConverter: (e2) => {
        if (e2 = stringToJSONObject(e2))
          return e2;
      } }, valid: { id: 14, retType: "boolean" }, createTime: { id: 15, retType: "number" }, updateTime: { id: 16, retType: "number" } };
      function aiAgentStreamContentRetConverter(e2) {
        try {
          var t2 = JSON.parse(e2);
          return "number" == typeof t2.index ? { msg: t2.msg || "", type: t2.type, lastChunk: { content: t2.msg, chunkTime: parseInt(t2.timestamp), type: t2.type, index: parseInt(t2.index) } } : t2;
        } catch (e3) {
          return;
        }
      }
      function aiAgentStreamAIRAGsRetConverter(e2) {
        try {
          var t2 = JSON.parse(e2);
          return t2 && t2.length > 0 ? t2.map((e3) => (e3.description = e3.desc, delete e3.desc, e3)) : [];
        } catch (e3) {
          return [];
        }
      }
      var nc = { code: { id: 1, retType: "number" }, accountId: 2, requestId: 3, content: { id: 4, retConverter: aiAgentStreamContentRetConverter }, aiRAGs: { id: 5, retConverter: aiAgentStreamAIRAGsRetConverter }, timestamp: { id: 6, retType: "number" }, aiStreamStatus: { id: 7, retType: "number" }, aiStream: { id: 8, retType: "boolean" } }, ac = { serverId: 1, clientId: 2, type: { id: 3, retType: "number" }, from: 4, to: 5, aiAccount: 6, startIndex: { id: 7, retType: "number" }, endIndex: { id: 8, retType: "number" }, excludeIndex: { id: 9, converter: objectToJSONString } }, oc = { serverId: 1, clientId: 2, type: { id: 3, retType: "number" }, content: { id: 4, retConverter: aiAgentStreamContentRetConverter }, aiRAGs: { id: 6, retConverter: aiAgentStreamAIRAGsRetConverter } }, cc = { v2AIChatNotify: { sid: 4, cid: 26, service: tc, response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(nc) }] }, v2AIProxyModelCall: { sid: 29, cid: 35, service: tc, params: [{ type: "Property", name: "tag", reflectMapper: ic }] }, v2AIGetUserList: { sid: 29, cid: 36, service: tc, params: [{ type: "Property", name: "tag", reflectMapper: { pageToken: 1, limit: 2 } }], response: [{ type: "PropertyArray", name: "datas", reflectMapper: invertSerializeItem(sc) }, { type: "Property", name: "queryTag", reflectMapper: invertSerializeItem({ hasMore: { id: 16, retType: "boolean" }, nextToken: 2 }) }] }, v2AIOnStreamMessageChunk: { sid: 4, cid: 29, service: tc, response: [{ type: "Property", name: "msg", reflectMapper: invertSerializeItem(ia) }] }, v2AIChatStreamNotify: { sid: 4, cid: 30, service: tc, response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(nc) }] }, v2AIStopModelStreamCall: { sid: 29, cid: 38, service: tc, params: [{ type: "Property", name: "tag", reflectMapper: { serverId: 1, clientId: 2, type: { id: 3, retType: "number" }, from: 4, to: 5, aiAccount: 6, opeType: { id: 7, retType: "number" }, updateContent: { id: 8 }, messageTime: { id: 11, retType: "number" } } }] }, v2AIStreamQuery: { sid: 29, cid: 39, service: tc, params: [{ type: "Property", name: "tag", reflectMapper: ac }], response: [{ type: "PropertyArray", name: "datas", reflectMapper: invertSerializeItem(oc) }] }, v2AIRegenMessage: { sid: 29, cid: 40, service: tc, params: [{ type: "Property", name: "tag", reflectMapper: { fromAccount: 1, to: 2, aiAccount: 3, serverId: 4, clientId: 5, time: { id: 6, retType: "number" }, type: { id: 7, retType: "number" }, opeType: { id: 8, retType: "number" }, replyMsgFromAccount: 9, replyMsgToAccount: 10, replyMsgTime: { id: 11, retType: "number" }, replyMsgIdServer: 12, replyMsgIdClient: 13 } }] } };
      class V2NIMAIEventImpl {
        constructor(e2, t2) {
          this.core = e2, this.service = t2, this.logger = this.core.logger;
        }
        setListener() {
        }
        beforeEmit(e2, ...t2) {
          var r2, i2, s2 = `${this.service.name}::emit ${e2.toString()}`;
          if ("onProxyAIModelCall" === e2) {
            var n2 = t2[0];
            this.logger.log(`${s2}`, `requestId:${n2.requestId};aiStreamStatus:${n2.aiStreamStatus}`);
          } else if ("onProxyAIModelStreamCall" === e2) {
            var a2 = t2[0];
            this.logger.log(`${s2}`, `requestId:${a2.requestId};chunkIndex:${null === (r2 = a2.content) || void 0 === r2 ? void 0 : r2.lastChunk.index};chunkTime:${null === (i2 = a2.content) || void 0 === i2 ? void 0 : i2.lastChunk.chunkTime}`);
          } else
            this.logger.log(`${s2}`, ...t2);
        }
      }
      class V2NIMAIHandlerImpl {
        constructor(e2, t2) {
          this.core = e2, this.service = t2, this.model = t2.model, this.logger = this.core.logger;
        }
        v2AIChatNotifyHandler(e2) {
          var t2 = e2.content.data;
          t2 && t2.requestId && (this.model.completeAiStream(t2.requestId), t2.aiStreamStatus = t2.aiStreamStatus || 0, t2.aiStream = t2.aiStream || false, t2.content && (t2.content.msg = t2.content.msg || ""), this.service.emit("onProxyAIModelCall", t2));
        }
        v2AIChatStreamNotifyHandler(e2) {
          var t2 = e2.content.data;
          if (t2 && t2.requestId && t2.content && t2.content.msg) {
            var r2 = this.model.getAiStream(t2.requestId);
            if (r2 || (r2 = this.model.setAiStream(t2.requestId, { isComplete: false, queryStatus: 0, chunks: [] }, true)), !r2.isComplete) {
              var { lastChunk: i2 } = t2.content;
              if (0 === i2.index && t2.aiRAGs && (r2 = this.model.setAiStream(t2.requestId, { aiRAGs: t2.aiRAGs })), this.logger.log(`V2AI::streamNotify requestId:${t2.requestId};index:${i2.index};cacheChunkLength:${r2.chunks.length};chunkTime:${i2.chunkTime}.`), 0 === r2.chunks.length && i2.index > 0)
                this.logger.log(`V2AI::streamNotify requestId:${t2.requestId};chunks missing 0,currentIdx:${i2.index},needQuery:${0 === r2.queryStatus}.`), 0 === r2.queryStatus && (r2 = this.model.setAiStream(t2.requestId, { queryStatus: 1 }), this.service._queryAiStream({ clientId: t2.requestId, type: 4, from: this.core.account, aiAccount: t2.accountId, startIndex: 0, endIndex: i2.index - 1 }));
              else if (i2.index > 0 && r2.chunks.length > 0 && void 0 === r2.chunks[i2.index - 1]) {
                var s2 = r2.chunks.reduce((e3, t3, r3) => (void 0 !== t3 && e3.push(r3), e3), []);
                this.logger.log(`V2AI::streamNotify requestId:${t2.requestId};out of order,currenIdx:${i2.index},cacheIdx:[${s2.join(",")}],needReport:${!r2.hasReported}.`), r2.hasReported || (r2 = this.model.setAiStream(t2.requestId, { hasReported: true }), this.reportOutOfOrder({ requestId: t2.requestId, cacheIds: s2, targetIndex: i2.index, target: "4-30" }));
              }
              (r2 = this.model.upsertAiStreamChunks(t2.requestId, i2.index, i2.content)).chunks[0] || 1 !== r2.queryStatus ? (t2.content.msg = r2.chunks.join(""), r2.aiRAGs && (t2.aiRAGs = r2.aiRAGs), this.service.emit("onProxyAIModelStreamCall", t2)) : this.logger.log(`V2AI::streamNotify requestId:${t2.requestId};chunks ignore index:${i2.index};queryStatus:${r2.queryStatus}.`);
            }
          }
        }
        v2AIOnStreamMessageChunkHandler(e2) {
          var t2, r2, i2, s2 = completeMessage(this.core, e2.content.msg);
          if (s2.streamConfig && s2.streamConfig.lastChunk) {
            var n2 = this.model.getAiStream(s2.messageClientId);
            if (!n2 || !n2.isComplete) {
              n2 || (n2 = this.model.setAiStream(s2.messageClientId, { isComplete: false, queryStatus: 0, chunks: [] }, true));
              var a2 = s2.streamConfig.lastChunk, o2 = s2.messageClientId;
              if (0 === a2.index && (null === (t2 = s2.aiConfig) || void 0 === t2 ? void 0 : t2.aiRAGs) && (n2 = this.model.setAiStream(o2, { aiRAGs: s2.aiConfig.aiRAGs })), this.logger.log(`V2AI::aiStream requestId:${o2};index:${a2.index};cacheChunkLength:${n2.chunks.length};chunkTime:${a2.chunkTime}.`), 0 === n2.chunks.length && a2.index > 0)
                this.logger.log(`V2AI::msg:aiStream requestId:${o2};chunks missing 0,currentIdx:${a2.index},needQuery:${0 === n2.queryStatus}.`), 0 === n2.queryStatus && (n2 = this.model.setAiStream(o2, { queryStatus: 1 }), this.service._queryAiStream({ serverId: s2.messageServerId, clientId: o2, type: (null === (r2 = s2.aiConfig) || void 0 === r2 ? void 0 : r2.accountId) ? s2.conversationType : 5, from: s2.senderId, to: s2.receiverId, aiAccount: null === (i2 = s2.aiConfig) || void 0 === i2 ? void 0 : i2.accountId, startIndex: 0, endIndex: a2.index - 1 }));
              else if (a2.index > 0 && n2.chunks.length > 0 && void 0 === n2.chunks[a2.index - 1]) {
                var c2 = n2.chunks.reduce((e3, t3, r3) => (void 0 !== t3 && e3.push(r3), e3), []);
                this.logger.log(`V2AI::msg:aiStream requestId:${o2};out of order,currenIdx:${a2.index};streamCache.chunks:${JSON.stringify(n2.chunks)},cacheIdx:[${c2.join(",")}],needReport:${!n2.hasReported}.`), n2.hasReported || (n2 = this.model.setAiStream(o2, { hasReported: true }), this.reportOutOfOrder({ requestId: o2, cacheIds: c2, targetIndex: a2.index, target: "4-29" }));
              }
              (n2 = this.model.upsertAiStreamChunks(o2, a2.index, a2.content)).chunks[0] || 1 !== n2.queryStatus ? (s2.streamConfig.status = -1, s2.aiConfig && (s2.aiConfig.aiStreamStatus = -1), s2.text = n2.chunks.join(""), n2.aiRAGs && s2.aiConfig && (s2.aiConfig.aiRAGs = n2.aiRAGs), n2.msg && (s2 = Object.assign({}, n2.msg, Object.assign({ text: s2.text, modifyTime: a2.chunkTime, modifyAccountId: n2.msg.senderId, streamConfig: s2.streamConfig }, s2.aiConfig ? { aiConfig: s2.aiConfig } : {}))), this.core.eventBus.emit("V2NIMAIService/receiveMessagesModified", [s2])) : this.logger.log(`V2AI::msg:callStream requestId:${o2};chunks ignore index:${a2.index};queryStatus:${n2.queryStatus}.`);
            }
          }
        }
        reportOutOfOrder(e2) {
          this.core.reporter.reportTraceStart("exceptions", { user_id: this.core.account, trace_id: get(this.core, "clientSocket.socket.sessionId"), action: 2, exception_service: 0 }), this.core.reporter.reportTraceUpdateV2("exceptions", { code: 0, context: e2.requestId, description: `[${e2.cacheIds.join(",")}],${e2.targetIndex}`, operation_type: 2, target: e2.target, net_connect: true }), this.core.reporter.reportTraceEnd("exceptions", 4);
        }
      }
      var dc = { "18_1": "v2SignallingCreateRoom", "18_2": "v2SignallingDelayRoom", "18_3": "v2SignallingCloseRoom", "18_4": "v2SignallingJoinRoom", "18_5": "v2SignallingLeaveRoom", "18_6": "v2SignallingInvite", "18_7": "v2SignallingCancelInvite", "18_16": "v2SignallingCall", "18_17": "v2SignallingCallSetup", "18_8": "v2SignallingRejectInvite", "18_9": "v2SignallingAcceptInvite", "18_10": "v2SignallingSendControl", "15_11": "v2SignallingOnlineEvent", "15_12": "v2SignallingMultiClientEvent", "15_13": "v2SignallingOfflineEvent", "15_14": "v2SignallingSyncChannels", "18_15": "v2SignallingGetRoomInfo" }, lc = "V2NIMSignallingService", mc = { accountId: 1, uid: { id: 2, retType: "number" }, joinTime: { id: 3, retType: "number" }, expireTime: { id: 4, retType: "number" }, deviceId: 5 }, pc = { channelType: { id: 1, retType: "number", retAccess: "channelInfo.channelType" }, channelName: { id: 2, retAccess: "channelInfo.channelName" }, channelId: { id: 3, retAccess: "channelInfo.channelId" }, createTime: { id: 4, retType: "number", retAccess: "channelInfo.createTime" }, expireTime: { id: 5, retType: "number", retAccess: "channelInfo.expireTime" }, creatorAccountId: { id: 6, retAccess: "channelInfo.creatorAccountId" }, channelExtension: { id: 7, retAccess: "channelInfo.channelExtension" }, channelValid: { id: 8, retDef: true, retAccess: "channelInfo.channelValid", retConverter: (e2) => 1 !== parseInt(e2) }, fromAccid: 10, toAccid: 11, requestId: 12, pushEnabled: { id: 13, access: "pushConfig.pushEnabled", converter: boolToInt, retType: "boolean" }, pushTitle: { id: 14, access: "pushConfig.pushTitle" }, pushContent: { id: 15, access: "pushConfig.pushContent" }, pushPayload: { id: 16, access: "pushConfig.pushPayload" }, unreadEnabled: { id: 17, access: "signallingConfig.unreadEnabled", converter: boolToInt, retType: "boolean", def: 1 }, members: { id: 18, retAccess: "members", retConverter: (e2) => {
        try {
          return JSON.parse(e2).map((e3) => deserialize(e3, invertSerializeItem(mc)));
        } catch (e3) {
          return;
        }
      } }, attach: { id: 19, retConverter: stringToJSONObject }, serverExtension: { id: 20, retDef: "" }, offlineEnabled: { id: 21, converter: boolToInt, retType: "boolean", def: 1 }, msgId: 22, selfUid: { id: 23, retType: "number", access: "signallingConfig.selfUid" }, time: { id: 24, retType: "number" }, rtcChannelName: { id: 25, access: "rtcConfig.rtcChannelName" }, rtcTokenTtl: { id: 26, retType: "number", access: "rtcConfig.rtcTokenTtl", retAccess: "rtcInfo.rtcTokenTtl" }, rtcToken: { id: 27, retAccess: "rtcInfo.rtcToken" }, rtcParams: { id: 28, access: "rtcConfig.rtcParams", retAccess: "rtcInfo.rtcParams" }, callStatus: { id: 30, retType: "number" } }, uc = { v2SignallingCall: { sid: 18, cid: 16, service: lc, params: [{ type: "Property", name: "tag", reflectMapper: pc }], response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(pc) }] }, v2SignallingCallSetup: { sid: 18, cid: 17, service: lc, params: [{ type: "Property", name: "tag", reflectMapper: pc }], response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(pc) }] }, v2SignallingCreateRoom: { sid: 18, cid: 1, service: lc, params: [{ type: "Property", name: "tag", reflectMapper: pc }], response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(pc) }] }, v2SignallingDelayRoom: { sid: 18, cid: 2, service: lc, params: [{ type: "Property", name: "tag", reflectMapper: pc }], response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(pc) }] }, v2SignallingCloseRoom: { sid: 18, cid: 3, service: lc, params: [{ type: "Property", name: "tag", reflectMapper: pc }], response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(pc) }] }, v2SignallingJoinRoom: { sid: 18, cid: 4, service: lc, params: [{ type: "Property", name: "tag", reflectMapper: pc }], response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(pc) }] }, v2SignallingLeaveRoom: { sid: 18, cid: 5, service: lc, params: [{ type: "Property", name: "tag", reflectMapper: pc }], response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(pc) }] }, v2SignallingInvite: { sid: 18, cid: 6, service: lc, params: [{ type: "Property", name: "tag", reflectMapper: pc }], response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(pc) }] }, v2SignallingCancelInvite: { sid: 18, cid: 7, service: lc, params: [{ type: "Property", name: "tag", reflectMapper: pc }], response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(pc) }] }, v2SignallingRejectInvite: { sid: 18, cid: 8, service: lc, params: [{ type: "Property", name: "tag", reflectMapper: pc }] }, v2SignallingAcceptInvite: { sid: 18, cid: 9, service: lc, params: [{ type: "Property", name: "tag", reflectMapper: pc }] }, v2SignallingSendControl: { sid: 18, cid: 10, service: lc, params: [{ type: "Property", name: "tag", reflectMapper: pc }] }, v2SignallingOnlineEvent: { sid: 15, cid: 11, service: lc, response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(pc) }] }, v2SignallingMultiClientEvent: { sid: 15, cid: 12, service: lc, response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(pc) }] }, v2SignallingOfflineEvent: { sid: 15, cid: 13, service: lc, response: [{ type: "PropertyArray", name: "datas", reflectMapper: invertSerializeItem(pc) }] }, v2SignallingSyncChannels: { sid: 15, cid: 14, service: lc, response: [{ type: "PropertyArray", name: "datas", reflectMapper: invertSerializeItem(pc) }] }, v2SignallingGetRoomInfo: { sid: 18, cid: 15, service: lc, params: [{ type: "Property", name: "tag", reflectMapper: pc }], response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(pc) }] }, v2SignallingBatchMarkRead: { sid: 4, cid: 5, hasPacketResponse: false, service: lc, params: [{ type: "Byte", name: "sid" }, { type: "Byte", name: "cid" }, { type: "LongArray", name: "ids" }] } }, hc = { calleeAccountId: { type: "string", required: true, allowEmpty: false }, requestId: { type: "string", required: true, allowEmpty: false }, channelType: { type: "enum", values: [1, 3, 2] }, channelName: { type: "string", required: false, allowEmpty: true }, channelExtension: { type: "string", required: false, allowEmpty: true }, serverExtension: { type: "string", required: false, allowEmpty: true }, signallingConfig: { type: "object", required: false, rules: { offlineEnabled: { type: "boolean", required: false }, unreadEnabled: { type: "boolean", required: false }, selfUid: { type: "number", required: false } } }, pushConfig: { type: "object", required: false, rules: { pushEnabled: { type: "boolean", required: false }, pushTitle: { type: "string", required: false, allowEmpty: true }, pushContent: { type: "string", required: false, allowEmpty: true }, pushPayload: { type: "string", required: false, allowEmpty: true } } }, rtcConfig: { type: "object", required: false, rules: { rtcChannelName: { type: "string", required: false, allowEmpty: true }, rtcTokenTtl: { type: "number", required: false }, rtcParams: { type: "string", required: false, allowEmpty: true } } } }, gc = { channelId: { type: "string", required: true, allowEmpty: false }, callerAccountId: { type: "string", required: true, allowEmpty: false }, requestId: { type: "string", required: true, allowEmpty: false }, serverExtension: { type: "string", required: false, allowEmpty: true }, signallingConfig: { type: "object", required: false, rules: { offlineEnabled: { type: "boolean", required: false }, unreadEnabled: { type: "boolean", required: false }, selfUid: { type: "number", required: false } } }, rtcConfig: { type: "object", required: false, rules: { rtcChannelName: { type: "string", required: false, allowEmpty: true }, rtcTokenTtl: { type: "number", required: false }, rtcParams: { type: "string", required: false, allowEmpty: true } } } }, vc = { channelType: { type: "enum", values: [1, 3, 2] }, channelName: { type: "string", required: false, allowEmpty: true }, channelExtension: { type: "string", required: false, allowEmpty: true } }, yc = { channelId: { type: "string", required: true, allowEmpty: false }, offlineEnabled: { type: "boolean", required: false }, serverExtension: { type: "string", required: false, allowEmpty: true } }, fc = { channelId: { type: "string", required: true, allowEmpty: false }, serverExtension: { type: "string", required: false, allowEmpty: true }, signallingConfig: { type: "object", required: false, rules: { offlineEnabled: { type: "boolean", required: false }, unreadEnabled: { type: "boolean", required: false }, selfUid: { type: "number", required: false } } }, rtcConfig: { type: "object", required: false, rules: { rtcChannelName: { type: "string", required: false, allowEmpty: true }, rtcTokenTtl: { type: "number", required: false }, rtcParams: { type: "string", required: false, allowEmpty: true } } } }, Ic = { channelId: { type: "string", required: true, allowEmpty: false }, offlineEnabled: { type: "boolean", required: false }, serverExtension: { type: "string", required: false, allowEmpty: true } }, Mc = { channelId: { type: "string", required: true, allowEmpty: false }, inviteeAccountId: { type: "string", required: true, allowEmpty: false }, requestId: { type: "string", required: true, allowEmpty: false }, serverExtension: { type: "string", required: false, allowEmpty: true }, signallingConfig: { type: "object", required: false, rules: { offlineEnabled: { type: "boolean", required: false }, unreadEnabled: { type: "boolean", required: false }, selfUid: { type: "number", required: false } } }, pushConfig: { type: "object", required: false, rules: { pushEnabled: { type: "boolean", required: false }, pushTitle: { type: "string", required: false, allowEmpty: true }, pushContent: { type: "string", required: false, allowEmpty: true }, pushPayload: { type: "string", required: false, allowEmpty: true } } } }, Sc = { channelId: { type: "string", required: true, allowEmpty: false }, inviteeAccountId: { type: "string", required: true, allowEmpty: false }, requestId: { type: "string", required: true, allowEmpty: false }, serverExtension: { type: "string", required: false, allowEmpty: true }, offlineEnabled: { type: "boolean", required: false }, pushConfig: { type: "object", required: false, rules: { pushEnabled: { type: "boolean", required: false }, pushTitle: { type: "string", required: false, allowEmpty: true }, pushContent: { type: "string", required: false, allowEmpty: true }, pushPayload: { type: "string", required: false, allowEmpty: true } } } }, Tc = { channelId: { type: "string", allowEmpty: false }, receiverAccountId: { type: "string", required: false }, serverExtension: { type: "string", required: false, allowEmpty: true } }, _c = { channelId: { type: "string", allowEmpty: false }, inviterAccountId: { type: "string", allowEmpty: false }, requestId: { type: "string", allowEmpty: false }, serverExtension: { type: "string", required: false, allowEmpty: true }, offlineEnabled: { type: "boolean", required: false } }, Cc = _c;
      function formatSignalingEvent(e2) {
        var t2, r2 = e2.attach, i2 = { eventType: r2.type, channelInfo: e2.channelInfo, operatorAccountId: e2.fromAccid, time: e2.time, serverExtension: e2.serverExtension, requestId: e2.requestId, pushConfig: e2.pushConfig, unreadEnabled: null === (t2 = e2.signallingConfig) || void 0 === t2 ? void 0 : t2.unreadEnabled }, { fromAccid: s2, toAccid: n2 } = e2;
        switch (i2.eventType) {
          case 1:
            break;
          case 2:
            i2.member = { accountId: r2.member[1], uid: Number(r2.member[2]), joinTime: Number(r2.member[3]), expireTime: Number(r2.member[4]), deviceId: r2.member[5] };
            break;
          case 3:
          case 4:
            i2.operatorAccountId = s2, i2.inviteeAccountId = n2, i2.inviterAccountId = s2;
            break;
          case 5:
          case 6:
            i2.operatorAccountId = s2, i2.inviterAccountId = n2, i2.inviteeAccountId = s2;
        }
        return JSON.parse(JSON.stringify(i2));
      }
      var Ec, bc = { "19_1": "v2PublishEvent", "14_2": "v2OnUserStatusChange", "19_3": "v2SubscribeUserStatus", "19_4": "v2UnsubscribeUserStatus", "19_5": "v2UnsubscribeAllUserStatus", "19_6": "v2QuerySubscribeEvent", "19_7": "v2QueryAllSubscribeEvent", "14_9": "v2OnMultiUserStatusChange" }, Rc = "V2NIMSubscriptionService", Nc = { eventType: { id: 1, retType: "number" }, statusType: { id: 2, retType: "number" }, uniqueId: 3, extension: 4, duration: { id: 5, retType: "number" }, onlineOnly: { id: 6, retType: "boolean", converter: (e2) => e2 ? 1 : 2 }, multiSync: { id: 7, retType: "boolean", converter: boolToInt }, publishTime: { id: 10, retType: "number" }, serverId: 11, clientType: { id: 12, retType: "number" }, serverExtension: 13, extensionReceived: 14, accountId: 103 }, Ac = { eventType: { id: 1, retType: "number" }, duration: { id: 2, retType: "number" }, immediateSync: { id: 3, retType: "number", converter: boolToInt }, accountId: 102, subscribeTime: { id: 105, retType: "number" } }, Oc = { v2PublishEvent: { sid: 19, cid: 1, service: Rc, params: [{ type: "Property", name: "tag", reflectMapper: Nc }], response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(Nc) }] }, v2OnUserStatusChange: { sid: 14, cid: 2, service: Rc, response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(Nc) }] }, v2SubscribeUserStatus: { sid: 19, cid: 3, service: Rc, params: [{ type: "Property", name: "tag", reflectMapper: Ac }, { type: "StrArray", name: "accountIds" }], response: [{ type: "StrArray", name: "failedList" }] }, v2UnsubscribeUserStatus: { sid: 19, cid: 4, service: Rc, params: [{ type: "Property", name: "tag", reflectMapper: Ac }, { type: "StrArray", name: "accountIds" }], response: [{ type: "StrArray", name: "failedList" }] }, v2UnsubscribeAllUserStatus: { sid: 19, cid: 5, service: Rc, params: [{ type: "Property", name: "tag", reflectMapper: Ac }] }, v2QuerySubscribeEvent: { sid: 19, cid: 6, service: Rc, params: [{ type: "Property", name: "tag", reflectMapper: Ac }, { type: "StrArray", name: "accountIds" }], response: [{ type: "PropertyArray", name: "data", reflectMapper: invertSerializeItem(Ac) }] }, v2QueryAllSubscribeEvent: { sid: 19, cid: 7, service: Rc, params: [{ type: "Property", name: "tag", reflectMapper: Ac }], response: [{ type: "PropertyArray", name: "data", reflectMapper: invertSerializeItem(Ac) }] }, v2OnMultiUserStatusChange: { sid: 14, cid: 9, service: Rc, response: [{ type: "PropertyArray", name: "data", reflectMapper: invertSerializeItem(Nc) }] } }, kc = { accountIds: { type: "array", required: true, itemType: "string", min: 1, max: 100 }, duration: { type: "number", required: false, min: 60, max: 2592e3 }, immediateSync: { type: "boolean", required: false } }, wc = { accountIds: { type: "array", required: false, itemType: "string", max: 100 } }, Pc = { statusType: { type: "number", required: true, min: 1e4, max: 2147483647 }, duration: { type: "number", required: false, min: 60, max: 604800 }, extension: { type: "jsonstr", required: false }, onlineOnly: { type: "boolean", required: false }, multiSync: { type: "boolean", required: false } };
      !function(e2) {
        e2[e2.V2NIM_PROXY_REQUEST_METHOD_GET = 1] = "V2NIM_PROXY_REQUEST_METHOD_GET", e2[e2.V2NIM_PROXY_REQUEST_METHOD_POST = 2] = "V2NIM_PROXY_REQUEST_METHOD_POST", e2[e2.V2NIM_PROXY_REQUEST_METHOD_PUT = 3] = "V2NIM_PROXY_REQUEST_METHOD_PUT", e2[e2.V2NIM_PROXY_REQUEST_METHOD_DELETE = 4] = "V2NIM_PROXY_REQUEST_METHOD_DELETE";
      }(Ec || (Ec = {}));
      var Vc = "V2NIMPassthroughService", Lc = { "22_1": "v2ProxyRequest", "22_2": "v2ProxyOnRequest" }, Uc = { zone: 1, path: 2, method: 3, header: 4, body: 5 }, Dc = { v2ProxyRequest: { sid: 22, cid: 1, service: Vc, params: [{ type: "Property", name: "tag", reflectMapper: Uc }], response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem(Uc) }] }, v2ProxyOnRequest: { sid: 22, cid: 2, service: Vc, response: [{ type: "Property", name: "data", reflectMapper: invertSerializeItem({ fromAccountId: 1, body: 2, time: { id: 3, retType: "number" } }) }] } }, qc = { path: { type: "string", allowEmpty: false }, zone: { type: "string", required: false }, method: { type: "enum", values: [Ec.V2NIM_PROXY_REQUEST_METHOD_DELETE, Ec.V2NIM_PROXY_REQUEST_METHOD_GET, Ec.V2NIM_PROXY_REQUEST_METHOD_POST, Ec.V2NIM_PROXY_REQUEST_METHOD_PUT], required: false }, header: { type: "jsonstr", required: false }, body: { type: "string", required: false } };
      !function setAdapters(e2) {
        merge(ge, e2());
      }(() => ({ setLogger, platform: "UNIAPP", localStorage: Le, request: requestFn, WebSocket: WebsocketFn, uploadFile: uploadFileFn, getFileUploadInformation: getFileUploadInformationFn, getSystemInfo: getSystemInfoFn, net: De, powerMonitor: new PowerMonitor(), logStorage: LogStorageImpl })), NIM.registerService(class V1NIMLoginServiceImpl extends V2Service {
        constructor(e2, t2) {
          super("V1NIMLoginService", e2), this.account = "", this.token = "", this.deviceId = "", this.processId = "", this.clientSession = "", this.status = "unconnected", this.config = mt, this.isManualLoginAttempt = false, this.core._registerDep(MiscService, "misc"), registerParser({ cmdMap: ze, cmdConfig: Ye }), e2.V1NIMLoginService = this, t2 && this.setOptions(t2);
          var r2 = new V1ClientSocket(this.core, this);
          this.clientSocket = r2, "v1" === this.core.options.apiVersion && (this.core.clientSocket = r2, this.core.auth = this), this.lbs = new V1NIMLoginLbs(e2), this.authenticator = new V1NIMLoginAuthenticator(e2), this.doLoginStepsManager = new PromiseManager();
        }
        reset() {
          this.lbs.reset();
        }
        setOptions(e2) {
          var t2, r2, i2;
          e2 && Object.keys(e2).length > 0 ? (this.config = assignOptions(this.config, e2), this.account = e2.account || this.core.options.account, this.token = e2.token || this.core.options.token, this.core.options = Object.assign(Object.assign({}, this.core.options), this.config)) : (this.config = assignOptions(this.core.options, this.config), this.account = this.core.options.account, this.token = this.core.options.token), null === (r2 = null === (t2 = this.core.clientSocket) || void 0 === t2 ? void 0 : t2.setLinkSSL) || void 0 === r2 || r2.call(t2, null === (i2 = this.config.linkSSL) || void 0 === i2 || i2);
          var s2 = "", n2 = "";
          this.config.isFixedDeviceId ? (s2 = ge.localStorage.getItem("__NIM_DEVC_ID__") || Ie(), n2 = ge.localStorage.getItem("__NIM_CLIENT_SESSION_ID__") || Ie(), ge.localStorage.setItem("__NIM_DEVC_ID__", s2), ge.localStorage.setItem("__NIM_CLIENT_SESSION_ID__", n2)) : (s2 = Ie(), n2 = Ie()), this.deviceId = s2, this.clientSession = n2, this.core.reporter.setConfig({ common: { dev_id: s2 } });
        }
        connect(e2 = {}) {
          return this.login(e2);
        }
        login(e2 = {}) {
          return __awaiter(this, void 0, void 0, function* () {
            this._checkApiVersion(), e2.isAutoReconnect || (this.isManualLoginAttempt = true, this.processId = Ie()), yield this._connect(e2), this.core.abtest.abtRequest();
            try {
              yield this.doLogin(e2.isAutoReconnect), this.processId = Ie(), this.isManualLoginAttempt = false;
            } catch (e3) {
              throw this.isManualLoginAttempt = false, e3;
            }
          });
        }
        _connect(e2 = {}) {
          return __awaiter(this, void 0, void 0, function* () {
            if (!/^(unconnected|waitReconnect)$/.test(this.core.status)) {
              var t2 = `NIM status is ${this.core.status}, and would not connect`;
              return this.logger.warn(t2), Promise.reject(t2);
            }
            this.clientSocket.beforeConnect(), this.core.reporter.reportTraceCancel("login"), this.core.reporter.reportTraceStart("login", { user_id: this.core.options.account, action: e2.isAutoReconnect ? "auto_login" : "manual_login", binary_websocket: false, process_id: this.processId }), this.core.reporter.reportTraceUpdateV2("login", { code: 0, description: JSON.stringify(Object.assign(Object.assign({}, this.core.options), { account: "***", token: "***" })), operation_type: "conf_init", succeed: true, duration: 0, target: "" }, { asyncParams: ge.net.getNetworkStatus() });
            var r2 = yield this.lbs.getLbsInfos();
            try {
              var i2 = yield this.clientSocket.connect({ linkUrls: r2, isAutoReconnect: e2.isAutoReconnect }, (e3, t3) => {
                this.core.reporter.reportTraceUpdateV2("login", { operation_type: "TCP", target: t3, code: e3.code || 408, description: `ws_handshake_failed:${e3.message}`, succeed: false }, { asyncParams: ge.net.getNetworkStatus() });
              });
              i2 && this.core.reporter.reportTraceUpdateV2("login", { operation_type: "TCP", target: i2, code: 200, succeed: true }, { asyncParams: ge.net.getNetworkStatus() });
            } catch (e3) {
              throw this.core.reporter.reportTraceEnd("login", false), e3;
            }
          });
        }
        doLogin(e2 = false) {
          return __awaiter(this, void 0, void 0, function* () {
            var t2;
            try {
              t2 = yield this.authenticator.verifyAuthentication(e2), this.core.reporter.reportTraceUpdateV2("login", { operation_type: "protocol", target: "2-3", code: 200, succeed: true }, { asyncParams: ge.net.getNetworkStatus() }), this.core.reporter.reportTraceEnd("login", true), this.core.status = "logined";
            } catch (e3) {
              var r2 = e3, i2 = get(r2, "data.disconnect_reason") || "", s2 = 415 === r2.code ? JSON.stringify({ disconnect_reason: i2 }) : r2.message;
              if (this.core.logger.warn("nim login:: login failed", e3), this.core.reporter.reportTraceUpdateV2("login", { operation_type: "protocol", target: "2-3", code: r2.code || 0, succeed: false, description: s2 }, { asyncParams: ge.net.getNetworkStatus() }), this.core.reporter.reportTraceEnd("login", false), this.clientSocket.doDisconnect(rt.OFFLINE, this.isManualLoginAttempt ? "FailedToInitializeLogin" : "ReconnectLoginFailed", e3), this.isManualLoginAttempt)
                throw e3;
              return;
            }
            try {
              var n2 = t2.loginTime ? parseInt(t2.loginTime) : Date.now();
              yield this.core.cloudStorage.init(n2);
            } catch (e3) {
              this.core.logger.error("NIM:login cloudStorage init failed ", e3);
            }
            this.core.eventBus.emit("logined", t2), this.core.emit("logined", t2), this.emit("logined", t2), this.core.logger.log("login done"), this.clientSocket.resetConnectStatus(), this.clientSocket.ping();
          });
        }
        disconnect() {
          return this.logout();
        }
        logout() {
          return __awaiter(this, void 0, void 0, function* () {
            switch (this._checkApiVersion(), this.doLoginStepsManager.clear(), this.status) {
              case "logined":
                try {
                  yield this.clientSocket.sendCmd("logout", void 0, { timeout: 1e3 }), this.clientSocket.doDisconnect(rt.ACTIVE, "UserActiveDisconnect"), this.core._clearModuleData();
                } catch (e2) {
                  this.logger.error("Instance::disconnect sendCmd:logout error", e2), this.clientSocket.doDisconnect(rt.ACTIVE, "UserActiveDisconnect"), this.core._clearModuleData();
                }
                break;
              case "connected":
              case "connecting":
              case "waitReconnect":
                return this.clientSocket.doDisconnect(rt.ACTIVE, "UserActiveDisconnect"), this.core._clearModuleData(), Promise.resolve();
              case "unconnected":
              case "destroyed":
                return Promise.resolve();
            }
          });
        }
        kick(e2) {
          var t2;
          return __awaiter(this, void 0, void 0, function* () {
            this._checkApiVersion();
            var r2 = yield this.clientSocket.sendCmd("kick", e2);
            return null === (t2 = r2.content) || void 0 === t2 ? void 0 : t2.deviceIds;
          });
        }
        _checkApiVersion() {
          if ("v1" !== this.core.options.apiVersion)
            throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_MISUSE, detail: { reason: 'apiVersion is not "v1"' } });
        }
        nimLoginClientChangeHandler(e2) {
          if (e2.error)
            this.logger.error("nimLoginClientChangeHandler:: error, ", e2.error);
          else {
            var { datas: t2, state: r2 } = e2.content, i2 = formatMultiPortLoginInfo(t2, r2);
            i2.length > 0 && (this.core.emit("multiPortLogin", i2), this.emit("multiPortLogin", i2));
          }
        }
        kickedHandler(e2) {
          if (e2.error)
            this.logger.error("kickedHandler:: error, ", e2.error);
          else {
            var t2 = function formatBeKickedTag$1(e3) {
              var t3 = format({ clientType: { type: "enum", values: $e }, customClientType: { type: "number" } }, e3), r2 = Ze[t3.reason];
              return r2 = r2 || { reason: "unknow", message: "Unknown reason" }, Object.assign(t3, r2);
            }(e2.content);
            this.logger.warn("kicked::", t2), this.clientSocket.doDisconnect(rt.KICKED, t2), this.core._clearModuleData();
          }
        }
        getConnectStatus() {
          switch (this.core.status) {
            case "unconnected":
            case "destroyed":
            default:
              return 0;
            case "connecting":
              return 2;
            case "connected":
            case "logined":
              return 1;
            case "waitReconnect":
              return 3;
          }
        }
        getLoginStatus() {
          switch (this.core.status) {
            case "unconnected":
            case "destroyed":
            case "waitReconnect":
            default:
              return 0;
            case "connecting":
            case "connected":
              return 2;
            case "logined":
              return 1;
          }
        }
        getLoginUser() {
          return this.core.options.account;
        }
        emit(e2, ...t2) {
          var r2 = `${this.name}::emit ${e2.toString()}`;
          return this.logger.log(`${r2}`, ...t2), super.emit(e2, ...t2);
        }
      }, "V1NIMLoginService"), NIM.registerService(class MsgService extends Service$1 {
        constructor(e2) {
          super("msg", e2), this.onV2SendMessage = (e3) => {
            var t2 = formatMsg$1(e3, { account: this.core.account, featureValue: He.default });
            t2.status = e3.status, this.core.eventBus.emit("session/updateForNewMsg", t2);
          }, this.onV2ModifyMessage = (e3) => {
            var t2, r2 = `${je[e3.scene]}-${e3.to === this.core.account ? e3.from : e3.to}`, i2 = null === (t2 = this.core.session) || void 0 === t2 ? void 0 : t2.getSessionWithUncomplete({ id: r2 }), s2 = formatMsg$1(e3, i2 ? { account: this.core.account, sessionAck: i2.ack, msgReceiptTime: i2.msgReceiptTime } : { account: this.core.account });
            this.core.eventBus.emit("session/updateForModifyMsg", s2);
          }, this.onV2RecallMsg = (e3) => {
            var t2 = formatDeletedMsgs([e3], getSceneFromRecallSysMsg(+e3.type));
            this.core.eventBus.emit("session/updateForDeletedMsg", t2);
          }, this.onV2DeleteSelfMsgs = (e3) => {
            var t2 = formatDeletedMsgs(e3);
            this.core.eventBus.emit("session/updateForDeletedMsg", t2);
          }, this.service = new ModuleService$2(e2), registerParser({ cmdMap: ir, cmdConfig: or }), this.registerListener();
        }
        registerListener() {
          this.core.eventBus.on("forwardReceive/msg/sendMsg", this.onV2SendMessage), this.core.eventBus.on("forwardReceive/msg/modifyMsg", this.onV2ModifyMessage), this.core.eventBus.on("forwardReceive/msg/recallMsg", this.onV2RecallMsg), this.core.eventBus.on("forwardReceive/msg/deleteSelfMsgs", this.onV2DeleteSelfMsgs);
        }
        sendTextMsg(e2) {
          return validate({ body: { type: "string", allowEmpty: false } }, e2), this.sendMsg(Object.assign(Object.assign({}, e2), { type: "text" }));
        }
        sendTipMsg(e2) {
          return validate({ body: { type: "string", allowEmpty: false } }, e2), this.sendMsg(Object.assign(Object.assign({}, e2), { type: "tip" }));
        }
        sendGeoLocationMsg(e2) {
          return validate({ attach: { type: "object", rules: { title: { type: "string", allowEmpty: false }, lat: { type: "number" }, lng: { type: "number" } } } }, e2), this.sendMsg(Object.assign(Object.assign({}, e2), { type: "geo", attach: JSON.stringify(e2.attach) }));
        }
        sendCustomMsg(e2) {
          return validate({ attach: { type: "string", allowEmpty: false } }, e2), this.sendMsg(Object.assign(Object.assign({}, e2), { type: "custom" }));
        }
        sendMsg(e2) {
          var t2;
          if (validate({ scene: { type: "enum", values: getEnumKeys(je) }, type: { type: "enum", values: getEnumKeys(Fe) }, to: { type: "string", allowEmpty: false }, ext: { type: "string", required: false }, setting: { type: "object", rules: { resendFlag: { type: "boolean", required: false }, needSaveHistory: { type: "boolean", required: false }, needRoaming: { type: "boolean", required: false }, needOffline: { type: "boolean", required: false }, needSelfSync: { type: "boolean", required: false }, needRouted: { type: "boolean", required: false }, needUpdateSession: { type: "boolean", required: false } }, required: false }, antiSpamInfo: { type: "object", required: false, rules: { clientAntispamHitting: { type: "boolean", required: false }, antiSpamUsingYidun: { type: "boolean", required: false } } }, pushInfo: { type: "object", required: false, rules: Kt }, robotInfo: { type: "object", required: false, rules: Yt }, teamSpecializationInfo: { type: "object", required: false, rules: { needACK: { type: "boolean", required: false } } } }, e2), "team" === e2.scene && e2.robotInfo && !e2.robotInfo.account)
            throw new ValidateError('When "scene" equals "team", account is required in robotInfo', { key: "account" }, "required");
          var r2, i2 = "p2p" === e2.scene ? "sendMsg" : "team" === e2.scene ? "sendTeamMsg" : "sendSuperTeamMsg", s2 = generatorMsgForCmd$1(e2, this.core.account, this.core.config.deviceId, null === (t2 = this.core.user) || void 0 === t2 ? void 0 : t2.myInfo), n2 = formatMsg$1(Object.assign(Object.assign({}, s2), { time: (/* @__PURE__ */ new Date()).getTime() }), { account: this.core.account, featureValue: He.default, statusValue: Ge.sending });
          try {
            e2.onSendBefore && e2.onSendBefore(n2);
          } catch (e3) {
            this.logger.error("sendMsg: options.onSendBefore error", e3);
          }
          return this.core.eventBus.emit("session/updateForNewMsg", n2), this.core.eventBus.emit("forwardSend/msg/sendMsg", s2), this.core.sendCmd(i2, { msg: s2 }).then((t3) => {
            var { content: i3, error: a2 } = t3;
            if (r2 = i3.msg, a2)
              throw a2;
            var o2 = formatMsg$1(Object.assign(Object.assign({}, s2), i3.msg), { account: this.core.account, featureValue: He.default, statusValue: Ge.sent });
            return o2.from === o2.to && this.markMsgsAck([o2]), this.core.eventBus.emit("session/updateForNewMsg", o2), this.core.eventBus.emit("forwardSend/msg/sendMsg", Object.assign(Object.assign({}, generatorMsgForCmd$1(o2, o2.from, o2.fromDeviceId)), { idClient: o2.idClient, status: "sent" })), this.core.reporter.report("msgSend", { msgId: o2.idServer, clientId: o2.idClient, msgTime: o2.time, fromAccid: "p2p" === e2.scene ? this.core.account : "", toAccid: o2.to, type: je[o2.scene], roomId: "", tid: "p2p" === e2.scene ? "" : o2.to, result: 200, failReason: "", rt: Date.now() - n2.time }), o2;
          }).catch((t3) => {
            var i3 = formatMsg$1(Object.assign(Object.assign(Object.assign({}, s2), { time: (/* @__PURE__ */ new Date()).getTime() }), r2), { account: this.core.account, featureValue: He.default, statusValue: 7101 === t3.code ? Ge.refused : Ge.sendFailed });
            throw t3.msg = i3, this.core.eventBus.emit("session/updateForNewMsg", i3), this.core.eventBus.emit("forwardSend/msg/sendMsg", Object.assign(Object.assign({}, generatorMsgForCmd$1(i3, i3.from, i3.fromDeviceId)), { status: "sendFailed" })), this.core.reporter.report("msgSend", { msgId: i3.idServer, clientId: i3.idClient, msgTime: i3.time, fromAccid: "p2p" === e2.scene ? this.core.account : "", toAccid: i3.to, type: je[i3.scene], roomId: "", tid: "p2p" === e2.scene ? "" : i3.to, result: null == t3 ? void 0 : t3.code, failReason: (null == t3 ? void 0 : t3.message) || "", rt: Date.now() - n2.time }), t3;
          });
        }
        resendMsg(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ msg: { type: "object", rules: { idClient: { type: "string", allowEmpty: false } } } }, e2);
            var t2 = e2.msg, r2 = Object.assign(Object.assign({}, t2), { attach: t2.attach ? JSON.stringify(t2.attach) : void 0, setting: { resendFlag: true } });
            if (t2.from !== this.core.account)
              throw new Error(`You can only resend messages that you sent: ${t2.idClient}`);
            return this.sendMsg(r2);
          });
        }
        forwardMsg(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ msg: { type: "object", rules: { idClient: { type: "string", allowEmpty: false } } }, scene: { type: "enum", values: getEnumKeys(je) }, to: { type: "string", allowEmpty: false } }, e2);
            var t2 = e2.msg, r2 = Object.assign(Object.assign({}, t2), { scene: e2.scene, to: e2.to, attach: t2.attach ? JSON.stringify(t2.attach) : void 0 });
            return this.sendMsg(r2);
          });
        }
        sendImageMsg(e2) {
          return this.doSendFile(Object.assign(Object.assign({}, e2), { type: "image" }));
        }
        sendFileMsg(e2) {
          return this.doSendFile(Object.assign(Object.assign({}, e2), { type: "file" }));
        }
        sendAudioMsg(e2) {
          return this.doSendFile(Object.assign(Object.assign({}, e2), { type: "audio" }));
        }
        sendVideoMsg(e2) {
          return this.doSendFile(Object.assign(Object.assign({}, e2), { type: "video" }));
        }
        doSendFile(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ scene: { type: "enum", values: getEnumKeys(je) }, to: { type: "string", allowEmpty: false }, type: { type: "string", allowEmpty: false }, attach: { type: "object", rules: { url: { type: "string", allowEmpty: false } }, required: false }, maxSize: { type: "number", min: 1, required: false } }, e2);
            var t2 = e2.attach;
            if (!t2) {
              if (!this.core.cloudStorage || !this.core.cloudStorage.uploadFile)
                throw new Error('Service "cloudStorage" does not exist');
              try {
                t2 = yield this.core.cloudStorage.uploadFile(e2);
              } catch (e3) {
                throw this.logger.error("sendFile:: upload File error or abort.", e3), e3;
              }
            }
            return this.sendMsg(Object.assign(Object.assign({}, e2), { attach: JSON.stringify(t2), type: e2.type }));
          });
        }
        recallMsg(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ msg: { type: "object", rules: { idClient: { type: "string", allowEmpty: false }, idServer: { type: "string", allowEmpty: false }, scene: { type: "enum", values: getEnumKeys(je) }, time: { type: "number" } } }, pushInfo: { type: "object", required: false, rules: tr }, ps: { type: "string", allowEmpty: false, required: false } }, e2);
            var t2 = e2.msg, r2 = processPushInfoInMsg({ time: t2.time, type: { p2p: 7, team: 8, superTeam: 12 }[t2.scene], to: t2.to, from: t2.from, ps: e2.ps, attach: e2.attach, deletedIdClient: t2.idClient, deletedIdServer: t2.idServer, opeAccount: t2.from, env: e2.env, pushInfo: e2.pushInfo });
            yield this.core.sendCmd({ p2p: "recallMsg", team: "recallMsg", superTeam: "recallSuperTeamMsg" }[t2.scene], { recallMsgTag: r2 });
            var i2 = formatDeletedMsgs([Object.assign({}, t2, { deletedMsgCreateTime: t2.time })]);
            return this.core.eventBus.emit("session/updateForDeletedMsg", i2), this.core.eventBus.emit("forwardSend/msg/recallMsg", r2), t2;
          });
        }
        deleteSelfMsgs(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ msgs: { type: "array", rules: { scene: { type: "enum", values: ["p2p", "team"] }, from: { type: "string", allowEmpty: false }, to: { type: "string", allowEmpty: false }, idServer: { type: "string", allowEmpty: false }, idClient: { type: "string", allowEmpty: false }, time: { type: "number", allowEmpty: false } } }, ext: { type: "string", allowEmpty: false, required: false } }, e2);
            var t2 = e2.msgs.map((t3) => ({ scene: "p2p" === t3.scene ? 1 : 2, from: t3.from, to: t3.to, idServer: t3.idServer, idClient: t3.idClient, deletedMsgCreateTime: t3.time, ext: e2.ext })), r2 = yield this.core.sendCmd("deleteSelfMsgs", { deletedMsgs: t2 }), i2 = formatDeletedMsgs(t2.map((e3) => {
              var t3;
              return Object.assign({}, e3, { time: null === (t3 = null == r2 ? void 0 : r2.content) || void 0 === t3 ? void 0 : t3.timetag });
            }));
            return this.core.eventBus.emit("session/updateForDeletedMsg", i2), this.core.eventBus.emit("forwardSend/msg/deleteSelfMsgs", t2.map((e3) => {
              var t3;
              return Object.assign(Object.assign({}, e3), { time: null === (t3 = null == r2 ? void 0 : r2.content) || void 0 === t3 ? void 0 : t3.timetag });
            })), i2;
          });
        }
        sendMsgReceipt(e2) {
          var t2, r2;
          return __awaiter(this, void 0, void 0, function* () {
            validate({ msg: { type: "object", rules: { idClient: { type: "string", allowEmpty: false }, target: { type: "string", allowEmpty: false }, time: { type: "number" } } } }, e2);
            var i2 = e2.msg;
            if ("p2p" === i2.scene && "in" === i2.flow) {
              var s2 = { to: i2.target, idClient: i2.idClient, time: i2.time }, n2 = yield this.core.sendCmd("sendMsgReceipt", { msgReceiptTag: s2 }), a2 = parseInt(null === (r2 = null === (t2 = n2.content) || void 0 === t2 ? void 0 : t2.msgReceiptTag) || void 0 === r2 ? void 0 : r2.time);
              return Object.assign(Object.assign({}, s2), { time: a2 ? Math.min(a2, s2.time) : s2.time });
            }
            this.logger.warn(`Msg scene: ${i2.scene}, flow: ${i2.flow} is not allowed to send msg receipt`);
          });
        }
        sendTeamMsgReceipt(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ teamMsgReceipts: { type: "array", rules: { teamId: { type: "string", allowEmpty: false }, idClient: { type: "string", allowEmpty: false }, idServer: { type: "string", allowEmpty: false } }, max: 50 } }, e2);
            var t2 = e2.teamMsgReceipts;
            this.core.sendCmd("sendTeamMsgReceipt", { teamMsgReceipts: t2 });
          });
        }
        getTeamMsgReads(e2) {
          var t2;
          return __awaiter(this, void 0, void 0, function* () {
            validate({ teamMsgReceipts: { type: "array", rules: { teamId: { type: "string", allowEmpty: false }, idClient: { type: "string", allowEmpty: false }, idServer: { type: "string", allowEmpty: false } } } }, e2);
            var r2 = e2.teamMsgReceipts, i2 = yield this.core.sendCmd("getTeamMsgReads", { teamMsgReceipts: r2 }), s2 = null === (t2 = i2.content) || void 0 === t2 ? void 0 : t2.teamMsgReceipts;
            return s2 = s2 ? s2.map((e3) => Object.assign(Object.assign({}, e3), { read: parseInt(e3.read), unread: parseInt(e3.unread) })) : [];
          });
        }
        getTeamMsgReadAccounts(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ teamMsgReceipt: { type: "object", rules: { teamId: { type: "string", allowEmpty: false }, idClient: { type: "string", allowEmpty: false }, idServer: { type: "string", allowEmpty: false } } } }, e2);
            var t2 = e2.teamMsgReceipt;
            return (yield this.core.sendCmd("getTeamMsgReadAccounts", { teamMsgReceiptTag: t2 })).content;
          });
        }
        markMsgsAck(e2) {
          if (e2 && e2.length > 0) {
            var t2 = [], r2 = [];
            e2.forEach((e3) => {
              "p2p" === e3.scene && "in" === e3.flow ? t2.push(e3) : "team" === e3.scene && "in" === e3.flow && r2.push(e3);
            }), t2.length > 0 && this.core.sendCmd("batchMarkRead", { sid: 7, cid: 2, ids: t2.map((e3) => e3.idServer) }), r2.length > 0 && this.core.sendCmd("batchMarkRead", { sid: 8, cid: 3, ids: r2.map((e3) => e3.idServer) });
          }
        }
        onMsgHandler(e2) {
          var t2;
          if (e2.error)
            this.logger.error("msgHandler::recvError", e2.error);
          else {
            var r2 = fillIdServer(e2, e2.content.msg, "idServer"), i2 = getSessionId(r2, this.core.account), s2 = null === (t2 = this.core.session) || void 0 === t2 ? void 0 : t2.getSessionWithUncomplete({ id: i2 }), n2 = formatMsg$1(r2, s2 ? { account: this.core.account, sessionAck: s2.ack, msgReceiptTime: s2.msgReceiptTime } : { account: this.core.account });
            this.logger.getDebugMode() ? this.logger.debug("msgHandler::recvMsg", n2.idClient, n2.idServer, n2) : this.logger.log("msgHandler::recvMsg", n2.idClient, n2.idServer), this.markMsgsAck([n2]), this.core.eventBus.emit("session/updateForNewMsg", n2), "superTeam" === n2.scene ? this.core.eventBus.emit("sync/updateTimetag", { superTeamRoamingMsgs: n2.time }) : this.core.eventBus.emit("sync/updateTimetag", { roamingMsgs: n2.time }), this.core.emit("msg", n2), "notification" === n2.type ? this.core.eventBus.emit("team/onNotification", n2) : "out" !== n2.flow && this.doMsgReceiveReport(n2, e2), "notification" !== n2.type && this.core.user.checkUserUpdate(n2);
          }
        }
        doMsgReceiveReport(e2, t2) {
          if (e2.from !== this.core.account) {
            var r2 = "p2p" === e2.scene, i2 = get(e2, "__clientExt.statistics.apiCallingTime") || 0, s2 = get(e2, "__clientExt.statistics.sendTime") || 0, n2 = get(e2, "__clientExt.statistics.attachUploadDuration") || 0, a2 = this.core.timeOrigin.getNTPTime(), o2 = e2.time, c2 = this.core.timeOrigin.checkNodeReliable(t2.__receiveTimeNode) ? this.core.timeOrigin.getNTPTime(t2.__receiveTimeNode) : a2;
            this.core.reporter.report("msgReceive", { msgId: e2.idServer, clientId: e2.idClient, serverTime: o2, receiveTime: c2, fromAccid: r2 ? e2.from : "", toAccid: e2.to, type: je[e2.scene], tid: r2 ? "" : e2.to, apiCallingTime: i2, sendTime: s2, attachUploadDuration: n2, callbackTime: a2, preHandleTime: a2, result: 200, failReason: "", rt: a2 - o2 });
          }
        }
        nimOnTeamMsgsHandler(e2) {
          e2.content.datas.forEach((t2) => {
            this.onMsgHandler(Object.assign({}, e2, { content: { msg: t2 } }));
          });
        }
        syncRoamingMsgsHandler(e2) {
          var t2, r2, i2 = e2.content.msgs || [];
          if (0 !== i2.length) {
            var s2 = getSessionId(i2[0], this.core.account), n2 = null === (t2 = this.core.session) || void 0 === t2 ? void 0 : t2.getSessionWithUncomplete({ id: s2 }), a2 = (i2 = formatMsgs$1(i2, n2 ? { account: this.core.account, featureValue: He.roam, sessionAck: n2.ack, msgReceiptTime: n2.msgReceiptTime } : { account: this.core.account, featureValue: He.roam }))[0].time, o2 = { timetag: a2, sessionId: s2, msgs: reverse(i2) };
            "function" != typeof (null === (r2 = this.core.sync) || void 0 === r2 ? void 0 : r2.getSyncDoneFlag) || this.core.sync.getSyncDoneFlag() || this.core.eventBus.emit("session/syncMsgs", o2), this.core.emit("syncRoamingMsgs", o2), "superTeam" === i2[0].scene ? this.core.eventBus.emit("sync/updateTimetag", { superTeamRoamingMsgs: a2 }) : this.core.eventBus.emit("sync/updateTimetag", { roamingMsgs: a2 });
          }
        }
        syncOfflineMsgsHandler(e2) {
          var t2 = e2.content.msgs || [];
          if (0 !== t2.length) {
            var r2 = {}, i2 = [];
            t2.forEach((e3) => {
              var t3 = getSessionId(e3, this.core.account), s3 = this.core.session.getSessionWithUncomplete({ id: t3 }), n2 = formatMsg$1(e3, s3 ? { account: this.core.account, featureValue: He.leave, sessionAck: s3.ack, msgReceiptTime: s3.msgReceiptTime } : { account: this.core.account, featureValue: He.leave });
              i2.push(n2), r2[n2.sessionId] ? r2[n2.sessionId].push(n2) : r2[n2.sessionId] = [n2];
            }), this.markMsgsAck(i2);
            var s2 = 0;
            Object.keys(r2).forEach((e3) => {
              var t3 = r2[e3].sort((e4, t4) => t4.time - e4.time);
              (t3 = removeDupMsgsByIdClient(t3))[0].time > s2 && (s2 = t3[0].time);
              var i3 = { timetag: t3[0].time, sessionId: e3, msgs: t3 };
              this.core.eventBus.emit("session/syncMsgs", i3), this.core.emit("syncOfflineMsgs", i3);
            }), this.core.eventBus.emit("sync/updateTimetag", { offlineMsgs: s2 });
          }
        }
        syncDeleteSelfMsgsHandler(e2) {
          var t2, r2 = null === (t2 = e2.content) || void 0 === t2 ? void 0 : t2.deletedMsgs;
          r2 && r2.length > 0 || this.logger.warn("syncDeleteSelfMsgs:: no msgs");
          var i2 = r2[r2.length - 1].time;
          this.core.eventBus.emit("sync/updateTimetag", { deleteSelfMsgs: i2 });
        }
        onDeleteSelfMsgHandler(e2) {
          var t2 = formatDeletedMsgs([e2.content.deletedMsg]);
          this.core.eventBus.emit("session/updateForDeletedMsg", t2), this.core.emit("deleteSelfMsgs", t2);
        }
        onDeleteSelfMsgsHandler(e2) {
          var t2 = formatDeletedMsgs(e2.content.deletedMsgs);
          this.core.eventBus.emit("session/updateForDeletedMsg", t2), this.core.emit("deleteSelfMsgs", t2);
        }
        onBroadcastMsgHandler(e2) {
          var t2 = e2.content.msg, r2 = this.service.processBroadcastMsg([t2]);
          this.core.emit("broadcastMsgs", r2);
        }
        syncBroadcastMsgHandler(e2) {
          var t2 = e2.content.msgs, r2 = this.service.processBroadcastMsg(t2);
          this.core.emit("broadcastMsgs", r2);
        }
      }, "msg"), NIM.registerService(class UserService extends Service$1 {
        constructor(e2) {
          super("user", e2), this.userInfoMap = /* @__PURE__ */ new Map(), this.myInfo = formatUser({}), registerParser({ cmdMap: Gt, cmdConfig: Wt });
        }
        setBlack(e2) {
          return validate({ account: { type: "string", allowEmpty: false }, isAdd: { type: "boolean" } }, e2), this.core.sendCmd("setBlack", e2).then(() => {
            this.core.eventBus.emit("forwardSend/user/updateBlackList", e2.account, e2.isAdd);
          });
        }
        setMute(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ account: { type: "string", allowEmpty: false }, isAdd: { type: "boolean" } }, e2), yield this.core.sendCmd("setMute", e2).then(() => {
            }), this.core.eventBus.emit("forwardSend/user/setMute", e2.account, e2.isAdd);
          });
        }
        getRelations() {
          return this.core.sendCmd("syncRelations", { timetag: 0 });
        }
        getBlackList() {
          return __awaiter(this, void 0, void 0, function* () {
            return (yield this.core.sendCmd("syncRelations", { timetag: 0 })).blackList || [];
          });
        }
        getMuteList() {
          return __awaiter(this, void 0, void 0, function* () {
            return (yield this.core.sendCmd("syncRelations", { timetag: 0 })).muteList || [];
          });
        }
        updatePushToken() {
          return __awaiter(this, void 0, void 0, function* () {
            this.logger.error("This function is deprecated, please use nim.offlinePush.setOfflinePushConfig instead");
          });
        }
        updateAppBackground() {
          return __awaiter(this, void 0, void 0, function* () {
            this.logger.error("This function is deprecated, please use nim.offlinePush.setOfflinePushConfig instead");
          });
        }
        getUsersNameCardFromServer(e2) {
          return validate({ accounts: { type: "array", max: 150, itemType: "string" } }, e2), this.core.sendCmd("getUsersNameCardFromServer", pick(e2, ["accounts"])).then((t2) => {
            var { content: r2 } = t2;
            return this.logger.log("user:: getUsers done", e2.accounts), r2 && r2.users ? r2.users.map((e3) => formatUser(e3)) : [];
          });
        }
        updateMyNameCard(e2) {
          if (validate({ nick: { type: "string", required: false }, avatar: { type: "string", required: false }, signature: { type: "string", required: false }, gender: { type: "enum", values: getEnumKeys(Et), required: false }, email: { type: "string", required: false }, birth: { type: "string", required: false }, tel: { type: "string", required: false }, ext: { type: "string", required: false } }, e2), 0 === Object.keys(e2).length)
            return Promise.resolve(this.myInfo);
          var t2 = pick(e2, ["nick", "avatar", "signature", "email", "birth", "tel", "ext"]);
          return e2.gender && (t2.gender = Et[e2.gender]), this.core.sendCmd("updateMyNameCard", { user: t2 }).then((r2) => {
            var { content: i2 } = r2;
            return i2 && i2.timetag && this.core.eventBus.emit("sync/updateTimetag", { myInfo: +i2.timetag }), e2.gender && (t2.gender = e2.gender), this.myInfo = Object.assign({}, this.myInfo, t2), this.core.eventBus.emit("forwardSend/user/updateUserInfo", t2), this.myInfo;
          });
        }
        checkUserUpdate(e2) {
          var t2 = e2.from;
          if (t2 !== this.core.account) {
            var r2 = this.userInfoMap.get(t2);
            if (r2) {
              var i2 = r2.updateTime, s2 = e2.userUpdateTime;
              !isNaN(i2) && !isNaN(s2) && "number" == typeof i2 && "number" == typeof s2 && i2 < s2 && this.refreshUserInfo(t2);
            } else
              this.refreshUserInfo(t2);
          }
        }
        refreshUserInfo(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            var t2 = yield this.getUsersNameCardFromServer({ accounts: [e2] });
            for (var r2 of t2)
              this.userInfoMap.set(r2.account, r2), this.core.emit("updateUserInfo", r2);
          });
        }
        onUpdateBlackListHandler(e2) {
          var { content: t2 } = e2;
          t2.account ? this.core.emit("updateBlackList", t2) : this.logger.warn("onUpdateBlackListHandler: no account");
        }
        onUpdateMuteListHandler(e2) {
          var { content: t2 } = e2;
          t2.account ? this.core.emit("updateMuteList", t2) : this.logger.warn("onUpdateBlackListHandler: no account");
        }
        syncRelationsHandler(e2) {
          var { content: t2 } = e2, { list: r2, timetag: i2 } = t2, s2 = { blackList: [], muteList: [] };
          return i2 && this.core.eventBus.emit("sync/updateTimetag", { relations: i2 }), r2 && r2.length && r2.forEach((e3) => {
            var t3 = function formatRelationMember(e4) {
              var t4 = { account: e4.account, updateTime: +e4.updateTime, createTime: +e4.createTime };
              return "1" === e4.isMuted && (t4.isMuted = true), "1" === e4.isBlack && (t4.isBlack = true), t4;
            }(e3);
            t3.isBlack && s2.blackList.push(t3), t3.isMuted && s2.muteList.push(t3);
          }), this.core.emit("relations", s2), Promise.resolve(s2);
        }
        syncMyNameCardHandler(e2) {
          e2.content.user && (this.myInfo = formatUser(e2.content.user), this.core.emit("syncMyNameCard", this.myInfo), this.core.eventBus.emit("sync/updateTimetag", { myInfo: e2.content.timetag }));
        }
        onUpdateMyNameCardHandler(e2) {
          var t2 = e2.content.user;
          t2 ? (Object.assign(this.myInfo, formatUser(t2)), this.core.emit("updateMyNameCard", this.myInfo)) : this.logger.warn("onUpdateMyNameCardHandler no user info");
        }
      }, "user"), NIM.registerService(class SessionService extends Service$1 {
        constructor(e2, t2) {
          super("session", e2), this.list = /* @__PURE__ */ new Map(), this.unreadCountFilterFn = (e3) => true, this.lastMessageFilterFn = (e3) => true, this.initEventListeners(), registerParser({ cmdMap: pr, cmdConfig: gr }), this.stickTopService = new StickTopService(e2), this.unreadModule = new UnreadModuleService(e2), t2 && this.setOptions(t2);
        }
        setOptions(e2) {
          "function" == typeof (null == e2 ? void 0 : e2.unreadCountFilterFn) && (this.unreadCountFilterFn = e2.unreadCountFilterFn), "function" == typeof (null == e2 ? void 0 : e2.lastMessageFilterFn) && (this.lastMessageFilterFn = e2.lastMessageFilterFn);
        }
        reset() {
          this.list.forEach((e2) => {
            e2.unreadMsgs = [];
          }), this.list.clear();
        }
        initEventListeners() {
          this.core.eventBus.on("session/syncMsgs", this.onSyncMsgs.bind(this)), this.core.eventBus.on("session/updateForNewMsg", this.updateSessionWithMsg.bind(this)), this.core.eventBus.on("session/updateForModifyMsg", this.updateSessionByModifyMsg.bind(this)), this.core.eventBus.on("session/updateForClearMsg", (e2, t2 = true) => {
            e2 && e2.length > 0 && e2.forEach((e3) => {
              this.updateSession({ id: e3.sessionId, lastMsg: null, unread: 0, unreadMsgs: [] }, t2);
            });
          }), this.core.eventBus.on("session/updateForDeletedMsg", this.updateSessionForDeletedMsg.bind(this));
        }
        createSession(e2, t2) {
          try {
            var { scene: r2, accid: i2 } = getAccountFromSessionId(e2);
            return { id: e2, scene: r2, to: i2, lastMsg: t2, updateTime: t2 ? t2.time : 0, unread: 0, unreadMsgs: [], ack: 0 };
          } catch (t3) {
            throw this.logger.error(`Failed to create session with ${e2}`, t3), new Error(`Failed to create session with ${e2}`);
          }
        }
        getSession(e2) {
          validate({ id: { type: "string", allowEmpty: false } }, e2);
          var t2 = this.list.get(e2.id);
          if (this.isSessionComplete(t2))
            return t2;
        }
        getSessionWithUncomplete(e2) {
          return this.list.get(e2.id);
        }
        getAllSessions() {
          var e2 = [];
          for (var [t2, r2] of this.list)
            this.isSessionComplete(r2) && e2.push(r2);
          return e2;
        }
        getSessions(e2) {
          validate({ limit: { type: "number", required: false }, lastSessionId: { type: "string", allowEmpty: false, required: false }, desc: { type: "boolean", required: false } }, e2);
          var t2 = [], { limit: r2 = 100, desc: i2 = true } = e2, { lastSessionId: s2 } = e2, n2 = 0;
          if (i2) {
            for (var [a2, o2] of this.list) {
              if (s2 === a2)
                break;
              this.isSessionComplete(o2) && t2.push(o2);
            }
            return t2.slice(-r2).reverse();
          }
          for (var [c2, d2] of this.list)
            if (s2)
              c2 === s2 && (s2 = void 0);
            else if (this.isSessionComplete(d2)) {
              if (++n2 > r2)
                break;
              t2.push(d2);
            }
          return t2;
        }
        resetSessionUnreadCount(e2) {
          var t2;
          return __awaiter(this, void 0, void 0, function* () {
            validate({ id: { type: "string", allowEmpty: false } }, e2), validate({ id: { type: "string", allowEmpty: false } }, e2);
            var r2 = e2.id, i2 = this.list.get(r2);
            if (!i2)
              throw this.logger.warn("resetSessionUnreadCount: can not find session " + r2), new Error("Session::canSessionResetUnreadCount: can not find session " + r2);
            var s2 = false;
            try {
              s2 = this.unreadModule.canSessionResetUnreadCount(i2);
            } catch (e3) {
              this.logger.warn(e3);
            }
            if (false !== s2) {
              var { accid: n2, scene: a2 } = getAccountFromSessionId(r2), o2 = { to: n2, timetag: (null === (t2 = null == i2 ? void 0 : i2.lastMsg) || void 0 === t2 ? void 0 : t2.time) || i2.updateTime || 0 }, c2 = "markSuperTeamSessionAck";
              return "superTeam" !== a2 && (o2.scene = "p2p" === a2 ? 0 : 1, c2 = "markSessionAck"), this.core.sendCmd(c2, o2).then(() => {
                var e3 = this.storeUnreadByAck(r2, o2.timetag);
                e3 && this.core.emit("updateSession", e3);
              });
            }
          });
        }
        resetMultiSessionUnreadCount(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ ids: { type: "array", itemType: "string", min: 1 } }, e2);
            var t2 = e2.ids.map((e3) => this.list.get(e3)).filter((t3, r3) => !!t3 || (this.logger.warn("Session::canSessionResetUnreadCount: can not find session " + e2.ids[r3]), false)), { superTeam: r2, p2pOrTeam: i2 } = this.unreadModule.filterSessionForResetUnreadCount(t2), s2 = chunk(r2.params, 50), n2 = chunk(i2.params, 50);
            for (var a2 of s2)
              yield this.core.sendCmd(r2.cmd, { datas: a2 }), a2.forEach((e3) => {
                var t3 = this.storeUnreadByAck(e3.sessionId, e3.timetag);
                t3 && this.core.emit("updateSession", t3);
              });
            for (var o2 of n2)
              yield this.core.sendCmd(i2.cmd, { datas: o2 }), o2.forEach((e3) => {
                var t3 = this.storeUnreadByAck(e3.sessionId, e3.timetag);
                t3 && this.core.emit("updateSession", t3);
              });
          });
        }
        resetAllSessionsUnreadCount() {
          var e2 = [];
          return this.list.forEach((t2) => {
            e2.push(t2.id);
          }), 0 === e2.length ? Promise.resolve() : this.resetMultiSessionUnreadCount({ ids: e2 });
        }
        deleteSession(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ id: { type: "string", allowEmpty: false }, isSyncToServer: { type: "boolean", required: false } }, e2), this.list.delete(e2.id), this.core.msgLog && e2.isSyncToServer && (yield this.core.msgLog.deleteRoamingMsgs({ ids: [e2.id] }));
          });
        }
        deleteAllSessionsFromLocal() {
          this.list.clear();
        }
        addStickTopSession(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            var t2 = yield this.stickTopService.addStickTopSession(e2);
            return this.list.set(t2.id, t2), t2;
          });
        }
        deleteStickTopSession(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            var t2 = yield this.stickTopService.deleteStickTopSession(e2);
            return this.list.set(t2.id, t2), t2;
          });
        }
        updateStickTopSession(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            var t2 = yield this.stickTopService.updateStickTopSession(e2);
            return this.list.set(t2.id, t2), t2;
          });
        }
        nimMultiSyncAddStickTopSessionHandler(e2) {
          var t2 = this.stickTopService.stickTopSessionHandler(e2.content.data);
          this.list.set(t2.id, t2), this.core.emit("updateSession", t2);
        }
        nimMultiSyncDeleteStickTopSessionHandler(e2) {
          var t2 = this.stickTopService.stickTopSessionHandler({ id: e2.content.data.id, updateTime: e2.content.timetag, ext: "" }, false);
          this.list.set(t2.id, t2), this.core.emit("updateSession", t2);
        }
        nimMultiSyncUpdateStickTopSessionHandler(e2) {
          var t2 = this.stickTopService.stickTopSessionHandler(e2.content.data);
          this.list.set(t2.id, t2), this.core.emit("updateSession", t2);
        }
        nimSyncStickTopSessionsHandler(e2) {
          if (this.core.eventBus.emit("sync/updateTimetag", { stickTopSessions: e2.content.timetag }), e2.content.isThereAnyChange) {
            var t2 = e2.content.datas, r2 = [];
            this.list.forEach((e3) => {
              var t3;
              e3 && (null === (t3 = null == e3 ? void 0 : e3.stickTopInfo) || void 0 === t3 ? void 0 : t3.isStickOnTop) && r2.push(e3);
            }), r2.forEach((e3) => {
              var r3 = e3.id, i2 = t2.find((e4) => {
                var { scene: t3, accid: i3 } = getAccountFromSessionId(e4.id, "|");
                return `${t3}-${i3}` === r3;
              });
              if (!i2) {
                var s2 = {}, { scene: n2, accid: a2 } = getAccountFromSessionId(r3, "-");
                s2.id = `${n2}|${a2}`, s2.ext = "", s2.isTop = false, t2.push(s2);
              }
            }), t2.forEach((e3) => {
              var t3;
              false === e3.isTop ? (delete e3.isTop, t3 = this.stickTopService.stickTopSessionHandler(e3, false)) : t3 = this.stickTopService.stickTopSessionHandler(e3), this.list.set(t3.id, t3);
            });
          }
        }
        updateSessionWithMsg(e2) {
          var t2, r2, i2 = true, s2 = true, n2 = "boolean" != typeof (null === (t2 = e2.pushInfo) || void 0 === t2 ? void 0 : t2.needPushBadge) || (null === (r2 = e2.pushInfo) || void 0 === r2 ? void 0 : r2.needPushBadge);
          try {
            i2 = !!this.unreadCountFilterFn(e2);
          } catch (e3) {
            this.logger.error("session:updateSessionWithMsg, unreadCountFilterFn error", e3);
          }
          try {
            s2 = !!this.lastMessageFilterFn(e2);
          } catch (e3) {
            this.logger.error("session:updateSessionWithMsg, lastMessageFilterFn error", e3);
          }
          var a2 = this.list.get(e2.sessionId) || this.createSession(e2.sessionId), o2 = false;
          if (this.logger.log("session:updateSessionWithMsg, pending ", e2.sessionId, e2.idClient, e2.idServer, s2, i2), s2 && (!a2.lastMsg || a2.lastMsg.time < e2.time || e2.status === Ge[Ge.sending] || a2.lastMsg.status === Ge[Ge.sending]) && (a2.lastMsg = e2, a2.updateTime = e2.time, o2 = true), i2 && n2 && e2.status === Ge[Ge.unread] && e2.time > (a2.ack || 0)) {
            a2.unread++;
            var c2 = a2.unreadMsgs || [];
            c2.unshift(e2), c2.sort((e3, t3) => t3.time - e3.time), a2.unreadMsgs = c2, o2 = true;
          }
          o2 && (this.logger.log("session:updateSessionWithMsg updating ", a2.id, a2.unread, a2.lastMsg && a2.lastMsg.idClient), this.list.set(a2.id, a2), this.core.emit("updateSession", a2));
        }
        updateSessionByModifyMsg(e2) {
          var t2 = this.list.get(e2.sessionId) || this.createSession(e2.sessionId), r2 = t2.unreadMsgs || [], i2 = r2.findIndex((t3) => t3.idClient === e2.idClient);
          i2 > -1 && (r2[i2] = e2), t2.unreadMsgs = r2, this.list.set(t2.id, t2);
          var s2 = true;
          try {
            s2 = !!this.lastMessageFilterFn(e2);
          } catch (e3) {
            this.logger.error("session:updateSessionByModifyMsg, lastMessageFilterFn error", e3);
          }
          s2 && (t2.lastMsg && t2.lastMsg.idClient !== e2.idClient || (t2.lastMsg = e2, t2.updateTime = e2.time, this.logger.log("session:updateSessionByModifyMsg updating ", t2.id, t2.unread, t2.lastMsg && t2.lastMsg.idClient), this.list.set(t2.id, t2), this.core.emit("updateSession", t2)));
        }
        storeUnreadByAck(e2, t2) {
          var r2 = this.list.get(e2) || this.createSession(e2);
          if (!(r2.ack && t2 < r2.ack)) {
            var i2 = r2.unreadMsgs || [], s2 = [], n2 = [], a2 = 0;
            return r2.unreadMsgs = [], i2.length > 0 && (i2.forEach((e3) => {
              n2.includes(e3.idClient) || e3.time > t2 && (a2++, n2.push(e3.idClient), s2.push(e3));
            }), r2.unreadMsgs = s2.sort((e3, t3) => t3.time - e3.time)), r2.ack = t2, r2.unread = a2, r2.lastMsg && "unread" === r2.lastMsg.status && t2 >= r2.lastMsg.time && (r2.lastMsg.status = "read"), this.list.set(e2, r2), r2;
          }
          this.logger.warn("storeUnreadByAck: not need update ack", e2, t2, r2.ack);
        }
        updateSession(e2, t2 = true) {
          var r2 = e2.id, i2 = this.list.get(r2) || this.createSession(e2.id), s2 = Object.assign(i2, e2);
          return this.list.set(r2, s2), this.logger.log("updateSession: update", t2, pick(e2, ["id", "ack", "unread"]), s2.lastMsg && s2.lastMsg.idClient), t2 && this.core.emit("updateSession", s2), s2;
        }
        isSessionComplete(e2) {
          return !!e2 && (!!(e2.id && e2.scene && e2.to) && void 0 !== e2.lastMsg);
        }
        syncSessionAckHandler(e2) {
          var t2 = e2.content.p2p || {}, r2 = e2.content.team.m_map || {};
          this.logger.log("syncSessionAck::", t2, r2), Object.keys(t2).forEach((e3) => {
            this.updateSession({ id: "p2p-" + e3, ack: t2[e3] }, false);
          }), Object.keys(r2).forEach((e3) => {
            this.updateSession({ id: "team-" + e3, ack: r2[e3] }, false);
          });
        }
        syncSuperTeamSessionAckHandler(e2) {
          var t2 = e2.content.superTeam.m_map;
          this.logger.log("syncSuperTeamSessionAck::", t2), Object.keys(t2).forEach((e3) => {
            this.updateSession({ id: "superTeam-" + e3, ack: t2[e3] }, false);
          });
        }
        syncMarkSessionAckHandler(e2) {
          var t2 = e2.content, r2 = `${0 === t2.scene ? "p2p" : 1 === t2.scene ? "team" : "superTeam"}-${t2.to}`, i2 = this.list.get(r2);
          if (i2 && i2.ack && t2.timetag < i2.ack)
            this.logger.warn(`syncMarkSessionAckHandler: ${r2} do not need update ack`, i2.ack, t2.timetag);
          else {
            var s2 = this.storeUnreadByAck(r2, t2.timetag);
            s2 && this.core.emit("updateSession", s2);
          }
        }
        syncMarkSuperTeamSessionAckHandler(e2) {
          e2.content.scene = 5, this.syncMarkSessionAckHandler(e2);
        }
        onSyncDone() {
          var e2 = [];
          this.list.forEach((t2, r2) => {
            e2.push(this.storeUnreadByAck(r2, t2.ack || 0));
          }), this.list.clear(), e2.sort((e3, t2) => e3.updateTime - t2.updateTime).forEach((e3) => {
            this.list.set(e3.id, e3);
          }), (e2 = e2.filter((e3) => this.isSessionComplete(e3)).sort((e3, t2) => t2.updateTime - e3.updateTime)).length > 0 && this.core.emit("sessions", e2);
        }
        onSyncMsgs(e2) {
          var t2 = this.list.get(e2.sessionId), r2 = [];
          try {
            r2 = e2.msgs.filter((e3) => {
              var t3, r3, i3 = "boolean" != typeof (null === (t3 = e3.pushInfo) || void 0 === t3 ? void 0 : t3.needPushBadge) || (null === (r3 = e3.pushInfo) || void 0 === r3 ? void 0 : r3.needPushBadge);
              return this.unreadCountFilterFn(JSON.parse(JSON.stringify(e3))) && i3;
            });
          } catch (e3) {
            this.logger.error("session:onSyncMsgs, unreadCountFilterFn error ", e3);
          }
          var i2, s2 = [];
          try {
            s2 = e2.msgs.filter((e3) => this.lastMessageFilterFn(JSON.parse(JSON.stringify(e3))));
          } catch (e3) {
            this.logger.error("session:onSyncMsgs, lastMessageFilterFn error ", e3);
          }
          s2 && s2.length > 0 && (i2 = s2[s2.length - 1], i2 = s2[0].time > i2.time ? s2[0] : i2);
          var n2 = i2 ? i2.time : 0;
          t2 || (t2 = i2 ? this.createSession(e2.sessionId, i2) : this.createSession(e2.sessionId)), t2.unreadMsgs = t2.unreadMsgs ? r2.concat(t2.unreadMsgs).filter((e3) => e3.status === Ge[Ge.unread]) : r2.filter((e3) => e3.status === Ge[Ge.unread]), t2.updateTime && t2.updateTime >= n2 || (t2.updateTime = n2), t2.lastMsg && t2.lastMsg.time >= n2 || (t2.lastMsg = i2), this.list.set(t2.id, t2);
        }
        updateSessionForDeletedMsg(e2) {
          var t2 = {};
          e2.forEach((e3) => {
            var r2 = e3.to === this.core.account ? e3.from : e3.to, i2 = `${e3.scene}-${r2}`, s2 = this.list.get(i2);
            if (s2) {
              var n2 = s2.unreadMsgs.some((t3) => t3.idClient === e3.idClient), a2 = true;
              try {
                a2 = !!this.unreadCountFilterFn(e3);
              } catch (e4) {
                this.logger.error("session:updateSessionForDeletedMsg, unreadCountFilterFn error", e4);
              }
              var o2 = s2.ack || 0;
              if (a2 && n2 && o2 < e3.time && e3.from !== this.core.account && s2.unread > 0 && (s2.unread = s2.unread - 1, s2.unreadMsgs && s2.unreadMsgs.length > 0)) {
                var c2 = function findIndex(e4, t3) {
                  e4 = e4 || [], t3 = t3 || {};
                  for (var r3 = 0; r3 < e4.length; r3++) {
                    var i3 = true;
                    for (var s3 in t3)
                      if (e4[r3][s3] !== t3[s3]) {
                        i3 = false;
                        break;
                      }
                    if (i3)
                      return r3;
                  }
                  return -1;
                }(s2.unreadMsgs, { idClient: e3.idClient });
                c2 >= 0 && s2.unreadMsgs.splice(c2, 1);
              }
              s2.lastMsg && s2.lastMsg.idClient === e3.idClient && (s2.lastMsg = null), t2[s2.id] = true;
            }
          }), Object.keys(t2).forEach((e3) => {
            var t3 = this.list.get(e3);
            t3 && this.core.emit("updateSession", t3);
          });
        }
        multiSyncMsgReceiptHandler(e2) {
          var t2, r2 = null === (t2 = e2.content) || void 0 === t2 ? void 0 : t2.msgReceiptTag;
          if (r2) {
            this.updateSessionMsgReceiptTime([r2], true), r2.msgReceiptTime = r2.time, r2.sessionId = `p2p-${r2.from}`;
            var i2 = __rest(r2, ["time", "from"]);
            this.core.emit("msgReceipts", [i2]);
          }
        }
        syncMsgReceiptsHandler(e2) {
          var t2, r2 = null === (t2 = e2.content) || void 0 === t2 ? void 0 : t2.msgReceipts;
          r2 && this.updateSessionMsgReceiptTime(r2, false);
        }
        updateSessionMsgReceiptTime(e2, t2 = true) {
          e2 && e2.length > 0 && e2.forEach((e3) => {
            var r2 = this.list.get(`p2p-${e3.from}`);
            r2 || (r2 = this.createSession(`p2p-${e3.from}`));
            var i2 = parseInt(e3.time);
            r2.msgReceiptTime && r2.msgReceiptTime >= i2 || (r2.msgReceiptTime = i2, r2.lastMsg && "sent" === r2.lastMsg.status && i2 >= r2.lastMsg.time && (r2.lastMsg.status = "receipt"), this.logger.log(`session: update session ${r2.id} msgReceiptTime: ${r2.msgReceiptTime}`), this.list.set(r2.id, r2), t2 && this.core.emit("updateSession", r2));
          });
        }
      }, "session"), NIM.registerService(class TeamService extends Service$1 {
        constructor(e2) {
          super("team", e2), this.myTeamMembersMap = /* @__PURE__ */ new Map(), this.service = new ModuleService$1(e2), this.setListeners(), registerParser({ cmdMap: Bt, cmdConfig: $t });
        }
        setListeners() {
          this.core.eventBus.on("forwardReceive/team/updateMyMemberInfo", (e2) => {
            this.emitMemberUpdate(e2);
          }), this.core.eventBus.on("team/onNotification", (e2) => this.notificationHandler(e2));
        }
        reset() {
          this.myTeamMembersMap.clear();
        }
        mergeMyTeamMembers(e2) {
          e2.forEach((e3) => {
            var t2 = e3.teamId, r2 = this.myTeamMembersMap.get(t2), i2 = Object.assign({}, r2, e3);
            this.myTeamMembersMap.set(t2, i2);
          });
        }
        getTeamInfo(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ teamId: { type: "string", regExp: /\d+/, allowEmpty: false } }, e2), formatTeam((yield this.core.sendCmd("getTeamInfo", { teamId: e2.teamId })).content.team);
          });
        }
        getTeams() {
          return __awaiter(this, void 0, void 0, function* () {
            return formatTeams((yield this.core.sendCmd("getTeams", { timetag: 0 })).content.teams);
          });
        }
        getTeamsById(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ teamIds: { type: "array", itemType: "string" } }, e2);
            var t2 = yield this.core.sendCmd("getTeamsById", { teamIds: e2.teamIds });
            return { teams: formatTeams(t2.content.teams), tids: t2.content.tids };
          });
        }
        createTeam(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ type: { type: "enum", values: ["advanced", "normal"] }, name: { type: "string", allowEmpty: false }, level: { type: "number", required: false }, accounts: { type: "array", itemType: "string", required: false }, ps: { type: "string", allowEmpty: true, max: 5e3, required: false }, joinMode: { type: "enum", values: ["noVerify", "needVerify", "rejectAll"], required: false }, beInviteMode: { type: "enum", values: ["noVerify", "needVerify"], required: false }, inviteMode: { type: "enum", values: ["manager", "all"], required: false }, updateTeamMode: { type: "enum", values: ["manager", "all"], required: false }, updateExtMode: { type: "enum", values: ["manager", "all"], required: false }, intro: { type: "string", allowEmpty: true, required: false }, announcement: { type: "string", allowEmpty: true, required: false }, avatar: { type: "string", allowEmpty: true, required: false }, ext: { type: "string", allowEmpty: true, required: false } }, e2);
            var t2 = generateTeam(e2), r2 = formatTeam((yield this.core.sendCmd("createTeam", { team: t2, accounts: e2.accounts || [], ps: e2.ps || "" })).content.team);
            return this.core.eventBus.emit("forwardSend/team/created", r2), r2;
          });
        }
        dismissTeam(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ teamId: { type: "string", regExp: /\d+/, allowEmpty: false } }, e2), yield this.core.sendCmd("dismissTeam", { teamId: e2.teamId });
          });
        }
        leaveTeam(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ teamId: { type: "string", regExp: /\d+/, allowEmpty: false } }, e2), yield this.core.sendCmd("leaveTeam", { teamId: e2.teamId });
          });
        }
        transferTeam(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ teamId: { type: "string", regExp: /\d+/, allowEmpty: false }, account: { type: "string", allowEmpty: false }, leave: { type: "boolean" } }, e2), yield this.core.sendCmd("transferTeam", e2);
          });
        }
        updateTeamInfo(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ teamId: { type: "string", regExp: /\d+/, allowEmpty: false }, joinMode: { type: "enum", values: ["noVerify", "needVerify", "rejectAll"], required: false }, beInviteMode: { type: "enum", values: ["noVerify", "needVerify"], required: false }, inviteMode: { type: "enum", values: ["manager", "all"], required: false }, updateTeamMode: { type: "enum", values: ["manager", "all"], required: false }, updateExtMode: { type: "enum", values: ["manager", "all"], required: false }, intro: { type: "string", allowEmpty: true, required: false }, announcement: { type: "string", allowEmpty: true, required: false }, avatar: { type: "string", allowEmpty: true, required: false }, ext: { type: "string", allowEmpty: true, required: false } }, e2);
            var t2 = generateTeam(e2);
            return yield this.core.sendCmd("updateTeamInfo", { team: t2 }), formatTeam(t2);
          });
        }
        getTeamMembers(e2) {
          var t2;
          return __awaiter(this, void 0, void 0, function* () {
            validate({ teamId: { type: "string", regExp: /\d+/, allowEmpty: false }, accounts: { type: "array", itemType: "string", required: false } }, e2);
            var r2 = yield this.core.sendCmd("getTeamMembers", { teamId: e2.teamId, timetag: 0 }), i2 = formatTeamMembers(null === (t2 = r2.content) || void 0 === t2 ? void 0 : t2.teamMembers);
            return e2.accounts && e2.accounts.length > 0 ? i2.filter((t3) => {
              var r3;
              return null === (r3 = e2.accounts) || void 0 === r3 ? void 0 : r3.includes(t3.account);
            }) : i2;
          });
        }
        getMutedTeamMembers(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ teamId: { type: "string", regExp: /\d+/, allowEmpty: false } }, e2), formatTeamMembers((yield this.core.sendCmd("getMutedTeamMembers", { teamId: e2.teamId })).content.teamMembers);
          });
        }
        addTeamMembers(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ teamId: { type: "string", regExp: /\d+/, allowEmpty: false }, accounts: { type: "array", itemType: "string", min: 1 }, ps: { type: "string", allowEmpty: true, max: 5e3, required: false } }, e2), yield this.core.sendCmd("addTeamMembers", { teamId: e2.teamId, accounts: e2.accounts, ps: e2.ps || "", attach: e2.ext || "" });
          });
        }
        removeTeamMembers(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ teamId: { type: "string", regExp: /\d+/, allowEmpty: false }, accounts: { type: "array", itemType: "string", min: 1 } }, e2), yield this.core.sendCmd("removeTeamMembers", { teamId: e2.teamId, accounts: e2.accounts });
          });
        }
        applyTeam(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ teamId: { type: "string", regExp: /\d+/, allowEmpty: false }, ps: { type: "string", allowEmpty: true, max: 5e3, required: false } }, e2), formatTeam((yield this.core.sendCmd("applyTeam", { teamId: e2.teamId, ps: e2.ps || "" })).content.team);
          });
        }
        addTeamManagers(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ teamId: { type: "string", regExp: /\d+/, allowEmpty: false }, accounts: { type: "array", min: 1, itemType: "string" } }, e2), yield this.core.sendCmd("addTeamManagers", e2);
          });
        }
        removeTeamManagers(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ teamId: { type: "string", regExp: /\d+/, allowEmpty: false }, accounts: { type: "array", min: 1, itemType: "string" } }, e2), yield this.core.sendCmd("removeTeamManagers", e2);
          });
        }
        updateMyMemberInfo(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ teamId: { type: "string", regExp: /\d+/, allowEmpty: false }, nickInTeam: { type: "string", allowEmpty: true, required: false }, bitConfigMask: { type: "number", min: 0, max: 2, required: false }, ext: { type: "string", required: false } }, e2);
            var t2 = generatorTeamMemberForCmd({ teamId: e2.teamId, nickInTeam: e2.nickInTeam, bitConfigMask: e2.bitConfigMask, ext: e2.ext });
            yield this.core.sendCmd("updateMyMemberInfo", { teamMember: t2 });
            var r2 = formatTeamMember(Object.assign({ updateTime: (/* @__PURE__ */ new Date()).getTime(), account: this.core.account }, t2)), i2 = this.emitMemberUpdate(r2);
            return this.core.eventBus.emit("forwardSend/team/updateMyMemberInfo", i2), r2;
          });
        }
        emitMemberUpdate(e2) {
          e2 = formatTeamMember(e2), this.mergeMyTeamMembers([e2]), this.core.emit("updateTeamMember", e2);
          var t2 = cloneDeep(this.myTeamMembersMap.get(e2.teamId));
          return this.core.emit("myTeamMembers", [t2]), t2;
        }
        updateMemberNick(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ teamId: { type: "string", regExp: /\d+/, allowEmpty: false }, account: { type: "string", allowEmpty: false }, nickInTeam: { type: "string", allowEmpty: true } }, e2);
            var t2 = generatorTeamMemberForCmd({ teamId: e2.teamId, nickInTeam: e2.nickInTeam, account: e2.account });
            return yield this.core.sendCmd("updateNickInTeam", { teamMember: t2 }), formatTeamMember(Object.assign({ updateTime: (/* @__PURE__ */ new Date()).getTime() }, t2));
          });
        }
        muteTeamMember(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ teamId: { type: "string", regExp: /\d+/, allowEmpty: false }, account: { type: "string", allowEmpty: false }, mute: { type: "boolean" } }, e2), yield this.core.sendCmd("muteTeamMember", { teamId: e2.teamId, account: e2.account, mute: e2.mute ? 1 : 0 });
          });
        }
        getTeamMemberInvitorAccid(e2) {
          var t2;
          return __awaiter(this, void 0, void 0, function* () {
            validate({ teamId: { type: "string", regExp: /\d+/, allowEmpty: false }, accounts: { type: "array", itemType: "string", max: 200 } }, e2);
            var r2 = { teamId: e2.teamId };
            e2.accounts && e2.accounts.length > 0 && (r2.accounts = e2.accounts);
            var i2 = yield this.core.sendCmd("getTeamMemberInvitorAccid", r2);
            return (null === (t2 = i2.content) || void 0 === t2 ? void 0 : t2.accountsMap) || {};
          });
        }
        muteTeam(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ teamId: { type: "string", regExp: /\d+/, allowEmpty: false }, mute: { type: "boolean" } }, e2), yield this.core.sendCmd("muteTeam", { teamId: e2.teamId, mute: e2.mute ? 1 : 0 });
          });
        }
        passTeamApply(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ teamId: { type: "string", regExp: /\d+/, allowEmpty: false }, from: { type: "string", allowEmpty: false } }, e2);
            try {
              yield this.core.sendCmd("passTeamApply", e2), this.core.eventBus.emit("forwardSend/team/passTeamApply", e2);
            } catch (r2) {
              var t2 = r2;
              throw this.core.eventBus.emit("forwardSend/team/passTeamApply", e2, null == t2 ? void 0 : t2.code), r2;
            }
          });
        }
        rejectTeamApply(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ teamId: { type: "string", regExp: /\d+/, allowEmpty: false }, from: { type: "string", allowEmpty: false }, ps: { type: "string", max: 5e3, required: false } }, e2);
            try {
              yield this.core.sendCmd("rejectTeamApply", { teamId: e2.teamId, from: e2.from, ps: e2.ps || "" }), this.core.eventBus.emit("forwardSend/team/rejectTeamApply", e2);
            } catch (r2) {
              var t2 = r2;
              throw this.core.eventBus.emit("forwardSend/team/rejectTeamApply", e2, null == t2 ? void 0 : t2.code), r2;
            }
          });
        }
        acceptTeamInvite(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ teamId: { type: "string", regExp: /\d+/, allowEmpty: false }, from: { type: "string", allowEmpty: false } }, e2);
            try {
              yield this.core.sendCmd("acceptTeamInvite", e2), this.core.eventBus.emit("forwardSend/team/acceptTeamInvite", e2);
            } catch (r2) {
              var t2 = r2;
              throw this.core.eventBus.emit("forwardSend/team/acceptTeamInvite", e2, null == t2 ? void 0 : t2.code), r2;
            }
          });
        }
        rejectTeamInvite(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ teamId: { type: "string", regExp: /\d+/, allowEmpty: false }, from: { type: "string", allowEmpty: false }, ps: { type: "string", max: 5e3, required: false } }, e2);
            try {
              yield this.core.sendCmd("rejectTeamInvite", { teamId: e2.teamId, from: e2.from, ps: e2.ps || "" }), this.core.eventBus.emit("forwardSend/team/rejectTeamInvite", e2);
            } catch (r2) {
              var t2 = r2;
              throw this.core.eventBus.emit("forwardSend/team/rejectTeamInvite", e2, null == t2 ? void 0 : t2.code), r2;
            }
          });
        }
        notifyTeamMsgReceiptsHandler(e2) {
          var t2, r2 = null === (t2 = e2.content) || void 0 === t2 ? void 0 : t2.teamMsgReceipts;
          r2 && r2.length > 0 && (this.core.emit("teamMsgReceipts", r2), this.core.emit("msgReceipts", r2));
        }
        syncTeamsHandler(e2) {
          var t2 = e2.content;
          this.core.eventBus.emit("sync/updateTimetag", { teams: parseInt(t2.timetag) });
          var r2 = null == t2 ? void 0 : t2.teams;
          if (r2 && r2.length) {
            var i2 = formatTeams(r2);
            this.core.emit("teams", i2);
          }
        }
        syncCreateTeamHandler(e2) {
          var t2 = e2.content, r2 = formatTeam(null == t2 ? void 0 : t2.team), i2 = generatorMemberByTeam(r2, r2.owner, "owner");
          this.core.emit("createTeam", r2, i2);
        }
        syncUpdateTeamMemberHandler(e2) {
          var t2 = e2.content, r2 = formatTeamMember(null == t2 ? void 0 : t2.teamMember);
          r2.updateTime || (r2.updateTime = (/* @__PURE__ */ new Date()).getTime()), this.mergeMyTeamMembers([r2]), this.core.emit("updateTeamMember", r2);
          var i2 = cloneDeep(this.myTeamMembersMap.get(r2.teamId));
          this.core.emit("myTeamMembers", [i2]);
        }
        syncMyTeamMembersHandler(e2) {
          var t2 = e2.content;
          this.core.eventBus.emit("sync/updateTimetag", { myTeamMembers: parseInt(t2.timetag) });
          var r2 = null == t2 ? void 0 : t2.teamMembers.map((e3) => formatTeamMember(e3));
          this.mergeMyTeamMembers(r2), this.core.emit("myTeamMembers", cloneDeep(r2));
        }
        notificationHandler(e2) {
          var { attach: t2, scene: r2, from: i2, to: s2, time: n2, idServer: a2, idClient: o2 } = e2, { team: c2, account: d2, accounts: l2, type: m2 } = t2;
          if ("team" === r2)
            switch (this.logger.getDebugMode() ? this.logger.debug("team::recvNotification", a2, o2, t2) : this.logger.log("team::recvNotification", a2, o2, s2, m2, d2, l2), m2) {
              case "updateTeam":
                c2.updateTime = n2, this.core.emit("updateTeam", c2);
                break;
              case "addTeamMembers":
                this.service.notifyAddTeamMembers(c2, l2);
                break;
              case "acceptTeamInvite":
                this.service.notifyAddTeamMembers(c2, [i2]);
                break;
              case "passTeamApply":
                this.service.notifyAddTeamMembers(c2, [d2]);
                break;
              case "addTeamManagers":
                this.service.notifyUpdateTeamManagers(s2, l2, true, n2);
                break;
              case "removeTeamManagers":
                this.service.notifyUpdateTeamManagers(s2, l2, false, n2);
                break;
              case "removeTeamMembers":
                this.service.notifyRemoveTeamMembers(c2, l2);
                break;
              case "leaveTeam":
                this.service.notifyRemoveTeamMembers(c2, [i2]);
                break;
              case "dismissTeam":
                this.core.emit("dismissTeam", { teamId: s2 });
                break;
              case "transferTeam":
                this.service.notifyTransferTeam(c2, i2, d2);
                break;
              case "updateTeamMemberMute":
                this.service.notifyUpdateTeamMembersMute(c2, [d2], t2.mute);
            }
        }
      }, "team"), NIM.registerService(class SystemMessageService extends Service$1 {
        constructor(e2) {
          super("systemMessage", e2), this.sysMsgUnread = { total: 0, friend: 0, msg: 0, team: 0, superTeam: 0 }, this.core.eventBus.on("logined", () => {
            this.initEventListeners();
          }), registerParser({ cmdMap: yr, cmdConfig: Mr });
        }
        initEventListeners() {
          this.core.eventBus.on("systemMessage/passFriendApply", (e2) => {
            this.core.emit("updateSystemMessages", [{ idServer: e2.idServer, from: e2.account, state: "pass", type: "friendRequest" }]);
          }), this.core.eventBus.on("systemMessage/rejectFriendApply", (e2) => {
            this.core.emit("updateSystemMessages", [{ idServer: e2.idServer, from: e2.account, state: "decline", type: "friendRequest" }]);
          });
        }
        doMarkSysMsgAck(e2) {
          var t2 = [], r2 = [], i2 = ["customSuperTeam"];
          e2.forEach((e3) => {
            e3.idServer && (i2.includes(e3.type) ? r2.push(e3.idServer) : t2.push(e3.idServer));
          }), t2.length > 0 && this.core.sendCmd("batchMarkRead", { sid: "7", cid: "3", ids: t2 }), r2.length > 0 && this.core.sendCmd("batchMarkRead", { sid: "21", cid: "19", ids: r2 });
        }
        sendCustomSysMsg(e2) {
          validate({ to: { type: "string", allowEmpty: false }, type: { type: "enum", values: ["customP2p", "customTeam", "customSuperTeam"] }, attach: { type: "string", allowEmpty: false }, setting: { type: "object", rules: { needSaveOffline: { type: "boolean", required: false }, env: { type: "string", allowEmpty: false, required: false } }, required: false }, pushInfo: { type: "object", required: false, rules: tr } }, e2);
          var t2 = "customSuperTeam" === e2.type ? "sendSuperTeamCustomSysMsg" : "sendCustomSysMsg";
          return this.core.sendCmd(t2, { sysMsg: generatorSysMsgForCmd$1(e2) }).then(() => {
            this.logger.log("sendCustomSysMsg success");
          }).catch((e3) => {
            throw this.logger.error("sendCustomSysMsg failed", e3.message), e3;
          });
        }
        onSysMsgHandler(e2) {
          var t2, r2 = null === (t2 = e2.content) || void 0 === t2 ? void 0 : t2.sysMsg;
          if (r2) {
            var i2 = formatSystemMessage(r2 = fillIdServer(e2, e2.content.sysMsg, "idServer"), this.logger, Zt.default);
            this.core.emit("sysMsg", i2), this.doMarkSysMsgAck([i2]);
          } else
            this.logger.warn("onSysMsg no content.sysMsg");
        }
        syncOfflineSysMsgsHandler(e2) {
          if (e2.content.sysMsgs && e2.content.sysMsgs.length > 0) {
            var t2 = e2.content.sysMsgs.map((e3) => formatSystemMessage(e3, this.logger, Zt.leave));
            this.core.emit("syncSysMsgs", t2), this.doMarkSysMsgAck(t2);
          }
        }
        onRecallMsgHandler(e2) {
          var t2, r2 = null === (t2 = e2.content) || void 0 === t2 ? void 0 : t2.sysMsg;
          if (r2) {
            var i2 = formatDeletedMsgs([r2 = fillIdServer(e2, e2.content.sysMsg, "idServer")], getSceneFromRecallSysMsg(+r2.type));
            this.core.eventBus.emit("session/updateForDeletedMsg", i2);
            var s2 = formatSystemMessage(r2, this.logger, Zt.default);
            this.core.emit("sysMsg", s2), this.doMarkSysMsgAck([s2]);
          } else
            this.logger.warn("onSysMsg no content.sysMsg");
        }
        syncRecallMsgOfflineAndRoamingHandler(e2) {
          var { timetag: t2, type: r2, sysMsgs: i2 } = e2.content, s2 = parseInt(r2), n2 = 1 === s2 ? Zt.leave : Zt.roam, a2 = i2.map((e3) => formatSystemMessage(e3, this.logger, n2));
          1 === s2 && this.doMarkSysMsgAck(a2), this.core.eventBus.emit("sync/updateTimetag", { recallMsg: t2 }), this.core.emit("syncSysMsgs", a2);
        }
      }, "systemMessage"), NIM.registerService(class FriendService extends Service$1 {
        constructor(e2) {
          super("friend", e2), registerParser({ cmdMap: Tr, cmdConfig: Er });
        }
        getFriends() {
          var e2;
          return __awaiter(this, void 0, void 0, function* () {
            var t2 = yield this.core.sendCmd("getFriends", { timetag: 0 }), r2 = (null === (e2 = t2.content) || void 0 === e2 ? void 0 : e2.friends) || [];
            return r2 = r2.map((e3) => reverseFriend(e3));
          });
        }
        addFriend(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ account: { type: "string", allowEmpty: false }, ps: { type: "string", allowEmpty: false, required: false } }, e2), yield this.core.sendCmd("friendReuqest", { account: e2.account, type: 1, ps: e2.ps || "" });
            var t2 = (/* @__PURE__ */ new Date()).getTime();
            return this.core.eventBus.emit("forwardSend/friend/addFriend", e2.account), { account: e2.account, createTime: t2, updateTime: t2, valid: true, source: 0, passRelationShip: 1, relationShip: 1, bitsExtension: 0 };
          });
        }
        applyFriend(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ account: { type: "string", allowEmpty: false } }, e2), yield this.core.sendCmd("friendReuqest", { account: e2.account, type: 2, ps: e2.ps || "" });
          });
        }
        passFriendApply(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ account: { type: "string", allowEmpty: false } }, e2);
            try {
              yield this.core.sendCmd("friendReuqest", { account: e2.account, type: 3, ps: e2.ps || "" }).then((t2) => (this.core.eventBus.emit("systemMessage/passFriendApply", e2), t2)), this.core.eventBus.emit("forwardSend/friend/passFriendApply", e2.account);
            } catch (t2) {
              throw this.core.eventBus.emit("forwardSend/friend/passFriendApply", e2.account, t2), t2;
            }
          });
        }
        rejectFriendApply(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ account: { type: "string", allowEmpty: false } }, e2);
            try {
              yield this.core.sendCmd("friendReuqest", { account: e2.account, type: 4, ps: e2.ps || "" }).then((t2) => (this.core.eventBus.emit("systemMessage/rejectFriendApply", e2), t2)), this.core.eventBus.emit("forwardSend/friend/rejectFriendApply", e2.account, e2.ps);
            } catch (t2) {
              throw this.core.eventBus.emit("forwardSend/friend/rejectFriendApply", e2.account, e2.ps, t2), t2;
            }
          });
        }
        deleteFriend(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ account: { type: "string", allowEmpty: false }, delAlias: { type: "boolean" } }, e2), yield this.core.sendCmd("deleteFriend", { account: e2.account, delFriendParams: { delAlias: true === e2.delAlias ? 1 : 0 } }), this.core.eventBus.emit("forwardSend/friend/deleteFriend", e2.account);
          });
        }
        updateFriend(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ account: { type: "string", allowEmpty: false }, alias: { type: "string" }, ext: { type: "string", required: false } }, e2), yield this.core.sendCmd("updateFriend", { updateFriendTag: e2 }), this.core.eventBus.emit("forwardSend/friend/updateFriend", e2);
          });
        }
        syncFriendRequestHandler(e2) {
          var t2 = function formatFriendRequest(e3) {
            var t3 = Object.assign({}, e3);
            try {
              t3.ps = t3.ps && JSON.parse(t3.ps);
            } catch (e4) {
            }
            if (t3.type = Sr[t3.type], "addFriend" === t3.type || "passFriendApply" === t3.type) {
              var r2 = (/* @__PURE__ */ new Date()).getTime();
              t3.friend = { account: e3.account, alias: "", createTime: r2, ext: "", updateTime: r2, valid: true };
            }
            return t3;
          }(e2.content);
          this.core.emit("syncFriend", t2);
        }
        syncDeleteFriendHandler(e2) {
          var t2 = e2.content.account;
          this.logger.log(`friend::emit syncFriendAction: deleteFriend ${t2}`), this.core.emit("syncFriend", { type: "deleteFriend", account: t2 });
        }
        syncUpdateFriendHandler(e2) {
          var t2 = reverseFriend(e2.content.friend);
          this.logger.log("friend::emit syncFriendAction: updateFriend, ", null == t2 ? void 0 : t2.account), this.core.emit("syncFriend", { type: "updateFriend", friend: t2 });
        }
        syncFriendsHandler(e2) {
          var t2 = e2.content;
          this.core.eventBus.emit("sync/updateTimetag", { friends: parseInt(t2.timetag) });
          var r2 = null == t2 ? void 0 : t2.friends;
          if (r2 && r2.length) {
            var i2 = r2.map((e3) => reverseFriend(e3));
            this.core.emit("friends", i2);
          }
        }
        syncFriendUsersHandler(e2) {
          var t2 = e2.content;
          this.core.eventBus.emit("sync/updateTimetag", { friendUsers: parseInt(t2.timetag) });
          var r2 = null == t2 ? void 0 : t2.users;
          if (r2 && r2.length) {
            var i2 = r2.map((e3) => formatUser(e3));
            this.core.emit("users", i2);
          }
        }
      }, "friend"), NIM.registerService(class EventService extends Service$1 {
        constructor(e2) {
          super("event", e2), registerParser({ cmdMap: br, cmdConfig: Ar });
        }
        publishEvent(e2) {
          var t2;
          return __awaiter(this, void 0, void 0, function* () {
            validate({ type: { type: "number" }, value: { type: "number" }, ext: { type: "string", required: false }, validTime: { type: "number", min: 60, max: 2592e3, required: false }, broadcastType: { type: "number", required: false }, sync: { type: "boolean", required: false } }, e2);
            var r2 = Object.assign(Object.assign({ validTime: e2.validTime || 604800, broadcastType: e2.broadcastType || 2 }, e2), { idClient: Ie(), sync: true === e2.sync ? 1 : 0 }), i2 = yield this.core.sendCmd("publishEvent", { msgEvent: r2 });
            return formatEvent((null === (t2 = i2.content) || void 0 === t2 ? void 0 : t2.msgEvent) || {});
          });
        }
        subscribeEvent(e2) {
          var t2;
          return __awaiter(this, void 0, void 0, function* () {
            validate({ type: { type: "number" }, accounts: { type: "array", itemType: "string", max: 100 }, subscribeTime: { type: "number", min: 60, max: 2592e3, required: false } }, e2);
            var r2 = Object.assign(Object.assign({ subscribeTime: 2592e3 }, e2), { sync: true === e2.sync ? 1 : 0 }), i2 = yield this.core.sendCmd("subscribeEvent", { msgEventSubscribe: r2, accounts: e2.accounts });
            return { failedAccounts: (null === (t2 = i2.content) || void 0 === t2 ? void 0 : t2.accounts) || [] };
          });
        }
        unSubscribeEvents(e2) {
          var t2;
          return __awaiter(this, void 0, void 0, function* () {
            validate({ type: { type: "number" }, accounts: { type: "array", itemType: "string", max: 100, required: false } }, e2);
            var r2, i2 = { type: e2.type };
            if (e2.accounts && e2.accounts.length > 0) {
              var s2 = yield this.core.sendCmd("unSubscribeEventsByAccounts", { msgEventSubscribe: i2, accounts: e2.accounts });
              r2 = (null === (t2 = s2.content) || void 0 === t2 ? void 0 : t2.accounts) || [];
            } else
              yield this.core.sendCmd("unSubscribeEventsByType", { msgEventSubscribe: i2 }), r2 = [];
            return { failedAccounts: r2 };
          });
        }
        querySubscribeEvents(e2) {
          var t2;
          return __awaiter(this, void 0, void 0, function* () {
            var r2;
            return validate({ type: { type: "number" }, accounts: { type: "array", itemType: "string", max: 100, required: false } }, e2), r2 = e2.accounts && e2.accounts.length > 0 ? yield this.core.sendCmd("querySubscribeEventsByAccounts", { msgEventSubscribe: { type: e2.type }, accounts: e2.accounts }) : yield this.core.sendCmd("querySubscribeEventsByType", { msgEventSubscribe: { type: e2.type } }), formatSubscribes(null === (t2 = r2.content) || void 0 === t2 ? void 0 : t2.msgEventSubscribes);
          });
        }
        pushEventHandler(e2) {
          var t2, r2 = (null === (t2 = e2.content) || void 0 === t2 ? void 0 : t2.msgEvent) || {};
          this.core.emit("pushEvents", [formatEvent(r2)]);
        }
        pushEventsHandler(e2) {
          var t2, r2 = (null === (t2 = e2.content) || void 0 === t2 ? void 0 : t2.msgEvents) || {};
          this.core.emit("pushEvents", function formatEvents(e3) {
            return Array.isArray(e3) && e3.length > 0 ? e3.map((e4) => formatEvent(e4)) : [];
          }(r2));
        }
      }, "event"), NIM.registerService(class MsgExtendService extends Service$1 {
        constructor(e2) {
          super("msgExtend", e2), registerParser({ cmdMap: kr, cmdConfig: Vr });
        }
        getThreadMsgs(e2) {
          var t2;
          return __awaiter(this, void 0, void 0, function* () {
            validate({ scene: { type: "enum", values: getEnumKeys(je) }, threadMsgFromAccount: { type: "string", allowEmpty: false }, threadMsgIdServer: { type: "string", allowEmpty: false }, threadMsgTime: { type: "number" }, threadMsgToAccount: { type: "string", allowEmpty: false }, beginTime: { type: "number", required: false }, endTime: { type: "number", required: false }, lastMsgId: { type: "string", allowEmpty: false, required: false }, limit: { type: "number", min: 1, max: 100, required: false }, reverse: { type: "boolean", required: false } }, e2);
            var r2 = yield this.core.sendCmd("getThreadMsgs", function generateThreadMsgsParams(e3) {
              var t3 = { scene: je[e3.scene], from: e3.threadMsgFromAccount, to: e3.threadMsgToAccount, time: e3.threadMsgTime, idServer: e3.threadMsgIdServer }, r3 = { limit: e3.limit < 100 ? e3.limit : 100, beginTime: "number" == typeof e3.beginTime ? e3.beginTime : 0, reverse: true === e3.reverse ? 1 : 0 };
              return e3.lastMsgId && (r3.lastMsgId = e3.lastMsgId), { msg: t3, threadMsgReq: r3 };
            }(e2)), { msgs: i2, threadMsg: s2 } = r2.content, { threadMsgsMeta: n2 } = r2.content, a2 = getSessionId(s2, this.core.account), o2 = null === (t2 = this.core.session) || void 0 === t2 ? void 0 : t2.getSessionWithUncomplete({ id: a2 });
            return { msgs: i2 = formatMsgs$1(i2, o2 ? { account: this.core.account, sessionAck: o2.ack, msgReceiptTime: o2.msgReceiptTime } : { account: this.core.account }), threadMsg: s2 = formatMsg$1(s2, o2 ? { account: this.core.account, sessionAck: o2.ack, msgReceiptTime: o2.msgReceiptTime } : { account: this.core.account }), total: parseInt(n2.total), timetag: parseInt(n2.lastMsgTime) };
          });
        }
        getMsgsByIdServer(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ reqMsgs: { type: "array", rules: { scene: { type: "enum", values: getEnumKeys(je) }, from: { type: "string", allowEmpty: false }, to: { type: "string", allowEmpty: false }, idServer: { type: "string", allowEmpty: false }, time: { type: "number" } }, min: 1, max: 100 } }, e2), (yield this.core.sendCmd("getMsgsByIdServer", { reqMsgs: e2.reqMsgs.map((e3) => Object.assign(Object.assign({}, e3), { scene: getEnumKeyByEnumValue(je, e3.scene) })) })).content.msgs.map((e3) => {
              var t2, r2 = getSessionId(e3, this.core.account), i2 = null === (t2 = this.core.session) || void 0 === t2 ? void 0 : t2.getSessionWithUncomplete({ id: r2 });
              return formatMsg$1(e3, i2 ? { account: this.core.account, sessionAck: i2.ack, msgReceiptTime: i2.msgReceiptTime } : { account: this.core.account });
            });
          });
        }
      }, "msgExtend"), NIM.registerService(class MsgLogService extends Service$1 {
        constructor(e2) {
          super("msgLog", e2), this.onV2ClearHistoryMessage = (e3) => {
            var t2 = formatClearResult(e3);
            this.core.eventBus.emit("session/updateForClearMsg", [t2], true);
          }, registerParser({ cmdMap: Ur, cmdConfig: xr }), this.registerListener();
        }
        registerListener() {
          this.core.eventBus.on("forwardReceive/msgLog/clearHistoryMsgsFromServer", this.onV2ClearHistoryMessage);
        }
        deleteRoamingMsgs(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ ids: { type: "array", itemType: "string" } }, e2);
            var t2 = [];
            try {
              t2 = e2.ids.map((e3) => {
                var { scene: t3, accid: r2 } = getAccountFromSessionId(e3);
                return `${t3}|${r2}`;
              });
            } catch (t3) {
              throw this.logger.error(`Failed to delete roaming msgs with ${e2.ids}`, t3), new Error(`Failed to create session with ${e2.ids}`);
            }
            yield this.core.sendCmd("deleteRoamingMsgs", { ids: t2 });
          });
        }
        getHistoryMsgs(e2) {
          var t2, r2;
          return __awaiter(this, void 0, void 0, function* () {
            "function" != typeof (null === (t2 = this.core.sync) || void 0 === t2 ? void 0 : t2.getSyncDoneFlag) || this.core.sync.getSyncDoneFlag() || this.logger.warn("Please call getHistoryMsgs after syncdone event"), validate({ scene: { type: "enum", values: getEnumKeys(je) }, to: { type: "string", allowEmpty: false }, beginTime: { type: "number", required: false }, endTime: { type: "number", required: false }, limit: { type: "number", min: 1, max: 100, required: false }, reverse: { type: "boolean", required: false }, lastMsgId: { type: "string", required: false, allowEmpty: false }, asc: { type: "boolean", required: false }, msgTypes: { type: "array", itemType: "string", required: false } }, e2);
            var i2 = "p2p" === e2.scene ? "getHistoryMsgs" : "team" === e2.scene ? "getHistoryTeamMsgs" : "getHistorySuperTeamMsgs", s2 = yield this.core.sendCmd(i2, assignOptions({ beginTime: 0, endTime: 0, lastMsgId: 0, limit: 100, reverse: false }, Object.assign(Object.assign({}, e2), { msgTypes: e2.msgTypes ? e2.msgTypes.map((e3) => Fe[e3]) : [] }))), { content: n2 } = s2;
            if (!(n2.msgs && n2.msgs.length > 0))
              return [];
            var a2 = getSessionId(n2.msgs[0], this.core.account), o2 = null === (r2 = this.core.session) || void 0 === r2 ? void 0 : r2.getSessionWithUncomplete({ id: a2 }), c2 = formatMsgs$1(n2.msgs, o2 ? { account: this.core.account, sessionAck: o2.ack, msgReceiptTime: o2.msgReceiptTime } : { account: this.core.account });
            return true === e2.asc ? c2.sort((e3, t3) => e3.time - t3.time) : c2;
          });
        }
        clearHistoryMsgsFromServer(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ scene: { type: "enum", values: ["p2p", "team"] }, to: { type: "string", allowEmpty: false }, ext: { type: "string", required: false }, isSyncSelf: { type: "boolean", required: false } }, e2);
            var t2 = Object.assign(Object.assign({ isDeleteRoam: 1 }, e2), { type: "team" === e2.scene ? 2 : 1, isSyncSelf: true === e2.isSyncSelf ? 1 : 0 });
            t2[2 === t2.type ? "toTid" : "otherAccid"] = e2.to;
            var r2 = (yield this.core.sendCmd("clearHistoryMsgsFromServer", { clearHistoryMsgsFromServerReqTag: t2 })).content;
            return this.core.eventBus.emit("session/updateForClearMsg", [{ sessionId: `${e2.scene}-${e2.to}` }], true), this.core.eventBus.emit("forwardSend/msgLog/clearHistoryMsgsFromServer", Object.assign(Object.assign({}, t2), { time: r2.timetag })), r2;
          });
        }
        multiSyncClearServerHistoryMsgsHandler(e2) {
          var t2 = formatClearResult(e2.content.data);
          this.core.eventBus.emit("session/updateForClearMsg", [t2], true), this.core.emit("clearServerHistoryMsgs", [t2]);
        }
        ftsCloudMsgLogs(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.baseFtsCloudMsgLogs(e2, "nimFtsCloudMsgLogs");
          });
        }
        ftsCloudMsgLogsAggWithSession(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.baseFtsCloudMsgLogs(e2, "nimFtsCloudMsgLogsAggWithSession");
          });
        }
        baseFtsCloudMsgLogs(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            if (validate({ keyword: { type: "string", allowEmpty: false }, fromTime: { type: "number", required: false }, toTime: { type: "number", required: false }, sessionLimit: { type: "number", required: false }, msglogsLimit: { type: "number", required: false }, orderRule: { type: "enum", values: getEnumKeys(Or), required: false }, p2pSessionList: { type: "array", itemType: "string", required: false }, teamSessionList: { type: "array", itemType: "string", required: false }, senderList: { type: "array", itemType: "string", required: false }, msgTypeList: { type: "array", itemType: "enum", values: getEnumKeys(Fe), required: false }, msgSubTypeList: { type: "array", itemType: "number", required: false } }, e2), e2.fromTime && e2.toTime && e2.toTime < e2.fromTime)
              throw new ValidateError("Request parameter error: toTime should be greater than fromTime", e2, "");
            var r2 = function generateFtsTagForCmd(e3) {
              var t3 = format(Fr, e3);
              return Array.isArray(t3.msgTypeList) && (t3.msgTypeList = t3.msgTypeList.map((e4) => Fe[e4]).join(",")), ["p2pSessionList", "teamSessionList", "senderList", "msgSubTypeList"].forEach((e4) => {
                Array.isArray(t3[e4]) && (t3[e4] = t3[e4].join(","));
              }), t3;
            }(e2);
            return (yield this.core.sendCmd(t2, { tag: r2 })).content.datas.map((e3) => {
              var t3, r3 = getSessionId(e3, this.core.account), i2 = null === (t3 = this.core.session) || void 0 === t3 ? void 0 : t3.getSessionWithUncomplete({ id: r3 });
              return formatMsg$1(e3, i2 ? { account: this.core.account, sessionAck: i2.ack, msgReceiptTime: i2.msgReceiptTime } : { account: this.core.account });
            });
          });
        }
        syncClearServerHistoryMsgsHandler(e2) {
          var t2 = function formatClearResults(e3) {
            return Array.isArray(e3) && e3.length > 0 ? e3.map((e4) => formatClearResult(e4)) : [];
          }(e2.content.datas);
          this.core.emit("clearServerHistoryMsgs", t2);
        }
      }, "msgLog"), NIM.registerService(class PassThroughService extends Service$1 {
        constructor(e2) {
          super("passThrough", e2), this.core = e2, registerParser({ cmdMap: jr, cmdConfig: Hr });
        }
        request(e2) {
          return validate({ path: { type: "string", allowEmpty: false } }, e2), this.core.sendCmd("requestProxy", { requestProxyTag: e2 }).then((e3) => {
            var { content: t2 } = e3;
            return t2.requestProxyTag;
          });
        }
        onRequestProxyHandler(e2) {
          var { proxyMsg: t2 } = e2.content;
          t2 && t2.time && (t2.time = +t2.time), this.core.emit("proxyMsg", t2);
        }
      }, "passThrough"), NIM.registerService(CloudStorageService, "cloudStorage"), NIM.registerService(class SuperTeamService extends Service$1 {
        constructor(e2) {
          super("superTeam", e2), this.mySuperTeamMembersMap = /* @__PURE__ */ new Map(), this.service = new ModuleService(e2), registerParser({ cmdMap: hi, cmdConfig: yi }), this.setListeners();
        }
        setListeners() {
          this.core.eventBus.on("forwardReceive/superTeam/updateMyMemberInfo", (e2) => {
            this.emitMemberUpdate(e2);
          }), this.core.eventBus.on("team/onNotification", (e2) => this.notificationHandler(e2));
        }
        reset() {
          this.mySuperTeamMembersMap.clear();
        }
        mergeMySuperTeamMembers(e2) {
          e2.forEach((e3) => {
            var t2 = e3.teamId, r2 = this.mySuperTeamMembersMap.get(t2), i2 = Object.assign({}, r2, e3);
            this.mySuperTeamMembersMap.set(t2, i2);
          });
        }
        getSuperTeamInfo(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ teamId: { type: "string", regExp: /\d+/, allowEmpty: false } }, e2), formatSuperTeam((yield this.core.sendCmd("getSuperTeamInfo", { teamId: e2.teamId })).content.superTeam);
          });
        }
        getSuperTeams() {
          return __awaiter(this, void 0, void 0, function* () {
            return formatSuperTeams((yield this.core.sendCmd("getSuperTeams", { timetag: 0 })).content.superTeams);
          });
        }
        updateSuperTeamInfo(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ teamId: { type: "string", regExp: /\d+/, allowEmpty: false }, name: { type: "string", allowEmpty: false, required: false }, joinMode: { type: "enum", values: ["noVerify", "needVerify", "rejectAll"], required: false }, beInviteMode: { type: "enum", values: ["noVerify", "needVerify"], required: false }, inviteMode: { type: "enum", values: ["manager", "all"], required: false }, updateTeamMode: { type: "enum", values: ["manager", "all"], required: false }, updateExtMode: { type: "enum", values: ["manager", "all"], required: false }, intro: { type: "string", allowEmpty: true, required: false }, announcement: { type: "string", allowEmpty: true, required: false }, avatar: { type: "string", allowEmpty: true, required: false }, ext: { type: "string", allowEmpty: true, required: false } }, e2);
            var t2 = function generateSuperTeam(e3) {
              var t3 = Object.assign({}, e3), r2 = { joinMode: si, beInviteMode: ai, inviteMode: ci, updateTeamMode: li, updateExtMode: pi };
              return ["avatar", "name", "intro", "announcement", "ext"].forEach((e4) => {
                void 0 !== t3[e4] && (t3[e4] = t3[e4].toString());
              }), Object.keys(r2).forEach((e4) => {
                void 0 !== t3[e4] && (t3[e4] = r2[e4][t3[e4]]);
              }), t3;
            }(e2);
            return yield this.core.sendCmd("updateSuperTeamInfo", { superTeam: t2 }), formatSuperTeam(t2);
          });
        }
        addSuperTeamMembers(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ teamId: { type: "string", regExp: /\d+/, allowEmpty: false }, accounts: { type: "array", itemType: "string", min: 1 }, ps: { type: "string", allowEmpty: true, max: 5e3, required: false } }, e2), yield this.core.sendCmd("addSuperTeamMembers", { teamId: e2.teamId, accounts: e2.accounts, ps: e2.ps || "", attach: e2.ext || "" });
          });
        }
        removeSuperTeamMembers(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ teamId: { type: "string", regExp: /\d+/, allowEmpty: false }, accounts: { type: "array", itemType: "string", min: 1 } }, e2), yield this.core.sendCmd("removeSuperTeamMembers", { teamId: e2.teamId, accounts: e2.accounts });
          });
        }
        addSuperTeamManagers(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ teamId: { type: "string", regExp: /\d+/, allowEmpty: false }, accounts: { type: "array", min: 1, itemType: "string" } }, e2), yield this.core.sendCmd("addSuperTeamManagers", e2);
          });
        }
        removeSuperTeamManagers(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ teamId: { type: "string", regExp: /\d+/, allowEmpty: false }, accounts: { type: "array", min: 1, itemType: "string" } }, e2), yield this.core.sendCmd("removeSuperTeamManagers", e2);
          });
        }
        applySuperTeam(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ teamId: { type: "string", regExp: /\d+/, allowEmpty: false }, ps: { type: "string", allowEmpty: true, max: 5e3, required: false } }, e2), formatSuperTeam((yield this.core.sendCmd("applySuperTeam", { teamId: e2.teamId, ps: e2.ps || "" })).content.superTeam);
          });
        }
        transferSuperTeam(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ teamId: { type: "string", regExp: /\d+/, allowEmpty: false }, account: { type: "string", allowEmpty: false }, leave: { type: "boolean" } }, e2), yield this.core.sendCmd("transferSuperTeam", e2);
          });
        }
        muteSuperTeam(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ teamId: { type: "string", regExp: /\d+/, allowEmpty: false }, mute: { type: "boolean" } }, e2), yield this.core.sendCmd("muteSuperTeam", { teamId: e2.teamId, mute: e2.mute ? 1 : 0 });
          });
        }
        muteSuperTeamMembers(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ teamId: { type: "string", regExp: /\d+/, allowEmpty: false }, accounts: { type: "array", itemType: "string" }, mute: { type: "boolean" } }, e2), yield this.core.sendCmd("muteSuperTeamMembers", { teamId: e2.teamId, accounts: e2.accounts, mute: e2.mute ? 1 : 0 });
          });
        }
        updateMemberNick(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ teamId: { type: "string", regExp: /\d+/, allowEmpty: false }, account: { type: "string", allowEmpty: false }, nickInTeam: { type: "string", allowEmpty: true } }, e2);
            var t2 = generatorSuperTeamMemberForCmd({ teamId: e2.teamId, nickInTeam: e2.nickInTeam, account: e2.account });
            return yield this.core.sendCmd("updateSuperTeamMemberNick", { teamMember: t2 }), formatSuperTeamMember(Object.assign({ updateTime: (/* @__PURE__ */ new Date()).getTime() }, t2));
          });
        }
        updateMyMemberInfo(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ teamId: { type: "string", regExp: /\d+/, allowEmpty: false }, nickInTeam: { type: "string", allowEmpty: true, required: false }, bitConfigMask: { type: "number", min: 0, max: 2, required: false }, ext: { type: "string", required: false } }, e2);
            var t2 = generatorSuperTeamMemberForCmd({ teamId: e2.teamId, nickInTeam: e2.nickInTeam, bitConfigMask: e2.bitConfigMask, ext: e2.ext });
            yield this.core.sendCmd("updateMySuperTeamMemberInfo", { teamMember: t2 });
            var r2 = formatSuperTeamMember(Object.assign({ updateTime: (/* @__PURE__ */ new Date()).getTime(), account: this.core.account }, t2)), i2 = this.emitMemberUpdate(r2);
            return this.core.eventBus.emit("forwardSend/superTeam/updateMyMemberInfo", i2), r2;
          });
        }
        getSuperTeamMembersByAccounts(e2) {
          var t2;
          return __awaiter(this, void 0, void 0, function* () {
            validate({ teamId: { type: "string", regExp: /\d+/, allowEmpty: false }, accounts: { type: "array", itemType: "string", max: 20, min: 1 } }, e2);
            var r2 = e2.accounts.map((t3) => `${e2.teamId}|${t3}`), i2 = yield this.core.sendCmd("getSuperTeamMembersByAccounts", { memberIds: r2 });
            return formatSuperTeamMembers(null === (t2 = i2.content) || void 0 === t2 ? void 0 : t2.superTeamMembers);
          });
        }
        getSuperTeamMembers(e2) {
          var t2;
          return __awaiter(this, void 0, void 0, function* () {
            validate({ teamId: { type: "string", regExp: /\d+/, allowEmpty: false }, joinTime: { type: "number", min: 0, required: false }, limit: { type: "number", min: 1, max: 1e3, required: false }, reverse: { type: "boolean", required: false } }, e2);
            var r2 = yield this.core.sendCmd("getSuperTeamMembers", Object.assign({ joinTime: 0, limit: 100, reverse: false }, e2));
            return formatSuperTeamMembers(null === (t2 = r2.content) || void 0 === t2 ? void 0 : t2.superTeamMembers);
          });
        }
        queryMuteMembers(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ teamId: { type: "string", regExp: /\d+/, allowEmpty: false }, joinTime: { type: "number", min: 0, required: false }, limit: { type: "number", min: 1, required: false }, reverse: { type: "boolean", required: false } }, e2), formatSuperTeamMembers((yield this.core.sendCmd("queryMuteSuperTeamMembers", Object.assign({ limit: 100, joinTime: 0, reverse: false }, e2))).content.superTeamMembers);
          });
        }
        leaveSuperTeam(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ teamId: { type: "string", regExp: /\d+/, allowEmpty: false } }, e2), yield this.core.sendCmd("leaveSuperTeam", { teamId: e2.teamId });
          });
        }
        passSuperTeamApply(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ teamId: { type: "string", regExp: /\d+/, allowEmpty: false }, from: { type: "string", allowEmpty: false } }, e2);
            try {
              yield this.core.sendCmd("passSuperTeamApply", e2), this.core.eventBus.emit("forwardSend/superTeam/passTeamApply", e2);
            } catch (r2) {
              var t2 = r2;
              throw this.core.eventBus.emit("forwardSend/superTeam/passTeamApply", e2, null == t2 ? void 0 : t2.code), r2;
            }
          });
        }
        rejectSuperTeamApply(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ teamId: { type: "string", regExp: /\d+/, allowEmpty: false }, from: { type: "string", allowEmpty: false }, ps: { type: "string", max: 5e3, required: false } }, e2);
            try {
              yield this.core.sendCmd("rejectSuperTeamApply", { teamId: e2.teamId, from: e2.from, ps: e2.ps || "" }), this.core.eventBus.emit("forwardSend/superTeam/rejectSuperTeamApply", e2);
            } catch (r2) {
              var t2 = r2;
              throw this.core.eventBus.emit("forwardSend/superTeam/rejectSuperTeamApply", e2, null == t2 ? void 0 : t2.code), r2;
            }
          });
        }
        acceptSuperTeamInvite(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ teamId: { type: "string", regExp: /\d+/, allowEmpty: false }, from: { type: "string", allowEmpty: false } }, e2);
            try {
              yield this.core.sendCmd("acceptSuperTeamInvite", e2), this.core.eventBus.emit("forwardSend/superTeam/acceptSuperTeamInvite", e2);
            } catch (r2) {
              var t2 = r2;
              throw this.core.eventBus.emit("forwardSend/superTeam/acceptSuperTeamInvite", e2, null == t2 ? void 0 : t2.code), r2;
            }
          });
        }
        rejectSuperTeamInvite(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ teamId: { type: "string", regExp: /\d+/, allowEmpty: false }, from: { type: "string", allowEmpty: false }, ps: { type: "string", max: 5e3, required: false } }, e2);
            try {
              yield this.core.sendCmd("rejectSuperTeamInvite", { teamId: e2.teamId, from: e2.from, ps: e2.ps || "" }), this.core.eventBus.emit("forwardSend/superTeam/rejectSuperTeamInvite", e2);
            } catch (r2) {
              var t2 = r2;
              throw this.core.eventBus.emit("forwardSend/superTeam/rejectSuperTeamInvite", e2, null == t2 ? void 0 : t2.code), r2;
            }
          });
        }
        emitMemberUpdate(e2) {
          e2 = formatSuperTeamMember(e2), this.mergeMyTeamMembers([e2]), this.core.emit("updateTeamMember", e2);
          var t2 = cloneDeep(this.mySuperTeamMembersMap.get(e2.teamId));
          return this.core.emit("myTeamMembers", [t2]), t2;
        }
        mergeMyTeamMembers(e2) {
          e2.forEach((e3) => {
            var t2 = e3.teamId, r2 = this.mySuperTeamMembersMap.get(t2), i2 = Object.assign({}, r2, e3);
            this.mySuperTeamMembersMap.set(t2, i2);
          });
        }
        syncSuperTeamsHandler(e2) {
          var t2 = e2.content;
          this.core.eventBus.emit("sync/updateTimetag", { superTeams: parseInt(t2.timetag) });
          var r2 = null == t2 ? void 0 : t2.teams;
          if (r2 && r2.length) {
            var i2 = formatSuperTeams(r2);
            this.core.emit("superTeams", i2);
          }
        }
        syncCreateSuperTeamHandler(e2) {
          var t2 = e2.content, r2 = formatSuperTeam(null == t2 ? void 0 : t2.superTeam), i2 = generatorMemberBySuperTeam(r2, r2.owner, "owner");
          this.core.emit("createSuperTeam", r2, i2);
        }
        syncUpdateSuperTeamMemberHandler(e2) {
          var t2 = e2.content, r2 = formatSuperTeamMember(null == t2 ? void 0 : t2.teamMember);
          r2.updateTime || (r2.updateTime = (/* @__PURE__ */ new Date()).getTime()), this.mergeMySuperTeamMembers([r2]), this.core.emit("updateSuperTeamMember", r2);
          var i2 = cloneDeep(this.mySuperTeamMembersMap.get(r2.teamId));
          this.core.emit("mySuperTeamMembers", [i2]);
        }
        syncMySuperTeamMembersHandler(e2) {
          var t2 = e2.content;
          this.core.eventBus.emit("sync/updateTimetag", { mySuperTeamMembers: parseInt(t2.timetag) });
          var r2 = null == t2 ? void 0 : t2.teamMembers.map((e3) => formatSuperTeamMember(e3));
          this.mergeMySuperTeamMembers(r2), this.core.emit("mySuperTeamMembers", cloneDeep(r2));
        }
        notificationHandler(e2) {
          var { attach: t2, scene: r2, from: i2, to: s2, time: n2, idServer: a2, idClient: o2 } = e2, { team: c2, account: d2, accounts: l2, type: m2 } = t2;
          if ("superTeam" === r2)
            switch (this.logger.getDebugMode() ? this.logger.debug("superTeam::recvNotification", a2, o2, t2) : this.logger.log("superTeam::recvNotification", a2, o2, s2, m2, d2, l2), m2) {
              case "updateSuperTeam":
                c2.updateTime = n2, this.core.emit("updateSuperTeam", c2);
                break;
              case "addSuperTeamMembers":
                this.service.notifyAddSuperTeamMembers(c2, l2);
                break;
              case "acceptSuperTeamInvite":
                this.service.notifyAddSuperTeamMembers(c2, [i2]);
                break;
              case "passSuperTeamApply":
                this.service.notifyAddSuperTeamMembers(c2, [d2]);
                break;
              case "addSuperTeamManagers":
                this.service.notifyUpdateSuperTeamManagers(s2, l2, true, n2);
                break;
              case "removeSuperTeamManagers":
                this.service.notifyUpdateSuperTeamManagers(s2, l2, false, n2);
                break;
              case "removeSuperTeamMembers":
                this.service.notifyRemoveSuperTeamMembers(c2, l2);
                break;
              case "leaveSuperTeam":
                this.service.notifyRemoveSuperTeamMembers(c2, [i2]);
                break;
              case "dismissSuperTeam":
                this.core.emit("dismissSuperTeam", { teamId: s2 });
                break;
              case "transferSuperTeam":
                this.service.notifyTransferSuperTeam(c2, i2, d2);
                break;
              case "updateSuperTeamMembersMute":
                this.service.notifyUpdateSuperTeamMembersMute(c2, l2, t2.mute);
            }
        }
      }, "superTeam"), NIM.registerService(class SyncService extends Service$1 {
        constructor(e2, t2 = {}) {
          super("sync", e2), this.syncDoneFlag = false, this.config = { myInfo: !!e2.user.name, offlineMsgs: !!e2.msg.name, teams: !!e2.team.name, myTeamMembers: !!e2.team.name, roamingMsgs: !!e2.msg.name, relations: !!e2.user.name, friends: !!e2.friend.name, friendUsers: !!e2.user.name, msgReceipts: !!e2.msg.name, broadcastMsgs: !!e2.msg.name, recallMsg: !!e2.msg.name, sessionAck: !!e2.session.name, superTeamSessionAck: !!e2.session.name, superTeams: !!e2.superTeam.name, mySuperTeamMembers: !!e2.superTeam.name, superTeamRoamingMsgs: !!e2.superTeam.name, deleteSuperTeamMsg: !!e2.superTeam.name, deleteSelfMsgs: !!e2.msg.name, sessionHistoryMsgsDelete: !!e2.msgLog.name, avSignal: !!e2.signaling.name }, this.setOptions(t2), this.timetags = {}, this.initEventListeners(), registerParser({ cmdMap: lr, cmdConfig: mr });
        }
        setOptions(e2) {
          Object.assign(this.config, e2);
        }
        reset() {
          this.timetags = {}, this.syncDoneFlag = false;
        }
        getSyncDoneFlag() {
          return this.syncDoneFlag;
        }
        doSync() {
          var e2;
          return __awaiter(this, void 0, void 0, function* () {
            var t2 = this.genSyncParams();
            this.logger.log("sync::doSyncV1: ", t2);
            try {
              var r2 = yield this.core.clientSocket.sendCmd("sync", { sync: t2 });
              this.core.logger.log("sync::doSyncV1 done in", null === (e2 = r2.content) || void 0 === e2 ? void 0 : e2.timetag), this.syncDoneFlag = true, this.core.emit("syncdone");
            } catch (e3) {
              return this.core.logger.error("sync::doSyncV1 error", e3), this.syncDoneFlag = true, void this.core.emit("syncdone");
            }
          });
        }
        initEventListeners() {
          this.core.eventBus.on("logined", () => {
            this.syncDoneFlag = false, this.doSync();
          }), this.core.eventBus.on("sync/updateTimetag", (e2) => {
            Object.keys(e2).forEach((t2) => {
              e2[t2] > (this.timetags[t2] || 0) && (this.timetags[t2] = e2[t2]);
            });
          });
        }
        genSyncParams() {
          return Object.keys(this.config).filter((e2) => {
            var t2 = e2;
            return this.config[t2];
          }).reduce((e2, t2) => {
            var r2 = t2;
            return e2[r2] = this.timetags[r2] || 0, e2;
          }, {});
        }
        handleImmediate(e2) {
          return this.core.session && this.core.session.onSyncDone && this.core.session.onSyncDone(), Promise.resolve(e2);
        }
        delaySyncDone(e2) {
          var { hostEnvEnum: t2 } = ge.getSystemInfo();
          return 102 === t2 ? (this.core.logger.log("sync: emit ALIAPP sycnHandler, handle later"), new Promise((t3) => {
            setTimeout(() => {
              this.handleImmediate(e2).then(() => {
                t3(e2);
              });
            }, 100);
          })) : this.handleImmediate(e2);
        }
        syncHandler(e2) {
          return this.delaySyncDone(e2);
        }
      }, "sync"), NIM.registerService(class PluginService extends Service$1 {
        constructor(e2) {
          super("plugin", e2), this.core = e2, registerParser({ cmdMap: fi, cmdConfig: Ii });
        }
        getChatroomAddress(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ chatroomId: { type: "string", allowEmpty: false }, ipType: { type: "number", required: false } }, e2), (yield this.core.sendCmd("getChatroomAddress", { chatroomId: e2.chatroomId, isWeixinApp: "WXAPP" === ge.platform, ipType: e2.ipType || 0 })).content.address;
          });
        }
        getQChatAddress(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ ipType: { type: "number", required: false } }, e2), (yield this.core.sendCmd("getQChatAddress", { getQChatAddressTag: { ipType: (null == e2 ? void 0 : e2.ipType) || 0 } })).content.address;
          });
        }
      }, "plugin"), NIM.registerService(class OfflinePushService extends Service$1 {
        constructor(e2) {
          super("offlinePush", e2), this.plugin = void 0, this.authConfig = void 0, this.appBackgroundOptions = { badge: 0, isBackground: false }, this.setTokenAndBackgroundStateAfterLogin = (e3) => {
            this.plugin && (this.regToken(e3 && e3.aosPushInfo), this.core.sendCmd("updateAppBackground", { isBackground: this.appBackgroundOptions.isBackground, badge: this.appBackgroundOptions.badge || 0 }));
          }, registerParser({ cmdMap: Di, cmdConfig: qi }), this.core.eventBus.on("logined", this.setTokenAndBackgroundStateAfterLogin);
        }
        setOfflinePushConfig(e2) {
          e2.plugin ? (validate({ plugin: { type: "object", required: true }, authConfig: { type: "object", required: true } }, e2), this.plugin = e2.plugin, this.authConfig = e2.authConfig) : this.logger.warn("setOfflinePushConfig: invoke setOfflinePushConfig without plugin. If you are not running iOS or android app, please ignore this notice.");
        }
        regToken(e2) {
          var t2 = ge.getSystemInfo() || {}, r2 = t2.os ? t2.os.toLowerCase() : "";
          if (this.logger.log("OfflinePushService: os", r2), "ios" === r2 || "android" === r2)
            if (this.plugin && "function" == typeof this.plugin.getDeviceToken) {
              var i2 = "";
              e2 && e2.pushType ? i2 = e2.pushType : "ios" === r2 ? i2 = "" : "android" === r2 && (i2 = "8"), this.logger.log("OfflinePushService:: prepare to get device token. suggestPushType: " + i2), this.logger.log("OfflinePushService push config", JSON.stringify(this.authConfig, null, 2)), this.plugin.getDeviceToken({ suggestPushType: i2, config: this.authConfig }, (e3) => {
                e3 ? (this.logger.log("OfflinePushService:: token is :" + e3), this.pushTokenToServer(i2, e3)) : this.logger.warn("OfflinePushService:: token is empty. Please check your parameters");
              });
            } else
              this.logger.warn("OfflinePushService: plugin.getDeviceToken is not a function");
          else
            this.logger.warn("OfflinePushService: only Android or IOS support offline push");
        }
        pushTokenToServer(e2, t2) {
          var r2 = "", i2 = this.authConfig;
          switch (e2) {
            case "5":
              r2 = i2.xmCertificateName;
              break;
            case "6":
              r2 = i2.hwCertificateName;
              break;
            case "7":
              r2 = i2.mzCertificateName;
              break;
            case "8":
              r2 = i2.fcmCertificateName;
              break;
            case "9":
              r2 = i2.vivoCertificateName;
              break;
            case "10":
              r2 = i2.oppoCertificateName;
              break;
            case "11":
              r2 = i2.honorCertificateName;
              break;
            default:
              r2 = i2.apnsCertificateName;
          }
          "" === r2 || void 0 === r2 ? this.logger.warn("OfflinePushService:: certificate name is empty for push type: ", e2) : this.updatePushToken({ tokenName: r2, token: t2, pushkit: 0 });
        }
        updatePushToken(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            var t2;
            validate({ tokenName: { type: "string", allowEmpty: false, required: true }, token: { type: "string", allowEmpty: false, required: true }, pushkit: { type: "number", required: false } }, e2);
            try {
              var r2 = Si.parse("557d1e3cafa43e2589a588270c53d56f");
              t2 = Si.stringify(Ui.decrypt(e2.token, r2)), this.logger.log("updatePushToken:: token", t2);
            } catch (t3) {
              return this.logger.log("updatePushToken:: decrypt error", t3), void this.logger.warn("updatePushToken:: token before decrypt", e2.token);
            }
            yield this.core.sendCmd("updatePushToken", Object.assign(Object.assign({}, e2), { token: t2 }));
          });
        }
        updateAppBackground(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ isBackground: { type: "boolean", required: true }, badge: { type: "number", required: false } }, e2), this.appBackgroundOptions = { isBackground: e2.isBackground, badge: e2.badge || 0 }, yield this.core.sendCmd("updateAppBackground", { isBackground: e2.isBackground, badge: e2.badge || 0 });
          });
        }
      }, "offlinePush"), NIM.registerService(class CloudSessionService extends Service$1 {
        constructor(e2) {
          super("cloudSession", e2), registerParser({ cmdMap: xi, cmdConfig: ji });
        }
        queryCloudSessionList(e2) {
          var t2;
          return __awaiter(this, void 0, void 0, function* () {
            validate({ minTimestamp: { type: "number", min: 0, required: false }, maxTimestamp: { type: "number", min: 0, required: false }, limit: { type: "number", min: 1, required: false }, includedLastMsg: { type: "boolean", required: false } }, e2);
            var r2 = Object.assign({ limit: 100, includedLastMsg: true }, e2);
            r2.includedLastMsg = Xe.boolean(e2, "includedLastMsg");
            var i2 = yield this.core.sendCmd("nimQueryCloudSessionList", { tag: r2 }), s2 = (null === (t2 = i2.content) || void 0 === t2 ? void 0 : t2.tag) || {}, n2 = i2.content.sessions;
            return { hasMore: +s2.hasMore > 0, sessionList: formatCloudSessions(n2, this.core.account, this.logger) };
          });
        }
        queryCloudSession(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ sessionId: { type: "string", allowEmpty: false } }, e2);
            var { accid: t2, scene: r2 } = getAccountFromSessionId(e2.sessionId, "-");
            return formatCloudSession((yield this.core.sendCmd("nimQueryCloudSession", { tag: { sessionId: "superTeam" === r2 ? `super_team|${t2}` : `${r2}|${t2}` } })).content.session, this.core.account, this.logger);
          });
        }
        updateCloudSession(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ sessionId: { type: "string", allowEmpty: false }, ext: { type: "string", allowEmpty: false, required: false } }, e2);
            var { accid: t2, scene: r2 } = getAccountFromSessionId(e2.sessionId, "-");
            yield this.core.sendCmd("nimUpdateCloudSession", { tag: { sessionId: "superTeam" === r2 ? `super_team|${t2}` : `${r2}|${t2}`, ext: e2.ext } });
          });
        }
        deleteCloudSessionList(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ sessionIdList: { type: "array", itemType: "string" } }, e2);
            var t2 = e2.sessionIdList.map((e3) => {
              var { accid: t3, scene: r2 } = getAccountFromSessionId(e3, "-");
              return { sessionId: "superTeam" === r2 ? `super_team|${t3}` : `${r2}|${t3}` };
            });
            yield this.core.sendCmd("nimDeleteCloudSessionList", { tags: t2 });
          });
        }
        nimMultiSyncUpdateCloudSessionHandler(e2) {
          var t2 = formatCloudSession(e2.content.session, this.core.account, this.logger);
          this.core.emit("multiSyncUpdateCloudSession", t2);
        }
      }, "cloudSession"), NIM.registerService(SignalingService, "signaling"), NIM.registerService(class V2NIMLoginServiceImpl extends V2Service {
        constructor(e2, t2 = {}) {
          var r2;
          super("V2NIMLoginService", e2), this.account = "", this.previousLoginAccount = "", this.token = "", this.deviceId = "", this.clientSession = "", this.processId = "", this.kickedDetail = null, this.binaryWebsocket = true, this.core._registerDep(MiscService, "misc"), registerParser({ cmdMap: pt, cmdConfig: gt }), "v2" === e2.options.apiVersion && (registerParser({ cmdMap: ut, cmdConfig: vt }), this.core.auth = this), this.previousLoginManager = new PromiseManager(), this.doLoginStepsManager = new PromiseManager(), this.loginTimerManager = new TimerManager(), this.loginOption = Object.assign({}, Ct), this.config = { lbsUrls: _t, linkUrl: "weblink.netease.im:443", linkSSL: true }, this.setOptions(t2), e2.V2NIMLoginService = this, false !== this.core.options.binaryWebsocket && "function" == typeof Uint8Array ? (this.binaryWebsocket = true, r2 = new V2BinaryClientSocket(this.core)) : (this.binaryWebsocket = false, r2 = new V2ClientSocket(this.core)), this.clientSocket = r2, "v2" === this.core.options.apiVersion && (this.core.clientSocket = r2), this.lifeCycle = new V2NIMLoginLifeCycle(e2), this.reconnect = new V2NIMLoginReconnect(e2), this.lbs = new V2NIMLoginLbs(e2), this.authenticator = new V2NIMLoginAuthenticator(e2), this.dataSync = new V2NIMLoginDataSync(e2);
        }
        get hasSettingService() {
          var e2;
          return !!(null === (e2 = this.core.V2NIMSettingService) || void 0 === e2 ? void 0 : e2.name);
        }
        setOptions(e2) {
          var t2, r2, i2;
          validate({ lbsUrls: { type: "array", itemType: "string", min: 1, required: false }, linkUrl: { type: "string", allowEmpty: false, required: false } }, e2, "", true), this.config = assignOptions(this.config, e2), null === (r2 = null === (t2 = this.core.clientSocket) || void 0 === t2 ? void 0 : t2.setLinkSSL) || void 0 === r2 || r2.call(t2, null === (i2 = this.config.linkSSL) || void 0 === i2 || i2);
          var s2 = "", n2 = "";
          this.config.isFixedDeviceId ? (s2 = ge.localStorage.getItem("__NIM_DEVC_ID__") || Ie(), n2 = ge.localStorage.getItem("__NIM_CLIENT_SESSION_ID__") || Ie(), ge.localStorage.setItem("__NIM_DEVC_ID__", s2), ge.localStorage.setItem("__NIM_CLIENT_SESSION_ID__", n2)) : (s2 = Ie(), n2 = Ie()), this.deviceId = s2, this.clientSession = n2, this.core.reporter.setConfig({ common: { dev_id: s2 } });
        }
        reset() {
          this.account = "", this.token = "", this.processId = "", this.lbs.reset(), this.reconnect.destroy(), this.authenticator.reset(), this.authenticator.clearLastLoginClient(), this.dataSync.reset();
        }
        login(e2, t2, r2 = {}) {
          return __awaiter(this, void 0, void 0, function* () {
            this._checkApiVersion();
            var i2 = ge.getSystemInfo() || {}, s2 = i2.os ? i2.os.toLowerCase() : "";
            if ("React Native" === ge.platform && "android" === s2 && this.hasSettingService && get(this.core.V2NIMSettingService, "push.offlinePushPlugin"))
              try {
                this.deviceInfo = yield this.core.V2NIMSettingService.push.getRNDeviceInfo();
              } catch (e3) {
                this.logger.error(e3);
              }
            if ("string" != typeof e2 || "" === e2.trim())
              throw new ValidateErrorV2({ detail: { reason: "Account must be string" } });
            if (validate(Tt, r2, "", true), 0 === (r2 = assignOptions(Ct, r2)).authType && !t2)
              throw new ValidateErrorV2({ detail: { reason: "When authType is 0, token cannot be empty" } });
            if ("" !== this.previousLoginAccount && this.previousLoginAccount !== e2 && this.core._clearModuleData(), 0 === this.getLoginStatus())
              this.logger.log(`V2NIMLoginService::login:allowLogin:${e2}`, r2);
            else {
              if (1 === this.getLoginStatus())
                return this.smoothForLogined(e2, t2, r2);
              if (2 === this.getLoginStatus())
                return this.smoothForLogining(e2, t2, r2);
            }
            this.account = e2, this.previousLoginAccount = e2, this.token = t2, this.processId = Ie(), this.loginOption = assignOptions(Ct, r2), this.kickedDetail = null, this.loginTimerManager.destroy(), this.loginTimerManager.addTimer(() => {
              var e3 = new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_TIMEOUT, detail: { reason: "Login API timeout" } });
              this.doLoginStepsManager.clear(e3), this.previousLoginManager.clear(e3), this.originLoginPromise = void 0, this.lifeCycle.processEvent("exited", e3);
            }, this.loginOption.timeout > 0 ? this.loginOption.timeout : 6e4, 1);
            try {
              yield this.multiTryDoLogin(), this.loginTimerManager.destroy();
            } catch (e3) {
              throw this.loginTimerManager.destroy(), e3;
            }
          });
        }
        setAppVisibility() {
          this.logger.warn("V2NIMLoginService::setAppVisibility is deprecated @v10.9.40");
        }
        getChatroomLinkAddress(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ roomId: { type: "string", regExp: /^\d+$/, required: true, allowEmpty: false }, miniProgram: { type: "boolean", required: false } }, { roomId: e2, miniProgram: t2 }, "", true), t2 = void 0 === t2 ? pendingIsMiniappEnv() : t2, (yield this.clientSocket.sendCmd("v2GetChatroomLinkAddress", { roomId: e2, miniProgram: t2 })).content.linkAddress;
          });
        }
        multiTryDoLogin(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            for (var t2 = new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INTERNAL, detail: { reason: "loginFailed" } }), r2 = 0; r2 <= this.loginOption.retryCount; r2++) {
              var i2 = `V2NIMLoginService::times of login try: ${r2}`;
              r2 > 0 ? this.logger.warn(i2) : this.logger.log(i2);
              try {
                this.originLoginPromise = e2 || this.doLogin(false), e2 = void 0;
                var s2 = yield this.previousLoginManager.add(this.originLoginPromise);
                return this.core.reporter.reportTraceEnd("login", true), this.doLoginStepsManager.clear(), this.previousLoginManager.clear(), this.originLoginPromise = void 0, s2;
              } catch (e3) {
                if (t2 = e3 || t2, this.logger.error(`V2NIMLoginService::login failed, times of login try: ${r2}, err.code: ${null == t2 ? void 0 : t2.code}, err.message: "${null == t2 ? void 0 : t2.message}"`), t2.code !== ce.V2NIM_ERROR_CODE_CANCELLED && this.core.reporter.reportTraceEnd("login", false), this.reconnect.clearReconnectTimer(), this.checkLoginTerminalCode(t2 && t2.code))
                  throw this.lifeCycle.processEvent("exited", t2), t2;
                t2 && 399 === t2.code && this.lbs.reset();
              }
            }
            throw this.lifeCycle.processEvent("exited", t2), t2;
          });
        }
        doLogin(e2) {
          var t2, r2;
          return __awaiter(this, void 0, void 0, function* () {
            var i2 = !!e2 || this.authenticator.checkAutoLogin(this.loginOption.forceMode);
            this.core.reporter.reportTraceCancel("login"), this.core.reporter.reportTraceStart("login", i2 ? { user_id: this.account, action: "auto_login", process_id: this.processId, binary_websocket: this.binaryWebsocket } : { user_id: this.account, action: "manual_login", process_id: this.processId, binary_websocket: this.binaryWebsocket }), this.core.reporter.reportTraceUpdateV2("login", { code: 0, description: JSON.stringify(this.loginOption), operation_type: "conf_init", succeed: true, duration: 0, target: "" }, { asyncParams: ge.net.getNetworkStatus() });
            var s2 = yield this.doLoginStepsManager.add(this.lbs.getLbsInfos());
            yield this.doLoginStepsManager.add(this.clientSocket.connect(s2, e2));
            var n2 = yield this.doLoginStepsManager.add(this.authenticator.verifyAuthentication(i2));
            if (this.processId = Ie(), this.clientSocket.resetSocketConfig(), this.reconnect.reset(), this.dataSync.reset(), this.lifeCycle.processEvent("loginSucc", void 0, Object.assign(Object.assign({}, n2), { isReconnect: e2 })), this.clientSocket.ping(), this.core.abtest.abtRequest(), "function" == typeof (null === (t2 = this.core.V2NIMClientAntispamUtil) || void 0 === t2 ? void 0 : t2.downloadLocalAntiSpamVocabs) && this.core.V2NIMClientAntispamUtil.downloadLocalAntiSpamVocabs(), "function" == typeof (null === (r2 = this.core.cloudStorage) || void 0 === r2 ? void 0 : r2.init))
              try {
                yield this.core.cloudStorage.init(n2.timestamp);
              } catch (e3) {
                this.logger.warn("doLogin::cloudStorage init error", e3);
              }
            return n2;
          });
        }
        smoothForLogined(e2, t2, r2) {
          return __awaiter(this, void 0, void 0, function* () {
            var i2 = this.checkIsSameLogin(e2, t2, r2);
            return this.logger.warn(`V2NIMLoginService::smoothForLogined:Logined, isSameLogin ${i2}`), i2 ? void 0 : (yield this.logout(), this.login(e2, t2, r2));
          });
        }
        smoothForLogining(e2, t2, r2) {
          return __awaiter(this, void 0, void 0, function* () {
            var i2 = this.checkIsSameLogin(e2, t2, r2);
            if (this.logger.warn(`V2NIMLoginService::smoothForLogining:Logining progress exists, abort the previous login attempt and start next attempt, isSameLogin ${i2}`), this.previousLoginManager.clear(), this.reconnect.reset(), this.account = e2, this.previousLoginAccount = e2, this.token = t2, this.loginOption = assignOptions(this.loginOption, r2), !i2)
              return this.doLoginStepsManager.clear(), this.clientSocket.doDisconnect(It.ACTIVE, "Aborted"), this.reset(), this.lifeCycle.processEvent("logout"), yield Promise.resolve(), this.login(e2, t2, r2);
            if (!this.originLoginPromise)
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INTERNAL, detail: { reason: "NoPreviousLoginExists" } });
            this.reconnect.reset(), yield Promise.resolve(), yield this.multiTryDoLogin(this.originLoginPromise);
          });
        }
        checkIsSameLogin(e2, t2, r2) {
          return this.account === e2 && this.loginOption.authType === r2.authType && (0 !== r2.authType || this.token === t2);
        }
        logout() {
          return __awaiter(this, void 0, void 0, function* () {
            this._checkApiVersion(), this.doLoginStepsManager.clear(), this.previousLoginManager.clear(), this.loginTimerManager.destroy(), this.originLoginPromise = void 0;
            var e2 = this.getConnectStatus(), t2 = this.getLoginStatus();
            switch (t2) {
              case 1:
                try {
                  yield this.clientSocket.sendCmd("v2Logout", void 0, { timeout: 1e3 }), this.clientSocket.doDisconnect(It.ACTIVE, "UserActiveDisconnect"), this.core._clearModuleData(), this.lifeCycle.processEvent("logout");
                } catch (e3) {
                  this.logger.error("Instance::disconnect sendCmd:logout error", e3), this.clientSocket.doDisconnect(It.ACTIVE, "UserActiveDisconnect"), this.core._clearModuleData(), this.lifeCycle.processEvent("logout");
                }
                break;
              case 2:
              case 3:
                this.clientSocket.doDisconnect(It.ACTIVE, "UserActiveDisconnect"), this.core._clearModuleData(), this.lifeCycle.processEvent("logout");
                break;
              case 0:
                throw this.core._clearModuleData(), new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_ILLEGAL_STATE, detail: { reason: `Illegal logout. loginStatus ${t2}. connectStatus ${e2}` } });
              default:
                throw this.core._clearModuleData(), new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_ILLEGAL_STATE, detail: { reason: `Illegal logout. illegal status: loginStatus ${t2}. connectStatus ${e2}` } });
            }
          });
        }
        getConnectStatus() {
          return this.lifeCycle.getConnectStatus();
        }
        getLoginStatus() {
          return this.lifeCycle.getLoginStatus();
        }
        getLoginUser() {
          return this.account;
        }
        getLoginClients() {
          return function uniqBy(e2, t2) {
            e2 = e2 || [], t2 = t2 || "";
            for (var r2 = [], i2 = [], s2 = 0; s2 < e2.length; s2++) {
              var n2 = e2[s2][t2];
              -1 === i2.indexOf(n2) && (i2.push(n2), r2.push(e2[s2]));
            }
            return r2;
          }(this.authenticator.loginClients, "clientId").map((e2) => pick(e2, ["type", "os", "timestamp", "customTag", "customClientType", "clientId", "clientIP"]));
        }
        getCurrentLoginClient() {
          var e2;
          if (null === (e2 = this.authenticator.loginClientOfThisConnection) || void 0 === e2 ? void 0 : e2.clientId)
            return pick(this.authenticator.loginClientOfThisConnection, ["type", "os", "timestamp", "customTag", "customClientType", "clientId", "clientIP"]);
        }
        getDataSync() {
          var e2 = this.dataSync.datas;
          return e2 && e2.length > 0 ? e2.map((e3) => ({ type: e3.type, state: e3.state })) : null;
        }
        setReconnectDelayProvider(e2) {
          this.reconnect._setReconnectDelayProvider(e2);
        }
        kickOffline(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            if (this._checkApiVersion(), validate({ clientId: { type: "string", allowEmpty: false } }, e2, "", true), 0 === get(yield this.clientSocket.sendCmd("v2KickOffline", { clientIds: [e2.clientId] }), "content.clientIds.length"))
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_REQUEST_FAILED });
          });
        }
        getKickedOfflineDetail() {
          return this.kickedDetail;
        }
        checkLoginTerminalCode(e2) {
          return this.authenticator.checkLoginTerminalCode(e2);
        }
        checkIllegalState() {
          if (!this.getLoginUser())
            throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_ILLEGAL_STATE });
        }
        _checkApiVersion() {
          if ("v2" !== this.core.options.apiVersion)
            throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_MISUSE, detail: { reason: 'apiVersion is not "v2"' } });
        }
        v2LoginHandler(e2) {
          if (e2.error)
            throw this.clientSocket.doDisconnect(It.ACTIVE, e2.error), e2.error;
          return e2;
        }
        v2LoginClientChangeHandler(e2) {
          this.authenticator.changeLoginClient(parseInt(e2.content.state), e2.content.datas);
        }
        nimLoginClientChangeHandler(e2) {
          this.authenticator.changeLoginClient(parseInt(e2.content.state), e2.content.datas);
        }
        qchatLoginClientChangeHandler(e2) {
          var t2 = parseInt(e2.content.state);
          t2 = 1 === t2 ? 2 : 3, this.authenticator.changeLoginClient(t2, [e2.content.data]);
        }
        v2BeKickedHandler(e2) {
          if (e2.error)
            this.core.logger.error("v2BeKickedHandler error, ", e2.error);
          else {
            var t2 = function formatBeKickedTag(e3) {
              return format({ reason: { type: "number" }, clientType: { type: "number" }, customClientType: { type: "number" } }, e3);
            }(e2.content);
            this.core.logger.warn("v2Bekicked::", t2), this.kickedDetail = t2, this.clientSocket.doDisconnect(It.KICKED, t2), this.core._clearModuleData(), this.lifeCycle.processEvent("kicked", new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_DISCONNECT, detail: { reason: "disconnect due to kicked" } }), t2), this.emit("onKickedOffline", t2);
          }
        }
        emit(e2, ...t2) {
          var r2 = `${this.name}::emit ${e2.toString()}`;
          if ("onLoginFailed" === e2 || "onDisconnected" === e2 || "onConnectFailed" === e2) {
            var i2 = t2[0];
            this.logger.log(`${r2}`, i2.toString());
          } else if ("onDataSync" === e2) {
            var s2 = t2[2];
            this.logger.log(`${r2}`, t2[0], t2[1], s2 && s2.toString());
          } else
            this.logger.log(`${r2}`, ...t2);
          return super.emit(e2, ...t2);
        }
      }, "V2NIMLoginService"), NIM.registerService(class V2NIMLocalConversationServiceImpl extends V2Service {
        constructor(e2, t2 = {}) {
          super("V2NIMLocalConversationService", e2), this.config = {}, this.model = new V2NIMLocalConversationModelImpl(), this.unread = new V2NIMLocalConversationUnreadImpl(this.core, this), this.compute = new V2NIMLocalConversationComputeImpl(this.core, this), this.event = new V2NIMLocalConversationEventImpl(this.core, this), this.handler = new V2NIMLocalConversationHandlerImpl(this.core, this), this.core._registerDep(V2NIMConversationIdUtilImpl, "V2NIMConversationIdUtil"), this.core._registerDep(V2NIMMessageServiceImpl, "V2NIMMessageService"), "v2" === this.core.options.apiVersion && (registerParser({ cmdMap: _a, cmdConfig: Ra }), this.setOptions(t2), this.setListener());
        }
        setOptions(e2) {
          this.config = Object.assign(this.config, e2);
        }
        setListener() {
          this.event.setListener();
        }
        reset() {
          this.model.reset(), this.unread.reset();
        }
        emit(e2, ...t2) {
          return this.event.beforeEmit(e2, ...t2), super.emit(e2, ...t2);
        }
        getConversationList(e2, t2) {
          this.checkV2(), validate({ offset: { type: "number", min: 0 } }, { offset: e2 }, "", true), validate({ limit: { type: "number", min: 1 } }, { limit: t2 }, "", true), this.core.V2NIMLoginService.checkIllegalState();
          var r2 = this.model.getByOption(e2, t2, {});
          return r2.conversationList = r2.conversationList.map((e3) => this.compute.computeFromExternal(e3)), Promise.resolve(r2);
        }
        getConversationListByOption(e2, t2, r2) {
          this.checkV2(), validate({ offset: { type: "number", min: 0 } }, { offset: e2 }, "", true), validate({ limit: { type: "number", min: 1 } }, { limit: t2 }, "", true), validate({ conversationTypes: { type: "array", itemType: "number", required: false }, onlyUnread: { type: "boolean", required: false } }, r2, "option", true), this.core.V2NIMLoginService.checkIllegalState();
          var i2 = this.model.getByOption(e2, t2, r2);
          return i2.conversationList = i2.conversationList.map((e3) => this.compute.computeFromExternal(e3)), Promise.resolve(i2);
        }
        getConversation(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validateConversationId(this.core.account, e2);
            var t2 = this.model.getById(e2);
            if (t2)
              return this.compute.computeFromExternal(t2);
            throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_RESOURCE_NOT_EXIST });
          });
        }
        getConversationListByIds(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validate({ conversationIds: { type: "array", itemType: "string", min: 1 } }, { conversationIds: e2 }, "", true), this.core.V2NIMLoginService.checkIllegalState();
            var t2 = e2.map((e3) => this.model.getById(e3)).filter((e3) => !!e3);
            return t2 = t2.map((e3) => this.compute.computeFromExternal(e3));
          });
        }
        createConversation(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validateConversationId(this.core.account, e2);
            var t2 = this.model.getById(e2);
            if (t2)
              return this.compute.computeFromExternal(t2);
            var r2 = this.compute.computeConvByMsgsCache(e2, { updateTime: this.core.timeOrigin.getNTPTime() });
            r2 = this.compute.computeConvWithUnread(r2), r2 = this.compute.computeFromExternal(r2), this.model.upsert(r2);
            var i2 = this.model.getById(e2);
            return this.triggerConversationCreated(i2), i2;
          });
        }
        deleteConversation(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validateConversationId(this.core.account, e2), validate({ clearMessage: { type: "boolean", required: false } }, { clearMessage: t2 }, "", true), yield this.unread.markConversationRead(e2);
            var r2 = this.model.deleteById(e2);
            if (!r2)
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_RESOURCE_NOT_EXIST });
            t2 && this.core.V2NIMMessageService.model.deleteMessages(e2), !!(r2 && r2.unreadCount > 0) && this.unread.digestUnreadCountChange(), this.emit("onConversationDeleted", [e2]);
          });
        }
        deleteConversationListByIds(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validate({ conversationIds: { type: "array", itemType: "string", min: 1 } }, { conversationIds: e2 }, "", true), validate({ clearMessage: { type: "boolean", required: false } }, { clearMessage: t2 }, "", true), yield this.unread.markMultiConversationRead(e2);
            var r2 = false;
            return e2.forEach((e3) => {
              t2 && this.core.V2NIMMessageService.model.deleteMessages(e3), this.model.deleteById(e3) && (r2 = true);
            }), r2 && this.unread.digestUnreadCountChange(), this.emit("onConversationDeleted", e2), [];
          });
        }
        getStickTopConversationList() {
          return __awaiter(this, void 0, void 0, function* () {
            return this.checkV2(), this.core.V2NIMLoginService.checkIllegalState(), this.model.getStickTopList();
          });
        }
        stickTopConversation(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validateConversationId(this.core.account, e2), validate({ stickTop: { type: "boolean" } }, { stickTop: t2 }, "", true);
            var r2 = this.model.getById(e2);
            if ((null == r2 ? void 0 : r2.stickTop) !== t2) {
              var i2 = this.core.V2NIMConversationIdUtil.parseConversationTargetId(e2), s2 = this.core.V2NIMConversationIdUtil.parseConversationType(e2), n2 = yield this.core.sendCmd(t2 ? "v2LocalConvStickTopAdd" : "v2LocalConvStickTopDelete", { tag: { id: getSessionIdFromConvInfo(s2, i2) } });
              this.model.updateStickTop(e2, t2);
              var a2 = n2.content.timetag || n2.content.data.updateTime;
              this.model.upsert({ conversationId: e2, type: s2, stickTop: t2, updateTime: a2, sortOrder: this.compute.computeSortOrder(t2, a2) });
              var o2 = [this.model.getById(e2)];
              this.triggerConversationChanged(o2);
            }
          });
        }
        updateConversationLocalExtension(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validateConversationId(this.core.account, e2), validate({ localExtension: { type: "string" } }, { localExtension: t2 }, "", true);
            var r2 = this.model.getById(e2);
            if (!r2)
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_RESOURCE_NOT_EXIST });
            if (r2.localExtension !== t2) {
              var i2 = Object.assign(Object.assign({}, r2), { localExtension: t2 });
              this.model.upsert(i2), this.triggerConversationChanged([i2]);
            }
          });
        }
        getTotalUnreadCount() {
          return this.checkV2(), this.unread.getTotalUnreadCount() || 0;
        }
        getUnreadCountByIds(e2) {
          this.checkV2(), validate({ conversationIds: { type: "array", itemType: "string", min: 1 } }, { conversationIds: e2 }, "", true);
          var t2 = this.unread.getUnreadCountByIds(e2);
          return Promise.resolve(t2);
        }
        getUnreadCountByFilter(e2) {
          this.checkV2(), this.valiteFilter(e2);
          var t2 = this.unread.getUnreadCountByFilter(e2);
          return Promise.resolve(t2);
        }
        clearTotalUnreadCount() {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), this.checkLogin();
            var e2 = this.model.getAll();
            yield this.unread.markMultiConversationRead(e2.map((e3) => e3.conversationId)), this.unread.clearUnreadCount(e2);
          });
        }
        clearUnreadCountByIds(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), this.checkLogin(), validate({ conversationIds: { type: "array", itemType: "string", min: 1 } }, { conversationIds: e2 }, "", true);
            var t2 = [], r2 = [], i2 = new RegExp(`^${this.core.account}\\|[1-3]\\|`);
            if (e2.forEach((e3) => {
              i2.test(e3) ? t2.push(e3) : r2.push(e3);
            }), t2.length > 0) {
              var s2 = t2.map((e3) => this.model.getById(e3)).filter((e3) => !!e3);
              yield this.unread.markMultiConversationRead(t2), this.unread.clearUnreadCount(s2);
            }
            return r2.map((e3) => ({ conversationId: e3, error: new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_RESOURCE_NOT_EXIST }) }));
          });
        }
        clearUnreadCountByTypes(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), this.checkLogin(), validate({ types: Na }, { types: e2 }, "", true);
            var t2 = this.model.getByOption(0, 1e3, { conversationTypes: e2 });
            yield this.unread.markMultiConversationRead(t2.conversationList.map((e3) => e3.conversationId)), this.unread.clearUnreadCount(t2.conversationList);
          });
        }
        subscribeUnreadCountByFilter(e2) {
          var t2;
          this.checkV2(), this.checkLogin(), this.valiteFilter(e2), 0 === (null === (t2 = e2.conversationTypes) || void 0 === t2 ? void 0 : t2.length) && delete e2.conversationTypes, this.unread.addFilter(e2);
        }
        unsubscribeUnreadCountByFilter(e2) {
          var t2;
          this.checkV2(), this.checkLogin(), this.valiteFilter(e2), 0 === (null === (t2 = e2.conversationTypes) || void 0 === t2 ? void 0 : t2.length) && delete e2.conversationTypes, this.unread.deleteFilter(e2);
        }
        getConversationReadTime(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.checkV2(), validateConversationId(this.core.account, e2), this.model.getReadTime(e2);
          });
        }
        markConversationRead(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.checkV2(), this.checkLogin(), validateConversationId(this.core.account, e2), this.unread.markConversationRead(e2);
          });
        }
        setCurrentConversation(e2) {
          this.checkV2(), e2 && validateConversationId(this.core.account, e2), this.unread.setCurrentConversation(e2);
        }
        valiteFilter(e2) {
          if (validate({ filter: { type: "object", required: true, rules: { conversationTypes: { type: "array", itemType: "number", required: false }, ignoreMuted: { type: "boolean", required: false } } } }, { filter: e2 }, "", true), void 0 === e2.conversationTypes && true !== e2.ignoreMuted)
            throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "Filter cannot be empty" } });
        }
        triggerConversationChanged(e2) {
          e2 = e2.map((e3) => this.compute.computeFromExternal(e3)), (e2 = JSON.parse(JSON.stringify(e2))).forEach((e3) => {
            e3.lastMessage || (e3.lastMessage = void 0), delete e3.lastMessageState;
          }), this.emit("onConversationChanged", e2);
        }
        triggerConversationCreated(e2) {
          e2 = this.compute.computeFromExternal(e2), delete (e2 = JSON.parse(JSON.stringify(e2))).lastMessageState, this.emit("onConversationCreated", e2);
        }
      }, "V2NIMLocalConversationService"), NIM.registerService(V2NIMConversationServiceImpl, "V2NIMConversationService"), NIM.registerService(class V2NIMConversationGroupServiceImpl extends V2Service {
        constructor(e2, t2 = {}) {
          super("V2NIMConversationGroupService", e2), this.config = {}, this.core._registerDep(V2NIMConversationServiceImpl, "V2NIMConversationService"), "v2" === this.core.options.apiVersion && true === this.core.options.enableV2CloudConversation && (registerParser({ cmdMap: Da, cmdConfig: Ba }), this.setOptions(t2));
        }
        setOptions(e2) {
          this.config = Object.assign(this.config, e2);
        }
        emit(e2, ...t2) {
          var r2 = `${this.name}::emit ${e2.toString()}`;
          if ("onConversationsAddedToGroup" === e2) {
            var i2 = t2[0], s2 = t2[1];
            this.logger.log(`${r2}`, `groupId:${i2}`, `conversations:${s2.map((e3) => e3.conversationId).join(",")}`);
          } else
            this.logger.log(`${r2}`, ...t2);
          return super.emit(e2, ...t2);
        }
        get ifEnabled() {
          return true === this.core.options.enableV2CloudConversation;
        }
        checkEnable() {
          if (true !== this.core.options.enableV2CloudConversation)
            throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_MISUSE, detail: { reason: "V2CloudConversation is not enabled" } });
        }
        createConversationGroup(e2, t2, r2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkEnable(), this.checkV2(), validate({ name: { type: "string", allowEmpty: false } }, { name: e2 }, "", true), validate({ serverExtension: { type: "string", required: false } }, { serverExtension: t2 }, "", true), validate({ conversationIds: { type: "array", itemType: "string", required: false } }, { conversationIds: r2 }, "", true);
            var i2 = yield this.core.sendCmd("v2ConversationGroupCreate", { tag: { name: e2, serverExtension: t2 || "", conversationIds: r2 && JSON.stringify(r2) } }), s2 = formatConversationGroup(get(i2, "content.data")), n2 = formatConversationFields(this.core, get(i2, "content.conversations")), a2 = formatFailedMap(get(i2, "content.info.failedMap"));
            return this.emit("onConversationGroupCreated", s2), n2.length > 0 && (this.core.V2NIMConversationService.versionCache.compareAndUpdateModel(n2), this.emit("onConversationsAddedToGroup", s2.groupId, n2.map((e3) => this.core.V2NIMConversationService.model.getById(e3.conversationId)).filter((e3) => !!e3))), { group: s2, failedList: a2 };
          });
        }
        deleteConversationGroup(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkEnable(), this.checkV2(), validate({ groupId: { type: "string", allowEmpty: false } }, { groupId: e2 }, "", true);
            var t2 = formatConversationGroupNotify(get(yield this.core.sendCmd("v2ConversationGroupDelete", { tag: { groupId: e2 } }), "content.info"));
            this.core.V2NIMConversationService.versionCache.compareAndDeleteGroupInModel(t2.deleteVersion, e2), this.emit("onConversationGroupDeleted", e2);
          });
        }
        updateConversationGroup(e2, t2, r2) {
          return __awaiter(this, void 0, void 0, function* () {
            if (this.checkEnable(), this.checkV2(), validate({ groupId: { type: "string", allowEmpty: false } }, { groupId: e2 }, "", true), validate({ name: { type: "string", required: false } }, { name: t2 }, "", true), validate({ serverExtension: { type: "string", required: false } }, { serverExtension: r2 }, "", true), void 0 === t2 && void 0 === r2)
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER });
            var i2 = formatConversationGroup(get(yield this.core.sendCmd("v2ConversationGroupUpdate", { tag: { groupId: e2, name: t2, serverExtension: r2 } }), "content.data"));
            this.emit("onConversationGroupChanged", i2);
          });
        }
        addConversationsToGroup(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkEnable(), this.checkV2(), validate({ groupId: { type: "string", allowEmpty: false } }, { groupId: e2 }, "", true), validate({ conversationIds: { type: "array", itemType: "string", min: 1, allowEmpty: false } }, { conversationIds: t2 }, "", true);
            var r2 = yield this.core.sendCmd("v2ConversationGroupAddTo", { tag: { groupId: e2, conversationIds: JSON.stringify(t2) } }), i2 = get(r2, "content.info.failedMap") || "", s2 = [];
            i2 && (s2 = formatFailedMap(i2));
            var n2 = formatConversationFields(this.core, get(r2, "content.datas"));
            this.core.V2NIMConversationService.versionCache.compareAndUpdateModel(n2);
            var a2 = n2.map((e3) => this.core.V2NIMConversationService.model.getById(e3.conversationId)).filter((e3) => !!e3);
            return a2.length > 0 && this.emit("onConversationsAddedToGroup", e2, a2), s2;
          });
        }
        removeConversationsFromGroup(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkEnable(), this.checkV2(), validate({ groupId: { type: "string", allowEmpty: false } }, { groupId: e2 }, "", true), validate({ conversationIds: { type: "array", itemType: "string", min: 1, allowEmpty: false } }, { conversationIds: t2 }, "", true);
            var r2 = yield this.core.sendCmd("v2ConversationGroupRemoveFrom", { tag: { groupId: e2, conversationIds: JSON.stringify(t2) } }), i2 = get(r2, "content.info.failedMap") || "", s2 = [];
            i2 && (s2 = formatFailedMap(i2));
            var n2 = formatConversationFields(this.core, get(r2, "content.datas"));
            return this.core.V2NIMConversationService.versionCache.compareAndUpdateModel(n2), this.emit("onConversationsRemovedFromGroup", e2, n2.map((e3) => e3.conversationId)), s2;
          });
        }
        getConversationGroup(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.checkEnable(), this.checkV2(), validate({ groupId: { type: "string", allowEmpty: false } }, { groupId: e2 }, "", true), formatConversationGroup(get(yield this.core.sendCmd("v2ConversationGroupGet", { tag: { groupId: e2 } }), "content.data"));
          });
        }
        getConversationGroupList() {
          return __awaiter(this, void 0, void 0, function* () {
            return this.checkEnable(), this.checkV2(), formatConversationGroups(get(yield this.core.sendCmd("v2ConversationGroupListGet"), "content.datas"));
          });
        }
        getConversationGroupListByIds(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkEnable(), this.checkV2(), validate({ groupIds: { type: "array", itemType: "string", min: 1 } }, { groupIds: e2 }, "", true);
            var t2 = formatConversationGroups(get(yield this.core.sendCmd("v2ConversationGroupsGet", { tag: { groupIds: e2 && JSON.stringify(e2) } }), "content.datas"));
            return e2.map((e3) => t2.filter((t3) => t3.groupId === e3)[0]).filter((e3) => !!e3);
          });
        }
        v2ConversationGroupNotifySyncOnlineHandler(e2) {
          if (this.ifEnabled) {
            var t2 = formatConversationGroupNotify(get(e2, "content.info")), { type: r2, deleteVersion: i2, conversationIds: s2 } = t2, n2 = formatConversationGroup(get(e2, "content.data"));
            if (this.core.logger.log("v2ConversationGroupNotifySyncOnlineHandler", t2, n2), 1 === r2)
              this.emit("onConversationGroupCreated", n2), s2 && s2.length > 0 && this.emit("onConversationsAddedToGroup", n2.groupId, s2.map((e3) => this.core.V2NIMConversationService.model.getById(e3)).filter((e3) => !!e3));
            else if (2 === r2)
              this.emit("onConversationGroupDeleted", n2.groupId), this.core.V2NIMConversationService.versionCache.compareAndDeleteGroupInModel(i2, n2.groupId);
            else if (3 === r2)
              this.emit("onConversationGroupChanged", n2);
            else if (4 === r2) {
              var a2 = s2.map((e3) => this.core.V2NIMConversationService.model.getById(e3)).filter((e3) => !!e3);
              this.emit("onConversationsAddedToGroup", n2.groupId, a2);
            } else
              5 === r2 && this.emit("onConversationsRemovedFromGroup", n2.groupId, s2);
          }
        }
      }, "V2NIMConversationGroupService"), NIM.registerService(V2NIMMessageServiceImpl, "V2NIMMessageService"), NIM.registerService(class V2NIMNotificationServiceImpl extends V2Service {
        constructor(e2, t2) {
          super("V2NIMNotificationService", e2), this.config = { compatibleWithV1: true }, this.notificationUtil = new NotificationUtil(this.core), this.core._registerDep(V2NIMConversationIdUtilImpl, "V2NIMConversationIdUtil"), "v2" === this.core.options.apiVersion && (registerParser({ cmdMap: ma, cmdConfig: ha }), this.setOptions(t2));
        }
        setOptions(e2) {
          var t2;
          (null === (t2 = this.core.systemMessage) || void 0 === t2 ? void 0 : t2.name) ? this.config.compatibleWithV1 = true : this.config.compatibleWithV1 = false, this.config = Object.assign(this.config, e2);
        }
        emit(e2, ...t2) {
          var r2 = `${this.name}::emit ${e2.toString()}`;
          if ("onReceiveCustomNotifications" === e2) {
            var i2 = t2[0];
            this.logger.log(`${r2}`, i2.map((e3) => `sender:${e3.senderId};receiver:${e3.receiverId};ctype:${e3.conversationType};time:${e3.timestamp}`));
          } else if ("onReceiveBroadcastNotifications" === e2) {
            var s2 = t2[0];
            this.logger.log(`${r2}`, s2.map((e3) => `id:${e3.id};sender:${e3.senderId};time:${e3.timestamp}`));
          } else
            this.logger.log(`${r2}`, ...t2);
          return super.emit(e2, ...t2);
        }
        sendCustomNotification(e2, t2, r2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validateConversationId(this.core.account, e2), validate(fa, { content: t2, params: r2 }, "", true);
            var i2 = 3 === this.core.V2NIMConversationIdUtil.parseConversationType(e2) ? "v2SendCustomNotificationWithSuperTeam" : "v2SendCustomNotification", s2 = this.notificationUtil.generateNotificationTag(e2, t2, r2);
            yield this.core.sendCmd(i2, { tag: s2 });
          });
        }
        processSystemNotification(e2) {
          var t2 = e2.type;
          if ([0, 1, 2, 3, 4, 15, 16, 17, 18].includes(t2))
            this.core.eventBus.emit("V2NIMTeamService/sysNotification", e2);
          else {
            if (![5, 6].includes(t2)) {
              var r2 = Object.assign(Object.assign({}, e2), { conversationType: { 100: 1, 101: 2, 102: 1, 103: 3 }[t2] });
              return delete r2.type, r2;
            }
            this.core.eventBus.emit("V2NIMFriendService/sysNotification", e2);
          }
        }
        markBroadcastMsgAck(e2) {
          this.config.compatibleWithV1 || this.core.sendCmd("v2BatchMarkRead", { sid: 7, cid: 17, ids: e2.map((e3) => e3.id) });
        }
        syncBroadcastMsgHandler(e2) {
          var t2 = e2.content.datas;
          this.markBroadcastMsgAck(t2), t2.forEach((e3) => {
            this.core.eventBus.emit("V2NIMSync/updateTimetag", { broadcastMsgs: parseInt(e3.id) });
          }), this.emit("onReceiveBroadcastNotifications", t2);
        }
        onBroadcastMsgHandler(e2) {
          var t2 = e2.content.data;
          this.markBroadcastMsgAck([t2]), this.core.eventBus.emit("V2NIMSync/updateTimetag", { broadcastMsgs: parseInt(t2.id) }), this.emit("onReceiveBroadcastNotifications", [t2]);
        }
        onSysNotificationHandler(e2) {
          var t2 = fillIdServer(e2, e2.content.data, "idServer");
          this.markSysNotificationAck([t2]);
          var r2 = this.processSystemNotification(t2);
          r2 && this.emit("onReceiveCustomNotifications", [r2]);
        }
        v2SyncOfflineSysNotificationsHandler(e2) {
          this.markSysNotificationAck(e2.content.datas);
          var t2 = e2.content.datas.sort((e3, t3) => e3.timestamp - t3.timestamp).map((e3) => this.processSystemNotification(e3)).filter((e3) => e3);
          t2 && this.emit("onReceiveCustomNotifications", t2);
        }
        v2NotificationRevokeHandler(e2) {
          var t2 = fillIdServer(e2, e2.content.data, "idServer");
          this.markSysNotificationAck([t2]);
        }
        v2NotificationSyncRevokeHandler(e2) {
          var { type: t2 } = e2.content;
          1 === parseInt(t2) && this.markSysNotificationAck(e2.content.datas);
        }
        markSysNotificationAck(e2) {
          if (!this.config.compatibleWithV1) {
            var t2 = [], r2 = [], i2 = [15, 16, 17, 18, 103];
            e2.forEach((e3) => {
              e3.idServer && (i2.includes(e3.type) ? r2.push(e3.idServer) : t2.push(e3.idServer));
            }), t2.length > 0 && this.core.sendCmd("v2BatchMarkRead", { sid: "7", cid: "3", ids: t2 }), r2.length > 0 && this.core.sendCmd("v2BatchMarkRead", { sid: "21", cid: "19", ids: r2 });
          }
        }
      }, "V2NIMNotificationService"), NIM.registerService(V2NIMStorageServiceImpl, "V2NIMStorageService"), NIM.registerService(V2NIMStorageUtil, "V2NIMStorageUtil"), NIM.registerService(class V2NIMTeamServiceImpl extends V2Service {
        constructor(e2) {
          super("V2NIMTeamService", e2), this.core._registerDep(V2NIMConversationIdUtilImpl, "V2NIMConversationIdUtil"), this.model = new V2NIMTeamModelImpl(), this.memberModel = new V2NIMTeamMemberModelImpl(), this.notificationModel = new V2NIMTeamNotificationModelImpl(), this.notification = new V2NIMTeamNotificationImpl(e2, this), this.event = new V2NIMTeamEventImpl(e2, this), this.handler = new V2NIMTeamHandlerImpl(e2, this), "v2" === this.core.options.apiVersion && (registerParser({ cmdMap: zn, cmdConfig: ea }), this.setListener());
        }
        setListener() {
          this.event.setListener();
        }
        reset() {
          this.model.reset(), this.memberModel.reset(), this.notificationModel.reset();
        }
        emit(e2, ...t2) {
          return this.event.beforeEmit(e2, ...t2), super.emit(e2, ...t2);
        }
        createTeam(e2, t2, r2, i2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validate({ createTeamParams: no }, { createTeamParams: e2 }, "", true), validate({ inviteeAccountIds: Object.assign(Object.assign({}, ao), { min: 0, required: false }) }, { inviteeAccountIds: t2 }, "", true), validate({ antispamConfig: mo }, { antispamConfig: i2 }, "", true);
            var s2 = 2 === e2.teamType ? "v2SuperTeamCreate" : "v2TeamCreate", n2 = yield this.core.sendCmd(s2, { team: e2, inviteeAccountIds: t2 || [], postscript: r2 || "", antispamConfig: i2 }), a2 = n2.content.team;
            return this.model.upsert(a2), this.getTeamMemberListByIds(a2.teamId, a2.teamType, [this.core.account]).catch((e3) => {
              this.core.logger.error("Get Member error after createTeam", e3);
            }), this.emit("onTeamCreated", a2), { team: a2, failedList: n2.content.failedList };
          });
        }
        updateTeamInfo(e2, t2, r2, i2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validate(po, { teamId: e2 }, "", true), validate(ho, { teamType: t2 }, "", true), validate(yo, { updateTeamInfoParams: r2 }, "", true), validate({ antispamConfig: mo }, { antispamConfig: i2 }, "", true);
            var s2 = Object.assign({ teamId: e2, teamType: t2 }, r2), n2 = 2 === t2 ? "v2SuperTeamUpdateInfo" : "v2TeamUpdateInfo";
            yield this.core.sendCmd(n2, { team: s2, antispamConfig: i2 }), this.model.upsert(s2);
          });
        }
        leaveTeam(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validate(po, { teamId: e2 }, "", true), validate(ho, { teamType: t2 }, "", true);
            var r2 = 2 === t2 ? "v2SuperTeamLeave" : "v2TeamLeave";
            yield this.core.sendCmd(r2, { teamId: e2 }), this.model.deleteById(e2, t2);
          });
        }
        getTeamInfo(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validate(po, { teamId: e2 }, "", true), validate(ho, { teamType: t2 }, "", true);
            var r2 = 2 === t2 ? "v2SuperTeamGetInfo" : "v2TeamGetInfo", i2 = this.model.getById(e2, t2, false);
            if (i2)
              return i2;
            var s2 = (yield this.core.sendCmd(r2, { teamId: e2 })).content.team;
            return this.model.upsert(s2), s2;
          });
        }
        getJoinedTeamList(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validate(go, { teamTypes: e2 }, "", true), this.core.V2NIMLoginService.checkIllegalState(), e2 && 0 !== e2.length || (e2 = [1, 2]);
            var t2 = [];
            return e2.forEach((e3) => {
              t2 = t2.concat(this.model.getAll(e3));
            }), t2.sort((e3, t3) => e3.createTime - t3.createTime);
          });
        }
        getJoinedTeamCount(e2) {
          this.checkV2(), validate(go, { teamTypes: e2 }, "", true), this.core.V2NIMLoginService.checkIllegalState(), e2 && 0 !== e2.length || (e2 = [1, 2]);
          var t2 = 0;
          return e2.forEach((e3) => {
            t2 += this.model.count(e3);
          }), t2;
        }
        getJoinedTeamMembers(e2) {
          this.checkV2(), validate(go, { teamTypes: e2 }, "", true), this.core.V2NIMLoginService.checkIllegalState(), e2 && 0 !== e2.length || (e2 = [1, 2]);
          var t2 = [];
          return e2.forEach((e3) => {
            var r2 = this.memberModel.chooseList(e3).filter((e4) => e4.accountId === this.core.account);
            t2 = t2.concat(r2);
          }), Promise.resolve(t2);
        }
        getTeamInfoByIds(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validate(uo, { teamIds: e2 }, "", true), validate(ho, { teamType: t2 }, "", true);
            var r2 = 2 === t2 ? "v2SuperTeamGetByIds" : "v2TeamGetByIds", i2 = e2.map((e3) => this.model.getById(e3, t2, false)), s2 = e2.filter((e3, t3) => !i2[t3]);
            if (0 === s2.length)
              return i2;
            var n2 = (yield this.core.sendCmd(r2, { teamIds: s2 })).content.teams;
            return i2.map((t3, r3) => {
              if (t3)
                return t3;
              var i3 = e2[r3], s3 = n2.find((e3) => e3.teamId === i3);
              return s3 && this.model.upsert(s3), s3;
            }).filter((e3) => !!e3);
          });
        }
        dismissTeam(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validate(po, { teamId: e2 }, "", true), validate(ho, { teamType: t2 }, "", true);
            var r2 = 2 === t2 ? "v2SuperTeamDismiss" : "v2TeamDismiss";
            yield this.core.sendCmd(r2, { teamId: e2 });
          });
        }
        inviteMember(e2, t2, r2, i2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validate(po, { teamId: e2 }, "", true), validate(ho, { teamType: t2 }, "", true), validate({ inviteeAccountIds: ao }, { inviteeAccountIds: r2 }, "", true), validate({ postscript: Object.assign(Object.assign({}, co), { required: false }) }, { postscript: i2 }, "", true);
            var s2 = 2 === t2 ? "v2SuperTeamInviteMembers" : "v2TeamInviteMembers";
            return (yield this.core.sendCmd(s2, { teamId: e2, accounts: r2, ps: i2 || "" })).content.abortedAccidList;
          });
        }
        inviteMemberEx(e2, t2, r2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validate(po, { teamId: e2 }, "", true), validate(ho, { teamType: t2 }, "", true), validate(vo, { inviteeParams: r2 }, "", true);
            var i2 = 2 === t2 ? "v2SuperTeamInviteMembers" : "v2TeamInviteMembers";
            return (yield this.core.sendCmd(i2, { teamId: e2, accounts: r2.inviteeAccountIds, ps: r2.postscript || "", attach: r2.serverExtension })).content.abortedAccidList;
          });
        }
        acceptInvitation(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validate(To, e2, "invitationInfo", true), validate(Co, e2, "invitationInfo", true);
            var { teamType: t2, teamId: r2, operatorAccountId: i2 } = e2, s2 = 2 === t2 ? "v2SuperTeamAcceptInvitation" : "v2TeamAcceptInvitation";
            try {
              var n2 = yield this.core.sendCmd(s2, { teamId: r2, from: i2 });
              return this.notification.updateTeamActionStatus(e2, 1), n2.content.team;
            } catch (t3) {
              var a2 = t3;
              throw this.notification.checkIfExpired(a2.code) && this.notification.updateTeamActionStatus(e2, 3), t3;
            }
          });
        }
        rejectInvitation(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validate(To, e2, "invitationInfo", true), validate(Co, e2, "invitationInfo", true), validate({ postscript: Object.assign(Object.assign({}, co), { required: false }) }, { postscript: t2 }, "", true);
            var { teamType: r2, teamId: i2, operatorAccountId: s2 } = e2, n2 = 2 === r2 ? "v2SuperTeamRejectInvite" : "v2TeamRejectInvite";
            try {
              yield this.core.sendCmd(n2, { teamId: i2, from: s2, ps: t2 || "" }), this.notification.updateTeamActionStatus(e2, 2);
            } catch (t3) {
              var a2 = t3;
              throw this.notification.checkIfExpired(a2.code) && this.notification.updateTeamActionStatus(e2, 3), t3;
            }
          });
        }
        kickMember(e2, t2, r2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validate(po, { teamId: e2 }, "", true), validate(ho, { teamType: t2 }, "", true), validate({ memberAccountIds: ao }, { memberAccountIds: r2 }, "", true);
            var i2 = 2 === t2 ? "v2SuperTeamKickMembers" : "v2TeamKickMembers";
            yield this.core.sendCmd(i2, { teamId: e2, accounts: r2 });
          });
        }
        applyJoinTeam(e2, t2, r2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validate(po, { teamId: e2 }, "", true), validate(ho, { teamType: t2 }, "", true);
            var i2 = 2 === t2 ? "v2SuperTeamApplyToJoin" : "v2TeamApplyToJoin", s2 = yield this.core.sendCmd(i2, { teamId: e2, ps: r2 || "" }), n2 = s2.content.team, a2 = s2.content.isInTeam;
            return n2.isValidTeam = !!n2.isValidTeam && !!a2, n2;
          });
        }
        acceptJoinApplication(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validate(To, e2, "applicationInfo", true), validate(Eo, e2, "applicationInfo", true);
            var { teamType: t2, teamId: r2, operatorAccountId: i2 } = e2, s2 = 2 === t2 ? "v2SuperTeamAcceptJoinApplication" : "v2TeamAcceptJoinApplication";
            try {
              yield this.core.sendCmd(s2, { teamId: r2, from: i2 }), this.notification.updateTeamActionStatus(e2, 1);
            } catch (t3) {
              var n2 = t3;
              throw this.notification.checkIfExpired(n2.code) && this.notification.updateTeamActionStatus(e2, 3), t3;
            }
          });
        }
        rejectJoinApplication(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validate(To, e2, "applicationInfo", true), validate(Eo, e2, "applicationInfo", true), validate({ postscript: Object.assign(Object.assign({}, co), { required: false }) }, { postscript: t2 }, "", true);
            var { teamType: r2, teamId: i2, operatorAccountId: s2 } = e2, n2 = 2 === r2 ? "v2SuperTeamRejectJoinApplication" : "v2TeamRejectJoinApplication";
            try {
              yield this.core.sendCmd(n2, { teamId: i2, from: s2, ps: t2 || "" }), this.notification.updateTeamActionStatus(e2, 2);
            } catch (t3) {
              var a2 = t3;
              throw this.notification.checkIfExpired(a2.code) && this.notification.updateTeamActionStatus(e2, 3), t3;
            }
          });
        }
        updateTeamMemberRole(e2, t2, r2, i2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validate(po, { teamId: e2 }, "", true), validate(ho, { teamType: t2 }, "", true), validate({ memberAccountIds: ao }, { memberAccountIds: r2 }, "", true), validate({ memberRole: fo }, { memberRole: i2 }, "", true);
            var s2 = 2 === i2 ? "AddManagers" : "RemoveManagers";
            s2 = 2 === t2 ? `v2SuperTeam${s2}` : `v2Team${s2}`, yield this.core.sendCmd(s2, { teamId: e2, accounts: uniq(r2) });
          });
        }
        transferTeamOwner(e2, t2, r2, i2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validate(po, { teamId: e2 }, "", true), validate(ho, { teamType: t2 }, "", true), validate({ accountId: lo }, { accountId: r2 }, "", true), validate({ leave: { type: "boolean", required: false } }, { leave: i2 }, "", true);
            var s2 = this.model.getById(e2, t2);
            if (s2 && s2.ownerAccountId === r2)
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "Transfer to self is not allowed" } });
            var n2 = 2 === t2 ? "v2SuperTeamTransferOwner" : "v2TeamTransferOwner";
            yield this.core.sendCmd(n2, { teamId: e2, account: r2, leave: i2 || false });
          });
        }
        updateSelfTeamMemberInfo(e2, t2, r2) {
          return __awaiter(this, void 0, void 0, function* () {
            if (this.checkV2(), validate(po, { teamId: e2 }, "", true), validate(ho, { teamType: t2 }, "", true), validate(Io, { memberInfoParams: r2 }, "", true), void 0 === r2.teamNick && void 0 === r2.serverExtension)
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER });
            var i2 = 2 === t2 ? "v2SuperTeamUpdateSelfMemberInfo" : "v2TeamUpdateSelfMemberInfo", s2 = Object.assign(Object.assign({}, r2), { teamId: e2, accountId: this.core.account }), n2 = r2.antispamConfig ? { teamMember: s2, specialFollowUpdate: {}, antispam: r2.antispamConfig } : { teamMember: s2 };
            yield this.core.sendCmd(i2, n2), yield this.notification.updateTeamMemberRole(e2, t2, [this.core.account], s2);
            var a2 = this.memberModel.getById(e2, t2, this.core.account);
            if (this.core.V2NIMSettingService.name && this.core.V2NIMConversationIdUtil.name) {
              var o2 = 1 === t2 ? this.core.V2NIMConversationIdUtil.teamConversationId(e2) : this.core.V2NIMConversationIdUtil.superTeamConversationId(e2), c2 = this.core.V2NIMSettingService.getConversationMuteStatus(o2);
              this.core.eventBus.emit("V2NIMSettingService/setMute", o2, c2);
            }
            this.core.eventBus.emit("forwardSend/V2NIMTeamService/updateSelfTeamMemberInfo", a2);
          });
        }
        updateTeamMemberNick(e2, t2, r2, i2) {
          return __awaiter(this, void 0, void 0, function* () {
            if (this.checkV2(), validate(po, { teamId: e2 }, "", true), validate(ho, { teamType: t2 }, "", true), validate({ accountId: lo }, { accountId: r2 }, "", true), validate({ nick: co }, { nick: i2 }, "", true), r2 === this.core.account)
              return this.updateSelfTeamMemberInfo(e2, t2, { teamNick: i2 });
            var s2 = 2 === t2 ? "v2SuperTeamUpdateMember" : "v2TeamUpdateMember";
            yield this.core.sendCmd(s2, { teamMember: { teamNick: i2, teamId: e2, accountId: r2 } });
          });
        }
        updateTeamMemberNickEx(e2, t2, r2) {
          return __awaiter(this, void 0, void 0, function* () {
            if (this.checkV2(), validate(po, { teamId: e2 }, "", true), validate(ho, { teamType: t2 }, "", true), validate(No, r2, "", true), r2.accountId === this.core.account)
              return this.updateSelfTeamMemberInfo(e2, t2, { teamNick: r2.teamNick, antispamConfig: r2.antispamConfig });
            var i2 = 2 === t2 ? "v2SuperTeamUpdateMember" : "v2TeamUpdateMember";
            yield this.core.sendCmd(i2, { teamMember: { teamNick: r2.teamNick, teamId: e2, accountId: r2.accountId }, antispam: r2.antispamConfig });
          });
        }
        setTeamChatBannedMode(e2, t2, r2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validate(po, { teamId: e2 }, "", true), validate(ho, { teamType: t2 }, "", true), validate(Mo, { chatBannedMode: r2 }, "", true);
            var i2 = 2 === t2 ? "v2SuperTeamSetChatBannedMode" : "v2TeamSetChatBannedMode";
            yield this.core.sendCmd(i2, { teamId: e2, chatBannedMode: r2 }), this.model.upsert({ teamId: e2, teamType: t2, chatBannedMode: r2 });
          });
        }
        setTeamMemberChatBannedStatus(e2, t2, r2, i2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validate(po, { teamId: e2 }, "", true), validate(ho, { teamType: t2 }, "", true), validate({ accountId: lo }, { accountId: r2 }, "", true), validate({ chatBanned: oo }, { chatBanned: i2 }, "", true);
            var s2 = 2 === t2 ? "v2SuperTeamMemberSetChatBannedStatus" : "v2TeamMemberSetChatBannedStatus";
            yield this.core.sendCmd(s2, { teamId: e2, accountId: 2 === t2 ? [r2] : r2, chatBanned: i2 ? 1 : 0 });
          });
        }
        getTeamMemberList(e2, t2, r2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validate(po, { teamId: e2 }, "", true), validate(ho, { teamType: t2 }, "", true), validate(So, { queryOption: r2 }, "", true);
            var i2 = void 0 === r2.direction ? 0 : r2.direction;
            i2 = 0 === i2 ? 1 : 0;
            var s2 = yield this.core.sendCmd("v2TeamMemberGetList", { tag: Object.assign(Object.assign({ teamId: e2, teamType: t2, onlyChatBanned: false, nextToken: "", limit: 100 }, r2), { direction: i2 }) }), n2 = s2.content.datas, a2 = get(s2, "raw.r.0");
            return 2 === t2 && a2 && a2.map && (n2 = a2.map((e3) => deserialize(e3, invertSerializeItem(Qn)))), { nextToken: s2.content.pageInfo.nextToken || "", finished: !+s2.content.pageInfo.hasMore, memberList: processTeamMembers(n2, t2) };
          });
        }
        getTeamMemberListByIds(e2, t2, r2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validate(po, { teamId: e2 }, "", true), validate(ho, { teamType: t2 }, "", true), validate({ accountIds: ao }, { accountIds: r2 }, "", true);
            for (var i2 = 2 === t2 ? "v2SuperTeamMemberGetListByIds" : "v2TeamMemberGetListByIds", s2 = r2.map((t3) => `${e2}|${t3}`), n2 = [], a2 = 0; a2 < s2.length; a2 += 20) {
              var o2 = processTeamMembers((yield this.core.sendCmd(i2, { tag: s2.slice(a2, a2 + 20) })).content.datas, t2);
              n2 = n2.concat(o2), o2.forEach((e3) => this.memberModel.upsert(e3));
            }
            return n2;
          });
        }
        getTeamMemberInvitor(e2, t2, r2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validate(po, { teamId: e2 }, "", true), validate(ho, { teamType: t2 }, "", true), validate({ accountIds: ao }, { accountIds: r2 }, "", true);
            var i2 = 2 === t2 ? "v2SuperTeamGetMemberInvitor" : "v2TeamGetMemberInvitor";
            return (yield this.core.sendCmd(i2, { teamId: e2, accounts: r2 })).content.accountsMap;
          });
        }
        searchTeamByKeyword(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.checkV2(), this.checkLogin(), validate({ keyword: lo }, { keyword: e2 }, "", true), this.model.searchTeamByKeyword(e2);
          });
        }
        addTeamMembersFollow(e2, t2, r2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validate(Ro, { teamId: e2, teamType: t2, accountIds: r2 }, "", true);
            var i2 = 2 === t2 ? "v2SuperTeamUpdateSelfMemberInfo" : "v2TeamUpdateSelfMemberInfo", [s2] = yield this.getTeamMemberListByIds(e2, t2, [this.core.account]), n2 = (yield this.core.sendCmd(i2, { teamMember: { teamId: e2 }, specialFollowUpdate: { accountIds: r2, operation: 1 } })).content.data;
            Object.keys(n2).length > 0 && (Object.assign(s2, n2), this.emit("onTeamMemberInfoUpdated", [s2]), this.memberModel.upsert(s2));
          });
        }
        removeTeamMembersFollow(e2, t2, r2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validate(Ro, { teamId: e2, teamType: t2, accountIds: r2 }, "", true);
            var [i2] = yield this.getTeamMemberListByIds(e2, t2, [this.core.account]), s2 = 2 === t2 ? "v2SuperTeamUpdateSelfMemberInfo" : "v2TeamUpdateSelfMemberInfo", n2 = (yield this.core.sendCmd(s2, { teamMember: { teamId: e2 }, specialFollowUpdate: { accountIds: r2, operation: 0 } })).content.data;
            Object.keys(n2).length > 0 && (Object.assign(i2, n2), this.emit("onTeamMemberInfoUpdated", [i2]), this.memberModel.upsert(i2));
          });
        }
        getTeamJoinActionInfoList(e2) {
          return this.checkV2(), validate(bo, e2, "option", true), this.core.V2NIMLoginService.checkIllegalState(), Promise.resolve(this.notificationModel.getByOption(e2));
        }
        clearAllTeamJoinActionInfo() {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), this.core.V2NIMLoginService.checkIllegalState(), this.notificationModel.reset();
          });
        }
        deleteTeamJoinActionInfo(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), this.core.V2NIMLoginService.checkIllegalState(), validate(To, e2, "", true), validate(_o, e2, "", true), validate({ timestamp: { type: "number", min: 1 } }, e2, "", true), this.notificationModel.delete(e2);
          });
        }
        setTeamJoinActionInfoRead(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), this.core.V2NIMLoginService.checkIllegalState(), e2 ? (validate(To, e2, "", true), validate(_o, e2, "", true), this.notificationModel.setRead(e2)) : this.notificationModel.setAllRead();
          });
        }
        getTeamJoinActionInfoUnreadCount() {
          return __awaiter(this, void 0, void 0, function* () {
            return this.checkV2(), this.core.V2NIMLoginService.checkIllegalState(), this.notificationModel.getUnreadCount();
          });
        }
      }, "V2NIMTeamService"), NIM.registerService(V2NIMUserServiceImpl, "V2NIMUserService"), NIM.registerService(class V2NIMUFriendServiceImpl extends V2Service {
        constructor(e2) {
          super("V2NIMFriendService", e2), this.notification = new V2NIMFriendNotificationImpl(this.core, this), this.model = new V2NIMFriendModelImpl(), this.notificationModel = new V2NIMFriendNotificationModelImpl(), this.core._registerDep(V2NIMUserServiceImpl, "V2NIMUserService"), "v2" === this.core.options.apiVersion && (registerParser({ cmdMap: Do, cmdConfig: xo }), this.setListener());
        }
        reset() {
          this.model.reset();
        }
        setListener() {
          this.core.eventBus.on("V2NIMFriendService/sysNotification", this.notification.processSysNotification.bind(this.notification)), this.core.eventBus.on("forwardReceive/V2NIMFriendService/addFriend", this.handleAddFriend.bind(this)), this.core.eventBus.on("forwardReceive/V2NIMFriendService/deleteFriend", this.handleDeleteFriend.bind(this)), this.core.eventBus.on("forwardReceive/V2NIMFriendService/setFriendInfo", this.handleSetFriendInfo.bind(this)), this.core.eventBus.on("forwardReceive/V2NIMFriendService/acceptAddApplication", this.handlePassFriendApply.bind(this)), this.core.eventBus.on("forwardReceive/V2NIMFriendService/rejectAddApplication", this.handleRejectFriendApply.bind(this));
        }
        emit(e2, ...t2) {
          var r2 = `${this.name}::emit ${e2.toString()}`;
          if ("onFriendAdded" === e2 || "onFriendInfoChanged" === e2) {
            var i2 = t2[0];
            this.logger.log(`${r2}`, `${i2.accountId};updateTime:${i2.updateTime}`);
          } else
            this.logger.log(`${r2}`, ...t2);
          return super.emit(e2, ...t2);
        }
        get hasUserService() {
          var e2;
          return !!(null === (e2 = this.core.V2NIMUserService) || void 0 === e2 ? void 0 : e2.name);
        }
        addFriend(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            if (this.checkV2(), e2 === this.core.account)
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "Cannot add yourself" } });
            validate(Bo, { accountId: e2, params: t2 }, "", true), yield this.core.sendCmd("v2AddFriend", { accountId: e2, verifyType: t2.addMode, postscript: t2.postscript || "" }), 1 === t2.addMode && (yield this.handleAddFriend(e2), this.notificationModel.updateFriendAddApplicationStatus(e2, 4, this.core.account));
          });
        }
        deleteFriend(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            if (this.checkV2(), e2 === this.core.account)
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "Cannot delete yourself" } });
            validate(Fo, { accountId: e2, params: t2 }, "", true), yield this.core.sendCmd("v2DeleteFriend", { accountId: e2, params: t2 }), t2.deleteAlias && this.model.upsertFriend(e2, { alias: "" }), this.handleDeleteFriend(e2);
          });
        }
        acceptAddApplication(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), checkApplication(e2, this.core.account);
            try {
              yield this.core.sendCmd("v2AddFriend", { accountId: e2.applicantAccountId, verifyType: 3, postscript: "" }), this.handlePassFriendApply(e2.applicantAccountId);
            } catch (t2) {
              throw this.handlePassFriendApply(e2.applicantAccountId, t2), t2;
            }
          });
        }
        rejectAddApplication(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), checkApplication(e2, this.core.account);
            try {
              yield this.core.sendCmd("v2AddFriend", { accountId: e2.applicantAccountId, verifyType: 4, postscript: t2 || "" }), this.handleRejectFriendApply({ applicantAccountId: e2.applicantAccountId, recipientAccountId: e2.recipientAccountId, operatorAccountId: this.core.account, postscript: t2 || "", timestamp: this.core.timeOrigin.getNTPTime(), read: false, status: 2 });
            } catch (r2) {
              throw this.handleRejectFriendApply({ applicantAccountId: e2.applicantAccountId, recipientAccountId: e2.recipientAccountId, operatorAccountId: this.core.account, postscript: t2 || "", timestamp: this.core.timeOrigin.getNTPTime(), read: false, status: 3 }, r2), r2;
            }
          });
        }
        setFriendInfo(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            if (this.checkV2(), validate(jo, { accountId: e2, params: t2 }, "", true), e2 === this.core.account)
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "Cannot set yourself" } });
            yield this.core.sendCmd("v2SetFriendInfo", { tag: Object.assign({ accountId: e2 }, t2) }), this.handleSetFriendInfo(e2, t2);
          });
        }
        getFriendList() {
          return __awaiter(this, void 0, void 0, function* () {
            return this.checkV2(), this.core.V2NIMLoginService.checkIllegalState(), this.computedFields(this.model.getFriendList());
          });
        }
        getFriendByIds(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.checkV2(), this.core.V2NIMLoginService.checkIllegalState(), validate({ accountIds: { type: "array", itemType: "string", required: true, min: 1 } }, { accountIds: e2 }, "", true), this.computedFields(this.model.getFriendByIds(e2));
          });
        }
        checkFriend(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), this.core.V2NIMLoginService.checkIllegalState(), validate({ accountIds: { type: "array", itemType: "string", required: true, min: 1 } }, { accountIds: e2 }, "", true);
            var t2 = {};
            return e2.forEach((e3) => {
              t2[e3] = !!this.model.getFriend(e3);
            }), t2;
          });
        }
        getAddApplicationList(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.checkV2(), this.core.V2NIMLoginService.checkIllegalState(), validate(Go, e2, "", true), this.notificationModel.getAddApplicationList(e2);
          });
        }
        setAddApplicationRead() {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), this.core.V2NIMLoginService.checkIllegalState(), this.notificationModel.setAllApplicationRead();
          });
        }
        setAddApplicationReadEx(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), this.core.V2NIMLoginService.checkIllegalState(), e2 ? (checkApplication(e2, this.core.account), this.notificationModel.setApplicationRead(e2)) : this.notificationModel.setAllApplicationRead();
          });
        }
        getAddApplicationUnreadCount() {
          return __awaiter(this, void 0, void 0, function* () {
            return this.checkV2(), this.core.V2NIMLoginService.checkIllegalState(), this.notificationModel.getAddApplicationUnreadCount();
          });
        }
        clearAllAddApplication() {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), this.core.V2NIMLoginService.checkIllegalState(), this.notificationModel.clearApplicationList();
          });
        }
        deleteAddApplication(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), this.core.V2NIMLoginService.checkIllegalState(), checkApplication(e2, this.core.account), this.notificationModel.deleteApplication(e2);
          });
        }
        searchFriendByOption(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            if (this.checkV2(), this.core.V2NIMLoginService.checkIllegalState(), validate({ keyword: { type: "string", allowEmpty: false }, searchAccountId: { type: "boolean", required: false } }, e2, "", true), !(void 0 === e2.searchAlias || e2.searchAlias) && !e2.searchAccountId)
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "searchAlias and searchAccountId cannot be false at the same time" } });
            return this.computedFields(this.model.getFriendListBySearchOption(e2));
          });
        }
        v2OnAddFriendHandler(e2) {
          var { accountId: t2, verifyType: r2, postscript: i2 } = e2.content;
          if (1 === r2)
            this.handleAddFriend(t2), this.notificationModel.updateFriendAddApplicationStatus(t2, 4, this.core.account);
          else if (2 === r2) {
            var s2 = { applicantAccountId: this.core.account, recipientAccountId: t2, operatorAccountId: this.core.account, postscript: i2, timestamp: this.core.timeOrigin.getNTPTime(), status: 0, read: false };
            this.handleApplyFriend(s2);
          } else if (3 === r2)
            this.handlePassFriendApply(t2);
          else if (4 === r2) {
            var n2 = { applicantAccountId: t2, recipientAccountId: this.core.account, operatorAccountId: this.core.account, postscript: i2, timestamp: this.core.timeOrigin.getNTPTime(), status: 2, read: false };
            this.handleRejectFriendApply(n2);
          }
        }
        v2OnDeleteFriendHandler(e2) {
          var { accountId: t2 } = e2.content;
          this.handleDeleteFriend(t2);
        }
        v2OnUpdateFriendInfoHandler(e2) {
          var { data: t2 } = e2.content, r2 = this.model.upsertFriend(t2.accountId, t2);
          this.emit("onFriendInfoChanged", this.computedField(r2));
        }
        v2SyncFriendListHandler(e2) {
          var { friends: t2, timetag: r2 } = e2.content;
          this.model.setFriendTimetag(r2), t2.forEach((e3) => {
            e3.serverExtension || (e3.serverExtension = ""), e3.customerExtension || (e3.customerExtension = ""), 0 === e3.relationShip ? this.model.deleteFriend(e3.accountId) : this.model.upsertFriend(e3.accountId, e3);
          });
        }
        v2SyncFriendUserListHandler(e2) {
          var { users: t2 } = e2.content;
          this.hasUserService && t2.forEach((e3) => {
            this.core.V2NIMUserService.model.setUser(e3);
          });
        }
        handleApplyFriend(e2) {
          this.emit("onFriendAddApplication", e2);
        }
        handleAddFriend(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.model.addFriend(e2), yield this.incrementSyncFriend(), yield this.core.V2NIMUserService.refreshUserInfo(e2);
            var t3 = this.model.getFriend(e2);
            t3 && this.emit("onFriendAdded", this.computedField(t3));
          });
        }
        handleDeleteFriend(e2, t2) {
          t2 = void 0 === t2 ? 1 : t2, this.emit("onFriendDeleted", e2, t2), this.model.deleteFriend(e2);
        }
        handleSetFriendInfo(e2, t2) {
          var r2 = this.model.upsertFriend(e2, t2);
          this.emit("onFriendInfoChanged", this.computedField(r2));
        }
        handlePassFriendApply(e2, t2) {
          var r2 = t2 ? null == t2 ? void 0 : t2.code : 200;
          if (!(r2 >= 19e4 || r2 === ce.V2NIM_ERROR_CODE_FRIEND_OPERATION_RATE_LIMIT))
            if (200 === r2 || r2 === ce.V2NIM_ERROR_CODE_FRIEND_ALREADY_EXIST)
              this.notificationModel.updateFriendAddApplicationStatus(e2, 1, this.core.account), this.handleAddFriend(e2);
            else {
              if (r2 >= 500 && r2 <= 599 && 509 !== r2)
                return;
              this.notificationModel.updateFriendAddApplicationStatus(e2, 3, this.core.account);
            }
        }
        handleRejectFriendApply(e2, t2) {
          var r2 = t2 ? null == t2 ? void 0 : t2.code : 200;
          if (!(r2 >= 19e4 || r2 === ce.V2NIM_ERROR_CODE_FRIEND_OPERATION_RATE_LIMIT))
            if (200 === r2)
              this.emit("onFriendAddRejected", e2), this.notificationModel.updateFriendAddApplicationStatus(e2.applicantAccountId, 2, this.core.account);
            else if (r2 === ce.V2NIM_ERROR_CODE_FRIEND_ALREADY_EXIST)
              this.notificationModel.updateFriendAddApplicationStatus(e2.applicantAccountId, 1, this.core.account);
            else {
              if (r2 >= 500 && r2 <= 599 && 509 !== r2)
                return;
              this.notificationModel.updateFriendAddApplicationStatus(e2.applicantAccountId, 3, this.core.account);
            }
        }
        incrementSyncFriend() {
          return __awaiter(this, void 0, void 0, function* () {
            var e2 = yield this.core.sendCmd("v2IncFriendInfo", { timetag: this.model.getFriendTimetag() }), { friends: t2, timetag: r2 } = e2.content;
            this.model.setFriendTimetag(r2), t2.forEach((e3) => {
              this.model.upsertFriend(e3.accountId, e3);
            });
          });
        }
        computedFields(e2) {
          return e2.map((e3) => this.computedField(e3));
        }
        computedField(e2) {
          var t2, r2, i2 = null === (r2 = null === (t2 = this.core.V2NIMUserService) || void 0 === t2 ? void 0 : t2.model) || void 0 === r2 ? void 0 : r2.getUser(e2.accountId);
          return i2 ? Object.assign({}, e2, { userProfile: i2 }) : e2;
        }
      }, "V2NIMFriendService"), NIM.registerService(class V2NIMSettingServiceImpl extends V2Service {
        constructor(e2) {
          super("V2NIMSettingService", e2), this.needToPushMobileOnDesktopOnline = true, this.core._registerDep(V2NIMConversationIdUtilImpl, "V2NIMConversationIdUtil"), this.push = new V2NIMSettingPushImpl(e2, this), this.mute = new V2NIMSettingMuteImpl(e2, this), this.event = new V2NIMSettingEventImpl(e2, this), this.handler = new V2NIMSettingHandlerImpl(e2, this), "v2" === this.core.options.apiVersion && (this.setListener(), registerParser({ cmdMap: Jo, cmdConfig: Xo }));
        }
        get hasUserService() {
          var e2;
          return !!(null === (e2 = this.core.V2NIMUserService) || void 0 === e2 ? void 0 : e2.name);
        }
        get hasTeamService() {
          var e2;
          return !!(null === (e2 = this.core.V2NIMTeamService) || void 0 === e2 ? void 0 : e2.name);
        }
        setListener() {
          this.event.setListener();
        }
        emit(e2, ...t2) {
          var r2 = `${this.name}::emit ${e2.toString()}`;
          return this.logger.log(`${r2}`, ...t2), super.emit(e2, ...t2);
        }
        getConversationMuteStatus(e2) {
          return this.mute.getConversationMuteStatus(e2);
        }
        setTeamMessageMuteMode(e2, t2, r2) {
          if (!this.hasTeamService)
            throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_MISUSE, detail: { reason: "setTeamMessageMuteMode: no team service" } });
          return this.checkV2(), validate(po, { teamId: e2 }, "", true), validate(ho, { teamType: t2 }, "", true), validate(Ho, { muteMode: r2 }, "", true), this.mute.setTeamMessageMuteMode(e2, t2, r2);
        }
        getTeamMessageMuteMode(e2, t2) {
          return this.mute.getTeamMessageMuteMode(e2, t2);
        }
        getAllTeamMessageMuteMode(e2) {
          return this.checkV2(), this.checkLogin(), validate(ho, { teamType: e2 }, "", true), this.mute.getAllTeamMessageMuteMode(e2);
        }
        setP2PMessageMuteMode(e2, t2) {
          if (this.checkV2(), validate(zo, { accountId: e2, muteMode: t2 }, "", true), e2 === this.core.account)
            throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "can not set mute mode for self" } });
          return this.mute.setP2PMessageMuteMode(e2, t2);
        }
        getP2PMessageMuteMode(e2) {
          return validate({ accountId: { type: "string", required: true, allowEmpty: false } }, { accountId: e2 }, "", true), this.mute.getP2PMessageMuteMode(e2);
        }
        getP2PMessageMuteList() {
          return this.mute.getP2PMessageMuteList();
        }
        setAppBackground(e2, t2) {
          return this.checkV2(), validate({ isBackground: { type: "boolean" }, badge: { type: "number", required: false } }, { isBackground: e2, badge: t2 }, "", true), this.push.setAppBackground(e2, t2);
        }
        setOfflinePushConfig(e2, t2) {
          validate(Ko, { config: t2 }, "", true), this.push.setOfflinePushConfig(e2, t2);
        }
        setPushMobileOnDesktopOnline(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validate({ need: { type: "boolean", required: false } }, { need: e2 }, "", true), e2 = void 0 === e2 || e2, yield this.core.sendCmd("v2SetPushMobileOnDesktopOnline", { tag: { need: e2 } }), this.needToPushMobileOnDesktopOnline = e2, this.emit("onPushMobileOnDesktopOnline", e2);
          });
        }
        getPushMobileOnDesktopOnline() {
          return this.checkLogin(), Promise.resolve(this.needToPushMobileOnDesktopOnline);
        }
      }, "V2NIMSettingService"), NIM.registerService(class V2NIMSyncServiceImpl extends V2Service {
        constructor(e2) {
          super("V2NIMSyncService", e2), this.teamKey = ["teams", "superTeams", "myTeamMembers", "mySuperTeamMembers"], this.config = {}, this.timetags = {}, "v2" === this.core.options.apiVersion && (this.initEventListeners(), registerParser({ cmdMap: Zo, cmdConfig: ec }), this.setListener());
        }
        reset() {
          this.timetags = {};
        }
        setListener() {
          this.core.eventBus.on("V2NIMSync/updateTimetag", (e2) => {
            Object.keys(e2).forEach((t2) => {
              e2[t2] > (this.timetags[t2] || 0) && (this.timetags[t2] = e2[t2]);
            });
          });
        }
        setOptions(e2) {
          var t2 = this.core, r2 = !(!t2.V2NIMConversationService.name && !t2.V2NIMLocalConversationService.name);
          return this.config = Object.assign({ myInfo: !!t2.V2NIMUserService.name, offlineMsgs: !!t2.V2NIMMessageService.name, roamingMsgs: !!t2.V2NIMMessageService.name, relations: !!t2.V2NIMUserService.name, friends: !!t2.V2NIMFriendService.name, friendUsers: !!t2.V2NIMUserService.name, msgReceipts: !!t2.V2NIMMessageService.name, broadcastMsgs: !!t2.V2NIMNotificationService.name, recallMsg: !!t2.V2NIMMessageService.name, sessionAck: r2, superTeamSessionAck: r2, stickTopSessions: r2, superTeamRoamingMsgs: !!t2.V2NIMTeamService.name, deleteSuperTeamMsg: !!t2.V2NIMTeamService.name, deleteSelfMsgs: !!t2.V2NIMMessageService.name, sessionHistoryMsgsDelete: !!t2.V2NIMMessageService.name, avSignal: !!t2.V2NIMSignallingService.name, teams: !!t2.V2NIMTeamService.name, superTeams: !!t2.V2NIMTeamService.name, myTeamMembers: !!t2.V2NIMTeamService.name, mySuperTeamMembers: !!t2.V2NIMTeamService.name, donnop: !!t2.V2NIMSettingService.name, p2pTeamModifyMessage: !!t2.V2NIMMessageService.name, superTeamModifyMessage: !!t2.V2NIMMessageService.name }, e2), this.config;
        }
        doBasicSync() {
          return __awaiter(this, void 0, void 0, function* () {
            var e2 = Object.keys(this.config).filter((e3) => !this.teamKey.includes(e3) && this.config[e3]), t2 = this.genSyncParams(e2);
            this.logger.log("V2Sync:basic", t2);
            var r2 = (yield this.core.clientSocket.sendCmd("v2NIMSync", { tag: t2 })).content.timetag;
            this.setTimetags(r2, e2.filter((e3) => "broadcastMsgs" !== e3)), yield this.delaySyncDone(), yield this.handleImmediate(), this.core.logger.log("sync::basic sync complete in", r2);
          });
        }
        doTeamSync() {
          return __awaiter(this, void 0, void 0, function* () {
            var e2 = this.teamKey.filter((e3) => this.config[e3]);
            if (0 !== e2.length) {
              var t2 = this.genSyncParams(e2);
              this.core.eventBus.emit("V2NIMTeamService/onSyncStarted"), this.logger.log("V2Sync:team", t2);
              var r2 = null;
              try {
                r2 = yield this.core.clientSocket.sendCmd("v2NIMSync", { tag: t2 });
              } catch (e3) {
                throw this.core.eventBus.emit("V2NIMTeamService/onSyncFailed", e3), e3;
              }
              this.core.eventBus.emit("V2NIMTeamService/onSyncFinished");
              var i2 = r2.content.timetag;
              this.setTimetags(i2, this.teamKey), this.core.logger.log("sync::team sync complete in", i2);
            }
          });
        }
        doQchatSync() {
          return __awaiter(this, void 0, void 0, function* () {
            var e2 = yield this.core.clientSocket.sendCmd("v2QChatSync", { tag: { systemNotification: 0 } });
            this.core.logger.log("sync::qchat sync complete in", e2.content.timetag);
          });
        }
        doSync() {
          return __awaiter(this, void 0, void 0, function* () {
            var e2 = get(this.core, "V2NIMLoginService.authenticator.loginClientOfThisConnection.loginType");
            if (void 0 !== e2) {
              if (this.logger.log(`sync::doSync:type ${e2}`), this.core.V2NIMLoginService.dataSync.switchDataSync({ type: 1, state: 2, subType: "mainSync" }), 1 === e2)
                try {
                  yield this.doBasicSync(), yield this.doTeamSync();
                } catch (e3) {
                  return void this.doSyncComplete(e3);
                }
              else if (2 === e2)
                try {
                  yield this.doQchatSync();
                } catch (e3) {
                  return void this.doSyncComplete(e3);
                }
              else {
                if (3 !== e2)
                  return;
                try {
                  yield this.doBasicSync(), yield this.doTeamSync(), yield this.doQchatSync();
                } catch (e3) {
                  return void this.doSyncComplete(e3);
                }
              }
              this.doSyncComplete();
            } else
              this.logger.warn("sync::doSync: no loginType, stop sync");
          });
        }
        doSyncComplete(e2) {
          e2 && this.core.logger.log("sync::doSync complete but got error", e2), this.core.V2NIMLoginService.dataSync.switchDataSync({ type: 1, state: 3, error: e2, subType: "mainSync" });
        }
        initEventListeners() {
          this.core.eventBus.on("V2NIMLoginService/loginLifeCycleLoginSucc", () => {
            this.doSync();
          });
        }
        genSyncParams(e2) {
          return e2.reduce((e3, t2) => {
            var r2 = t2;
            return e3[r2] = this.timetags[r2] || 0, e3;
          }, {});
        }
        setTimetags(e2, t2) {
          t2.forEach((t3) => {
            this.timetags[t3] = e2;
          });
        }
        handleImmediate() {
          return this.core.session && this.core.session.onSyncDone && this.core.session.onSyncDone(), Promise.resolve();
        }
        delaySyncDone() {
          var { hostEnvEnum: e2 } = ge.getSystemInfo();
          return 102 === e2 ? (this.core.logger.log("sync: emit ALIAPP sycnHandler, handle later"), new Promise((e3) => {
            setTimeout(() => {
              e3();
            }, 100);
          })) : Promise.resolve();
        }
      }, "V2NIMSyncService"), NIM.registerService(class V2NIMAIServiceImpl extends V2Service {
        constructor(e2) {
          super("V2NIMAIService", e2), this.model = new V2NIMAIModelImpl(), this.event = new V2NIMAIEventImpl(this.core, this), this.handler = new V2NIMAIHandlerImpl(this.core, this), registerParser({ cmdMap: rc, cmdConfig: cc });
        }
        setListener() {
          this.event.setListener();
        }
        reset() {
          this.model.reset();
        }
        emit(e2, ...t2) {
          return this.event.beforeEmit(e2, ...t2), super.emit(e2, ...t2);
        }
        getAIUserList() {
          return __awaiter(this, void 0, void 0, function* () {
            return this.checkV2(), (yield this.core.sendCmd("v2AIGetUserList", { tag: {} })).content.datas;
          });
        }
        proxyAIModelCall(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            if (validate(sn, e2, "", true), this.model.getAiStream(e2.requestId))
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, desc: "Same requestId", detail: { rawData: e2.requestId } });
            this.model.setAiStream(e2.requestId, { isComplete: false, queryStatus: 0, chunks: [] }, true), yield this.core.sendCmd("v2AIProxyModelCall", { tag: e2 });
          });
        }
        stopAIModelStreamCall(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate(nn, e2, "", true), yield this.core.sendCmd("v2AIStopModelStreamCall", { tag: { clientId: e2.requestId, aiAccount: e2.accountId, type: 4, from: this.core.account } }), this.logger.log(`V2AI::streamCallStop,requestId:${e2.requestId}`), this.model.completeAiStream(e2.requestId);
          });
        }
        _queryAiStream(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.model.setAiStream(e2.clientId, { queryStatus: 1 });
            try {
              var t2 = yield this.core.sendCmd("v2AIStreamQuery", { tag: e2 });
              this.model.setAiStream(e2.clientId, { queryStatus: 2 });
              var r2 = t2.content.datas;
              if (!(r2 && r2.length > 0))
                return;
              r2.forEach((e3) => {
                var t3 = e3.clientId, r3 = this.model.getAiStream(t3);
                if (r3 && (!r3 || !r3.isComplete) && e3.content && e3.content.lastChunk) {
                  var i2 = e3.content.lastChunk;
                  this.model.upsertAiStreamChunks(t3, i2.index, i2.content), 0 === i2.index && e3.aiRAGs && this.model.setAiStream(t3, { aiRAGs: e3.aiRAGs }), this.logger.log(`V2AI::queryAiStream requestId:${t3};index:${i2.index};cacheChunkLength:${r3.chunks.length};chunkTime:${i2.chunkTime}.`);
                }
              });
            } catch (t3) {
              this.logger.warn(`V2AI::queryAiStream requestId:${e2.clientId};error:`, t3), this.model.setAiStream(e2.clientId, { queryStatus: 2 });
            }
          });
        }
      }, "V2NIMAIService"), NIM.registerService(class DataStructureConverterImpl {
        constructor(e2) {
          this.name = "DataStructureConverter", this.core = e2;
        }
        messageConvertToV1(e2) {
          var t2, r2 = deserialize(serialize(e2, ia), invertSerializeItem(sr)), i2 = getSessionId(r2, this.core.account), s2 = null === (t2 = this.core.session) || void 0 === t2 ? void 0 : t2.getSessionWithUncomplete({ id: i2 });
          return formatMsg$1(r2, s2 ? { account: this.core.account, sessionAck: s2.ack, msgReceiptTime: s2.msgReceiptTime } : { account: this.core.account });
        }
        messageConvertToV2(e2) {
          var t2 = deserialize(serialize(generatorMsgForCmd$1(e2, e2.from, e2.fromDeviceId), sr), sa);
          return (t2 = completeMessage(this.core, t2)).sendingState = "sending" === e2.status ? 3 : "sendFailed" === e2.status ? 2 : 1, t2;
        }
      }, "DataStructureConverter"), NIM.registerService(class V2NIMMessageConverterImpl {
        constructor(e2) {
          this.name = "V2NIMMessageConverter", this.core = e2;
        }
        messageSerialization(e2) {
          if (!e2)
            return null;
          var t2 = serialize(e2, ia);
          return JSON.stringify(t2);
        }
        messageDeserialization(e2) {
          var t2, r2, i2, s2, n2, a2, o2, c2, d2, l2, m2, p2, u2, h2, g2, v2, y2, f2, I2, M2, S2, T2, _2;
          if (!e2)
            return null;
          try {
            var C2 = deserialize(JSON.parse(e2), sa);
            return C2.sendingState = 0, 1 !== C2.conversationType || C2.senderId !== this.core.account && C2.receiverId !== this.core.account ? 2 === C2.conversationType ? C2.conversationId = this.core.V2NIMConversationIdUtil.teamConversationId(C2.receiverId) : 3 === C2.conversationType && (C2.conversationId = this.core.V2NIMConversationIdUtil.superTeamConversationId(C2.receiverId)) : C2.conversationId = this.core.V2NIMConversationIdUtil.p2pConversationId(C2.senderId === this.core.account ? C2.receiverId : C2.senderId), C2.threadReply && (C2.threadReply.conversationType = C2.conversationType, C2.threadReply = completeMessageRefer(this.core, C2.threadReply)), C2.threadRoot && (C2.threadRoot.conversationType = C2.conversationType, C2.threadRoot = completeMessageRefer(this.core, C2.threadRoot)), [1, 3, 2, 0].includes(C2.conversationType) || this.core.logger.error(`V2NIMMessageConverterImpl.messageDeserialization: invalid conversationType(enum): ${C2.conversationType}`), C2.senderId && "string" != typeof C2.senderId && this.core.logger.error(`V2NIMMessageConverterImpl.messageDeserialization: invalid senderId(string): ${C2.senderId}`), C2.receiverId && "string" != typeof C2.receiverId && this.core.logger.error(`V2NIMMessageConverterImpl.messageDeserialization: invalid receiverId(string): ${C2.receiverId}`), "createTime" in C2 && isNaN(C2.createTime) && this.core.logger.error(`V2NIMMessageConverterImpl.messageDeserialization: invalid createTime(number): ${C2.createTime}`), [2, 7, 12, 100, 6, 1, -1, 4, 5, 11, 0, 10, 3].includes(C2.messageType) || this.core.logger.error(`V2NIMMessageConverterImpl.messageDeserialization: invalid messageType(enum): ${C2.messageType}`), "subType" in C2 && isNaN(C2.subType) && this.core.logger.error(`V2NIMMessageConverterImpl.messageDeserialization: invalid subType(number): ${C2.subType}`), C2.messageClientId && "string" != typeof C2.messageClientId && this.core.logger.error(`V2NIMMessageConverterImpl.messageDeserialization: invalid messageClientId(string): ${C2.messageClientId}`), C2.messageServerId && "string" != typeof C2.messageServerId && this.core.logger.error(`V2NIMMessageConverterImpl.messageDeserialization: invalid messageServerId(string): ${C2.messageServerId}`), C2.attachment && "object" != typeof C2.attachment && this.core.logger.error(`V2NIMMessageConverterImpl.messageDeserialization: invalid attachment(object): ${C2.attachment}`), C2.text && "string" != typeof C2.text && this.core.logger.error(`V2NIMMessageConverterImpl.messageDeserialization: invalid text(string): ${C2.text}`), C2.serverExtension && "string" != typeof C2.serverExtension && this.core.logger.error(`V2NIMMessageConverterImpl.messageDeserialization: invalid serverExtension(string): ${C2.serverExtension}`), C2.callbackExtension && "string" != typeof C2.callbackExtension && this.core.logger.error(`V2NIMMessageConverterImpl.messageDeserialization: invalid callbackExtension(string): ${C2.callbackExtension}`), (null === (t2 = C2.pushConfig) || void 0 === t2 ? void 0 : t2.pushContent) && "string" != typeof C2.pushConfig.pushContent && this.core.logger.error(`V2NIMMessageConverterImpl.messageDeserialization: invalid pushContent(string): ${C2.pushConfig.pushContent}`), (null === (r2 = C2.pushConfig) || void 0 === r2 ? void 0 : r2.pushPayload) && "string" != typeof C2.pushConfig.pushPayload && this.core.logger.error(`V2NIMMessageConverterImpl.messageDeserialization: invalid pushPayload(string): ${C2.pushConfig.pushPayload}`), (null === (i2 = C2.pushConfig) || void 0 === i2 ? void 0 : i2.forcePushContent) && "string" != typeof C2.pushConfig.forcePushContent && this.core.logger.error(`V2NIMMessageConverterImpl.messageDeserialization: invalid forcePushContent(string): ${C2.pushConfig.forcePushContent}`), (null === (s2 = C2.pushConfig) || void 0 === s2 ? void 0 : s2.forcePushAccountIds) && !Array.isArray(C2.pushConfig.forcePushAccountIds) && this.core.logger.error(`V2NIMMessageConverterImpl.messageDeserialization: invalid forcePushAccountIds(array): ${C2.pushConfig.forcePushAccountIds}`), (null === (n2 = C2.routeConfig) || void 0 === n2 ? void 0 : n2.routeEnvironment) && "string" != typeof C2.routeConfig.routeEnvironment && this.core.logger.error(`V2NIMMessageConverterImpl.messageDeserialization: invalid routeEnvironment(string): ${C2.routeConfig.routeEnvironment}`), (null === (a2 = C2.antispamConfig) || void 0 === a2 ? void 0 : a2.antispamBusinessId) && "string" != typeof C2.antispamConfig.antispamBusinessId && this.core.logger.error(`V2NIMMessageConverterImpl.messageDeserialization: invalid antispamBusinessId(string): ${C2.antispamConfig.antispamBusinessId}`), (null === (o2 = C2.antispamConfig) || void 0 === o2 ? void 0 : o2.antispamCustomMessage) && "string" != typeof C2.antispamConfig.antispamCustomMessage && this.core.logger.error(`V2NIMMessageConverterImpl.messageDeserialization: invalid antispamCustomMessage(string): ${C2.antispamConfig.antispamCustomMessage}`), (null === (c2 = C2.antispamConfig) || void 0 === c2 ? void 0 : c2.antispamCheating) && "string" != typeof C2.antispamConfig.antispamCheating && this.core.logger.error(`V2NIMMessageConverterImpl.messageDeserialization: invalid antispamCheating(string): ${C2.antispamConfig.antispamCheating}`), (null === (d2 = C2.antispamConfig) || void 0 === d2 ? void 0 : d2.antispamExtension) && "string" != typeof C2.antispamConfig.antispamExtension && this.core.logger.error(`V2NIMMessageConverterImpl.messageDeserialization: invalid antispamExtension(string): ${C2.antispamConfig.antispamExtension}`), (null === (l2 = C2.robotConfig) || void 0 === l2 ? void 0 : l2.accountId) && "string" != typeof C2.robotConfig.accountId && this.core.logger.error(`V2NIMMessageConverterImpl.messageDeserialization: invalid accountId(string): ${C2.robotConfig.accountId}`), (null === (m2 = C2.robotConfig) || void 0 === m2 ? void 0 : m2.topic) && "string" != typeof C2.robotConfig.topic && this.core.logger.error(`V2NIMMessageConverterImpl.messageDeserialization: invalid topic(string): ${C2.robotConfig.topic}`), (null === (p2 = C2.robotConfig) || void 0 === p2 ? void 0 : p2.function) && "string" != typeof C2.robotConfig.function && this.core.logger.error(`V2NIMMessageConverterImpl.messageDeserialization: invalid function(string): ${C2.robotConfig.function}`), (null === (u2 = C2.robotConfig) || void 0 === u2 ? void 0 : u2.customContent) && "string" != typeof C2.robotConfig.customContent && this.core.logger.error(`V2NIMMessageConverterImpl.messageDeserialization: invalid customContent(string): ${C2.robotConfig.customContent}`), (null === (h2 = C2.threadRoot) || void 0 === h2 ? void 0 : h2.senderId) && "string" != typeof C2.threadRoot.senderId && this.core.logger.error(`V2NIMMessageConverterImpl.messageDeserialization: invalid senderId(string): ${C2.threadRoot.senderId}`), (null === (g2 = C2.threadRoot) || void 0 === g2 ? void 0 : g2.receiverId) && "string" != typeof C2.threadRoot.receiverId && this.core.logger.error(`V2NIMMessageConverterImpl.messageDeserialization: invalid receiverId(string): ${C2.threadRoot.receiverId}`), (null === (v2 = C2.threadRoot) || void 0 === v2 ? void 0 : v2.messageClientId) && "string" != typeof C2.threadRoot.messageClientId && this.core.logger.error(`V2NIMMessageConverterImpl.messageDeserialization: invalid messageClientId(string): ${C2.threadRoot.messageClientId}`), (null === (y2 = C2.threadRoot) || void 0 === y2 ? void 0 : y2.messageServerId) && "string" != typeof C2.threadRoot.messageServerId && this.core.logger.error(`V2NIMMessageConverterImpl.messageDeserialization: invalid messageServerId(string): ${C2.threadRoot.messageServerId}`), C2.threadRoot && "createTime" in C2.threadRoot && isNaN(C2.threadRoot.createTime) && this.core.logger.error(`V2NIMMessageConverterImpl.messageDeserialization: invalid createTime(number): ${C2.threadRoot.createTime}`), C2.threadRoot && ![1, 3, 2, 0].includes(C2.threadRoot.conversationType) && this.core.logger.error(`V2NIMMessageConverterImpl.messageDeserialization: invalid conversationType(enum): ${C2.threadRoot.conversationType}`), (null === (f2 = C2.threadRoot) || void 0 === f2 ? void 0 : f2.conversationId) && "string" != typeof C2.threadRoot.conversationId && this.core.logger.error(`V2NIMMessageConverterImpl.messageDeserialization: invalid conversationId(string): ${C2.threadRoot.conversationId}`), (null === (I2 = C2.threadReply) || void 0 === I2 ? void 0 : I2.senderId) && "string" != typeof C2.threadReply.senderId && this.core.logger.error(`V2NIMMessageConverterImpl.messageDeserialization: invalid senderId(string): ${C2.threadReply.senderId}`), (null === (M2 = C2.threadReply) || void 0 === M2 ? void 0 : M2.receiverId) && "string" != typeof C2.threadReply.receiverId && this.core.logger.error(`V2NIMMessageConverterImpl.messageDeserialization: invalid receiverId(string): ${C2.threadReply.receiverId}`), (null === (S2 = C2.threadReply) || void 0 === S2 ? void 0 : S2.messageClientId) && "string" != typeof C2.threadReply.messageClientId && this.core.logger.error(`V2NIMMessageConverterImpl.messageDeserialization: invalid messageClientId(string): ${C2.threadReply.messageClientId}`), (null === (T2 = C2.threadReply) || void 0 === T2 ? void 0 : T2.messageServerId) && "string" != typeof C2.threadReply.messageServerId && this.core.logger.error(`V2NIMMessageConverterImpl.messageDeserialization: invalid messageServerId(string): ${C2.threadReply.messageServerId}`), C2.threadReply && "createTime" in C2.threadReply && isNaN(C2.threadReply.createTime) && this.core.logger.error(`V2NIMMessageConverterImpl.messageDeserialization: invalid createTime(number): ${C2.threadReply.createTime}`), C2.threadReply && ![1, 3, 2, 0].includes(C2.threadReply.conversationType) && this.core.logger.error(`V2NIMMessageConverterImpl.messageDeserialization: invalid conversationType(enum): ${C2.threadReply.conversationType}`), (null === (_2 = C2.threadReply) || void 0 === _2 ? void 0 : _2.conversationId) && "string" != typeof C2.threadReply.conversationId && this.core.logger.error(`V2NIMMessageConverterImpl.messageDeserialization: invalid conversationId(string): ${C2.threadReply.conversationId}`), delete C2.__clientExt, delete C2.userUpdateTime, C2;
          } catch (t3) {
            return this.core.logger.error(`V2NIMMessageConverterImpl.messageDeserialization: invalid message string: ${e2}`), null;
          }
        }
      }, "V2NIMMessageConverter"), NIM.registerService(class V2NIMMessageLogUtil extends V2Service {
        constructor(e2) {
          super("V2NIMMessageLogUtil", e2), this.clearHistoryMessageFn = (e3) => {
            var t2 = formatClearHistoryNotification(this.core, e3);
            this.emitClearHistoryMessage([t2]);
          }, this.core = e2, this.service = this.core.V2NIMMessageService, "v2" === this.core.options.apiVersion && (registerParser({ cmdMap: ja, cmdConfig: Ha }), this.setListener());
        }
        setListener() {
          this.core.eventBus.on("forwardReceive/V2NIMMessageLogService/clearHistoryMessage", this.clearHistoryMessageFn);
        }
        getMessageListByRefers(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            if (this.checkV2(), validate(fn, { messageRefers: e2 }, "", true), 0 === e2.length)
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "getMessageListByRefers: messageRefers cannot be an empty array" } });
            var t2 = [], r2 = e2.map((e3) => {
              var r3 = this.service.model.getMessageById(e3.messageClientId);
              return !r3 && e3.messageServerId && "0" !== e3.messageServerId && t2.push(e3), r3;
            }), i2 = [];
            if (t2.length > 0) {
              var s2 = yield this.core.sendCmd("v2GetMessageListByRefers", { tag: t2 });
              i2 = s2.content.msgs;
            }
            return r2.map((t3, r3) => {
              if (t3)
                return t3;
              var s3 = e2[r3], n2 = i2.find((e3) => e3.messageServerId === s3.messageServerId);
              return n2 ? completeMessage(this.core, n2) : void 0;
            }).filter((e3) => void 0 !== e3 && !this.service._filterMessage(e3));
          });
        }
        getMessageList(e2) {
          var t2;
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validate(vn, e2, "", true), validateConversationId(this.core.account, e2.conversationId);
            var r2 = this.core.V2NIMConversationIdUtil.parseConversationType(e2.conversationId), i2 = this.core.V2NIMConversationIdUtil.parseConversationTargetId(e2.conversationId), s2 = 1 === r2 ? "v2GetMessageList" : 2 === r2 ? "v2GetTeamMessageList" : "v2GetSuperTeamMessageList", n2 = e2.beginTime || 0, a2 = e2.endTime || 0;
            if (0 !== n2 && 0 !== a2 && n2 > a2)
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "getMessageList: beginTime cannot be greater than endTime" } });
            var o2 = void 0 === e2.direction ? 0 : e2.direction;
            if (e2.anchorMessage) {
              if (0 === o2) {
                if (0 === a2)
                  a2 = e2.anchorMessage.createTime;
                else if (a2 !== e2.anchorMessage.createTime)
                  throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "getMessageList: When providing anchorMessage, when sorting in descending order, endTime does not need to be provided, or endTime should be equal to anchorMessage.createTime" } });
              } else if (0 === n2)
                n2 = e2.anchorMessage.createTime;
              else if (n2 !== e2.anchorMessage.createTime)
                throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "getMessageList: When providing anchorMessage, when sorting in ascending order, there is no need to provide beginTime, or beginTime should be equal to anchorMessage.createTime" } });
            }
            var c2 = null === (t2 = e2.anchorMessage) || void 0 === t2 ? void 0 : t2.messageServerId, d2 = yield this.core.sendCmd(s2, { beginTime: n2, endTime: a2, lastMsgId: c2 || 0, limit: e2.limit || 50, direction: o2, msgTypes: e2.messageTypes ? e2.messageTypes.slice() : [], to: i2 }), { content: l2 } = d2, m2 = l2.msgs.map((e3) => completeMessage(this.core, e3));
            return c2 && (m2 = m2.filter((e3) => e3.messageServerId !== c2)), this.getMessageListMonkeyPatch(m2, e2);
          });
        }
        getMessageListMonkeyPatch(e2, t2) {
          var r2 = t2.conversationId, i2 = e2, s2 = i2.reduce((e3, t3) => (e3[t3.messageClientId] = true, e3), {}), n2 = this.service.model.getMessagesByConversationId(r2);
          n2 = n2.sort((e3, r3) => 1 === t2.direction ? e3.createTime - r3.createTime : r3.createTime - e3.createTime);
          var a2 = 0, o2 = t2.beginTime || 0, c2 = t2.endTime || 0;
          t2.anchorMessage && (0 === t2.direction ? c2 = t2.anchorMessage.createTime : o2 = t2.anchorMessage.createTime, a2 = n2.findIndex((e3) => {
            var r3;
            return e3.messageClientId === (null === (r3 = t2.anchorMessage) || void 0 === r3 ? void 0 : r3.messageClientId);
          }), a2 += 1);
          for (var d2 = a2; d2 < n2.length; d2++) {
            var l2 = n2[d2], m2 = !s2[l2.messageClientId], p2 = void 0 === l2.sendingState || 1 === l2.sendingState, u2 = l2.conversationId === r2, h2 = l2.createTime > o2 && (l2.createTime < c2 || 0 === c2), g2 = !t2.messageTypes || t2.messageTypes.includes(l2.messageType);
            m2 && p2 && u2 && h2 && g2 && i2.push(n2[d2]);
          }
          return (i2 = i2.sort((e3, r3) => 1 === t2.direction ? e3.createTime - r3.createTime : r3.createTime - e3.createTime)).slice(0, t2.limit || 50);
        }
        clearHistoryMessage(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validate(Sn, e2, "", true), validateConversationId(this.core.account, e2.conversationId);
            var { conversationId: t2, deleteRoam: r2, onlineSync: i2, serverExtension: s2 } = e2, n2 = this.core.V2NIMConversationIdUtil.parseConversationType(t2), a2 = this.core.V2NIMConversationIdUtil.parseConversationTargetId(t2), o2 = { deleteRoam: r2, onlineSync: i2, serverExtension: s2, conversationType: n2 };
            1 === n2 ? o2.receiverId = a2 : o2.teamId = a2;
            var c2 = this.core.timeOrigin.getNTPTime();
            (e2.clearMode = e2.clearMode || 0, 0 === e2.clearMode) && (c2 = (yield this.core.sendCmd("v2ClearHistoryMessage", { tag: o2 })).content.timetag);
            2 === e2.clearMode && ge.localStorage.setItem(`nim_${this.core.account}_${t2}_clearTime`, c2.toString()), this.core.eventBus.emit("forwardSend/V2NIMMessageLogService/clearHistoryMessage", Object.assign(Object.assign({}, o2), { deleteTime: c2 })), this.emitClearHistoryMessage([{ deleteTime: c2, serverExtension: s2, conversationId: t2 }]);
          });
        }
        clearRoamingMessage(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validate({ conversationIds: { type: "array", itemType: "string", min: 1 } }, { conversationIds: e2 }, void 0, true);
            var t2 = [];
            try {
              t2 = e2.map((e3) => {
                var t3 = this.core.V2NIMConversationIdUtil.parseConversationTargetId(e3);
                return getSessionIdFromConvInfo(this.core.V2NIMConversationIdUtil.parseConversationType(e3), t3);
              });
            } catch (t3) {
              throw this.logger.error(`V2NIMMessage::clearRoamingMessage with ${e2}`, t3), new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_PARAMETER_ERROR, detail: { reason: "Failed to create session", rawData: `${e2}` } });
            }
            yield this.core.sendCmd("v2ClearRoamingMessage", { conversationIds: t2 });
          });
        }
        syncClearHistoryMessageHandler(e2) {
          var t2 = e2.content.data.map((e3) => formatClearHistoryNotification(this.core, e3));
          this.emitClearHistoryMessage(t2);
        }
        onClearHistoryMessageHandler(e2) {
          var t2 = formatClearHistoryNotification(this.core, e2.content.data);
          this.emitClearHistoryMessage([t2]);
        }
        emitClearHistoryMessage(e2) {
          e2.forEach((e3) => {
            this.service.model.deleteMessages(e3.conversationId, e3.deleteTime), this.core.eventBus.emit("V2NIMSync/updateTimetag", { sessionHistoryMsgsDelete: e3.deleteTime });
          }), this.core.eventBus.emit("V2NIMMessageLogUtil/onClearHistoryNotifications", e2), this.service.emit("onClearHistoryNotifications", e2);
        }
      }, "V2NIMMessageLogUtil"), NIM.registerService(class V2NIMMessageExtendUtil extends V2Service {
        constructor(e2) {
          super("V2NIMMessageExtendUtil", e2), this.core = e2, this.service = this.core.V2NIMMessageService, "v2" === this.core.options.apiVersion && registerParser({ cmdMap: Wa, cmdConfig: ro });
        }
        pinMessage(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validate(yn, e2, "message", true), validate(Tn, { serverExtension: t2 }, "", true);
            var r2 = yield this.core.sendCmd("v2PinMessage", { msg: e2, msgPin: { serverExtension: t2 } });
            this.emitPinNotification({ pinState: 1, message: e2, serverExtension: t2, createTime: r2.content.timetag, updateTime: r2.content.timetag, operatorId: this.core.account });
          });
        }
        unpinMessage(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validate(yn, e2, "messageRefer", true), validate(Tn, { serverExtension: t2 }, "", true);
            var r2 = yield this.core.sendCmd("v2UnpinMessage", { msg: e2, msgPin: { serverExtension: t2 } });
            this.emitPinNotification({ pinState: 0, message: e2, serverExtension: t2, updateTime: r2.content.timetag, operatorId: this.core.account });
          });
        }
        updatePinMessage(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validate(yn, e2, "message", true), validate(Tn, { serverExtension: t2 }, "", true);
            var r2 = yield this.core.sendCmd("v2UpdatePinMessage", { msg: e2, msgPin: { serverExtension: t2 } });
            this.emitPinNotification({ pinState: 2, message: e2, serverExtension: t2, updateTime: r2.content.timetag, operatorId: this.core.account });
          });
        }
        getPinnedMessageList(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            if (this.checkV2(), !this.core.V2NIMConversationIdUtil || !this.core.V2NIMConversationIdUtil.parseConversationType)
              throw new Error('Service "V2NIMConversationService" does not exist');
            validateConversationId(this.core.account, e2);
            var t2 = this.core.V2NIMConversationIdUtil.convertToV1ConversationId(e2);
            return t2 = t2.replace("superTeam", "super_team"), (yield this.core.sendCmd("v2GetPinMessageList", { tag: { conversationId: t2, timetag: 0 } })).content.data.map((e3) => Object.assign(Object.assign({}, e3), { messageRefer: Object.assign(Object.assign({}, e3.messageRefer), { conversationId: this.core.V2NIMConversationIdUtil.messageConversationId(e3.messageRefer) }) })).sort((e3, t3) => t3.updateTime - e3.updateTime);
          });
        }
        addQuickComment(e2, t2, r2, i2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validate(bn, { message: e2, index: t2, serverExtension: r2, pushConfig: i2 }, "", true);
            var s2 = yield this.core.sendCmd("v2AddQuickComment", { message: e2, quickComment: { index: t2, serverExtension: r2, pushConfig: i2 } }), n2 = { operationType: 1, quickComment: { messageRefer: formatMessageRefer(this.core, e2), createTime: s2.content.timetag, index: t2, serverExtension: r2 || "", operatorId: this.core.account } };
            this.core.V2NIMMessageService.emit("onMessageQuickCommentNotification", n2);
          });
        }
        removeQuickComment(e2, t2, r2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validate(yn, e2, "messageRefer", true), validate({ index: { type: "number", min: 1 } }, { index: t2 }, "", true), validate({ serverExtension: { type: "string", required: false } }, { serverExtension: r2 }, "", true);
            var i2 = yield this.core.sendCmd("v2RemoveQuickComment", { message: e2, quickComment: { index: t2, serverExtension: r2 } }), s2 = { operationType: 2, quickComment: { messageRefer: formatMessageRefer(this.core, e2), createTime: i2.content.timetag, index: t2, serverExtension: r2 || "", operatorId: this.core.account } };
            this.core.V2NIMMessageService.emit("onMessageQuickCommentNotification", s2);
          });
        }
        getQuickCommentList(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validate(Rn, { messages: e2 }, "", true);
            var t2 = {};
            return (yield this.core.sendCmd("v2GetQuickComment", { tag: e2.map((e3) => ({ messageRefer: e3 })) })).content.data.forEach((e3) => {
              var r2, i2;
              try {
                if (!e3.detail)
                  return void (t2[r2 = e3.messageRefer.messageClientId] || (t2[r2] = []));
                var s2 = JSON.parse(e3.detail);
                t2[i2 = e3.messageRefer.messageClientId] || (t2[i2] = []), s2.forEach((r3) => {
                  t2[e3.messageRefer.messageClientId].push({ messageRefer: Object.assign(Object.assign({}, e3.messageRefer), { conversationId: this.core.V2NIMConversationIdUtil.messageConversationId(e3.messageRefer) }), operatorId: r3[1], index: parseInt(r3[2]), createTime: parseInt(r3[3]), serverExtension: r3[4] });
                });
              } catch (t3) {
                this.logger.error("getQuickCommentList JSON Parse Error", e3.detail, t3);
              }
            }), t2;
          });
        }
        voiceToText(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            if (this.checkV2(), validate(En, e2, "", true), !e2.voicePath && !e2.voiceUrl && !e2.file)
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "voiceToText: voicePathvoiceUrlfile cannot be empty at the same time" } });
            var { voicePath: t2, file: r2, mimeType: i2, sampleRate: s2, duration: n2, sceneName: a2 } = e2, o2 = a2 ? this.core.V2NIMStorageService.getStorageScene(a2) : null, c2 = e2.voiceUrl;
            if (!c2) {
              var d2 = {};
              r2 ? d2.file = r2 : 0 === (null == t2 ? void 0 : t2.indexOf("nim-external")) ? d2.fileInput = t2 : d2.filePath = t2, c2 = (yield this.core.cloudStorage.uploadFile(Object.assign({ type: "audio", nosScenes: o2 ? o2.sceneName : void 0, nosSurvivalTime: o2 ? o2.expireTime : void 0 }, d2))).url;
            }
            return (yield this.core.sendCmd("v2VoiceToText", { tag: { voiceUrl: c2, mimeType: i2, sampleRate: s2, duration: n2 } }, { timeout: 3e4 })).content.data;
          });
        }
        onPinMessageHandler(e2) {
          return this.pinMessageChangeHandler(e2, 1);
        }
        onUnpinMessageHandler(e2) {
          return this.pinMessageChangeHandler(e2, 0);
        }
        onUpdatePinMessageHandler(e2) {
          return this.pinMessageChangeHandler(e2, 2);
        }
        pinMessageChangeHandler(e2, t2) {
          var r2 = e2.content.msg, i2 = e2.content.pinInfo;
          r2.conversationId = this.core.V2NIMConversationIdUtil.messageConversationId(r2), this.emitPinNotification({ pinState: t2, message: r2, serverExtension: i2.serverExtension, createTime: i2.createTime, updateTime: i2.updateTime, operatorId: i2.accid });
        }
        emitPinNotification(e2) {
          var t2 = { pinState: e2.pinState, pin: Object.assign(Object.assign({ serverExtension: e2.serverExtension || "", operatorId: e2.operatorId }, e2.createTime ? { createTime: e2.createTime } : {}), { updateTime: e2.updateTime, messageRefer: formatMessageRefer(this.core, e2.message) }) };
          this.core.V2NIMMessageService.emit("onMessagePinNotification", t2);
        }
        onAddQuickCommentHandler(e2) {
          return this.onQuickCommentNotificationHandler(e2, 1);
        }
        onRemoveQuickCommentHandler(e2) {
          return this.onQuickCommentNotificationHandler(e2, 2);
        }
        onQuickCommentNotificationHandler(e2, t2) {
          var r2 = { operationType: t2, quickComment: Object.assign({ messageRefer: Object.assign(Object.assign({}, e2.content.message), { conversationId: this.core.V2NIMConversationIdUtil.messageConversationId(e2.content.message) }) }, e2.content.quickComment) };
          this.core.V2NIMMessageService.emit("onMessageQuickCommentNotification", r2);
        }
        addCollection(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.checkV2(), validate(Nn, { params: e2 }, "", true), (yield this.core.sendCmd("v2AddCollection", { tag: e2 })).content.data;
          });
        }
        removeCollections(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.checkV2(), validate(An, { collections: e2 }, "", true), (yield this.core.sendCmd("v2RemoveCollections", { tag: e2 })).content.data;
          });
        }
        updateCollectionExtension(e2, t2) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.checkV2(), validate(On, { collection: e2, serverExtension: t2 }, "", true), (yield this.core.sendCmd("v2UpdateCollectionExtension", { tag: Object.assign(Object.assign({}, e2), { serverExtension: t2 }) })).content.data;
          });
        }
        getCollectionListByOption(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.checkV2(), validate(kn, e2, "", true), (yield this.getCollectionListExByOption(e2)).collectionList;
          });
        }
        getCollectionListExByOption(e2) {
          var t2, r2;
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validate(kn, e2, "", true);
            var i2 = e2.beginTime || 0, s2 = e2.endTime || 0, n2 = void 0 === e2.direction ? 0 : e2.direction;
            if (void 0 !== (null === (t2 = e2.anchorCollection) || void 0 === t2 ? void 0 : t2.collectionId)) {
              if (0 === e2.direction) {
                if (0 === s2)
                  s2 = e2.anchorCollection.createTime;
                else if (s2 !== e2.anchorCollection.createTime)
                  throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "getCollectionListExByOption: When providing anchorCollection, when sorting in descending order, endTime does not need to be provided, or endTime should be equal to anchorCollection.createTime" } });
              } else if (0 === i2)
                i2 = e2.anchorCollection.createTime;
              else if (i2 !== e2.anchorCollection.createTime)
                throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "getCollectionListExByOption: When providing anchorCollection, when sorting in ascending order, there is no need to provide beginTime, or beginTime should be equal to anchorCollection.createTime" } });
            }
            if (0 !== i2 && 0 !== s2 && i2 >= s2)
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "getCollectionListExByOption: beginTime cannot be greater than endTime" } });
            var a2 = { beginTime: i2, endTime: s2, direction: n2, limit: e2.limit, collectionType: e2.collectionType, excludeId: (null === (r2 = e2.anchorCollection) || void 0 === r2 ? void 0 : r2.collectionId) ? e2.anchorCollection.collectionId : 0 };
            a2.collectionType || delete a2.collectionType;
            var o2 = yield this.core.sendCmd("v2GetCollectionListByOption", { tag: a2 });
            return { totalCount: o2.content.total, collectionList: o2.content.data };
          });
        }
        searchCloudMessages(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validate(wn, e2, "", true);
            var t2 = e2.beginTime || 0, r2 = e2.endTime || 0;
            if (0 !== t2 && 0 !== r2 && t2 > r2)
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "searchCloudMessages: beginTime cannot be greater than endTime" } });
            var i2 = void 0 === e2.sortOrder ? 0 : e2.sortOrder, s2 = e2.conversationLimit || 0, n2 = e2.messageLimit || 10, a2 = s2 > 0 ? "v2SearchCloudMessagesGroupByConversation" : "v2SearchCloudMessages", o2 = yield this.core.sendCmd(a2, { tag: Object.assign(Object.assign({}, e2), { beginTime: t2, endTime: r2, sortOrder: i2, conversationLimit: s2, messageLimit: n2 }) });
            return this.service._filterMessagesByFn(o2.content.data.map((e3) => completeMessage(this.core, e3)));
          });
        }
        searchCloudMessagesEx(e2) {
          var t2, r2, i2;
          return __awaiter(this, void 0, void 0, function* () {
            if (this.checkV2(), validate(Pn, e2, "", true), e2.conversationId && validateConversationId(this.core.account, e2.conversationId), !(null === (t2 = e2.keywordList) || void 0 === t2 ? void 0 : t2.length) && !(null === (r2 = e2.senderAccountIds) || void 0 === r2 ? void 0 : r2.length) && !(null === (i2 = e2.messageTypes) || void 0 === i2 ? void 0 : i2.length))
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "searchCloudMessagesEx: keywordList senderAccountIds messageTypes cannot be empty at the same time" } });
            0 === e2.searchTimePeriod && delete e2.searchTimePeriod;
            var s2 = yield this.core.sendCmd("v2SearchCloudMessagesEx", { tag: Object.assign({}, e2) }), { msgs: n2, hasMore: a2, nextPageToken: o2 } = s2.content, c2 = this.service._filterMessagesByFn(n2.map((e3) => completeMessage(this.core, e3))).sort((e3, t3) => t3.createTime - e3.createTime);
            return { count: n2.length, items: formatSearchCloudMessageListEx(this.core, c2), hasMore: intToBool(a2), nextPageToken: o2 };
          });
        }
        getThreadMessageList(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            if (validate(Bn, e2, "getThreadMessageList", true), e2.beginTime = e2.beginTime || 0, e2.endTime && e2.beginTime > e2.endTime)
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "getThreadMessageList: beginTime cannot be greater than endTime" } });
            var t2 = yield this.core.sendCmd("v2GetThreadMessageList", { messageRefer: e2.messageRefer, tag: { beginTime: e2.beginTime, endTime: e2.endTime, limit: e2.limit, reverse: 1 === e2.direction ? 1 : 0, excludeMessageServerId: e2.excludeMessageServerId } }), { message: r2, replyResult: i2, replyList: s2 } = t2.content, n2 = completeMessage(this.core, r2), a2 = s2.map((e3) => completeMessage(this.core, e3));
            return a2 = this.service._filterMessagesByFn(a2), a2 = this.service._filterMessageByClearTime(n2.conversationId, a2), { message: n2, timestamp: i2.timestamp, replyCount: i2.total, replyList: a2 };
          });
        }
      }, "V2NIMMessageExtendUtil"), NIM.registerService(class V2NIMSignallingServiceImpl extends V2Service {
        constructor(e2, t2 = {}) {
          super("V2NIMSignallingService", e2), this.config = { compatibleWithV1: true }, this.channels = {}, this.timer = 0, this.pollingInterval = 12e4, "v2" === this.core.options.apiVersion && (registerParser({ cmdMap: dc, cmdConfig: uc }), this.setOptions(t2));
        }
        reset() {
          this.timer = 0, this.channels = {};
        }
        setOptions(e2) {
          var t2;
          (null === (t2 = this.core.signaling) || void 0 === t2 ? void 0 : t2.name) ? this.config.compatibleWithV1 = true : this.config.compatibleWithV1 = false, this.config = Object.assign(this.config, e2);
        }
        emit(e2, ...t2) {
          var r2 = `${this.name}::emit ${e2.toString()}`;
          return this.logger.log(`${r2}`, ...t2), super.emit(e2, ...t2);
        }
        call(e2) {
          var t2;
          return __awaiter(this, void 0, void 0, function* () {
            if (this.checkV2(), validate(hc, e2, "", true), e2.calleeAccountId === this.core.account)
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "You cannot call yourself" } });
            var r2 = void 0 !== e2.pushConfig && (void 0 !== e2.pushConfig.pushEnabled && e2.pushConfig.pushEnabled), i2 = (yield this.core.sendCmd("v2SignallingCall", { tag: Object.assign(Object.assign({}, e2), { toAccid: e2.calleeAccountId, offlineEnabled: void 0 === (null === (t2 = e2.signallingConfig) || void 0 === t2 ? void 0 : t2.offlineEnabled) || e2.signallingConfig.offlineEnabled, pushConfig: Object.assign(Object.assign({}, e2.pushConfig || {}), { pushEnabled: r2 }) }) })).content.data;
            return this.channels[i2.channelInfo.channelId] = cloneDeep(i2.channelInfo), this.timer || (this.timer = this.core.timerManager.addTimer(this.aotoDelay.bind(this), this.pollingInterval, -1)), { callStatus: i2.callStatus, rtcInfo: i2.rtcInfo, roomInfo: { channelInfo: i2.channelInfo, members: i2.members } };
          });
        }
        callSetup(e2) {
          var t2;
          return __awaiter(this, void 0, void 0, function* () {
            if (this.checkV2(), validate(gc, e2, "", true), e2.callerAccountId === this.core.account)
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "callSetup: cannot be yourself" } });
            var r2 = (yield this.core.sendCmd("v2SignallingCallSetup", { tag: Object.assign(Object.assign({}, e2), { toAccid: e2.callerAccountId, offlineEnabled: void 0 === (null === (t2 = e2.signallingConfig) || void 0 === t2 ? void 0 : t2.offlineEnabled) || e2.signallingConfig.offlineEnabled }) })).content.data;
            return this.channels[r2.channelInfo.channelId] = cloneDeep(r2.channelInfo), this.timer || (this.timer = this.core.timerManager.addTimer(this.aotoDelay.bind(this), this.pollingInterval, -1)), { callStatus: r2.callStatus, rtcInfo: r2.rtcInfo, roomInfo: { channelInfo: r2.channelInfo, members: r2.members } };
          });
        }
        createRoom(e2, t2, r2) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.checkV2(), validate(vc, { channelType: e2, channelName: t2, channelExtension: r2 }, "", true), (yield this.core.sendCmd("v2SignallingCreateRoom", { tag: { channelType: e2, channelName: t2, channelExtension: r2 } })).content.data.channelInfo;
          });
        }
        delayRoom(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2();
            var t2 = yield this.core.sendCmd("v2SignallingDelayRoom", { tag: { channelId: e2 } });
            return { channelInfo: t2.content.data.channelInfo, members: t2.content.data.members };
          });
        }
        closeRoom(e2, t2, r2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validate(yc, { channelId: e2, offlineEnabled: t2, serverExtension: r2 }, "", true), yield this.core.sendCmd("v2SignallingCloseRoom", { tag: { channelId: e2, offlineEnabled: void 0 !== t2 && t2, serverExtension: r2 } });
          });
        }
        joinRoom(e2) {
          var t2;
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validate(fc, e2, "", true);
            var r2 = (yield this.core.sendCmd("v2SignallingJoinRoom", { tag: Object.assign(Object.assign({}, e2), { offlineEnabled: void 0 === (null === (t2 = e2.signallingConfig) || void 0 === t2 ? void 0 : t2.offlineEnabled) || e2.signallingConfig.offlineEnabled }) })).content.data;
            this.channels[r2.channelInfo.channelId] = cloneDeep(r2.channelInfo), this.timer || (this.timer = this.core.timerManager.addTimer(this.aotoDelay.bind(this), this.pollingInterval, -1));
            var { channelInfo: i2, members: s2, rtcInfo: n2 } = r2;
            return { roomInfo: { channelInfo: i2, members: s2 }, rtcInfo: n2 };
          });
        }
        leaveRoom(e2, t2, r2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkV2(), validate(Ic, { channelId: e2, offlineEnabled: t2, serverExtension: r2 }, "", true), yield this.core.sendCmd("v2SignallingLeaveRoom", { tag: { channelId: e2, offlineEnabled: void 0 !== t2 && t2, serverExtension: r2 } }), delete this.channels[e2];
          });
        }
        invite(e2) {
          var t2;
          return __awaiter(this, void 0, void 0, function* () {
            if (this.checkV2(), validate(Mc, e2, "", true), e2.inviteeAccountId === this.core.account)
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "invite: cannot be yourself" } });
            var r2 = void 0 !== e2.pushConfig && (void 0 !== e2.pushConfig.pushEnabled && e2.pushConfig.pushEnabled);
            return (yield this.core.sendCmd("v2SignallingInvite", { tag: Object.assign(Object.assign({}, e2), { toAccid: e2.inviteeAccountId, offlineEnabled: void 0 === (null === (t2 = e2.signallingConfig) || void 0 === t2 ? void 0 : t2.offlineEnabled) || e2.signallingConfig.offlineEnabled, pushConfig: Object.assign(Object.assign({}, e2.pushConfig || {}), { pushEnabled: r2 }) }) })).content.data;
          });
        }
        cancelInvite(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.checkV2(), validate(Sc, e2, "", true), (yield this.core.sendCmd("v2SignallingCancelInvite", { tag: Object.assign(Object.assign({}, e2), { toAccid: e2.inviteeAccountId }) })).content.data;
          });
        }
        rejectInvite(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            if (validate(_c, e2, "", true), e2.inviterAccountId === this.core.account)
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "rejectInvite: cannot be yourself" } });
            yield this.core.sendCmd("v2SignallingRejectInvite", { tag: Object.assign(Object.assign({}, e2), { toAccid: e2.inviterAccountId }) });
          });
        }
        acceptInvite(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            if (validate(Cc, e2, "", true), e2.inviterAccountId === this.core.account)
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: "acceptInvite: cannot be yourself" } });
            yield this.core.sendCmd("v2SignallingAcceptInvite", { tag: Object.assign(Object.assign({}, e2), { toAccid: e2.inviterAccountId }) });
          });
        }
        sendControl(e2, t2, r2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate(Tc, { channelId: e2, receiverAccountId: t2, serverExtension: r2 }, "", true), yield this.core.sendCmd("v2SignallingSendControl", { tag: { channelId: e2, toAccid: t2, serverExtension: r2 } });
          });
        }
        getRoomInfoByChannelName(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ channelName: { type: "string", allowEmpty: false } }, { channelName: e2 }, "", true);
            var t2 = yield this.core.sendCmd("v2SignallingGetRoomInfo", { tag: { channelName: e2 } }), { members: r2, channelInfo: i2 } = t2.content.data;
            return { channelInfo: i2, members: r2 || [] };
          });
        }
        aotoDelay() {
          return __awaiter(this, void 0, void 0, function* () {
            var e2 = Object.keys(this.channels);
            if (0 === e2.length)
              return this.timer && this.core.timerManager.deleteTimer(this.timer), void (this.timer = 0);
            this.logger.log("v2Signlling:autoDelay", e2);
            for (var t2 = 0; t2 < e2.length; t2++) {
              var r2 = e2[t2];
              try {
                var i2 = yield this.core.sendCmd("v2SignallingDelayRoom", { tag: { channelId: r2 } });
                this.channels[r2] = i2.content.data.channelInfo;
              } catch (e3) {
                this.logger.warn(`signling:autoDelay ${r2} failed`, e3), delete this.channels[r2];
              }
            }
          });
        }
        v2SignallingOnlineEventHandler(e2) {
          var t2 = fillIdServer(e2, e2.content.data, "msgId", "0"), r2 = t2.msgId;
          !this.config.compatibleWithV1 && r2 && parseInt(r2) && this.core.sendCmd("v2SignallingBatchMarkRead", { sid: 15, cid: 11, ids: [r2] }), this.handleLeaveRoom(t2), this.emit("onOnlineEvent", formatSignalingEvent(t2));
        }
        v2SignallingMultiClientEventHandler(e2) {
          this.handleLeaveRoom(e2.content.data), this.emit("onMultiClientEvent", formatSignalingEvent(e2.content.data));
        }
        v2SignallingOfflineEventHandler(e2) {
          if (e2.content.datas && e2.content.datas.length > 0) {
            if (!this.config.compatibleWithV1) {
              var t2 = e2.content.datas.map((e3) => e3.msgId);
              t2.length > 0 && this.core.sendCmd("v2SignallingBatchMarkRead", { sid: 15, cid: 11, ids: t2 });
            }
            var r2 = e2.content.datas.map((e3) => (this.handleLeaveRoom(e3), formatSignalingEvent(e3)));
            this.emit("onOfflineEvent", r2);
          }
        }
        v2SignallingSyncChannelsHandler(e2) {
          if (this.timer = 0, this.channels = {}, e2.content.datas && e2.content.datas.length > 0) {
            var t2 = e2.content.datas;
            t2.forEach((e3) => {
              var t3 = e3.channelInfo.channelId;
              this.channels[t3] = cloneDeep(e3.channelInfo);
            }), this.timer || (this.timer = this.core.timerManager.addTimer(this.aotoDelay.bind(this), this.pollingInterval, -1)), this.emit("onSyncRoomInfoList", t2);
          }
        }
        handleLeaveRoom(e2) {
          switch (e2.attach.type) {
            case 1:
            case 7:
            case 9:
              delete this.channels[e2.channelInfo.channelId];
          }
        }
      }, "V2NIMSignallingService"), NIM.registerService(class V2NIMSubscriptionServiceImpl extends V2Service {
        constructor(e2) {
          super("V2NIMSubscriptionService", e2), "v2" === this.core.options.apiVersion && registerParser({ cmdMap: bc, cmdConfig: Oc });
        }
        emit(e2, ...t2) {
          var r2 = `${this.name}::emit ${e2.toString()}`;
          return this.logger.log(`${r2}`, ...t2), super.emit(e2, ...t2);
        }
        subscribeUserStatus(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.checkLogin(), this.checkV2(), validate(kc, e2, "", true), (yield this.core.sendCmd("v2SubscribeUserStatus", { tag: { eventType: 1, duration: e2.duration || 60, immediateSync: void 0 !== e2.immediateSync && e2.immediateSync }, accountIds: e2.accountIds })).content.failedList;
          });
        }
        unsubscribeUserStatus(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkLogin(), this.checkV2(), validate(wc, e2, "", true);
            var t2 = [];
            e2.accountIds.length > 0 ? t2 = (yield this.core.sendCmd("v2UnsubscribeUserStatus", { tag: { eventType: 1 }, accountIds: e2.accountIds })).content.failedList : (yield this.core.sendCmd("v2UnsubscribeAllUserStatus", { tag: { eventType: 1 } }), t2 = []);
            return t2;
          });
        }
        publishCustomUserStatus(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.checkLogin(), this.checkV2(), validate(Pc, e2, "", true), (yield this.core.sendCmd("v2PublishEvent", { tag: Object.assign(Object.assign({}, e2), { eventType: 1, uniqueId: Ie(), duration: e2.duration || 60, onlineOnly: void 0 === e2.onlineOnly || e2.onlineOnly, multiSync: void 0 !== e2.multiSync && e2.multiSync }) })).content.data;
          });
        }
        queryUserStatusSubscriptions(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.checkLogin(), this.checkV2(), validate({ accountIds: { type: "array", required: true, itemType: "string", max: 3e3 } }, { accountIds: e2 }, "", true);
            var t2 = [];
            if (e2.length > 0)
              for (var r2 = 0; r2 < e2.length; r2 += 100) {
                var i2 = yield this.core.sendCmd("v2QuerySubscribeEvent", { tag: { eventType: 1 }, accountIds: e2.slice(r2, r2 + 100) });
                t2 = t2.concat(i2.content.data.map((e3) => ({ accountId: e3.accountId, subscribeTime: e3.subscribeTime, duration: e3.duration })));
              }
            else {
              var s2 = yield this.core.sendCmd("v2QueryAllSubscribeEvent", { tag: { eventType: 1 } });
              t2 = t2.concat(s2.content.data.map((e3) => ({ accountId: e3.accountId, subscribeTime: e3.subscribeTime, duration: e3.duration })));
            }
            return t2;
          });
        }
        v2OnUserStatusChangeHandler(e2) {
          var t2 = e2.content.data, { eventType: r2, extensionReceived: i2 } = t2, s2 = __rest(t2, ["eventType", "extensionReceived"]);
          1 === r2 ? this.emit("onUserStatusChanged", [Object.assign(Object.assign({}, s2), { extension: i2 })]) : this.logger.log("v2OnUserStatusChangeHandler eventType = ", r2, "msgEvent = ", t2);
        }
        v2OnMultiUserStatusChangeHandler(e2) {
          var t2 = e2.content.data.filter((e3) => 1 === e3.eventType).map((e3) => {
            var { eventType: t3, extensionReceived: r2 } = e3, i2 = __rest(e3, ["eventType", "extensionReceived"]);
            return Object.assign(Object.assign({}, i2), { extension: r2 });
          });
          t2.length > 0 && this.emit("onUserStatusChanged", t2);
        }
      }, "V2NIMSubscriptionService"), NIM.registerService(class V2NIMPassthroughServiceImpl extends V2Service {
        constructor(e2) {
          super("V2NIMPassthroughService", e2), registerParser({ cmdMap: Lc, cmdConfig: Dc });
        }
        emit(e2, ...t2) {
          var r2 = `${this.name}::emit ${e2.toString()}`;
          return this.logger.log(`${r2}`, ...t2), super.emit(e2, ...t2);
        }
        httpProxy(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            if (validate(qc, e2, "", true), e2.method === Ec.V2NIM_PROXY_REQUEST_METHOD_GET && e2.body || e2.method === Ec.V2NIM_PROXY_REQUEST_METHOD_POST && !e2.body || e2.method === Ec.V2NIM_PROXY_REQUEST_METHOD_PUT && !e2.body)
              throw new V2NIMErrorImpl({ code: ce.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: `method ${e2.method}, incorrect body` } });
            return (yield this.core.sendCmd("v2ProxyRequest", { tag: e2 })).content.data;
          });
        }
        v2ProxyOnRequestHandler(e2) {
          var { data: t2 } = e2.content;
          this.emit("onProxyNotify", t2);
        }
      }, "V2NIMPassthroughService"), NIM.registerService(YSFServiceImpl, "YSFService"), NIM.registerService(class QChatChannelService extends Service {
        constructor(e2, t2) {
          super("qchatChannel", e2), this.config = { autoSubscribe: false }, this.core = e2, registerParser({ cmdMap: is, cmdConfig: getCmdConfig$4() }), t2 && this.setOptions(t2), this.subscribeModuleService = new UnreadInfoModuleService(e2), this.subscribeForVisitorService = new SubscribeForVisitorService(e2), this.setListener();
        }
        setOptions(e2) {
          e2 && (this.config = Object.assign(this.config, e2));
        }
        setListener() {
          this.core.eventBus.on("logined", (e2) => {
            this.subscribeModuleService.resumeSubscribe(e2.isAutoReconnect), this.subscribeForVisitorService.resumeSubscribe(e2.isAutoReconnect), this.config.autoSubscribe && (this.subscribeModuleService.autoSubscribeServerMap = {}, this.subscribeModuleService.autoSubscribeUnreadMap = {}, this.subscribeModuleService.autoSubscribe());
          }), this.core.eventBus.on("V2NIMLoginService/loginLifeCycleLoginSucc", (e2) => {
            this.subscribeModuleService.resumeSubscribe(e2.isReconnect), this.subscribeForVisitorService.resumeSubscribe(e2.isReconnect), this.config.autoSubscribe && (this.subscribeModuleService.autoSubscribeServerMap = {}, this.subscribeModuleService.autoSubscribeUnreadMap = {}, this.subscribeModuleService.autoSubscribe());
          }), this.core.eventBus.on("qchatChannel/changeUnread", this.subscribeModuleService.changeUnread.bind(this.subscribeModuleService)), this.core.eventBus.on("qchatChannel/updateUnreads", this.subscribeModuleService.updateUnreads.bind(this.subscribeModuleService)), this.core.eventBus.on("qchatChannel/cacheSubscribe", this.subscribeModuleService.cacheSubscribe.bind(this.subscribeModuleService)), this.core.eventBus.on("qchatChannel/clearUnreadCountByServers", this.subscribeModuleService.clearUnreadCountByServers.bind(this.subscribeModuleService)), this.core.eventBus.on("qchatChannel/getRoleIdsByServerId", this.subscribeModuleService.getRoleIdsByServerId.bind(this.subscribeModuleService)), this.core.eventBus.on("qchatChannel/autoUnSubscribe", (e2) => {
            if (this.logger.log("QChatChannel::enter autoUnSubscribe sysMsg is", e2), e2.type === Rs[Rs.channelVisibilityUpdate])
              this.logger.log("QChatChannel::begin autoUnSubscribe channel key is", `${e2.serverId}_${e2.channelId}`), this.subscribeModuleService._unSubscribeChannel(e2.serverId, e2.channelId), this.logger.log("QChatChannel::autoUnSubscribe channel done key is", `${e2.serverId}_${e2.channelId}`);
            else if (e2.type === Rs[Rs.serverEnterLeave]) {
              (this.subscribeModuleService.manualSubscribeServerMap[e2.serverId] || this.subscribeModuleService.autoSubscribeServerMap[e2.serverId]) && (this.logger.log("QChatChannel::begin autoUnSubscribe server key is", e2.serverId), this.subscribeModuleService._unSubscribeServer(e2.serverId), this.logger.log("QChatChannel::autoUnSubscribe server done key is", e2.serverId));
              var t2 = this.subscribeModuleService.unreadServerCount[e2.serverId];
              if (!t2)
                return;
              this.logger.log("QChatChannel::begin autoUnSubscribe channels key is", Object.keys(t2)), Object.keys(t2).forEach((t3) => {
                this.subscribeModuleService._unSubscribeChannel(e2.serverId, t3);
              }), this.logger.log("QChatChannel::autoUnSubscribe channels done key is", Object.keys(t2));
            }
          }), this.core.eventBus.on("qchatChannel/serverIdentifyChange", (e2) => {
            this.subscribeModuleService.changeCacheServerRoleIds(e2);
          });
        }
        createChannel(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ serverId: { type: "string", min: 1 }, type: { type: "enum", values: getEnumKeys(Zi) }, name: { type: "string", required: false }, topic: { type: "string", required: false }, ext: { type: "string", required: false }, visitorMode: { type: "number", required: false } }, e2), formatChannel((yield this.core.sendCmd("qchatCreateChannel", { channelInfo: Object.assign(Object.assign({}, e2), { type: Zi[e2.type] }), antispamTag: generateAntispamTag(e2) })).content.channelInfo);
          });
        }
        deleteChannel(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ channelId: { type: "string", allowEmpty: false } }, e2), yield this.core.sendCmd("qchatDeleteChannel", e2);
          });
        }
        updateChannel(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ channelId: { type: "string", min: 1 }, serverId: { type: "string", required: false }, type: { type: "enum", values: getEnumKeys(Zi), required: false }, name: { type: "string", required: false }, topic: { type: "string", required: false }, ext: { type: "string", required: false }, visitorMode: { type: "number", required: false } }, e2);
            var t2 = e2;
            return e2.type && (t2.type = Zi[e2.type]), formatChannel((yield this.core.sendCmd("qchatUpdateChannel", { channelInfo: t2, antispamTag: generateAntispamTag(e2) })).content.channelInfo);
          });
        }
        getChannels(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ channelIds: { type: "array", itemType: "string", min: 1 } }, e2), formatChannels((yield this.core.sendCmd("qchatGetChannels", e2)).content.channelList);
          });
        }
        getChannelsByPage(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ serverId: { type: "string", min: 1 }, timetag: { type: "number" }, limit: { type: "number", min: 1, required: false } }, e2);
            var t2 = yield this.core.sendCmd("qchatGetChannelsByPage", { qchatGetChannelListPageTag: Object.assign({ limit: 100 }, e2) }), { datas: r2, listQueryTag: i2 } = t2.content;
            return { listQueryTag: { hasMore: 1 == +i2.hasMore, nextTimetag: parseInt(i2.nextTimetag) }, datas: formatChannels(r2) };
          });
        }
        getMembersByPage(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ serverId: { type: "string", min: 1 }, channelId: { type: "string", min: 1 }, timetag: { type: "number" }, limit: { type: "number", min: 1, required: false } }, e2);
            var t2 = yield this.core.sendCmd("qchatGetMembersByPage", { qchatGetMembersByPageTag: e2 }), { datas: r2, listQueryTag: i2 } = t2.content;
            return { listQueryTag: { hasMore: 1 == +i2.hasMore, nextTimetag: parseInt(i2.nextTimetag) }, datas: formatMembers$1(r2) };
          });
        }
        updateWhiteBlackRole(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ serverId: { type: "string", min: 1 }, channelId: { type: "string", min: 1 }, roleId: { type: "string", min: 1 }, type: { type: "enum", values: getEnumKeys(Qi) }, opeType: { type: "enum", values: getEnumKeys(Xi) } }, e2), yield this.core.sendCmd("qchatUpdateWhiteBlackRole", { qchatUpdateWhiteBlackRoleTag: Object.assign(Object.assign({}, e2), { type: Qi[e2.type], opeType: Xi[e2.opeType] }) });
          });
        }
        getWhiteBlackRolesPage(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ serverId: { type: "string", min: 1 }, channelId: { type: "string", min: 1 }, type: { type: "enum", values: getEnumKeys(Qi) }, timetag: { type: "number" }, limit: { type: "number", min: 1, required: false } }, e2);
            var t2 = yield this.core.sendCmd("qchatGetWhiteBlackRolesPage", { qchatGetWhiteBlackRolesPageTag: Object.assign(Object.assign({}, e2), { type: Qi[e2.type] }) }), { datas: r2, listQueryTag: i2 } = t2.content;
            return { listQueryTag: { hasMore: 1 == +i2.hasMore, nextTimetag: parseInt(i2.nextTimetag) }, datas: formatRoles(r2) };
          });
        }
        updateWhiteBlackMembers(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ serverId: { type: "string", min: 1 }, channelId: { type: "string", min: 1 }, type: { type: "enum", values: getEnumKeys(Qi) }, opeType: { type: "enum", values: getEnumKeys(Xi) }, toAccids: { type: "array", itemType: "string", min: 1 } }, e2), yield this.core.sendCmd("qchatUpdateWhiteBlackMembers", { qchatUpdateWhiteBlackMembersTag: Object.assign(Object.assign({}, e2), { type: Qi[e2.type], opeType: Xi[e2.opeType], toAccids: JSON.stringify(e2.toAccids) }) });
          });
        }
        getWhiteBlackMembersPage(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ serverId: { type: "string", min: 1 }, channelId: { type: "string", min: 1 }, type: { type: "enum", values: getEnumKeys(Qi) }, timetag: { type: "number" }, limit: { type: "number", min: 1, required: false } }, e2);
            var t2 = yield this.core.sendCmd("qchatGetWhiteBlackMembersPage", { qchatGetWhiteBlackMembersPageTag: Object.assign(Object.assign({ limit: 100 }, e2), { type: Qi[e2.type] }) }), { datas: r2, listQueryTag: i2 } = t2.content;
            return { listQueryTag: { hasMore: 1 == +i2.hasMore, nextTimetag: parseInt(i2.nextTimetag) }, datas: formatMembers$1(r2) };
          });
        }
        getExistingWhiteBlackRoles(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ serverId: { type: "string", min: 1 }, channelId: { type: "string", min: 1 }, type: { type: "enum", values: getEnumKeys(Qi) }, roleIds: { type: "array", itemType: "string", min: 1 } }, e2);
            var t2 = yield this.core.sendCmd("qchatGetExistingWhiteBlackRoles", { qchatGetExistingWhiteBlackRolesTag: Object.assign(Object.assign({}, e2), { type: Qi[e2.type], roleIds: JSON.stringify(e2.roleIds) }) }), { datas: r2 } = t2.content;
            return { datas: formatRoles(r2) };
          });
        }
        getExistingWhiteBlackMembers(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ serverId: { type: "string", min: 1 }, channelId: { type: "string", min: 1 }, type: { type: "enum", values: getEnumKeys(Qi) }, accids: { type: "array", itemType: "string", min: 1 } }, e2);
            var t2 = yield this.core.sendCmd("qchatGetExistingWhiteBlackMembers", { qchatGetExistingWhiteBlackMembersTag: Object.assign(Object.assign({}, e2), { type: Qi[e2.type], accids: JSON.stringify(e2.accids) }) }), { datas: r2 } = t2.content;
            return { datas: formatMembers$1(r2) };
          });
        }
        updateCategoryInfoOfChannel(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ channelId: { type: "string", min: 1 }, categoryId: { type: "string", allowEmpty: false, required: false }, syncMode: { type: "number", min: 0, max: 1, required: false } }, e2), formatChannel((yield this.core.sendCmd("qchatUpdateCategoryInfoOfChannel", { qchatUpdateCategoryInfoOfChannelTag: e2 })).content.channelInfo);
          });
        }
        createChannelCategory(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ serverId: { type: "string", allowEmpty: false }, name: { type: "string", allowEmpty: false, required: false }, ext: { type: "string", required: false }, viewMode: { type: "number", min: 0, max: 1, required: false } }, e2), formatChannelCategory((yield this.core.sendCmd("qchatCreateChannelCategory", { qchatCreateChannelCategoryTag: e2 })).content.QChatChannelCategoryInfo);
          });
        }
        removeChannelCategory(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ categoryId: { type: "string", allowEmpty: false } }, e2), yield this.core.sendCmd("qchatRemoveChannelCategory", e2);
          });
        }
        updateChannelCategory(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ categoryId: { type: "string", allowEmpty: false }, name: { type: "string", allowEmpty: false, required: false }, ext: { type: "string", required: false }, viewMode: { type: "number", min: 0, max: 1, required: false } }, e2), formatChannelCategory((yield this.core.sendCmd("qchatUpdateChannelCategory", { qchatUpdateChannelCategoryTag: e2 })).content.QChatChannelCategoryInfo);
          });
        }
        getChannelCategoriesByID(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ categoryIds: { type: "array", itemType: "string", min: 1 } }, e2), formatChannelCategorys((yield this.core.sendCmd("qchatGetChannelCategoriesByID", e2)).content.channelCategoryList);
          });
        }
        updateChannelCategoryWhiteBlackRole(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ categoryId: { type: "string", allowEmpty: false }, serverId: { type: "string", allowEmpty: false }, type: { type: "enum", values: getEnumKeys(Qi) }, opeType: { type: "enum", values: getEnumKeys(Xi) }, roleId: { type: "string", allowEmpty: false } }, e2), yield this.core.sendCmd("qchatUpdateChannelCategoryWhiteBlackRole", { qchatUpdateChannelCategoryWhiteBlackRoleTag: Object.assign(Object.assign({}, e2), { type: Qi[e2.type], opeType: Xi[e2.opeType] }) });
          });
        }
        getChannelCategoryWhiteBlackRolesPage(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ categoryId: { type: "string", allowEmpty: false }, serverId: { type: "string", allowEmpty: false }, type: { type: "enum", values: getEnumKeys(Qi) }, timetag: { type: "number", min: 0 }, limit: { type: "number", min: 1, required: false } }, e2);
            var t2 = yield this.core.sendCmd("qchatGetChannelCategoryWhiteBlackRolesPage", { qchatGetChannelCategoryWhiteBlackRolesPageTag: Object.assign(Object.assign({}, e2), { type: Qi[e2.type] }) }), { datas: r2, listQueryTag: i2 } = t2.content;
            return { listQueryTag: { hasMore: 1 == +i2.hasMore, nextTimetag: parseInt(i2.nextTimetag) }, datas: formatRoles(r2) };
          });
        }
        updateChannelCategoryWhiteBlackMembers(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ categoryId: { type: "string", allowEmpty: false }, serverId: { type: "string", allowEmpty: false }, type: { type: "enum", values: getEnumKeys(Qi) }, opeType: { type: "enum", values: getEnumKeys(Xi) }, toAccids: { type: "array", itemType: "string", min: 1 } }, e2), yield this.core.sendCmd("qchatUpdateChannelCategoryWhiteBlackMembers", { qchatUpdateChannelCategoryWhiteBlackMembersTag: Object.assign(Object.assign({}, e2), { type: Qi[e2.type], opeType: Xi[e2.opeType], toAccids: JSON.stringify(e2.toAccids) }) });
          });
        }
        getChannelCategoryWhiteBlackMembersPage(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ categoryId: { type: "string", allowEmpty: false }, serverId: { type: "string", allowEmpty: false }, type: { type: "enum", values: getEnumKeys(Qi) }, timetag: { type: "number", min: 0 }, limit: { type: "number", min: 1, required: false } }, e2);
            var t2 = yield this.core.sendCmd("qchatGetChannelCategoryWhiteBlackMembersPage", { qchatGetChannelCategoryWhiteBlackMembersPageTag: Object.assign(Object.assign({}, e2), { type: Qi[e2.type] }) }), { datas: r2, listQueryTag: i2 } = t2.content;
            return { listQueryTag: { hasMore: 1 == +i2.hasMore, nextTimetag: parseInt(i2.nextTimetag) }, datas: formatMembers$1(r2) };
          });
        }
        getChannelCategoryWhiteBlackRoles(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ categoryId: { type: "string", allowEmpty: false }, serverId: { type: "string", allowEmpty: false }, type: { type: "enum", values: getEnumKeys(Qi) }, roleIds: { type: "array", itemType: "string", min: 1 } }, e2);
            var t2 = yield this.core.sendCmd("qchatGetChannelCategoryWhiteBlackRoles", { qchatGetChannelCategoryWhiteBlackRolesTag: Object.assign(Object.assign({}, e2), { type: Qi[e2.type], roleIds: JSON.stringify(e2.roleIds) }) }), { datas: r2 } = t2.content;
            return formatRoles(r2);
          });
        }
        getChannelCategoryWhiteBlackMembers(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ categoryId: { type: "string", allowEmpty: false }, serverId: { type: "string", allowEmpty: false }, type: { type: "enum", values: getEnumKeys(Qi) }, accids: { type: "array", itemType: "string", min: 1 } }, e2);
            var t2 = yield this.core.sendCmd("qchatGetChannelCategoryWhiteBlackMembers", { qchatGetChannelCategoryWhiteBlackMembersTag: Object.assign(Object.assign({}, e2), { type: Qi[e2.type], accids: JSON.stringify(e2.accids) }) }), { datas: r2 } = t2.content;
            return formatMembers$1(r2);
          });
        }
        getChannelCategoriesPage(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ serverId: { type: "string", allowEmpty: false }, timetag: { type: "number", min: 0 }, limit: { type: "number", min: 1, required: false } }, e2);
            var t2 = yield this.core.sendCmd("qchatGetChannelCategoriesPage", { qchatGetChannelCategoriesPageTag: e2 }), { datas: r2, listQueryTag: i2 } = t2.content;
            return { listQueryTag: { hasMore: 1 == +i2.hasMore, nextTimetag: parseInt(i2.nextTimetag) }, datas: formatChannelCategorys(r2) };
          });
        }
        getChannelCategoryChannelsPage(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ serverId: { type: "string", allowEmpty: false }, categoryId: { type: "string", allowEmpty: false }, timetag: { type: "number", min: 0 }, limit: { type: "number", min: 1, required: false } }, e2);
            var t2 = yield this.core.sendCmd("qchatGetChannelCategoryChannelsPage", { qchatGetChannelCategoryChannelsPageTag: e2 }), { datas: r2, listQueryTag: i2 } = t2.content;
            return { listQueryTag: { hasMore: 1 == +i2.hasMore, nextTimetag: parseInt(i2.nextTimetag) }, datas: formatChannels(r2) };
          });
        }
        subscribeChannel(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            if (validate({ type: { type: "number", min: 1, max: 5 }, opeType: { type: "number", min: 1, max: 2 } }, e2), this.config.autoSubscribe && !e2.isInternalTrigger && 5 !== e2.type)
              throw new CustomError("subscribe server failed, manual subscribe is not allowed in auto subscribe mode", {}, 403);
            var t2 = yield this.subscribeModuleService.subscribe(e2);
            if (t2.unreadInfos = formatUnreadInfos(t2.unreadInfos), 5 !== e2.type)
              return 1 === e2.opeType && (e2.channels = t2.unreadInfos.map((e3) => ({ serverId: e3.serverId, channelId: e3.channelId }))), this.logger.debug("QChatChannel::subscribeChannel:: cacheSubscribe ", e2), this.config.autoSubscribe ? this.subscribeModuleService.cacheAutoSubscribe(e2) : this.subscribeModuleService.cacheSubscribe(e2), this.subscribeModuleService.updateUnreads(t2.unreadInfos), t2;
            this.subscribeModuleService.cacheSubscribe(e2);
          });
        }
        getChannelUnreadInfos(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            var t2 = formatUnreadInfos((yield this.core.sendCmd("qchatGetUnreadInfo", e2)).content.unreadInfos);
            return this.subscribeModuleService.updateUnreads(t2), t2;
          });
        }
        getChannelSearchByPage(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            if (validate({ keyword: { type: "string", allowEmpty: false }, startTime: { type: "number", min: 0, required: false }, endTime: { type: "number", min: 1, required: false }, order: { type: "enum", values: getEnumKeys(es), required: false }, limit: { type: "number", min: 1, required: false }, serverId: { type: "string", required: false }, sort: { type: "enum", values: getEnumKeys(Ji), required: false }, cursor: { type: "string", allowEmpty: false, required: false } }, e2), e2.startTime && e2.endTime && e2.startTime >= e2.endTime)
              throw new ValidateError("startTime more than endTime", e2, "timeRule");
            var t2 = yield this.core.sendCmd("qchatGetChannelSearchByPage", { qchatGetChannelSearchByPageTag: Object.assign(Object.assign({}, e2), { order: e2.order && es[e2.order], sort: e2.sort && Ji[e2.sort] }) }), { datas: r2, listQueryTag: i2 } = t2.content;
            return { listQueryTag: { hasMore: 1 == +i2.hasMore, nextTimetag: parseInt(i2.nextTimetag), cursor: i2.cursor }, datas: formatChannels(r2) };
          });
        }
        channelMemberSearch(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ serverId: { type: "string", allowEmpty: false }, channelId: { type: "string", allowEmpty: false }, keyword: { type: "string", allowEmpty: false }, limit: { type: "number", min: 1, required: false } }, e2), formatChannelMembers((yield this.core.sendCmd("qchatChannelMemberSearch", { qchatChannelMemberSearchTag: e2 })).content.datas);
          });
        }
        subscribeAsVisitor(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ opeType: { type: "number", min: 1, max: 2 }, type: { type: "number", required: false }, channels: { type: "array", rules: { serverId: { type: "string", allowEmpty: false }, channelId: { type: "string", allowEmpty: false } }, min: 1 } }, e2), yield this.subscribeForVisitorService.subscribeChannelAsVisitor(e2);
          });
        }
        qchatAutoSubscribeNotificationHandler(e2) {
          var t2 = formatUnreadInfos(e2.content.unreadInfos), r2 = e2.content.serverIds;
          this.subscribeModuleService.updateUnreads(t2);
          var i2 = [];
          if (r2.length) {
            var s2 = { opeType: 1 };
            s2.channels = r2.map((e3) => ({ serverId: e3.serverId, channelId: "" })), s2.type = 4, i2.push(s2);
          }
          if (t2.length) {
            var n2 = { opeType: 1 };
            n2.channels = t2.map((e3) => ({ serverId: e3.serverId, channelId: e3.channelId })), n2.type = 1, i2.push(n2);
          }
          if (i2.length)
            for (var a2 of i2)
              this.subscribeModuleService.cacheAutoSubscribe(a2);
        }
      }, "qchatChannel"), NIM.registerService(class QChatMediaService extends Service {
        constructor(e2, t2) {
          super("qchatMedia", e2), this.config = {}, this.tokenExpireTime = 24e4, this.getTokenState = false, this.core = e2, registerParser({ cmdMap: Ds, cmdConfig: getCmdConfig$3() }), t2 && this.setOptions(t2), this.setListener(), this.tokenExpireTime = 24e4, this.channelId = "", this.serverId = "";
        }
        setOptions(e2) {
          e2 && (this.config = Object.assign(this.config, e2), (null == e2 ? void 0 : e2.neroom) && this.setNeroom(e2.neroom));
        }
        setNeroom(e2) {
          this.neroom = new e2();
        }
        setListener() {
          this.core.eventBus.on("disconnect", this._existRomm.bind(this)), this.core.eventBus.on("kicked", this._existRomm.bind(this)), this.core.eventBus.on("V2NIMLoginService/loginLifeCycleLogout", this._existRomm.bind(this)), this.core.eventBus.on("V2NIMLoginService/loginLifeCycleKicked", this._existRomm.bind(this)), this.core.eventBus.on("qchatMedia/serverOrChannelLeave", (e2) => __awaiter(this, void 0, void 0, function* () {
            (e2.type === Rs[Rs.channelVisibilityUpdate] && e2.channelId === this.channelId || e2.type === Rs[Rs.serverEnterLeave] && e2.serverId === this.serverId) && this.roomContext && this.roomContext.roomUuid && (yield this.disconnectChannel());
          }));
        }
        _existRomm() {
          return __awaiter(this, void 0, void 0, function* () {
            this.roomContext && (yield this.disconnectChannel()), this.tokenTimer && (this.core.timerManager.deleteTimer(this.tokenTimer), this.tokenTimer = void 0);
          });
        }
        _checkPermission(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return yield this.core.qchatRole.checkPermission(e2);
          });
        }
        _checkConnectState() {
          if ("connect" !== this.state)
            throw new CustomError("QChatMedia::you should connect first");
        }
        kickMemberOut(e2) {
          var t2;
          return __awaiter(this, void 0, void 0, function* () {
            this._checkConnectState(), validate({ accid: { type: "string", allowEmpty: false } }, e2);
            try {
              yield null === (t2 = this.roomContext) || void 0 === t2 ? void 0 : t2.kickMemberOut(e2.accid);
            } catch (t3) {
              throw this.logger.error("QChatMedia::kickMemberOut error params is " + JSON.stringify(e2), t3), new CustomError("QChatMedia::kickMemberOut error", t3);
            }
          });
        }
        disconnectChannel() {
          var e2;
          return __awaiter(this, void 0, void 0, function* () {
            this.logger.debug("QChatMedia::disconnect begin disconnect");
            try {
              yield null === (e2 = this.roomContext) || void 0 === e2 ? void 0 : e2.leaveRoom();
            } catch (e3) {
              this.logger.error("QChatMedia::disconnect error", e3);
            }
            this.authService && (yield this.authService.logout()), this._setStateInit(), this.core.emit("qchatMediaDisconnect"), this.core.qchatMedia.emit("qchatMediaDisconnect");
          });
        }
        _setStateInit() {
          this.logger.debug("QChatMedia::disconnect end"), this.roomContext = void 0, this.rtcController = void 0, this.state = "init", this.tokenTimer && (this.core.timerManager.deleteTimer(this.tokenTimer), this.tokenTimer = void 0), this.channelId = "", this.serverId = "";
        }
        muteAudio(e2) {
          var t2, r2, i2, s2, n2;
          return __awaiter(this, void 0, void 0, function* () {
            if (this._checkConnectState(), validate({ accid: { type: "string", allowEmpty: false } }, e2), (null === (t2 = this.roomContext) || void 0 === t2 ? void 0 : t2.localMember.uuid) === e2.accid)
              try {
                yield null === (r2 = this.rtcController) || void 0 === r2 ? void 0 : r2.muteMyAudio();
              } catch (e3) {
                throw this.logger.error("QChatMedia::muteAudio error", e3), new CustomError("QChatMedia::muteAudio error", e3);
              }
            else
              try {
                var a2 = null === (i2 = this.roomContext) || void 0 === i2 ? void 0 : i2.roomProperties.audioOff;
                if (a2 && "offNotAllowSelfOn" === (null === (s2 = a2.value) || void 0 === s2 ? void 0 : s2.split("_")[0])) {
                  if (!(yield this._checkPermission({ serverId: this.serverId, channelId: this.channelId, auth: "RTCChannelOpenCloseEveryoneMicrophone" })))
                    return void this.logger.error("QChatMedia::unMuteAudio not allow open auido");
                }
                yield null === (n2 = this.rtcController) || void 0 === n2 ? void 0 : n2.muteMemberAudio(e2.accid);
              } catch (t3) {
                throw this.logger.error("QChatMedia::muteAudio error params is " + JSON.stringify(e2), t3), new CustomError("QChatMedia::muteAudio error", t3);
              }
          });
        }
        unMuteAudio(e2) {
          var t2, r2, i2, s2, n2;
          return __awaiter(this, void 0, void 0, function* () {
            this._checkConnectState(), validate({ accid: { type: "string", allowEmpty: false } }, e2);
            var a2 = null === (t2 = this.roomContext) || void 0 === t2 ? void 0 : t2.roomProperties.audioOff;
            if (a2 && "offNotAllowSelfOn" === (null === (r2 = a2.value) || void 0 === r2 ? void 0 : r2.split("_")[0]) && !(yield this._checkPermission({ serverId: this.serverId, channelId: this.channelId, auth: "RTCChannelOpenCloseEveryoneMicrophone" })))
              return void this.logger.error("QChatMedia::unMuteAudio not allow open auido");
            if ((null === (i2 = this.roomContext) || void 0 === i2 ? void 0 : i2.localMember.uuid) === e2.accid)
              try {
                yield null === (s2 = this.rtcController) || void 0 === s2 ? void 0 : s2.unmuteMyAudio();
              } catch (e3) {
                throw this.logger.error("QChatMedia::unMuteAudio error", e3), new CustomError("QChatMedia::unMuteAudio error", e3);
              }
            else
              try {
                yield null === (n2 = this.rtcController) || void 0 === n2 ? void 0 : n2.unmuteMemberAudio(e2.accid);
              } catch (t3) {
                throw this.logger.error("QChatMedia::unMuteAudio error params is " + JSON.stringify(e2), t3), new CustomError("QChatMedia::unMuteAudio error", t3);
              }
          });
        }
        muteVideo(e2) {
          var t2, r2, i2, s2, n2;
          return __awaiter(this, void 0, void 0, function* () {
            if (this._checkConnectState(), validate({ accid: { type: "string", allowEmpty: false } }, e2), (null === (t2 = this.roomContext) || void 0 === t2 ? void 0 : t2.localMember.uuid) === e2.accid)
              try {
                yield null === (r2 = this.rtcController) || void 0 === r2 ? void 0 : r2.muteMyVideo();
              } catch (e3) {
                throw this.logger.error("QChatMedia::muteVideo error", e3), new CustomError("QChatMedia::muteVideo error", e3);
              }
            else
              try {
                var a2 = null === (i2 = this.roomContext) || void 0 === i2 ? void 0 : i2.roomProperties.videoOff;
                if (a2 && "offNotAllowSelfOn" === (null === (s2 = a2.value) || void 0 === s2 ? void 0 : s2.split("_")[0])) {
                  if (!(yield this._checkPermission({ serverId: this.serverId, channelId: this.channelId, auth: "RTCChannelOpenCloseEveryoneCamera" })))
                    return void this.logger.error("QChatMedia::unMuteVideo not allow open video");
                }
                yield null === (n2 = this.rtcController) || void 0 === n2 ? void 0 : n2.muteMemberVideo(e2.accid);
              } catch (t3) {
                throw this.logger.error("QChatMedia::muteVideo error params is " + JSON.stringify(e2), t3), new CustomError("QChatMedia::muteVideo error", t3);
              }
          });
        }
        unMuteVideo(e2) {
          var t2, r2, i2, s2, n2;
          return __awaiter(this, void 0, void 0, function* () {
            this._checkConnectState(), validate({ accid: { type: "string", allowEmpty: false } }, e2);
            var a2 = null === (t2 = this.roomContext) || void 0 === t2 ? void 0 : t2.roomProperties.videoOff;
            if (a2 && "offNotAllowSelfOn" === (null === (r2 = a2.value) || void 0 === r2 ? void 0 : r2.split("_")[0]) && !(yield this._checkPermission({ serverId: this.serverId, channelId: this.channelId, auth: "RTCChannelOpenCloseEveryoneCamera" })))
              return void this.logger.error("QChatMedia::unMuteVideo not allow open video");
            if ((null === (i2 = this.roomContext) || void 0 === i2 ? void 0 : i2.localMember.uuid) === e2.accid)
              try {
                yield null === (s2 = this.rtcController) || void 0 === s2 ? void 0 : s2.unmuteMyVideo();
              } catch (e3) {
                throw this.logger.error("QChatMedia::unMuteVideo error", e3), new CustomError("QChatMedia::unMuteVideo error", e3);
              }
            else
              try {
                null === (n2 = this.rtcController) || void 0 === n2 || n2.unmuteMemberVideo(e2.accid);
              } catch (e3) {
                throw this.logger.error("QChatMedia::unMuteVideo error", e3), new CustomError("QChatMedia::unMuteVideo error", e3);
              }
          });
        }
        startScreenShare() {
          var e2;
          return __awaiter(this, void 0, void 0, function* () {
            this._checkConnectState();
            try {
              null === (e2 = this.rtcController) || void 0 === e2 || e2.startScreenShare();
            } catch (e3) {
              throw this.logger.error("QChatMedia::startScreenShare error", e3), new CustomError("QChatMedia::startScreenShare error", e3);
            }
          });
        }
        stopScreenShare() {
          var e2;
          return __awaiter(this, void 0, void 0, function* () {
            this._checkConnectState();
            try {
              null === (e2 = this.rtcController) || void 0 === e2 || e2.stopScreenShare();
            } catch (e3) {
              throw this.logger.error("QChatMedia::stopScreenShare error", e3), new CustomError("QChatMedia::stopScreenShare error", e3);
            }
          });
        }
        stopMemberScreenShare(e2) {
          var t2;
          return __awaiter(this, void 0, void 0, function* () {
            this._checkConnectState(), validate({ accid: { type: "string", allowEmpty: false } }, e2);
            try {
              null === (t2 = this.rtcController) || void 0 === t2 || t2.stopMemberScreenShare(e2.accid);
            } catch (e3) {
              throw this.logger.error("QChatMedia::stopMemberScreenShare error", e3), new CustomError("QChatMedia::stopMemberScreenShare error", e3);
            }
          });
        }
        subscribeRemoteVideoStream(e2) {
          var t2;
          return __awaiter(this, void 0, void 0, function* () {
            this._checkConnectState(), validate({ accid: { type: "string", allowEmpty: false }, streamType: { type: "number", allowEmpty: false, min: 0, max: 1 } }, e2);
            try {
              null === (t2 = this.rtcController) || void 0 === t2 || t2.subscribeRemoteVideoStream(e2.accid, e2.streamType);
            } catch (e3) {
              throw this.logger.error("QChatMedia::subscribeRemoteVideoStream error", e3), new CustomError("QChatMedia::subscribeRemoteVideoStream error", e3);
            }
          });
        }
        unSubscribeRemoteVideoStream(e2) {
          var t2;
          return __awaiter(this, void 0, void 0, function* () {
            this._checkConnectState(), validate({ accid: { type: "string", allowEmpty: false }, streamType: { type: "number", allowEmpty: false, min: 0, max: 1 } }, e2);
            try {
              null === (t2 = this.rtcController) || void 0 === t2 || t2.unsubscribeRemoteVideoStream(e2.accid, e2.streamType);
            } catch (e3) {
              throw this.logger.error("QChatMedia::unSubscribeRemoteVideoStream error", e3), new CustomError("QChatMedia::unSubscribeRemoteVideoStream error", e3);
            }
          });
        }
        setupVideoCanvas(e2) {
          var t2;
          if (this._checkConnectState(), (null === (t2 = this.roomContext) || void 0 === t2 ? void 0 : t2.localMember.uuid) === e2.accid)
            try {
              return this.rtcController.setupLocalVideoCanvas(e2.videoView);
            } catch (e3) {
              throw this.logger.error("QChatMedia::setupVideoCanvas error", e3), new CustomError("QChatMedia::setupVideoCanvas error", e3);
            }
          else
            try {
              return this.rtcController.setupRemoteVideoCanvas(e2.videoView, e2.accid);
            } catch (e3) {
              throw this.logger.error("QChatMedia::setupVideoCanvas error", e3), new CustomError("QChatMedia::setupVideoCanvas error", e3);
            }
        }
        setupRemoteVideoSubStreamCanvas(e2) {
          this._checkConnectState(), validate({ accid: { type: "string", allowEmpty: false } }, e2);
          try {
            return this.rtcController.setupRemoteVideoSubStreamCanvas(e2.videoView, e2.accid);
          } catch (e3) {
            throw this.logger.error("QChatMedia::setupRemoteVideoSubStreamCanvas error", e3), new CustomError("QChatMedia::setupRemoteVideoSubStreamCanvas error", e3);
          }
        }
        getScreenSharingUserUuid() {
          this._checkConnectState();
          try {
            return this.rtcController.getScreenSharingUserUuid();
          } catch (e2) {
            throw this.logger.error("QChatMedia::getScreenSharingUserUuid error", e2), new CustomError("QChatMedia::getScreenSharingUserUuid error", e2);
          }
        }
        initQChatMedia(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            if (this.neroom)
              if (void 0 === this.state) {
                try {
                  this.neroom.initialize({ appKey: this.core.options.appkey, serverConfig: e2.serverConfig });
                } catch (e3) {
                  throw this.logger.error("QChatMedia::initQChatMedia error", e3), new CustomError("QChatMedia::initQChatMedia error", e3);
                }
                this.authService = this.neroom.authService, this.roomService = this.neroom.roomService, this.messageChannelService = this.neroom.messageChannelService, this.state = "init";
              } else
                this.logger.error("QChatMedia::init::you already init QChatMedia");
            else
              this.logger.warn("QChatMedia::init::you should import neroom SDK");
          });
        }
        loginByIM() {
          var e2;
          return __awaiter(this, void 0, void 0, function* () {
            if ("init" === this.state) {
              var t2 = yield this._getToken(), r2 = get(this.core, "options.token") || get(this.core, "V2NIMLoginService.token");
              try {
                yield null === (e2 = this.authService) || void 0 === e2 ? void 0 : e2.loginByIM(this.core.account, t2, r2);
              } catch (e3) {
                throw this.logger.error("QChatMedia::loginByIM error", e3), new CustomError("QChatMedia::loginByIM error", e3);
              }
              this.state = "login";
            } else
              this.logger.error("QChatMedia::connect::you should init before login");
          });
        }
        _getToken() {
          var e2;
          return __awaiter(this, void 0, void 0, function* () {
            this.logger.log("QChatMedia::getToken begin getToken");
            var t2 = yield this.core.sendCmd("qchatGetNeroomToken", { qchatGetNeroomTokenTag: { neroomDeviceId: null === (e2 = this.neroom) || void 0 === e2 ? void 0 : e2.deviceId } }), { token: r2, expire: i2 } = t2.content.neroomToken;
            return this.logger.log(`QChatMedia::getToken success token is ${r2},expire is ${i2} `), this.tokenTimer || (this.logger.debug(`QChatMedia::getToken set token timer,expire is ${1e3 * i2 - this.tokenExpireTime} `), this.tokenTimer = this.core.timerManager.addTimer(() => __awaiter(this, void 0, void 0, function* () {
              this.tokenTimer && this.core.timerManager.deleteTimer(this.tokenTimer), this.tokenTimer = void 0;
              var e3 = yield this._getToken();
              this.authService && this.authService.renewToken(e3);
            }), 1e3 * i2 - this.tokenExpireTime)), r2;
          });
        }
        connectChannel(e2) {
          var t2, r2;
          return __awaiter(this, void 0, void 0, function* () {
            if (void 0 !== this.state) {
              "init" === this.state && (yield this.loginByIM()), this.serverId = e2.serverId, this.channelId = e2.channelId;
              try {
                yield null === (t2 = this.roomService) || void 0 === t2 ? void 0 : t2.joinRoom({ roomUuid: e2.channelId, role: "qchatAudience", userName: this.core.account, initialProperties: {} }, {});
              } catch (e3) {
                throw this.logger.error("QChatMedia::connectChannel error", e3), new CustomError("QChatMedia::connectChannel error", e3);
              }
              var i2 = null === (r2 = this.roomService) || void 0 === r2 ? void 0 : r2.getRoomContext(e2.channelId);
              i2 ? (this.roomContext = i2, this.rtcController = this.roomContext.rtcController, this.state = "connect", yield this.rtcController.joinRtcChannel(), this.core.emit("connectChannel"), this.core.qchatMedia.emit("connectChannel")) : this.logger.error("QChatMedia::connect room not exited");
            } else
              this.logger.error("QChatMedia::connect::you should init before login");
          });
        }
        updateRTCChannelInfo(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ serverId: { type: "string", allowEmpty: false }, channelId: { type: "string", allowEmpty: false }, limit: { type: "number", allowEmpty: false } }, e2), yield this.core.sendCmd("qchatUpdateRTCChannelConfig", { RTCChannelConfig: Object.assign(Object.assign({}, e2), { audio: JSON.stringify(e2.audio), video: JSON.stringify(e2.video) }) });
          });
        }
        getRTCChannelInfo(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ serverId: { type: "string", allowEmpty: false }, channelId: { type: "string", allowEmpty: false } }, e2), function formatRTCChannelConfig(e3) {
              try {
                e3.audio && (e3.audio = JSON.parse(e3.audio));
              } catch (e4) {
                throw new ValidateError('result "audio" JSON parse error', { key: "audio" }, "JSON parse error");
              }
              try {
                e3.video && (e3.video = JSON.parse(e3.video));
              } catch (e4) {
                throw new ValidateError('result "video" JSON parse error', { key: "video" }, "JSON parse error");
              }
              return format(Us, e3);
            }((yield this.core.sendCmd("qchatGetRTCChannelConfig", { qchatGetRTCChannelConfigTag: e2 })).content.RTCChannelConfig);
          });
        }
        getRTCChannelOnlineMembers(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ serverId: { type: "string", allowEmpty: false }, channelId: { type: "string", allowEmpty: false } }, e2), formatMembers((yield this.core.sendCmd("qchatGetRTCChannelMembers", { qchatGetRTCChannelMembersTag: e2 })).content.memberList);
          });
        }
        addRTCChannelListener() {
          var e2, t2;
          this._checkConnectState();
          try {
            null === (e2 = this.authService) || void 0 === e2 || e2.addAuthListener({ onAuthEvent: (e3) => __awaiter(this, void 0, void 0, function* () {
              if (1026 === e3 && !this.getTokenState) {
                this.logger.log("QChatMedia::loginByIM token expire,begin get new token "), this.getTokenState = true;
                var t3 = yield this._getToken();
                this.authService && (yield this.authService.renewToken(t3)), this.getTokenState = false;
              }
            }) });
          } catch (e3) {
            throw this.getTokenState = false, this.logger.error("QChatMedia::loginByIM addAuthListener error", e3), new CustomError("QChatMedia::loginByIM addAuthListener error", e3);
          }
          null === (t2 = this.roomContext) || void 0 === t2 || t2.addRoomListener({ onRoomPropertiesChanged: (e3) => {
            var t3, r2, i2, s2, n2, a2;
            if (this.logger.log("QChatMedia::addRTCChannelListener::onRoomPropertiesChanged", e3), e3.audioOff) {
              var o2 = null === (t3 = e3.audioOff.value) || void 0 === t3 ? void 0 : t3.split("_")[0];
              "offNotAllowSelfOn" !== o2 && "offAllowSelfOn" !== o2 || (null === (r2 = this.roomContext) || void 0 === r2 ? void 0 : r2.localMember.isAudioOn) && (null === (i2 = this.rtcController) || void 0 === i2 || i2.muteMyAudio());
            } else if (e3.videoOff) {
              var c2 = null === (s2 = e3.videoOff.value) || void 0 === s2 ? void 0 : s2.split("_")[0];
              "offNotAllowSelfOn" !== c2 && "offAllowSelfOn" !== c2 || (null === (n2 = this.roomContext) || void 0 === n2 ? void 0 : n2.localMember.isVideoOn) && (null === (a2 = this.rtcController) || void 0 === a2 || a2.muteMyVideo());
            }
          }, onRoomPropertiesDeleted: (e3) => {
            this.logger.log("QChatMedia::addRTCChannelListener::onRoomPropertiesDeleted", e3);
          }, onMemberJoinRtcChannel: (e3) => {
            this.logger.log("QChatMedia::addRTCChannelListener::onMemberJoinRTCChannel", e3);
            var t3 = e3.map((e4) => e4.uuid);
            this.core.emit("memberJoinRTCChannel", t3), this.core.qchatMedia.emit("memberJoinRTCChannel", t3);
          }, onMemberLeaveRoom: (e3) => {
            this.logger.log("QChatMedia::addRTCChannelListener::onMemberLeaveRoom", e3);
            var t3 = e3.map((e4) => e4.uuid);
            this.core.emit("memberLeaveRTCChannel", t3), this.core.qchatMedia.emit("memberLeaveRTCChannel", t3);
          }, onRoomEnded: (e3) => {
            this.authService && this.authService.logout(), this._setStateInit(), this.logger.log("QChatMedia::addRTCChannelListener::onRoomEnded", e3), this.core.emit("RTCChannelEnded", e3), this.core.qchatMedia.emit("RTCChannelEnded", e3);
          }, onRtcChannelError: (e3) => {
            this.logger.log("QChatMedia::addRTCChannelListener::onRtcChannelError", e3), "SOCKET_ERROR" === e3 && this.disconnectChannel(), this.core.emit("RTCChannelError", e3), this.core.qchatMedia.emit("RTCChannelError", e3);
          }, onRtcAudioVolumeIndication: (e3) => {
            this.logger.log("QChatMedia::addRTCChannelListener::onRtcAudioVolumeIndication", e3), this.core.emit("onRtcAudioVolumeIndication", e3), this.core.qchatMedia.emit("onRtcAudioVolumeIndication", e3);
          }, onMemberAudioMuteChanged: (e3, t3, r2) => {
            this.logger.log("QChatMedia::addRTCChannelListener::onMemberAudioMuteChanged", e3, t3), this.core.emit("memberAudioMuteChanged", { memberAccId: e3.uuid, mute: t3, operateByAccId: r2.uuid }), this.core.qchatMedia.emit("memberAudioMuteChanged", { memberAccId: e3.uuid, mute: t3, operateByAccId: r2.uuid });
          }, onMemberScreenShareStateChanged: (e3, t3, r2) => {
            this.logger.log("QChatMedia::addRTCChannelListener::onMemberScreenShareStateChanged", e3, t3), this.core.emit("memberScreenShareStateChanged", { memberAccId: e3.uuid, isSharing: t3, operateByAccId: r2.uuid }), this.core.qchatMedia.emit("memberScreenShareStateChanged", { memberAccId: e3.uuid, isSharing: t3, operateByAccId: r2.uuid });
          }, onMemberVideoMuteChanged: (e3, t3, r2) => {
            this.logger.log("QChatMedia::addRTCChannelListener::onMemberVideoMuteChanged", e3, t3), this.core.emit("memberVideoMuteChanged", { memberAccId: e3.uuid, mute: t3, operateByAccId: r2.uuid }), this.core.qchatMedia.emit("memberVideoMuteChanged", { memberAccId: e3.uuid, mute: t3, operateByAccId: r2.uuid });
          } });
        }
        enumCameraDevices() {
          return this._checkConnectState(), this.rtcController.enumCameraDevices().then((e2) => e2.data, (e2) => {
            throw this.logger.error("QChatMedia::enumCameraDevices error", e2), new CustomError("QChatMedia::enumCameraDevices error", e2);
          });
        }
        enumPlayoutDevices() {
          return this._checkConnectState(), this.rtcController.enumPlayoutDevices().then((e2) => e2.data, (e2) => {
            throw this.logger.error("QChatMedia::enumPlayoutDevices error", e2), new CustomError("QChatMedia::enumPlayoutDevices error", e2);
          });
        }
        enumRecordDevices() {
          return this._checkConnectState(), this.rtcController.enumRecordDevices().then((e2) => e2.data, (e2) => {
            throw this.logger.error("QChatMedia::enumRecordDevices error", e2), new CustomError("QChatMedia::enumRecordDevices error", e2);
          });
        }
        removeRTCChannelListener() {
          var e2, t2;
          this._checkConnectState(), null === (e2 = this.roomContext) || void 0 === e2 || e2.removeRoomListener({}), null === (t2 = this.authService) || void 0 === t2 || t2.removeAuthListener({});
        }
        setSelectedCameraDevice(e2) {
          return this._checkConnectState(), validate({ deviceId: { type: "string", allowEmpty: false } }, e2), this.rtcController.setSelectedCameraDevice(e2.deviceId).then((e3) => e3.data, (e3) => {
            throw this.logger.error("QChatMedia::setSelectedCameraDevice error", e3), new CustomError("QChatMedia::setSelectedCameraDevice error", e3);
          });
        }
        setSelectedPlayoutDevice(e2) {
          return this._checkConnectState(), validate({ deviceId: { type: "string", allowEmpty: false } }, e2), this.rtcController.setSelectedPlayoutDevice(e2.deviceId).then((e3) => e3.data, (e3) => {
            throw this.logger.error("QChatMedia::setSelectedPlayoutDevice error", e3), new CustomError("QChatMedia::setSelectedPlayoutDevice error", e3);
          });
        }
        setSelectedRecordDevice(e2) {
          return this._checkConnectState(), validate({ deviceId: { type: "string", allowEmpty: false } }, e2), this.rtcController.setSelectedRecordDevice(e2.deviceId).then((e3) => e3.data, (e3) => {
            throw this.logger.error("QChatMedia::setSelectedRecordDevice error", e3), new CustomError("QChatMedia::setSelectedRecordDevice error", e3);
          });
        }
        getRTCMembers() {
          return this._checkConnectState(), this.roomContext.remoteMembers.filter((e2) => e2.isInRtcChannel).map((e2) => ({ accid: e2.uuid, isAudioOn: !!e2.isAudioOn, isVideoOn: !!e2.isVideoOn, isSharingScreen: !!e2.isSharingScreen, properties: e2.properties }));
        }
        subscribeRemoteVideoSubStream(e2) {
          var t2;
          return __awaiter(this, void 0, void 0, function* () {
            this._checkConnectState(), validate({ accid: { type: "string", allowEmpty: false } }, e2);
            try {
              null === (t2 = this.rtcController) || void 0 === t2 || t2.subscribeRemoteVideoSubStream(e2.accid);
            } catch (e3) {
              throw this.logger.error("QChatMedia::subscribeRemoteVideoSubStream error", e3), new CustomError("QChatMedia::subscribeRemoteVideoSubStream error", e3);
            }
          });
        }
        unsubscribeRemoteVideoSubStream(e2) {
          var t2;
          return __awaiter(this, void 0, void 0, function* () {
            this._checkConnectState(), validate({ accid: { type: "string", allowEmpty: false } }, e2);
            try {
              null === (t2 = this.rtcController) || void 0 === t2 || t2.unsubscribeRemoteVideoSubStream(e2.accid);
            } catch (e3) {
              throw this.logger.error("QChatMedia::unsubscribeRemoteVideoSubStream error", e3), new CustomError("QChatMedia::unsubscribeRemoteVideoSubStream error", e3);
            }
          });
        }
        muteAllAudio() {
          var e2;
          return __awaiter(this, void 0, void 0, function* () {
            if (this._checkConnectState(), yield this._checkPermission({ serverId: this.serverId, channelId: this.channelId, auth: "RTCChannelOpenCloseEveryoneMicrophone" }))
              try {
                null === (e2 = this.roomContext) || void 0 === e2 || e2.updateRoomProperty("audioOff", JSON.stringify({ value: `offNotAllowSelfOn_${(/* @__PURE__ */ new Date()).getTime()}` }));
              } catch (e3) {
                throw this.logger.error("QChatMedia::muteAllAudio error", e3), new CustomError("QChatMedia::muteAllAudio error", e3);
              }
            else
              this.logger.error("QChatMedia::connect::auth your have not RTCChannelOpenCloseEveryoneMicrophone auth");
          });
        }
        muteAllVideo() {
          var e2;
          return __awaiter(this, void 0, void 0, function* () {
            if (this._checkConnectState(), yield this._checkPermission({ serverId: this.serverId, channelId: this.channelId, auth: "RTCChannelOpenCloseEveryoneCamera" }))
              try {
                null === (e2 = this.roomContext) || void 0 === e2 || e2.updateRoomProperty("videoOff", JSON.stringify({ value: `offNotAllowSelfOn_${(/* @__PURE__ */ new Date()).getTime()}` }));
              } catch (e3) {
                throw this.logger.error("QChatMedia::muteAllVideo error", e3), new CustomError("QChatMedia::muteAllVideo error", e3);
              }
            else
              this.logger.error("QChatMedia::connect::auth your have not RTCChannelOpenCloseEveryoneCamera auth");
          });
        }
        unMuteAllAudio() {
          var e2;
          return __awaiter(this, void 0, void 0, function* () {
            if (this._checkConnectState(), yield this._checkPermission({ serverId: this.serverId, channelId: this.channelId, auth: "RTCChannelOpenCloseEveryoneMicrophone" }))
              try {
                null === (e2 = this.roomContext) || void 0 === e2 || e2.updateRoomProperty("audioOff", JSON.stringify({ value: `disable_${(/* @__PURE__ */ new Date()).getTime()}` }));
              } catch (e3) {
                throw this.logger.error("QChatMedia::unMuteAllAudio error", e3), new CustomError("QChatMedia::unMuteAllAudio error", e3);
              }
            else
              this.logger.error("QChatMedia::connect::auth your have not RTCChannelOpenCloseEveryoneMicrophone auth");
          });
        }
        unMuteAllVideo() {
          var e2;
          return __awaiter(this, void 0, void 0, function* () {
            if (this._checkConnectState(), yield this._checkPermission({ serverId: this.serverId, channelId: this.channelId, auth: "RTCChannelOpenCloseEveryoneCamera" }))
              try {
                null === (e2 = this.roomContext) || void 0 === e2 || e2.updateRoomProperty("videoOff", JSON.stringify({ value: `disable_${(/* @__PURE__ */ new Date()).getTime()}` }));
              } catch (e3) {
                throw this.logger.error("QChatMedia::unMuteAllVideo error", e3), new CustomError("QChatMedia::unMuteAllVideo error", e3);
              }
            else
              this.logger.error("QChatMedia::connect::auth your have not RTCChannelOpenCloseEveryoneCamera auth");
          });
        }
      }, "qchatMedia"), NIM.registerService(class QChatMsgService extends Service {
        constructor(e2) {
          super("qchatMsg", e2), this.core = e2, this.lastChannelIdInMark = "", registerParser({ cmdMap: Bs, cmdConfig: getCmdConfig$2() }), this.notificationModuleService = new NotificationModuleService(e2), this.messageModuleService = new MessageModuleService(e2), this.extendModuleService = new ExtendModuleService(e2);
        }
        sendMessage(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ serverId: { type: "string", allowEmpty: false }, channelId: { type: "string", allowEmpty: false }, type: { type: "enum", values: getEnumKeys(_s) }, ext: { type: "string", required: false }, mentionAll: { type: "boolean", required: false }, mentionAccids: { type: "array", itemType: "string", required: false }, mentionRoleIds: { type: "array", itemType: "string", required: false, min: 1 }, historyEnable: { type: "boolean", required: false }, pushEnable: { type: "boolean", required: false } }, e2), yield this.messageModuleService.sendMessage(e2);
          });
        }
        updateMessage(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            if (validate({ message: { type: "object", rules: { serverId: { type: "string", allowEmpty: false }, channelId: { type: "string", allowEmpty: false }, msgIdServer: { type: "string", allowEmpty: false }, time: { type: "number", min: 0 }, body: { type: "string", required: false }, ext: { type: "string", required: false } } } }, e2), "number" == typeof e2.message.status && e2.message.status < 1e4)
              throw new CustomError("Status should be greater than or equal to 10000");
            return yield this.messageModuleService.doUpdateMessage(e2);
          });
        }
        resendMessage(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ serverId: { type: "string", allowEmpty: false }, channelId: { type: "string", allowEmpty: false }, msgIdClient: { type: "string", allowEmpty: false } }, e2), yield this.messageModuleService.resendMessage(e2);
          });
        }
        deleteMessage(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ message: { type: "object", rules: { serverId: { type: "string", allowEmpty: false }, channelId: { type: "string", allowEmpty: false }, msgIdServer: { type: "string", allowEmpty: false }, time: { type: "number", min: 0 } } } }, e2);
            var t2 = JSON.parse(JSON.stringify(e2));
            return t2.message.status = 2, yield this.messageModuleService.doUpdateMessage(t2);
          });
        }
        revokeMessage(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ message: { type: "object", rules: { serverId: { type: "string", allowEmpty: false }, channelId: { type: "string", allowEmpty: false }, msgIdServer: { type: "string", allowEmpty: false }, time: { type: "number", min: 0 } } } }, e2);
            var t2 = JSON.parse(JSON.stringify(e2));
            return t2.message = pick(t2.message, ["serverId", "channelId", "msgIdServer", "time"]), t2.message.status = 1, yield this.messageModuleService.doUpdateMessage(t2);
          });
        }
        markMessageRead(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ serverId: { type: "string" }, channelId: { type: "string" }, time: { type: "number", min: 0 } }, e2), e2.channelId !== this.lastChannelIdInMark && this.messageModuleService.markMessageRead.flush(), this.lastChannelIdInMark = e2.channelId, this.messageModuleService.markMessageRead(e2);
          });
        }
        replyMessage(e2) {
          validate({ replyMessage: { type: "object", rules: { msgIdServer: { type: "string", allowEmpty: false } } } }, e2);
          var t2 = e2.replyMessage;
          if (e2.serverId !== t2.serverId || e2.channelId !== t2.channelId)
            throw new CustomError("Forbid replying to message from other server, channel");
          return this.sendMessage(e2);
        }
        getMessageHistoryByIds(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ serverId: { type: "string", allowEmpty: false }, channelId: { type: "string", allowEmpty: false }, messageReferList: { type: "array", rules: { msgIdServer: { type: "string", allowEmpty: false }, time: { type: "number" } } } }, e2), yield this.extendModuleService.getMessageHistoryByIds(e2);
          });
        }
        getReferMessages(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ message: { type: "object", rules: { msgIdServer: { type: "string", allowEmpty: false }, time: { type: "number" } } }, referType: { type: "enum", values: getEnumKeys(Ns), required: false } }, e2), yield this.extendModuleService.getReferMessages(e2);
          });
        }
        getThreadMessages(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ message: { type: "object", rules: { msgIdServer: { type: "string", allowEmpty: false }, time: { type: "number" } } }, messageQueryOption: { type: "object", rules: { beginTime: { type: "number", required: false }, endTime: { type: "number", required: false }, excludeMsgId: { type: "string", required: false }, limit: { type: "number", required: false }, reverse: { type: "boolean", required: false } } } }, e2), yield this.extendModuleService.getThreadMessages(e2);
          });
        }
        getThreadRootMessagesMeta(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ serverId: { type: "string", allowEmpty: false }, channelId: { type: "string", allowEmpty: false }, threadRootMessages: { type: "array", rules: { msgIdServer: { type: "string", allowEmpty: false }, time: { type: "number" } } } }, e2), yield this.extendModuleService.getThreadRootMessagesMeta(e2);
          });
        }
        sendSystemNotification(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ serverId: { type: "string", allowEmpty: false }, channelId: { type: "string", allowEmpty: false, required: false }, attach: { type: "object", required: false } }, e2), yield this.notificationModuleService.sendSystemNotification(e2);
          });
        }
        updateSystemNotification(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ systemNotification: { type: "object", rules: { msgIdServer: { type: "string", allowEmpty: false }, type: { type: "enum", values: getEnumKeys(Rs) }, body: { type: "string", required: false }, ext: { type: "string", required: false }, status: { type: "number", required: false } } } }, e2), yield this.notificationModuleService.updateSystemNotification(e2);
          });
        }
        markSystemNotificationsRead(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ systemNotifications: { type: "array", rules: { msgIdServer: { type: "string", allowEmpty: false }, type: { type: "string", allowEmpty: false } }, min: 1 } }, e2), yield this.notificationModuleService.markSystemNotificationsRead(e2);
          });
        }
        getHistoryMessage(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ serverId: { type: "string", allowEmpty: false }, channelId: { type: "string", allowEmpty: false }, beginTime: { type: "number", min: 0, required: false }, endTime: { type: "number", min: 0, required: false }, excludeMsgId: { type: "string", allowEmpty: false, required: false }, limit: { type: "number", min: 1, required: false }, reverse: { type: "boolean", required: false } }, e2), yield this.messageModuleService.getHistoryMessage(e2);
          });
        }
        getMentionedMeMessages(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ serverId: { type: "string", allowEmpty: false }, channelId: { type: "string", allowEmpty: false }, timestamp: { type: "number", min: 0, required: false }, limit: { type: "number", min: 1, required: false } }, e2), yield this.messageModuleService.getMentionedMeMessages(e2);
          });
        }
        areMentionedMeMessages(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            if (validate({ messages: { type: "array", rules: { serverId: { type: "string", allowEmpty: false }, channelId: { type: "string", allowEmpty: false }, msgIdServer: { type: "string", allowEmpty: false } }, min: 1 } }, e2), !e2.messages.every((t2) => e2.messages[0].serverId === t2.serverId))
              throw new CustomError("Different serverId", e2, 10414);
            if (this.core.qchatChannel.subscribeForVisitorService.isInAutoServers(e2.messages[0].serverId))
              throw new CustomError("Not allowed for visitor", e2, 10403);
            return yield this.messageModuleService.areMentionedMeMessages(e2.messages);
          });
        }
        addQuickComment(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            yield this.extendModuleService.updateQuickComment(e2, 1);
          });
        }
        removeQuickComment(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            yield this.extendModuleService.updateQuickComment(e2, 2);
          });
        }
        getQuickComments(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ serverId: { type: "string", allowEmpty: false }, channelId: { type: "string", allowEmpty: false }, msgList: { type: "array", rules: { msgIdServer: { type: "string", allowEmpty: false } }, min: 1 } }, e2), yield this.extendModuleService.getQuickComments(e2);
          });
        }
        sendTypingEvent(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ serverId: { type: "string", allowEmpty: false }, channelId: { type: "string", allowEmpty: false }, ext: { type: "string", required: false } }, e2), yield this.extendModuleService.sendTypingEvent(e2);
          });
        }
        getLastMessageOfChannels(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ serverId: { type: "string", allowEmpty: false }, channelIdList: { type: "array", itemType: "string" } }, e2), yield this.messageModuleService.getLastMessageOfChannels(e2);
          });
        }
        qchatOnMsgHandler(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.messageModuleService.onMsg(e2);
          });
        }
        qchatOnRecvUnreadInfoHandler(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.messageModuleService.onRecvUnreadInfo(e2);
          });
        }
        qchatOnSysMsgHandler(e2) {
          this.notificationModuleService.onSysMsg(e2);
        }
        qchatMultiSyncMessageReadHandler(e2) {
          this.messageModuleService.onMultiSyncRead(e2);
        }
        qchatMultiSyncSystemNotificationUpdateHandler(e2) {
          this.notificationModuleService.onMultiSysMsg(e2);
        }
        qchatSyncSystemNotificationHandler(e2) {
          this.notificationModuleService.onSyncSysMsg(e2);
        }
        qchatRecvMessageUpdateHandler(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            this.messageModuleService.onRecvMsgUpdate(e2);
          });
        }
        searchMsgByPage(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ keyword: { type: "string", allowEmpty: false, required: false }, serverId: { type: "string", allowEmpty: false, required: true }, channelId: { type: "string", allowEmpty: false, required: false }, fromAccid: { type: "string", allowEmpty: false, required: false }, fromTime: { type: "number", allowEmpty: false, required: false }, toTime: { type: "number", allowEmpty: false, required: false }, msgTypes: { type: "array", itemType: "string", allowEmpty: false, required: true }, subTypes: { type: "array", itemType: "string", allowEmpty: false, required: false }, includeSelf: { type: "boolean", allowEmpty: false, required: false }, order: { type: "enum", values: getEnumKeys(es), required: false }, limit: { type: "number", min: 0, required: false }, sort: { type: "enum", values: getEnumKeys(Ts), required: false }, cursor: { type: "string", allowEmpty: false, required: false } }, e2), yield this.messageModuleService.messageSearchByPage(e2);
          });
        }
        qchatMultiSyncServersMessageReadHandler(e2) {
          this.messageModuleService.onMultiSyncServersRead(e2);
        }
      }, "qchatMsg"), NIM.registerService(class QChatRoleService extends Service {
        constructor(e2) {
          super("qchatRole", e2), this.core = e2, registerParser({ cmdMap: Gs, cmdConfig: getCmdConfig() }), this.category = new CategoryModuleService(e2);
        }
        createServerRole(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ serverId: { type: "string", allowEmpty: false }, name: { type: "string", allowEmpty: false }, priority: { type: "number", min: 1 }, icon: { type: "string", required: false }, ext: { type: "string", required: false } }, e2), formatRole((yield this.core.sendCmd("qchatCreateServerRole", { serverRole: Object.assign(Object.assign({}, generatorRoleForCmd(e2)), { type: vs.custom }), antispamTag: generateAntispamTag(e2) })).content.serverRole);
          });
        }
        updateServerRole(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ serverId: { type: "string", allowEmpty: false }, roleId: { type: "string", allowEmpty: false }, name: { type: "string", required: false }, icon: { type: "string", required: false }, ext: { type: "string", required: false }, priority: { type: "number", required: false }, auths: { type: "object", required: false } }, e2), formatRole((yield this.core.sendCmd("qchatUpdateServerRole", { updateServerRoleTag: generatorRoleForCmd(e2), antispamTag: generateAntispamTag(e2) })).content.serverRole);
          });
        }
        deleteServerRole(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ serverId: { type: "string", allowEmpty: false }, roleId: { type: "string", allowEmpty: false } }, e2), yield this.core.sendCmd("qchatDeleteServerRole", e2);
          });
        }
        getServerRoles(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ serverId: { type: "string", allowEmpty: false }, channelId: { type: "string", allowEmpty: false, required: false }, categoryId: { type: "string", allowEmpty: false, required: false }, limit: { type: "number", min: 1, required: false }, priority: { type: "number", required: false } }, e2);
            var t2 = yield this.core.sendCmd("qchatGetServerRoles", { getServerRolesTag: generatorRoleForCmd(e2) }), r2 = t2.content.serverRoles.filter((e3) => 1 === parseInt(e3.isMember));
            return r2 = r2.map((e3) => e3.roleId), { roles: formatRoles(t2.content.serverRoles), isMemberRoles: r2 };
          });
        }
        addChannelRole(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ serverId: { type: "string", allowEmpty: false }, channelId: { type: "string", allowEmpty: false }, parentRoleId: { type: "string", allowEmpty: false } }, e2), formatRole((yield this.core.sendCmd("qchatAddChannelRole", { channelRole: generatorRoleForCmd(e2) })).content.channelRole);
          });
        }
        getChannelRoles(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ serverId: { type: "string", allowEmpty: false }, channelId: { type: "string", allowEmpty: false }, timetag: { type: "number", required: false }, limit: { type: "number", min: 1, required: false } }, e2), formatRoles((yield this.core.sendCmd("qchatGetChannelRoles", { getChannelRolesTag: e2 })).content.channelRoles);
          });
        }
        removeChannelRole(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ serverId: { type: "string", allowEmpty: false }, channelId: { type: "string", allowEmpty: false }, roleId: { type: "string", allowEmpty: false } }, e2), yield this.core.sendCmd("qchatRemoveChannelRole", e2);
          });
        }
        updateChannelRole(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ serverId: { type: "string", allowEmpty: false }, channelId: { type: "string", allowEmpty: false }, roleId: { type: "string", allowEmpty: false }, auths: { type: "object", required: false } }, e2);
            var t2 = yield this.core.sendCmd("qchatUpdateChannelRole", { updateChannelRoleTag: generatorRoleForCmd(e2) });
            if (406 === t2.raw.code)
              throw new CustomError("No update required", {}, 406);
            return formatRole(t2.content.channelRole);
          });
        }
        addMemberRole(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ serverId: { type: "string", allowEmpty: false }, channelId: { type: "string", allowEmpty: false }, accid: { type: "string", allowEmpty: false } }, e2), formatRole((yield this.core.sendCmd("qchatAddMemberRole", { memberRole: e2 })).content.memberRole);
          });
        }
        getMemberRoles(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ serverId: { type: "string", allowEmpty: false }, channelId: { type: "string", allowEmpty: false }, timetag: { type: "number", required: false }, limit: { type: "number", min: 1, required: false } }, e2), formatRoles((yield this.core.sendCmd("qchatGetMemberRoles", { getMemberRolesTag: e2 })).content.memberRoles);
          });
        }
        removeMemberRole(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ serverId: { type: "string", allowEmpty: false }, channelId: { type: "string", allowEmpty: false }, accid: { type: "string", allowEmpty: false } }, e2), yield this.core.sendCmd("qchatRemoveMemberRole", { memberRole: e2 });
          });
        }
        updateMemberRole(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ serverId: { type: "string", allowEmpty: false }, channelId: { type: "string", allowEmpty: false }, accid: { type: "string", allowEmpty: false }, auths: { type: "object", required: false } }, e2);
            var t2 = yield this.core.sendCmd("qchatUpdateMemberRole", { updateMemberRoleTag: generatorRoleForCmd(e2) });
            if (406 === t2.raw.code)
              throw new CustomError("No update required", {}, 406);
            return formatRole(t2.content.memberRole);
          });
        }
        addMembersToServerRole(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ serverId: { type: "string", allowEmpty: false }, roleId: { type: "string", allowEmpty: false }, accids: { type: "array", itemType: "string", min: 1 } }, e2);
            var t2 = yield this.core.sendCmd("qchatAddMembersToServerRole", Object.assign(Object.assign({}, e2), { accids: JSON.stringify(e2.accids) })), r2 = get(t2, "content.accids.successAccids"), i2 = get(t2, "content.accids.failedAccids");
            return { successAccids: r2 ? JSON.parse(r2) : [], failedAccids: i2 ? JSON.parse(i2) : [] };
          });
        }
        removeMembersFromServerRole(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ serverId: { type: "string", allowEmpty: false }, roleId: { type: "string", allowEmpty: false }, accids: { type: "array", itemType: "string", min: 1 } }, e2);
            var t2 = yield this.core.sendCmd("qchatRemoveMembersFromServerRole", Object.assign(Object.assign({}, e2), { accids: JSON.stringify(e2.accids) })), r2 = get(t2, "content.accids.successAccids"), i2 = get(t2, "content.accids.failedAccids");
            return { successAccids: r2 ? JSON.parse(r2) : [], failedAccids: i2 ? JSON.parse(i2) : [] };
          });
        }
        getMembersFromServerRole(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ serverId: { type: "string", allowEmpty: false }, roleId: { type: "string", allowEmpty: false }, timetag: { type: "number", required: false }, accid: { type: "string", allowEmpty: false, required: false }, limit: { type: "number", min: 1, required: false } }, e2), formatRoles((yield this.core.sendCmd("qchatGetMembersFromServerRole", { getMembersFromServerRoleTag: e2 })).content.members);
          });
        }
        getServerRolesByAccid(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ serverId: { type: "string", allowEmpty: false }, accid: { type: "string", allowEmpty: false }, timetag: { type: "number", required: false }, limit: { type: "number", min: 1, required: false } }, e2), formatRoles((yield this.core.sendCmd("qchatGetServerRolesByAccid", { getServerRolesByAccidTag: e2 })).content.serverRoles);
          });
        }
        getExistingServerRolesByAccids(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ serverId: { type: "string", allowEmpty: false }, accids: { type: "array", itemType: "string" } }, e2);
            var t2 = yield this.core.sendCmd("qchatGetExistingServerRolesByAccids", { serverId: e2.serverId, accids: JSON.stringify(e2.accids) });
            try {
              var r2 = JSON.parse(t2.content.serverRoles);
              return Object.keys(r2).forEach((e3) => {
                r2[e3].forEach((t3, i2) => {
                  r2[e3][i2] = deserialize(t3, getDeserializeTag().serverRole);
                }), r2[e3] = formatRoles(r2[e3]);
              }), r2;
            } catch (r3) {
              throw this.logger.error(`can not parse serverRolesGroupByAccid from ${e2.serverId} and ${e2.accids}`, t2.content.serverRoles), r3;
            }
          });
        }
        getExistingChannelRolesByServerRoleIds(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ serverId: { type: "string", allowEmpty: false }, channelId: { type: "string", allowEmpty: false }, roleIds: { type: "array", itemType: "string" } }, e2), formatRoles((yield this.core.sendCmd("qchatGetExistingChannelRolesByServerRoleIds", { serverId: e2.serverId, channelId: e2.channelId, roleIds: JSON.stringify(e2.roleIds) })).content.channelRoles);
          });
        }
        getExistingAccidsOfMemberRoles(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ serverId: { type: "string", allowEmpty: false }, channelId: { type: "string", allowEmpty: false }, accids: { type: "array", itemType: "string" } }, e2);
            var t2 = (yield this.core.sendCmd("qchatGetExistingAccidsOfMemberRoles", { serverId: e2.serverId, channelId: e2.channelId, accids: JSON.stringify(e2.accids) })).content.memberRoles;
            return t2 && t2.length > 0 ? t2.map((e3) => e3.accid) : [];
          });
        }
        getExistingAccidsInServerRole(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ serverId: { type: "string", allowEmpty: false }, roleId: { type: "string", allowEmpty: false }, accids: { type: "array", itemType: "string" } }, e2);
            var t2 = (yield this.core.sendCmd("qchatGetExistingAccidsInServerRole", { serverId: e2.serverId, roleId: e2.roleId, accids: JSON.stringify(e2.accids) })).content.members;
            return t2 && t2.length > 0 ? t2.map((e3) => e3.accid) : [];
          });
        }
        updateServerRolePriorities(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ serverId: { type: "string", allowEmpty: false }, serverRoles: { type: "array" } }, e2), formatRoles((yield this.core.sendCmd("qchatUpdateServerRolePriorities", { serverId: e2.serverId, serverRoles: e2.serverRoles.map((e3) => ({ serverId: e3.serverId, roleId: e3.roleId, priority: e3.priority })) })).content.serverRoles);
          });
        }
        checkPermission(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ serverId: { type: "string", allowEmpty: false }, channelId: { type: "string", allowEmpty: false, required: false }, auth: { type: "string" } }, e2), (yield this.core.sendCmd("qchatCheckPermission", { checkPermissionTag: Object.assign(Object.assign({}, e2), { auth: Is[e2.auth] || e2.auth }) })).content.checked;
          });
        }
        addChannelCategoryRole(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return yield this.category.addChannelCategoryRole(e2);
          });
        }
        removeChannelCategoryRole(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return yield this.category.removeChannelCategoryRole(e2);
          });
        }
        updateChannelCategoryRole(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return yield this.category.updateChannelCategoryRole(e2);
          });
        }
        getChannelCategoryRole(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return yield this.category.getChannelCategoryRole(e2);
          });
        }
        addChannelCategoryMemberRole(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return yield this.category.addChannelCategoryMemberRole(e2);
          });
        }
        removeChannelCategoryMemberRole(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return yield this.category.removeChannelCategoryMemberRole(e2);
          });
        }
        updateChannelCategoryMemberRole(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return yield this.category.updateChannelCategoryMemberRole(e2);
          });
        }
        getChannelCategoryMemberRole(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return yield this.category.getChannelCategoryMemberRole(e2);
          });
        }
        checkPermissions(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ serverId: { type: "string", allowEmpty: false }, channelId: { type: "string", allowEmpty: false, required: false }, auths: { type: "array", itemType: "string" } }, e2), this.core.logger.log("qchatRole::checkPermission options is", e2);
            var t2 = yield this.core.sendCmd("qchatCheckPermissions", { checkPermissionsTag: Object.assign(Object.assign({}, e2), { auths: JSON.stringify(e2.auths.map((e3) => Is[e3] || e3)) }) });
            this.core.logger.log("qchatRole::checkPermission result is", t2.content);
            var r2 = {};
            return t2.content.checkPermissionsResult.forEach((e3) => {
              r2[e3.auth] = e3.isAllow;
            }), this.core.logger.log("qchatRole::checkPermission auths is", r2), formatRoleAuths(r2);
          });
        }
      }, "qchatRole"), NIM.registerService(class QChatServerService extends Service {
        constructor(e2) {
          super("qchatServer", e2), this.core = e2, registerParser({ cmdMap: js, cmdConfig: getCmdConfig$1() });
        }
        createServer(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ icon: { type: "string", required: false }, name: { type: "string", required: false }, ext: { type: "string", required: false }, searchType: { type: "number", required: false, min: 0 }, searchEnable: { type: "boolean", required: false }, inviteMode: { type: "number", min: 0, max: 1, required: false }, applyMode: { type: "number", min: 0, max: 1, required: false } }, e2), formatServer((yield this.core.sendCmd("qchatCreateServer", { serverInfo: Object.assign(Object.assign({}, e2), { searchEnable: false === e2.searchEnable ? 0 : 1 }), antispamTag: generateAntispamTag(e2) })).content.serverInfo);
          });
        }
        deleteServer(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ serverId: { type: "string", min: 1 } }, e2), yield this.core.sendCmd("qchatDeleteServer", e2);
          });
        }
        updateServer(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ serverId: { type: "string", min: 1 }, icon: { type: "string", required: false }, name: { type: "string", required: false }, ext: { type: "string", required: false }, searchType: { type: "number", required: false, min: 0 }, searchEnable: { type: "boolean", required: false }, inviteMode: { type: "number", min: 0, max: 1, required: false }, applyMode: { type: "number", min: 0, max: 1, required: false } }, e2), formatServer((yield this.core.sendCmd("qchatUpdateServer", { serverInfo: Object.assign(Object.assign({}, e2), { searchEnable: false === e2.searchEnable ? 0 : 1 }), antispamTag: generateAntispamTag(e2) })).content.serverInfo);
          });
        }
        getServers(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ serverIds: { type: "array", itemType: "string", min: 1 } }, e2), formatServers((yield this.core.sendCmd("qchatGetServers", e2)).content.serverList);
          });
        }
        getServersByPage(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ timestamp: { type: "number" }, limit: { type: "number", min: 1, required: false } }, e2);
            var t2 = yield this.core.sendCmd("qchatGetServersByPage", { tag: e2 }), { datas: r2, listQueryTag: i2 } = t2.content;
            return { listQueryTag: { hasMore: 1 == +i2.hasMore, nextTimetag: parseInt(i2.nextTimetag) }, datas: formatServers(r2) };
          });
        }
        inviteServerMembers(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ serverId: { type: "string", min: 1 }, accids: { type: "array", itemType: "string", min: 1 }, ps: { type: "string" }, params: { type: "object", rules: { ttl: { type: "number" } }, required: false } }, e2);
            var t2 = yield this.core.sendCmd("qchatInviteServerMembers", e2), r2 = t2.content.record || {};
            return { failByOverAccids: t2.content.failByOverAccids, failByBanAccids: t2.content.failByBanAccids, recordInfo: formatInviteApplyRecord(r2) };
          });
        }
        acceptServerInvite(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ serverId: { type: "string", allowEmpty: false }, accid: { type: "string", allowEmpty: false }, recordInfo: { type: "object", rules: { requestId: { type: "string", allowEmpty: false } } } }, e2), yield this.core.sendCmd("qchatAcceptServerInvite", e2);
          });
        }
        rejectInviteServer(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ serverId: { type: "string", min: 1 }, accid: { type: "string", min: 1 }, ps: { type: "string" }, recordInfo: { type: "object", rules: { requestId: { type: "string", allowEmpty: false } } } }, e2), yield this.core.sendCmd("qchatRejectInviteServer", e2);
          });
        }
        applyServerJoin(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ serverId: { type: "string", min: 1 }, ps: { type: "string" }, params: { type: "object", rules: { ttl: { type: "number" } }, required: false } }, e2), formatInviteApplyRecord((yield this.core.sendCmd("qchatApplyServerJoin", e2)).content.data);
          });
        }
        acceptServerApply(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ serverId: { type: "string", min: 1 }, accid: { type: "string", min: 1 }, recordInfo: { type: "object", rules: { requestId: { type: "string", allowEmpty: false } } } }, e2), yield this.core.sendCmd("qchatAcceptServerApply", e2);
          });
        }
        rejectServerApply(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ serverId: { type: "string", min: 1 }, accid: { type: "string", min: 1 }, ps: { type: "string" }, recordInfo: { type: "object", rules: { requestId: { type: "string", allowEmpty: false } } } }, e2), yield this.core.sendCmd("qchatRejectServerApply", e2);
          });
        }
        kickServerMembers(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ serverId: { type: "string", min: 1 }, accids: { type: "array", itemType: "string", min: 1 } }, e2), yield this.core.sendCmd("qchatKickServerMembers", e2);
          });
        }
        leaveServer(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ serverId: { type: "string", min: 1 } }, e2), yield this.core.sendCmd("qchatLeaveServer", e2);
          });
        }
        updateMyMemberInfo(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ serverId: { type: "string", min: 1 }, accid: { type: "string", required: false }, nick: { type: "string", allowEmpty: true, required: false }, avatar: { type: "string", required: false }, ext: { type: "string", required: false } }, e2), formatMember$1((yield this.core.sendCmd("qchatUpdateMyMemberInfo", { memberInfo: e2, antispamTag: generateAntispamTag(e2) })).content.memberInfo);
          });
        }
        updateServerMemberInfo(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ serverId: { type: "string", min: 1 }, accid: { type: "string", min: 1 }, nick: { type: "string", required: false }, avatar: { type: "string", required: false } }, e2), formatMember$1((yield this.core.sendCmd("qchatUpdateServerMemberInfo", { memberInfo: e2, antispamTag: generateAntispamTag(e2) })).content.memberInfo);
          });
        }
        getServerMembers(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ accids: { type: "array" } }, e2);
            var t2 = [];
            if (e2.accids.length)
              for (var r2 of e2.accids)
                t2.push(`${r2.serverId}|${r2.accid}`);
            return formatMembers$1((yield this.core.sendCmd("qchatGetServerMembers", { accids: t2 })).content.accidList);
          });
        }
        getServerMembersByPage(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ serverId: { type: "string", min: 1 }, timetag: { type: "number" }, limit: { type: "number", min: 1, required: false } }, e2);
            var t2 = yield this.core.sendCmd("qchatGetServerMembersByPage", { tag: e2 }), { datas: r2, listQueryTag: i2 } = t2.content;
            return { listQueryTag: { hasMore: 1 == +i2.hasMore, nextTimetag: parseInt(i2.nextTimetag) }, datas: formatMembers$1(r2) };
          });
        }
        subscribeServer(e2) {
          var t2, r2, i2, s2;
          return __awaiter(this, void 0, void 0, function* () {
            if (validate({ type: { type: "number", min: 4, max: 4, required: false }, opeType: { type: "number", min: 1, max: 2 } }, e2), (null === (r2 = null === (t2 = this.core.qchatChannel) || void 0 === t2 ? void 0 : t2.config) || void 0 === r2 ? void 0 : r2.autoSubscribe) && !e2.isInternalTrigger)
              throw new CustomError("subscribe server failed, manual subscribe is not allowed in auto subscribe mode", {}, 403);
            if (e2.type || (e2.type = 4), e2.servers.length) {
              var n2 = Object.assign(Object.assign({}, e2), { channels: e2.servers.map((e3) => ({ serverId: e3.serverId, channelId: "" })) }), { failedChannels: a2 } = yield this.core.qchatChannel.subscribeModuleService.subscribe(n2);
              return (null === (s2 = null === (i2 = this.core.qchatChannel) || void 0 === i2 ? void 0 : i2.config) || void 0 === s2 ? void 0 : s2.autoSubscribe) ? this.core.qchatChannel.subscribeModuleService.cacheAutoSubscribe(n2) : this.core.qchatChannel.subscribeModuleService.cacheSubscribe(n2), { failedServers: a2 };
            }
          });
        }
        banServerMember(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ serverId: { type: "string", allowEmpty: false }, accid: { type: "string", allowEmpty: false }, ext: { type: "string", required: false } }, e2), yield this.core.sendCmd("qchatUpdateServerMemberBan", { tag: Object.assign(Object.assign({}, e2), { opeType: 1 }) });
          });
        }
        unbanServerMember(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ serverId: { type: "string", allowEmpty: false }, accid: { type: "string", allowEmpty: false }, ext: { type: "string", required: false } }, e2), yield this.core.sendCmd("qchatUpdateServerMemberBan", { tag: Object.assign(Object.assign({}, e2), { opeType: 2 }) });
          });
        }
        getBannedMembersByPage(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ serverId: { type: "string", allowEmpty: false }, timetag: { type: "number", min: 0 }, limit: { type: "number", min: 1, required: false } }, e2);
            var t2 = yield this.core.sendCmd("qchatGetBannedMembersByPage", { tag: e2 }), { datas: r2, listQueryTag: i2 } = t2.content;
            return { listQueryTag: { hasMore: 1 == +i2.hasMore, nextTimetag: parseInt(i2.nextTimetag) }, datas: formatServerMemberBanInfos(r2) };
          });
        }
        serverSearchByPage(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            if (validate({ keyword: { type: "string", allowEmpty: false }, startTime: { type: "number", min: 0, required: false }, endTime: { type: "number", min: 0, required: false }, limit: { type: "number", min: 1, required: false }, serverType: { type: "array", itemType: "number", min: 0, required: false }, order: { type: "enum", values: getEnumKeys(es), required: false }, searchType: { type: "enum", values: getEnumKeys(rs) }, sort: { type: "enum", values: getEnumKeys(ts), required: false }, cursor: { type: "string", allowEmpty: false, required: false } }, e2), e2.startTime && e2.endTime && e2.startTime >= e2.endTime)
              throw new ValidateError("startTime more than endTime", e2, "timeRule");
            var t2 = yield this.core.sendCmd("qchatServerSearchByPage", { tag: Object.assign(Object.assign({}, e2), { order: e2.order && es[e2.order], searchType: rs[e2.searchType], sort: e2.sort && ts[e2.sort], serverType: JSON.stringify(e2.serverType) }) }), { datas: r2, listQueryTag: i2 } = t2.content;
            return { listQueryTag: { hasMore: 1 == +i2.hasMore, nextTimetag: parseInt(i2.nextTimetag), cursor: i2.cursor }, datas: formatServers(r2) };
          });
        }
        serverMemberSearchByPage(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ serverId: { type: "string", allowEmpty: false }, keyword: { type: "string", allowEmpty: false }, limit: { type: "number", min: 1, required: false } }, e2), formatMembers$1((yield this.core.sendCmd("qchatServerMemberSearchByPage", { tag: e2 })).content.members);
          });
        }
        generateInviteCode(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ serverId: { type: "string", allowEmpty: false }, ttl: { type: "number", min: 0, required: false } }, e2), function formatExpireTime(e3) {
              return format({ expireTime: { type: "number" } }, e3);
            }((yield this.core.sendCmd("qchatGenerateInviteCode", { tag: e2 })).content.data);
          });
        }
        joinByInviteCode(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ serverId: { type: "string", allowEmpty: false }, inviteCode: { type: "string", allowEmpty: false }, ps: { type: "string", required: false } }, e2), yield this.core.sendCmd("qchatJoinByInviteCode", { tag: e2 });
          });
        }
        getInviteApplyRecordOfServer(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ serverId: { type: "string", allowEmpty: false }, fromTime: { type: "number", min: 0 }, toTime: { type: "number", min: 0 }, reverse: { type: "boolean", required: false }, limit: { type: "number", min: 1, required: false }, cursor: { type: "string", allowEmpty: false, required: false } }, e2), formatInviteApplyRecords((yield this.core.sendCmd("qchatGetInviteApplyRecordOfServer", { tag: Object.assign(Object.assign({}, e2), { reverse: e2.reverse ? 1 : 0 }) })).content.data);
          });
        }
        getInviteApplyRecordOfSelf(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ fromTime: { type: "number", min: 0 }, toTime: { type: "number", min: 0 }, reverse: { type: "boolean", required: false }, limit: { type: "number", min: 1, required: false }, cursor: { type: "string", allowEmpty: false, required: false } }, e2), formatInviteApplyRecords((yield this.core.sendCmd("qchatGetInviteApplyRecordOfSelf", { tag: Object.assign(Object.assign({}, e2), { reverse: e2.reverse ? 1 : 0 }) })).content.data);
          });
        }
        markRead(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ serverIds: { type: "array", itemType: "string", required: true } }, e2);
            var t2 = formatClearServersUnread((yield this.core.sendCmd("qchatClearServersUnread", e2)).content.clearServersUnreadTag), { successServerIds: r2, ackTimestamp: i2 } = t2;
            return this.logger.log("qchatServer::clearServersUnread:: begin auto clear servers unreadInfo"), this.core.eventBus.emit("qchatChannel/clearUnreadCountByServers", r2, i2), t2;
          });
        }
        subscribeAllChannel(e2) {
          var t2, r2;
          return __awaiter(this, void 0, void 0, function* () {
            if (validate({ type: { type: "number", required: true }, serverIds: { type: "array", itemType: "string", required: true, max: 10 } }, e2), null === (r2 = null === (t2 = this.core.qchatChannel) || void 0 === t2 ? void 0 : t2.config) || void 0 === r2 ? void 0 : r2.autoSubscribe)
              throw new CustomError("subscribe channel failed, manual subscribe is not allowed in auto subscribe mode.", {}, 403);
            var i2 = yield this.core.sendCmd("qchatSubscribeChannelsByServers", e2, { timeout: 3e4 });
            i2.content.unreadInfos = formatUnreadInfos(i2.content.unreadInfos), i2.content.failServerIds = formatFailServerIds(i2.content.failServerIds);
            var s2 = { type: e2.type, opeType: 1, channels: i2.content.unreadInfos.map((e3) => ({ serverId: e3.serverId, channelId: e3.channelId })) };
            return this.core.eventBus.emit("qchatChannel/cacheSubscribe", s2), this.core.eventBus.emit("qchatChannel/getRoleIdsByServerId", e2.serverIds), this.core.eventBus.emit("qchatChannel/updateUnreads", i2.content.unreadInfos), i2.content;
          });
        }
        enterAsVisitor(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ serverIds: { type: "array", itemType: "string", min: 1 } }, e2);
            var t2 = formatFailServerIds((yield this.core.sendCmd("qchatEnterAsVisitor", { tag: { serverIds: JSON.stringify(e2.serverIds) } })).content.failServerIds), r2 = difference(e2.serverIds, t2);
            return this.core.qchatChannel.subscribeForVisitorService.cacheServer(r2), { failedServers: t2 };
          });
        }
        leaveAsVisitor(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            validate({ serverIds: { type: "array", itemType: "string", min: 1 } }, e2);
            var t2 = formatFailServerIds((yield this.core.sendCmd("qchatLeaveAsVisitor", { tag: { serverIds: JSON.stringify(e2.serverIds) } })).content.failServerIds);
            return difference(e2.serverIds, t2).forEach((e3) => {
              this.core.qchatChannel.subscribeForVisitorService.deleteServer(e3);
            }), { failedServers: t2 };
          });
        }
        subscribeAsVisitor(e2) {
          return __awaiter(this, void 0, void 0, function* () {
            return validate({ opeType: { type: "number", min: 1, max: 2 }, type: { type: "number", required: false }, serverIds: { type: "array", itemType: "string", min: 1 } }, e2), e2.serverIds.length ? yield this.core.qchatChannel.subscribeForVisitorService.subscribeServerAsVisitor(e2) : { failedServers: [] };
          });
        }
      }, "qchatServer"), NIM.registerPrivateService(class EventForwardCenter {
        constructor(e2) {
          this.bindEvents = () => {
            this.core.eventBus.on("forwardSend/msg/sendMsg", this.onV1SendMsg), this.core.eventBus.on("forwardSend/msg/recallMsg", this.onV1RecallMsg), this.core.eventBus.on("forwardSend/msg/deleteSelfMsgs", this.onV1DeleteSelfMsgs), this.core.eventBus.on("forwardSend/msgLog/clearHistoryMsgsFromServer", this.onV1ClearHistoryMessage), this.core.eventBus.on("forwardSend/V2NIMMessageService/sendMsg", this.onV2SendMsg), this.core.eventBus.on("forwardSend/V2NIMMessageService/modifyMsg", this.onV2ModifyMsg), this.core.eventBus.on("forwardSend/V2NIMMessageService/revokeMessage", this.onV2RevokeMessage), this.core.eventBus.on("forwardSend/V2NIMMessageService/deleteSelfMsgs", this.onV2DeleteSelfMsgs), this.core.eventBus.on("forwardSend/V2NIMMessageLogService/clearHistoryMessage", this.onV2ClearHistoryMessage), this.core.eventBus.on("forwardSend/team/created", this.onV1TeamCreated), this.core.eventBus.on("forwardSend/team/updateMyMemberInfo", this.onV1TeamMemberUpdate), this.core.eventBus.on("forwardSend/superTeam/updateMyMemberInfo", this.onV1SuperTeamMemberUpdate), this.core.eventBus.on("forwardSend/V2NIMTeamService/updateSelfTeamMemberInfo", this.onV2TeamMemberUpdate), this.core.eventBus.on("forwardSend/team/passTeamApply", (e3, t2) => this.onV1TeamApply(e3, 1, 1, t2)), this.core.eventBus.on("forwardSend/superTeam/passSuperTeamApply", (e3, t2) => {
              this.onV1TeamApply(e3, 2, 1, t2);
            }), this.core.eventBus.on("forwardSend/team/rejectTeamApply", (e3, t2) => {
              this.onV1TeamApply(e3, 1, 2, t2);
            }), this.core.eventBus.on("forwardSend/superTeam/rejectSuperTeamApply", (e3, t2) => {
              this.onV1TeamApply(e3, 2, 2, t2);
            }), this.core.eventBus.on("forwardSend/team/acceptTeamInvite", (e3, t2) => {
              this.onV1TeamInvite(e3, 1, 1, t2);
            }), this.core.eventBus.on("forwardSend/superTeam/acceptSuperTeamInvite", (e3, t2) => {
              this.onV1TeamInvite(e3, 2, 1, t2);
            }), this.core.eventBus.on("forwardSend/team/rejectTeamInvite", (e3, t2) => {
              this.onV1TeamInvite(e3, 1, 2, t2);
            }), this.core.eventBus.on("forwardSend/superTeam/rejectSuperTeamInvite", (e3, t2) => {
              this.onV1TeamInvite(e3, 2, 2, t2);
            }), this.core.eventBus.on("forwardSend/user/updateBlackList", this.onV1UpdateBlackList), this.core.eventBus.on("forwardSend/user/updateUserInfo", this.onV1UpdateUserInfo), this.core.eventBus.on("forwardSend/user/setMute", this.onV1SetMute), this.core.eventBus.on("forwardSend/friend/addFriend", this.onV1AddFriend), this.core.eventBus.on("forwardSend/friend/deleteFriend", this.onV1DeleteFriend), this.core.eventBus.on("forwardSend/friend/updateFriend", this.onV1UpdateFriend), this.core.eventBus.on("forwardSend/friend/passFriendApply", this.onV1PassFriendApply), this.core.eventBus.on("forwardSend/friend/rejectFriendApply", this.onV1RejectFriendApply);
          }, this.onV1TeamApply = (e3, t2, r2, i2) => {
            if (i2) {
              if (!this.core.V2NIMTeamService.notification.checkIfExpired(i2))
                return;
              r2 = 3;
            }
            this.core.eventBus.emit("forwardReceive/V2NIMTeamService/updateTeamActionStatus", { teamId: e3.teamId, teamType: t2, operatorAccountId: e3.from, actionType: 0 }, r2);
          }, this.onV1TeamInvite = (e3, t2, r2, i2) => {
            if (i2) {
              if (!this.core.V2NIMTeamService.notification.checkIfExpired(i2.code))
                return;
              r2 = 3;
            }
            this.core.eventBus.emit("forwardReceive/V2NIMTeamService/updateTeamActionStatus", { teamId: e3.teamId, teamType: t2, operatorAccountId: e3.from, actionType: 2 }, r2);
          }, this.onV1PassFriendApply = (e3, t2) => {
            this.core.eventBus.emit("forwardReceive/V2NIMFriendService/acceptAddApplication", e3, t2);
          }, this.onV1RejectFriendApply = (e3, t2, r2) => {
            this.core.eventBus.emit("forwardReceive/V2NIMFriendService/rejectAddApplication", { applicantAccountId: e3, recipientAccountId: this.core.account, operatorAccountId: this.core.account, postscript: t2 || "", timestamp: this.core.timeOrigin.getNTPTime(), read: true, status: 3 }, r2);
          }, this.onV1SetMute = (e3, t2) => {
            this.core.eventBus.emit("forwardReceive/v2NIMSettingService/setP2PMessageMuteMode", e3, t2 ? 1 : 0);
          }, this.onV1UpdateFriend = (e3) => {
            this.core.eventBus.emit("forwardReceive/V2NIMFriendService/setFriendInfo", e3.account, Object.assign(Object.assign({}, "alias" in e3 ? { alias: e3.alias } : {}), "ext" in e3 ? { serverExtension: e3.ext } : {}));
          }, this.onV1AddFriend = (e3) => {
            this.core.eventBus.emit("forwardReceive/V2NIMFriendService/addFriend", e3);
          }, this.onV1DeleteFriend = (e3) => {
            this.core.eventBus.emit("forwardReceive/V2NIMFriendService/deleteFriend", e3);
          }, this.onV1UpdateUserInfo = (e3) => {
            var t2 = deserialize(serialize(e3, Ht.user), invertSerializeItem(ko));
            this.core.eventBus.emit("forwardReceive/V2NIMUserService/updateUserProfile", t2);
          }, this.onV1UpdateBlackList = (e3, t2) => {
            this.core.eventBus.emit("forwardReceive/V2NIMUserService/updateBlockList", e3, t2);
          }, this.onV1TeamCreated = (e3) => {
            var t2 = deserialize(serialize(generateTeam(e3), Ft.team), invertSerializeItem(Yn));
            this.core.eventBus.emit("forwardReceive/V2NIMTeamService/created", t2);
          }, this.onV1TeamMemberUpdate = (e3) => {
            (e3 = Object.assign({}, e3)).type && (e3.type = { normal: 0, owner: 1, manager: 2 }[e3.type]);
            var t2 = deserialize(serialize(e3, Ft.teamMember), invertSerializeItem(Jn));
            t2.teamType = 1, this.core.eventBus.emit("forwardReceive/V2NIMTeamService/updateSelfTeamMemberInfo", t2);
          }, this.onV1SuperTeamMemberUpdate = (e3) => {
            (e3 = Object.assign({}, e3)).type && (e3.type = { normal: 0, owner: 1, manager: 2 }[e3.type]);
            var t2 = deserialize(serialize(e3, gi.superTeamMember), invertSerializeItem(Qn));
            t2.teamType = 2, this.core.eventBus.emit("forwardReceive/V2NIMTeamService/updateSelfTeamMemberInfo", t2);
          }, this.onV2TeamMemberUpdate = (e3) => {
            var t2 = e3.teamType, r2 = serialize(e3, Jn);
            if (2 === t2) {
              var i2 = deserialize(r2, invertSerializeItem(gi.superTeamMember));
              this.core.eventBus.emit("forwardReceive/superTeam/updateMyMemberInfo", i2);
            } else {
              var s2 = deserialize(r2, invertSerializeItem(Ft.teamMember));
              this.core.eventBus.emit("forwardReceive/team/updateMyMemberInfo", s2);
            }
          }, this.onV1SendMsg = (e3) => {
            var t2 = deserialize(serialize(e3, sr), sa);
            (t2 = completeMessage(this.core, t2)).sendingState = "sending" === e3.status ? 3 : "sent" === e3.status ? 1 : 2, this.core.eventBus.emit("forwardReceive/V2NIMMessageService/sendMsg", t2);
          }, this.onV2SendMsg = (e3) => {
            var t2 = deserialize(serialize(e3, ia), invertSerializeItem(sr));
            t2.status = 3 === e3.sendingState ? "sending" : 1 === e3.sendingState ? "sent" : "sendFailed", this.core.eventBus.emit("forwardReceive/msg/sendMsg", t2);
          }, this.onV2ModifyMsg = (e3) => {
            var t2 = deserialize(serialize(e3, ia), invertSerializeItem(sr));
            this.core.eventBus.emit("forwardReceive/msg/modifyMsg", t2);
          }, this.onV1RecallMsg = (e3) => {
            e3.deleteMsgCreatetime = e3.time;
            var t2 = deserialize(serialize(e3, nr.recallMsgTag), invertSerializeItem(oa));
            this.core.eventBus.emit("forwardReceive/V2NIMMessageService/revokeMessages", [t2]);
          }, this.onV2RevokeMessage = (e3) => {
            var t2 = deserialize(serialize(e3, oa), ar.recallMsgTag);
            this.core.eventBus.emit("forwardReceive/msg/recallMsg", t2);
          }, this.onV1DeleteSelfMsgs = (e3) => {
            var t2 = e3.map((e4) => deserialize(serialize(e4, nr.deleteSelfMsgTag), invertSerializeItem(na)));
            t2.forEach((e4) => {
              e4.messageRefer = formatMessageRefer(this.core, e4.messageRefer);
            }), this.core.eventBus.emit("forwardReceive/V2NIMMessageService/deleteMessages", t2);
          }, this.onV2DeleteSelfMsgs = (e3) => {
            var t2 = e3.map((e4) => deserialize(serialize(e4, na), ar.deleteSelfMsgTag));
            this.core.eventBus.emit("forwardReceive/msg/deleteSelfMsgs", t2);
          }, this.onV1ClearHistoryMessage = (e3) => {
            var t2 = deserialize(serialize(e3, Dr.clearHistoryMsgsFromServerReqTag), invertSerializeItem($a));
            this.core.eventBus.emit("forwardReceive/V2NIMMessageLogService/clearHistoryMessage", t2);
          }, this.onV2ClearHistoryMessage = (e3) => {
            var t2 = deserialize(serialize(e3, $a), qr.clearHistoryMsgsFromServerReqTag);
            this.core.eventBus.emit("forwardReceive/msgLog/clearHistoryMsgsFromServer", t2);
          }, this.core = e2, this.bindEvents();
        }
      }, "eventForwardCenter"), e.V2NIMConst = le, e.default = NIM, Object.defineProperty(e, "__esModule", { value: true });
    });
  }
});
export default require_NIM_UNIAPP_SDK();
/*! Bundled license information:

nim-web-sdk-ng/dist/v2/NIM_UNIAPP_SDK.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE *)
*/
//# sourceMappingURL=nim-web-sdk-ng_dist_v2_NIM_UNIAPP_SDK.js.map
